// Golden test: Nullable T? methods — is_some, is_none, unwrap, unwrap_or, expect
// Tests nullable method support in bootstrap compiler
// Nullable semantics: null = 0, non-null = any non-zero value
// Also tests T? type annotation parsing (v0.90.102)
// Also tests T? in function params and return types (v0.93.1)
// Expected output: 293

// v0.93.1: Function with nullable parameter and return type
fn add_or_zero(x: i64?, y: i64) -> i64? =
    if x.is_some() { x.unwrap() + y } else { null };

// v0.93.1: Function returning nullable String
fn maybe_greet(do_it: bool) -> String? =
    if do_it { "hello" } else { null };

fn main() -> i64 = {
    // Test 1: is_some on non-null value with type annotation
    let x: i64? = 42;
    let r1 = if x.is_some() { 10 } else { 0 };  // 10

    // Test 2: is_none on non-null value
    let r2 = if x.is_none() { 0 } else { 20 };  // 20

    // Test 3: unwrap on non-null value (identity)
    let r3 = x.unwrap();  // 42

    // Test 4: unwrap_or with non-null — returns receiver
    let r4 = x.unwrap_or(99);  // 42

    // Test 5: is_some on null with type annotation
    let y: i64? = null;
    let r5 = if y.is_some() { 0 } else { 30 };  // 30

    // Test 6: is_none on null value
    let r6 = if y.is_none() { 15 } else { 0 };  // 15

    // Test 7: unwrap_or with null — returns default
    let r7 = y.unwrap_or(34);  // 34

    // Test 8: Function with nullable param — non-null path
    let r8_val = add_or_zero(50, 10);
    let r8 = r8_val.unwrap_or(0);  // 60

    // Test 9: Function with nullable param — null path
    let r9_val = add_or_zero(null, 10);
    let r9 = r9_val.unwrap_or(0);  // 0

    // Test 10: Function returning nullable String — non-null
    let r10_val = maybe_greet(true);
    let r10 = if r10_val.is_some() { 40 } else { 0 };  // 40

    // Total: 10 + 20 + 42 + 42 + 30 + 15 + 34 + 60 + 0 + 40 = 293
    println(r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9 + r10);
    0
};
