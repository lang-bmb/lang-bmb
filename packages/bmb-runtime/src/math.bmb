// BMB Runtime: Math Module
// Self-hosted mathematical utility functions
//
// Note: Functions use rt_ prefix to avoid conflicts with C runtime during testing.

// ============================================================================
// Power and Exponentiation
// ============================================================================

// Integer power: base^exp (exp >= 0)
// Uses fast exponentiation by squaring
fn rt_pow(base: i64, exp: i64) -> i64 =
    if exp < 0 { 0 }  // Negative exponent returns 0 for integers
    else if exp == 0 { 1 }
    else if exp == 1 { base }
    else { rt_pow_helper(base, exp, 1) };

fn rt_pow_helper(base: i64, exp: i64, acc: i64) -> i64 =
    if exp == 0 { acc }
    else if exp % 2 == 0 { rt_pow_helper(base * base, exp / 2, acc) }
    else { rt_pow_helper(base * base, exp / 2, acc * base) };

// ============================================================================
// GCD and LCM
// ============================================================================

// Greatest Common Divisor (Euclidean algorithm)
fn rt_gcd(a: i64, b: i64) -> i64 = {
    let abs_a = if a < 0 { 0 - a } else { a };
    let abs_b = if b < 0 { 0 - b } else { b };
    rt_gcd_helper(abs_a, abs_b)
};

fn rt_gcd_helper(a: i64, b: i64) -> i64 =
    if b == 0 { a }
    else { rt_gcd_helper(b, a % b) };

// Least Common Multiple
fn rt_lcm(a: i64, b: i64) -> i64 = {
    if a == 0 { 0 }
    else if b == 0 { 0 }
    else {
        let g = rt_gcd(a, b);
        let abs_a = if a < 0 { 0 - a } else { a };
        let abs_b = if b < 0 { 0 - b } else { b };
        (abs_a / g) * abs_b
    }
};

// ============================================================================
// Square Root
// ============================================================================

// Integer square root (floor of sqrt)
// Uses Newton-Raphson iteration
fn rt_isqrt(n: i64) -> i64 =
    if n < 0 { 0 }
    else if n == 0 { 0 }
    else if n == 1 { 1 }
    else { rt_isqrt_newton(n, n) };

fn rt_isqrt_newton(n: i64, guess: i64) -> i64 = {
    let next = (guess + n / guess) / 2;
    if next >= guess { guess }
    else { rt_isqrt_newton(n, next) }
};

// ============================================================================
// Factorial
// ============================================================================

// Factorial: n! (n >= 0)
fn rt_factorial(n: i64) -> i64 =
    if n < 0 { 0 }
    else if n <= 1 { 1 }
    else { rt_factorial_helper(n, 1) };

fn rt_factorial_helper(n: i64, acc: i64) -> i64 =
    if n <= 1 { acc }
    else { rt_factorial_helper(n - 1, acc * n) };

// ============================================================================
// Prime Numbers
// ============================================================================

// Check if n is prime
fn rt_is_prime(n: i64) -> i64 =
    if n < 2 { 0 }
    else if n == 2 { 1 }
    else if n % 2 == 0 { 0 }
    else { rt_is_prime_check(n, 3) };

fn rt_is_prime_check(n: i64, i: i64) -> i64 =
    if i * i > n { 1 }
    else if n % i == 0 { 0 }
    else { rt_is_prime_check(n, i + 2) };

// ============================================================================
// Fibonacci
// ============================================================================

// Fibonacci number (iterative via tail recursion)
fn rt_fib(n: i64) -> i64 =
    if n < 0 { 0 }
    else if n == 0 { 0 }
    else if n == 1 { 1 }
    else { rt_fib_helper(n, 0, 1) };

fn rt_fib_helper(n: i64, a: i64, b: i64) -> i64 =
    if n == 1 { b }
    else { rt_fib_helper(n - 1, b, a + b) };

// ============================================================================
// Absolute Value and Sign
// ============================================================================

// Absolute value
fn rt_abs(n: i64) -> i64 =
    if n < 0 { 0 - n } else { n };

// Sign: returns -1, 0, or 1
fn rt_sign(n: i64) -> i64 =
    if n < 0 { -1 }
    else if n > 0 { 1 }
    else { 0 };

// ============================================================================
// Min/Max
// ============================================================================

fn rt_min(a: i64, b: i64) -> i64 =
    if a < b { a } else { b };

fn rt_max(a: i64, b: i64) -> i64 =
    if a > b { a } else { b };

// ============================================================================
// Clamping
// ============================================================================

// Clamp value to range [lo, hi]
fn rt_clamp(x: i64, lo: i64, hi: i64) -> i64 =
    if x < lo { lo }
    else if x > hi { hi }
    else { x };

// ============================================================================
// Division Utilities
// ============================================================================

// Integer division rounding towards negative infinity
fn rt_div_floor(a: i64, b: i64) -> i64 = {
    if b == 0 { 0 }  // Division by zero returns 0
    else {
        let q = a / b;
        let r = a % b;
        // Adjust if remainder has opposite sign to divisor
        if r != 0 {
            if (r < 0) != (b < 0) { q - 1 } else { q }
        } else { q }
    }
};

// Integer division rounding towards positive infinity
fn rt_div_ceil(a: i64, b: i64) -> i64 = {
    if b == 0 { 0 }
    else {
        let q = a / b;
        let r = a % b;
        // Adjust if remainder has same sign as divisor
        if r != 0 {
            if (r > 0) == (b > 0) { q + 1 } else { q }
        } else { q }
    }
};

// Modulo that always returns non-negative result (like Python's %)
fn rt_mod(a: i64, b: i64) -> i64 = {
    if b == 0 { 0 }
    else {
        let r = a % b;
        if r < 0 {
            if b < 0 { r - b } else { r + b }
        } else { r }
    }
};

// ============================================================================
// Tests
// ============================================================================

fn test_pow() -> i64 = {
    let p1 = rt_pow(2, 10);  // 1024
    let p2 = rt_pow(3, 5);   // 243
    let p3 = rt_pow(5, 0);   // 1
    let p4 = rt_pow(7, 1);   // 7
    let p5 = rt_pow(2, -1);  // 0 (negative exp)

    if p1 != 1024 { 1 }
    else if p2 != 243 { 2 }
    else if p3 != 1 { 3 }
    else if p4 != 7 { 4 }
    else if p5 != 0 { 5 }
    else { 0 }
};

fn test_gcd_lcm() -> i64 = {
    let g1 = rt_gcd(48, 18);   // 6
    let g2 = rt_gcd(17, 13);   // 1 (coprime)
    let g3 = rt_gcd(-12, 8);   // 4 (handles negative)
    let l1 = rt_lcm(4, 6);     // 12
    let l2 = rt_lcm(3, 5);     // 15

    if g1 != 6 { 10 }
    else if g2 != 1 { 11 }
    else if g3 != 4 { 12 }
    else if l1 != 12 { 13 }
    else if l2 != 15 { 14 }
    else { 0 }
};

fn test_sqrt() -> i64 = {
    let s1 = rt_isqrt(0);    // 0
    let s2 = rt_isqrt(1);    // 1
    let s3 = rt_isqrt(4);    // 2
    let s4 = rt_isqrt(10);   // 3 (floor)
    let s5 = rt_isqrt(100);  // 10
    let s6 = rt_isqrt(101);  // 10

    if s1 != 0 { 20 }
    else if s2 != 1 { 21 }
    else if s3 != 2 { 22 }
    else if s4 != 3 { 23 }
    else if s5 != 10 { 24 }
    else if s6 != 10 { 25 }
    else { 0 }
};

fn test_factorial() -> i64 = {
    let f0 = rt_factorial(0);  // 1
    let f1 = rt_factorial(1);  // 1
    let f5 = rt_factorial(5);  // 120
    let f10 = rt_factorial(10); // 3628800

    if f0 != 1 { 30 }
    else if f1 != 1 { 31 }
    else if f5 != 120 { 32 }
    else if f10 != 3628800 { 33 }
    else { 0 }
};

fn test_prime() -> i64 = {
    let p2 = rt_is_prime(2);   // 1
    let p3 = rt_is_prime(3);   // 1
    let p4 = rt_is_prime(4);   // 0
    let p17 = rt_is_prime(17); // 1
    let p18 = rt_is_prime(18); // 0
    let p97 = rt_is_prime(97); // 1

    if p2 != 1 { 40 }
    else if p3 != 1 { 41 }
    else if p4 != 0 { 42 }
    else if p17 != 1 { 43 }
    else if p18 != 0 { 44 }
    else if p97 != 1 { 45 }
    else { 0 }
};

fn test_fib() -> i64 = {
    let f0 = rt_fib(0);   // 0
    let f1 = rt_fib(1);   // 1
    let f5 = rt_fib(5);   // 5
    let f10 = rt_fib(10); // 55
    let f20 = rt_fib(20); // 6765

    if f0 != 0 { 50 }
    else if f1 != 1 { 51 }
    else if f5 != 5 { 52 }
    else if f10 != 55 { 53 }
    else if f20 != 6765 { 54 }
    else { 0 }
};

fn test_div() -> i64 = {
    let d1 = rt_div_floor(7, 3);   // 2
    let d2 = rt_div_floor(-7, 3);  // -3
    let d3 = rt_div_ceil(7, 3);    // 3
    let d4 = rt_div_ceil(-7, 3);   // -2
    let m1 = rt_mod(-7, 3);        // 2 (Python-style)

    if d1 != 2 { 60 }
    else if d2 != -3 { 61 }
    else if d3 != 3 { 62 }
    else if d4 != -2 { 63 }
    else if m1 != 2 { 64 }
    else { 0 }
};

fn main() -> i64 = {
    let r1 = test_pow();
    if r1 != 0 {
        let _p = println(r1);
        r1
    } else {
        let r2 = test_gcd_lcm();
        if r2 != 0 {
            let _p = println(r2);
            r2
        } else {
            let r3 = test_sqrt();
            if r3 != 0 {
                let _p = println(r3);
                r3
            } else {
                let r4 = test_factorial();
                if r4 != 0 {
                    let _p = println(r4);
                    r4
                } else {
                    let r5 = test_prime();
                    if r5 != 0 {
                        let _p = println(r5);
                        r5
                    } else {
                        let r6 = test_fib();
                        if r6 != 0 {
                            let _p = println(r6);
                            r6
                        } else {
                            let r7 = test_div();
                            if r7 != 0 {
                                let _p = println(r7);
                                r7
                            } else {
                                let _p = println(999);
                                0  // Success
                            }
                        }
                    }
                }
            }
        }
    }
};
