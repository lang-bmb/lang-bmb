// BMB Core Library v0.60.260
// Extended types and functions beyond prelude
//
// Note: This file extends the prelude (prelude.bmb).
// Functions in prelude (abs, min, max, clamp, sign, in_range, diff, bool_*)
// are NOT redefined here to avoid duplication warnings.
//
// Contents:
// - Unit type (empty value)
// - Never type (uninhabited)
// - Pair<A, B> generic tuple
// - Generic utility functions

// ============================================
// Unit type (빈 값)
// ============================================

@derive(Debug, Clone, PartialEq, Eq, Default)
pub struct Unit {}

pub fn unit() -> Unit
  post true
= new Unit {};

// ============================================
// Never type (절대 반환하지 않음)
// ============================================

pub enum Never {}

// ============================================
// IntPair - i64 pair (generic Pair has a bug, see ISSUE-20260204)
// ============================================

pub struct IntPair {
    fst: i64,
    snd: i64,
}

pub fn int_pair(a: i64, b: i64) -> IntPair
  post ret.fst == a and ret.snd == b
= new IntPair { fst: a, snd: b };

pub fn int_fst(p: IntPair) -> i64
  post ret == p.fst
= p.fst;

pub fn int_snd(p: IntPair) -> i64
  post ret == p.snd
= p.snd;

pub fn int_swap(p: IntPair) -> IntPair
  post ret.fst == p.snd and ret.snd == p.fst
= new IntPair { fst: p.snd, snd: p.fst };

// ============================================
// Identity function (i64 specialization)
// ============================================

pub fn identity_i64(x: i64) -> i64
  post ret == x
= x;

// ============================================
// Const combinator (i64 specialization)
// ============================================

pub fn const_i64(a: i64, _b: i64) -> i64
  post ret == a
= a;

// ============================================
// Tests
// ============================================

fn test_unit() -> i64 = {
    let u = unit();
    0
};

fn test_pair() -> i64 = {
    let p = int_pair(1, 2);
    if int_fst(p) != 1 { 1 }
    else if int_snd(p) != 2 { 2 }
    else {
        let swapped = int_swap(p);
        if int_fst(swapped) != 2 { 3 }
        else if int_snd(swapped) != 1 { 4 }
        else { 0 }
    }
};

fn test_identity() -> i64 = {
    if identity_i64(42) != 42 { 1 }
    else { 0 }
};

fn main() -> i64 = {
    let r1 = test_unit();
    if r1 != 0 { let _p = println(r1); r1 }
    else {
        let r2 = test_pair();
        if r2 != 0 { let _p = println(r2 + 10); r2 + 10 }
        else {
            let r3 = test_identity();
            if r3 != 0 { let _p = println(r3 + 20); r3 + 20 }
            else {
                let _p = println(999);
                999
            }
        }
    }
};
