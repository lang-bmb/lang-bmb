// BMB Core Library v0.60.261
// Extended types and functions beyond prelude
//
// Note: This file extends the prelude (prelude.bmb).
// Functions in prelude (abs, min, max, clamp, sign, in_range, diff, bool_*)
// are NOT redefined here to avoid duplication warnings.
//
// Contents:
// - Unit type (empty value)
// - Never type (uninhabited)
// - Pair<A, B> generic tuple (v0.60.261: fixed generic struct field access)
// - Generic utility functions

// ============================================
// Unit type (빈 값)
// ============================================

@derive(Debug, Clone, PartialEq, Eq, Default)
pub struct Unit {}

pub fn unit() -> Unit
  post true
= new Unit {};

// ============================================
// Never type (절대 반환하지 않음)
// ============================================

pub enum Never {}

// ============================================
// Pair<A, B> - generic tuple (v0.60.261: now works correctly)
// ============================================

pub struct Pair<A, B> {
    fst: A,
    snd: B,
}

pub fn pair<A, B>(a: A, b: B) -> Pair<A, B>
= new Pair { fst: a, snd: b };

pub fn fst<A, B>(p: Pair<A, B>) -> A
= p.fst;

pub fn snd<A, B>(p: Pair<A, B>) -> B
= p.snd;

pub fn swap<A, B>(p: Pair<A, B>) -> Pair<B, A>
= new Pair { fst: p.snd, snd: p.fst };

// ============================================
// IntPair - i64 pair (non-generic version for postconditions)
// ============================================

pub struct IntPair {
    fst: i64,
    snd: i64,
}

pub fn int_pair(a: i64, b: i64) -> IntPair
  post ret.fst == a and ret.snd == b
= new IntPair { fst: a, snd: b };

pub fn int_fst(p: IntPair) -> i64
  post ret == p.fst
= p.fst;

pub fn int_snd(p: IntPair) -> i64
  post ret == p.snd
= p.snd;

pub fn int_swap(p: IntPair) -> IntPair
  post ret.fst == p.snd and ret.snd == p.fst
= new IntPair { fst: p.snd, snd: p.fst };

// ============================================
// Identity function (i64 specialization)
// ============================================

pub fn identity_i64(x: i64) -> i64
  post ret == x
= x;

// ============================================
// Const combinator (i64 specialization)
// ============================================

pub fn const_i64(a: i64, _b: i64) -> i64
  post ret == a
= a;

// ============================================
// Tests
// ============================================

fn test_unit() -> i64 = {
    let u = unit();
    0
};

fn test_generic_pair() -> i64 = {
    let p = pair(10, 20);
    let f = fst(p);
    let s = snd(p);
    if f != 10 { 1 }
    else if s != 20 { 2 }
    else {
        let swapped = swap(p);
        let sf = fst(swapped);
        let ss = snd(swapped);
        if sf != 20 { 3 }
        else if ss != 10 { 4 }
        else { 0 }
    }
};

fn test_int_pair() -> i64 = {
    let p = int_pair(1, 2);
    if int_fst(p) != 1 { 1 }
    else if int_snd(p) != 2 { 2 }
    else {
        let swapped = int_swap(p);
        if int_fst(swapped) != 2 { 3 }
        else if int_snd(swapped) != 1 { 4 }
        else { 0 }
    }
};

fn test_identity() -> i64 = {
    if identity_i64(42) != 42 { 1 }
    else { 0 }
};

fn main() -> i64 = {
    let r1 = test_unit();
    if r1 != 0 { let _p = println(r1); r1 }
    else {
        let r2 = test_generic_pair();
        if r2 != 0 { let _p = println(r2 + 10); r2 + 10 }
        else {
            let r3 = test_int_pair();
            if r3 != 0 { let _p = println(r3 + 20); r3 + 20 }
            else {
                let r4 = test_identity();
                if r4 != 0 { let _p = println(r4 + 30); r4 + 30 }
                else {
                    let _p = println(999);
                    999
                }
            }
        }
    }
};
