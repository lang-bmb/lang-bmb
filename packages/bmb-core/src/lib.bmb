// bmb-core: Core types and functions for BMB
// Version: 0.1.0
//
// This package provides foundational types and functions:
// - Boolean operations (bool_not, xor, iff, etc.)
// - Numeric operations (abs, min, max, clamp, etc.)
// - Option type operations
// - Result type operations
//
// All functions have explicit contracts for verification.

// ============================================================
// Boolean Operations
// ============================================================

/// Logical NOT (explicit function form)
pub fn bool_not(x: bool) -> bool
    post (x and not ret) or (not x and ret)
= not x;

/// Logical implication: a implies b
pub fn bool_implies(a: bool, b: bool) -> bool
    post ret == (not a or b)
= not a or b;

/// Logical equivalence: a iff b
pub fn iff(a: bool, b: bool) -> bool
    post ret == ((a and b) or (not a and not b))
= (a and b) or (not a and not b);

/// Exclusive OR: exactly one is true
pub fn xor(a: bool, b: bool) -> bool
    post ret == ((a and not b) or (not a and b))
= (a and not b) or (not a and b);

/// Convert boolean to integer (0 or 1)
pub fn to_int(b: bool) -> i64
    post ret >= 0 and ret <= 1
= if b { 1 } else { 0 };

/// Convert integer to boolean (0 = false, else true)
pub fn from_int(x: i64) -> bool
    post (x == 0 and not ret) or (x != 0 and ret)
= x != 0;

/// Three-way conditional selection
pub fn select(cond: bool, a: i64, b: i64) -> i64
    post (cond and ret == a) or (not cond and ret == b)
= if cond { a } else { b };

// ============================================================
// Numeric Operations
// ============================================================

/// Absolute value of an integer
pub fn abs(x: i64) -> i64
    post ret >= 0
= if x >= 0 { x } else { 0 - x };

/// Minimum of two integers
pub fn min(a: i64, b: i64) -> i64
    post ret <= a and ret <= b and (ret == a or ret == b)
= if a <= b { a } else { b };

/// Maximum of two integers
pub fn max(a: i64, b: i64) -> i64
    post ret >= a and ret >= b and (ret == a or ret == b)
= if a >= b { a } else { b };

/// Clamp value to range [lo, hi]
pub fn clamp(x: i64, lo: i64, hi: i64) -> i64
    pre lo <= hi
    post ret >= lo and ret <= hi
= if x < lo { lo } else if x > hi { hi } else { x };

/// Sign of an integer (-1, 0, or 1)
pub fn sign(x: i64) -> i64
    post ret >= -1 and ret <= 1
= if x < 0 { -1 } else if x > 0 { 1 } else { 0 };

/// Check if value is in range [lo, hi] inclusive
pub fn in_range(x: i64, lo: i64, hi: i64) -> bool
    pre lo <= hi
    post ret == (x >= lo and x <= hi)
= x >= lo and x <= hi;

/// Difference between two values (always non-negative)
pub fn diff(a: i64, b: i64) -> i64
    post ret >= 0
= abs(a - b);

/// Integer power: base^exp (for non-negative exponents)
pub fn pow(base: i64, exp: i64) -> i64
    pre exp >= 0
    post exp == 0 and ret == 1 or exp > 0
= if exp == 0 { 1 } else { base * pow(base, exp - 1) };

/// Greatest common divisor
pub fn gcd(a: i64, b: i64) -> i64
    pre a > 0 and b > 0
    post ret > 0
= if b == 0 { a } else { gcd(b, a - (a / b) * b) };

/// Least common multiple
pub fn lcm(a: i64, b: i64) -> i64
    pre a > 0 and b > 0
    post ret > 0
= (a / gcd(a, b)) * b;

/// Check if n is even
pub fn is_even(n: i64) -> bool
    post ret == (n - (n / 2) * 2 == 0)
= n - (n / 2) * 2 == 0;

/// Check if n is odd
pub fn is_odd(n: i64) -> bool
    post ret == (n - (n / 2) * 2 != 0)
= n - (n / 2) * 2 != 0;
