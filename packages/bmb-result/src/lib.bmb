// BMB Result Library v0.17.1
// Result type for error handling - specialized versions
//
// AI-Native Design:
// - Explicit error handling (no exceptions)
// - Contract-specified error conditions
// - Type-specialized versions for bootstrap compatibility
//
// Note: Generic Result<T, E> requires advanced generics support.
// This version provides specialized types using string encoding.

// ============================================
// Result Constants
// ============================================

fn RESULT_OK() -> i64 = 1;
fn RESULT_ERR() -> i64 = 0;

// ============================================
// i64 Result (most common: value or error code)
// ============================================

// Encoding: "ok|value" or "err|code"

/// Create Ok(value)
pub fn ok_i64(value: i64) -> String =
    "ok|" + int_to_string(value);

/// Create Err(code)
pub fn err_i64(code: i64) -> String
    pre code != 0
    post ret.len() > 4
= "err|" + int_to_string(code);

/// Check if result is Ok
pub fn is_ok_i64(res: String) -> bool
    post ret == (res.len() >= 3 and res.byte_at(0) == 111 and res.byte_at(1) == 107)
= res.len() >= 3 and res.byte_at(0) == 111 and res.byte_at(1) == 107;  // "ok"

/// Check if result is Err
pub fn is_err_i64(res: String) -> bool
    post ret == (res.len() >= 4 and res.byte_at(0) == 101)
= res.len() >= 4 and res.byte_at(0) == 101;  // "err"

/// Unwrap Ok value with default
pub fn unwrap_or_i64(res: String, default: i64) -> i64 =
    if is_ok_i64(res) { parse_result_value(res) }
    else { default };

/// Unsafe unwrap (precondition: must be Ok)
pub fn unwrap_i64(res: String) -> i64
    pre is_ok_i64(res)
= parse_result_value(res);

/// Unwrap Err code (precondition: must be Err)
pub fn unwrap_err_i64(res: String) -> i64
    pre is_err_i64(res)
= parse_err_code(res);

/// Map Ok value: add n
pub fn map_ok_add(res: String, n: i64) -> String =
    if is_ok_i64(res) { ok_i64(parse_result_value(res) + n) }
    else { res };

/// Map Err code: add offset
pub fn map_err_add(res: String, offset: i64) -> String =
    if is_err_i64(res) { err_i64(parse_err_code(res) + offset) }
    else { res };

/// Combine: return first Ok, or last result
pub fn or_i64(a: String, b: String) -> String =
    if is_ok_i64(a) { a } else { b };

/// Combine: return second if first Ok, else first
pub fn and_i64(a: String, b: String) -> String =
    if is_ok_i64(a) { b } else { a };

// ============================================
// Safe Arithmetic Operations
// ============================================

/// Safe division with error on divide by zero
pub fn safe_divide(a: i64, b: i64) -> String
    post (b == 0 and is_err_i64(ret)) or (b != 0 and is_ok_i64(ret))
= if b == 0 { err_i64(ERR_DIVIDE_BY_ZERO()) }
  else { ok_i64(a / b) };

/// Safe modulo with error on divide by zero
pub fn safe_mod(a: i64, b: i64) -> String
    post (b == 0 and is_err_i64(ret)) or (b != 0 and is_ok_i64(ret))
= if b == 0 { err_i64(ERR_DIVIDE_BY_ZERO()) }
  else { ok_i64(a - (a / b) * b) };

/// Check for valid sqrt input
pub fn safe_sqrt_check(x: i64) -> String
    post (x < 0 and is_err_i64(ret)) or (x >= 0 and is_ok_i64(ret))
= if x < 0 { err_i64(ERR_INVALID_INPUT()) }
  else { ok_i64(x) };

// ============================================
// String Result
// ============================================

/// Create Ok(value) for String
pub fn ok_string(value: String) -> String =
    "ok|" + value;

/// Create Err(message) for String
pub fn err_string(message: String) -> String
    pre message.len() > 0
= "err|" + message;

/// Check if result is Ok
pub fn is_ok_string(res: String) -> bool =
    res.len() >= 3 and res.byte_at(0) == 111 and res.byte_at(1) == 107;

/// Unwrap Ok value with default
pub fn unwrap_or_string(res: String, default: String) -> String =
    if is_ok_string(res) { res.slice(3, res.len()) }
    else { default };

// ============================================
// Error Code Constants
// ============================================

pub fn ERR_INVALID_INPUT() -> i64 = 1;
pub fn ERR_OUT_OF_RANGE() -> i64 = 2;
pub fn ERR_DIVIDE_BY_ZERO() -> i64 = 100;
pub fn ERR_OVERFLOW() -> i64 = 101;
pub fn ERR_NOT_FOUND() -> i64 = 200;
pub fn ERR_PERMISSION_DENIED() -> i64 = 201;
pub fn ERR_IO_ERROR() -> i64 = 300;
pub fn ERR_PARSE_ERROR() -> i64 = 400;

// ============================================
// Internal Helpers
// ============================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn parse_result_value(res: String) -> i64 =
    // "ok|value" - value starts at position 3
    parse_int_from(res, 3, 0);

fn parse_err_code(res: String) -> i64 =
    // "err|code" - code starts at position 4
    parse_int_from(res, 4, 0);

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc }
    else {
        let c = s.byte_at(pos);
        if c == 45 { 0 - parse_int_from(s, pos + 1, 0) }  // '-'
        else if c >= 48 and c <= 57 { parse_int_from(s, pos + 1, acc * 10 + (c - 48)) }
        else { acc }
    };
