// bmb-io: File I/O operations for BMB
// Version: 0.1.0
//
// This package provides file I/O operations:
// - File reading (read_file)
// - File writing (write_file, append_file)
// - File system queries (file_exists, file_size)
//
// Note: These functions are implemented as interpreter builtins.
// The stub bodies are for type checking.
//
// All functions have explicit contracts for verification.

// ============================================================
// File Reading
// ============================================================

/// Read entire file contents as a string
/// Returns: File contents on success, empty string on error
@trust
pub fn read_file(path: String) -> String
    pre path.len() > 0
= "";

/// Read file with explicit result type
/// Returns: 0 on success, negative error code on failure
@trust
pub fn read_file_result(path: String) -> i64
    pre path.len() > 0
    post ret <= 0
= 0;

// ============================================================
// File Writing
// ============================================================

/// Write string contents to file
/// Returns: 0 on success, negative error code on failure
/// Creates file if not exists, overwrites if exists
@trust
pub fn write_file(path: String, content: String) -> i64
    pre path.len() > 0
    post ret <= 0
= 0;

/// Append string to existing file
/// Returns: 0 on success, negative error code on failure
@trust
pub fn append_file(path: String, content: String) -> i64
    pre path.len() > 0
    post ret <= 0
= 0;

// ============================================================
// File System Queries
// ============================================================

/// Check if file exists
/// Returns: 1 if exists, 0 if not
@trust
pub fn file_exists(path: String) -> i64
    pre path.len() > 0
    post ret == 0 or ret == 1
= 0;

/// Get file size in bytes
/// Returns: Size on success, -1 on error
@trust
pub fn file_size(path: String) -> i64
    pre path.len() > 0
    post ret >= -1
= 0;

// ============================================================
// Error Codes
// ============================================================

/// Success
pub fn IO_SUCCESS() -> i64 = 0;

/// File not found (ENOENT)
pub fn IO_ERROR_NOT_FOUND() -> i64 = -2;

/// Permission denied (EACCES)
pub fn IO_ERROR_PERMISSION() -> i64 = -13;

/// File already exists (EEXIST)
pub fn IO_ERROR_EXISTS() -> i64 = -17;

/// Invalid argument (EINVAL)
pub fn IO_ERROR_INVALID() -> i64 = -22;

/// No space left (ENOSPC)
pub fn IO_ERROR_NO_SPACE() -> i64 = -28;

/// Read-only filesystem (EROFS)
pub fn IO_ERROR_READ_ONLY() -> i64 = -30;

/// Generic/unknown error
pub fn IO_ERROR_UNKNOWN() -> i64 = -1;

// ============================================================
// Path Utilities
// ============================================================

/// Check if path looks valid (basic validation)
pub fn is_valid_path(path: String) -> i64
    post ret == 0 or ret == 1
= if path.len() == 0 { 0 } else if path.len() > 4096 { 0 } else { 1 };

/// Find file extension (position of last '.')
/// Returns: Position of '.', or -1 if no extension
pub fn find_extension(path: String) -> i64
    post ret >= -1 and ret < path.len()
= find_last_char(path, 46);

fn find_last_char(s: String, c: i64) -> i64 =
    find_last_char_from(s, c, s.len() - 1);

fn find_last_char_from(s: String, c: i64, pos: i64) -> i64 =
    if pos < 0 { -1 }
    else if s.byte_at(pos) == c { pos }
    else { find_last_char_from(s, c, pos - 1) };
