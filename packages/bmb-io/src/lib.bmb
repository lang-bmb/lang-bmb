// BMB I/O Library v0.1.0
// File and Console I/O utilities
//
// Provides ergonomic wrappers around runtime I/O functions:
// - File operations (read, write, append, exists, size)
// - Console I/O (print, println, read_line)
//
// Note: These functions wrap C runtime functions defined in bmb_runtime.c

// ============================================
// Result type for I/O operations
// ============================================

pub enum IoResult<T> {
    Ok(T),
    Err(i64),
}

pub fn io_ok<T>(value: T) -> IoResult<T> = IoResult::Ok(value);
pub fn io_err<T>(code: i64) -> IoResult<T> = IoResult::Err(code);

pub fn is_io_ok<T>(res: IoResult<T>) -> bool = match res {
    IoResult::Ok(_) => true,
    IoResult::Err(_) => false,
};

pub fn is_io_err<T>(res: IoResult<T>) -> bool = match res {
    IoResult::Ok(_) => false,
    IoResult::Err(_) => true,
};

// ============================================
// File Operations
// ============================================

// Read entire file contents as String
// Returns empty string on error
pub fn io_read_file(path: String) -> String
  post true
= read_file(path);

// Write string to file (creates or overwrites)
// Returns 0 on success, negative on error
pub fn io_write_file(path: String, content: String) -> i64
  post ret <= 0
= write_file(path, content);

// Note: append_file requires runtime wrapper for BmbString*
// TODO: Add bmb_append_file_str(BmbString*, BmbString*) to runtime

// Check if file exists
pub fn io_file_exists(path: String) -> bool = file_exists(path) != 0;

// Get file size in bytes (-1 on error)
pub fn io_file_size(path: String) -> i64 = file_size(path);

// ============================================
// Console Output
// ============================================

// Print integer to stdout with newline
// Note: println is void in runtime, we return 0 for BMB ergonomics
pub fn io_println(n: i64) -> i64 = {
    let _p = println(n);
    0
};

// Print string to stdout with newline
pub fn io_println_str(s: String) -> i64 = {
    let _p = println_str(s);
    0
};

// ============================================
// Console Input
// ============================================

// Read integer from stdin
pub fn io_read_int() -> i64 = read_int();

// Note: read_line not yet available in runtime
// TODO: Add bmb_read_line to runtime

// ============================================
// Path Utilities
// ============================================

// Join two path components with /
pub fn path_join(base: String, child: String) -> String = base + "/" + child;

// Find last dot position for extension (-1 if none)
pub fn path_ext_pos(path: String) -> i64 = path_find_dot(path, path.len() - 1);

fn path_find_dot(path: String, pos: i64) -> i64 =
    if pos < 0 { -1 }
    else if path.byte_at(pos) == 46 { pos }  // '.'
    else if path.byte_at(pos) == 47 or path.byte_at(pos) == 92 { -1 }  // '/' or '\'
    else { path_find_dot(path, pos - 1) };

// Check if path has an extension
pub fn path_has_extension(path: String) -> bool = path_ext_pos(path) >= 0;

// ============================================
// Tests
// ============================================

fn test_io_result() -> i64 = {
    let ok: IoResult<i64> = IoResult::Ok(42);
    let err: IoResult<i64> = IoResult::Err(-1);

    if not is_io_ok(ok) { 1 }
    else if is_io_ok(err) { 2 }
    else if not is_io_err(err) { 3 }
    else if is_io_err(ok) { 4 }
    else { 0 }
};

fn test_path_extension() -> i64 = {
    // Test path_ext_pos: returns position of last dot
    let pos1 = path_ext_pos("file.txt");      // Should be 4
    let pos2 = path_ext_pos("archive.tar.gz"); // Should be 11
    let pos3 = path_ext_pos("noext");          // Should be -1
    let pos4 = path_ext_pos("/path/to/file.bmb"); // Should be position of .bmb

    if pos1 != 4 { 1 }
    else if pos2 != 11 { 2 }
    else if pos3 != -1 { 3 }
    else if not path_has_extension("/path/to/file.bmb") { 4 }
    else if path_has_extension("noext") { 5 }
    else { 0 }
};

fn test_path_join() -> i64 = {
    let p1 = path_join("/home", "user");
    let p2 = path_join("dir", "file.txt");

    if p1 != "/home/user" { 1 }
    else if p2 != "dir/file.txt" { 2 }
    else { 0 }
};

fn test_file_ops() -> i64 = {
    // Write a test file
    let test_path = "/tmp/bmb_io_test.txt";
    let content = "Hello, BMB!";
    let w = io_write_file(test_path, content);

    if w != 0 { 1 }
    else {
        // Check file exists
        if not io_file_exists(test_path) { 2 }
        else {
            // Read file back
            let read_content = io_read_file(test_path);
            if read_content != content { 3 }
            else {
                // Check file size
                let size = io_file_size(test_path);
                if size != 11 { 4 }
                else { 0 }
            }
        }
    }
};

fn main() -> i64 = {
    let r1 = test_io_result();
    if r1 != 0 { let _p = println(r1); r1 }
    else {
        let r2 = test_path_extension();
        if r2 != 0 { let _p = println(r2 + 10); r2 + 10 }
        else {
            let r3 = test_path_join();
            if r3 != 0 { let _p = println(r3 + 20); r3 + 20 }
            else {
                let r4 = test_file_ops();
                if r4 != 0 { let _p = println(r4 + 30); r4 + 30 }
                else {
                    let _p = println(999);
                    999
                }
            }
        }
    }
};
