// bmb-string: String utility functions for BMB
// Version: 0.1.0
//
// This package provides string manipulation functions:
// - Character classification (is_whitespace, is_digit, is_alpha, etc.)
// - Character conversion (to_upper, to_lower, etc.)
// - String search (contains_char, starts_with, ends_with, etc.)
// - String trimming
// - Integer parsing
// - String comparison
//
// All functions have explicit contracts for verification.

// ============================================================
// Character Classification
// ============================================================

/// Check if character code is whitespace (space, tab, newline, CR)
pub fn char_is_whitespace(c: i64) -> bool
    post ret == (c == 32 or c == 9 or c == 10 or c == 13)
= c == 32 or c == 9 or c == 10 or c == 13;

/// Check if character code is a digit (0-9)
pub fn char_is_digit(c: i64) -> bool
    post ret == (c >= 48 and c <= 57)
= c >= 48 and c <= 57;

/// Check if character code is lowercase letter (a-z)
pub fn char_is_lower(c: i64) -> bool
    post ret == (c >= 97 and c <= 122)
= c >= 97 and c <= 122;

/// Check if character code is uppercase letter (A-Z)
pub fn char_is_upper(c: i64) -> bool
    post ret == (c >= 65 and c <= 90)
= c >= 65 and c <= 90;

/// Check if character code is a letter (a-z or A-Z)
pub fn char_is_alpha(c: i64) -> bool
    post ret == (char_is_lower(c) or char_is_upper(c))
= char_is_lower(c) or char_is_upper(c);

/// Check if character code is alphanumeric
pub fn char_is_alnum(c: i64) -> bool
    post ret == (char_is_alpha(c) or char_is_digit(c))
= char_is_alpha(c) or char_is_digit(c);

// ============================================================
// Character Conversion
// ============================================================

/// Convert lowercase to uppercase
pub fn char_to_upper(c: i64) -> i64
    post (char_is_lower(c) and ret == c - 32) or (not char_is_lower(c) and ret == c)
= if char_is_lower(c) { c - 32 } else { c };

/// Convert uppercase to lowercase
pub fn char_to_lower(c: i64) -> i64
    post (char_is_upper(c) and ret == c + 32) or (not char_is_upper(c) and ret == c)
= if char_is_upper(c) { c + 32 } else { c };

/// Convert digit character to integer (0-9)
pub fn digit_to_int(c: i64) -> i64
    pre char_is_digit(c)
    post ret >= 0 and ret <= 9 and ret == c - 48
= c - 48;

/// Convert integer (0-9) to digit character
pub fn int_to_digit(n: i64) -> i64
    pre n >= 0 and n <= 9
    post char_is_digit(ret) and ret == n + 48
= n + 48;

// ============================================================
// String Search
// ============================================================

/// Check if string contains character at any position
pub fn contains_char(s: String, c: i64) -> bool
    post ret == contains_char_from(s, c, 0)
= contains_char_from(s, c, 0);

fn contains_char_from(s: String, c: i64, pos: i64) -> bool
    pre pos >= 0
    post (pos >= s.len()) implies not ret
= if pos >= s.len() { false }
  else if s.byte_at(pos) == c { true }
  else { contains_char_from(s, c, pos + 1) };

/// Check if string starts with given prefix
pub fn starts_with(s: String, prefix: String) -> bool
    post (prefix.len() > s.len() and not ret) or
         (prefix.len() <= s.len() and (ret == starts_with_check(s, prefix, 0)))
= if prefix.len() > s.len() { false } else { starts_with_check(s, prefix, 0) };

fn starts_with_check(s: String, prefix: String, pos: i64) -> bool
    pre pos >= 0
    post (pos >= prefix.len()) implies ret
= if pos >= prefix.len() { true }
  else if s.byte_at(pos) != prefix.byte_at(pos) { false }
  else { starts_with_check(s, prefix, pos + 1) };

/// Check if string ends with given suffix
pub fn ends_with(s: String, suffix: String) -> bool
    post (suffix.len() > s.len()) implies not ret
= if suffix.len() > s.len() { false } else { ends_with_check(s, suffix, 0) };

fn ends_with_check(s: String, suffix: String, pos: i64) -> bool
    pre pos >= 0
    post (pos >= suffix.len()) implies ret
= if pos >= suffix.len() { true }
  else {
      let s_pos = s.len() - suffix.len() + pos;
      if s.byte_at(s_pos) != suffix.byte_at(pos) { false }
      else { ends_with_check(s, suffix, pos + 1) }
  };

/// Find first occurrence of character, returns -1 if not found
pub fn index_of_char(s: String, c: i64) -> i64
    post ret >= -1 and ret < s.len()
= index_of_char_from(s, c, 0);

fn index_of_char_from(s: String, c: i64, pos: i64) -> i64
    pre pos >= 0
= if pos >= s.len() { -1 }
  else if s.byte_at(pos) == c { pos }
  else { index_of_char_from(s, c, pos + 1) };

/// Count occurrences of character
pub fn count_char(s: String, c: i64) -> i64
    post ret >= 0
= count_char_from(s, c, 0);

fn count_char_from(s: String, c: i64, pos: i64) -> i64
    pre pos >= 0
    post ret >= 0
= if pos >= s.len() { 0 }
  else {
      let rest = count_char_from(s, c, pos + 1);
      if s.byte_at(pos) == c { 1 + rest } else { rest }
  };

// ============================================================
// String Trimming
// ============================================================

/// Find first non-whitespace position
pub fn find_trim_start(s: String) -> i64
    post ret >= 0 and ret <= s.len()
= find_trim_start_from(s, 0);

fn find_trim_start_from(s: String, pos: i64) -> i64
    pre pos >= 0
    post ret >= pos and ret <= s.len()
= if pos >= s.len() { pos }
  else if char_is_whitespace(s.byte_at(pos)) { find_trim_start_from(s, pos + 1) }
  else { pos };

/// Find position after last non-whitespace
pub fn find_trim_end(s: String) -> i64
    post ret >= 0 and ret <= s.len()
= find_trim_end_from(s, s.len());

fn find_trim_end_from(s: String, pos: i64) -> i64
    pre pos >= 0
    post ret >= 0 and ret <= pos
= if pos <= 0 { 0 }
  else if char_is_whitespace(s.byte_at(pos - 1)) { find_trim_end_from(s, pos - 1) }
  else { pos };

/// Check if string is empty or only whitespace
pub fn is_blank(s: String) -> bool
    post ret == (find_trim_start(s) >= s.len())
= find_trim_start(s) >= s.len();

// ============================================================
// Integer Parsing
// ============================================================

/// Parse non-negative integer from string (returns -1 on error)
pub fn parse_uint(s: String) -> i64
    post ret >= -1
= if s.len() == 0 { -1 } else { parse_uint_acc(s, 0, 0) };

fn parse_uint_acc(s: String, pos: i64, acc: i64) -> i64
    pre pos >= 0 and acc >= 0
    post ret >= -1
= if pos >= s.len() { acc }
  else {
      let c = s.byte_at(pos);
      if char_is_digit(c) { parse_uint_acc(s, pos + 1, acc * 10 + digit_to_int(c)) }
      else { -1 }
  };

/// Parse signed integer from string
pub fn parse_int(s: String) -> i64
= if s.len() == 0 { -9223372036854775807 }
  else if s.byte_at(0) == 45 {
      let rest = s.slice(1, s.len());
      let val = parse_uint(rest);
      if val == -1 { -9223372036854775807 } else { 0 - val }
  }
  else { parse_uint(s) };

/// Check if string represents a valid integer
pub fn is_valid_int(s: String) -> bool
    post (s.len() == 0) implies not ret
= if s.len() == 0 { false }
  else if s.byte_at(0) == 45 { s.len() > 1 and all_digits(s, 1) }
  else { all_digits(s, 0) };

fn all_digits(s: String, pos: i64) -> bool
    pre pos >= 0
    post (pos >= s.len()) implies ret
= if pos >= s.len() { true }
  else if char_is_digit(s.byte_at(pos)) { all_digits(s, pos + 1) }
  else { false };

// ============================================================
// String Comparison
// ============================================================

/// Compare two strings lexicographically (-1, 0, 1)
pub fn string_compare(a: String, b: String) -> i64
    post ret >= -1 and ret <= 1
= string_compare_from(a, b, 0);

fn string_compare_from(a: String, b: String, pos: i64) -> i64
    pre pos >= 0
    post ret >= -1 and ret <= 1
= if pos >= a.len() and pos >= b.len() { 0 }
  else if pos >= a.len() { -1 }
  else if pos >= b.len() { 1 }
  else {
      let ca = a.byte_at(pos);
      let cb = b.byte_at(pos);
      if ca < cb { -1 } else if ca > cb { 1 } else { string_compare_from(a, b, pos + 1) }
  };

/// Check string equality
pub fn string_eq(a: String, b: String) -> bool
    post ret == (string_compare(a, b) == 0)
= a.len() == b.len() and string_eq_from(a, b, 0);

fn string_eq_from(a: String, b: String, pos: i64) -> bool
    pre pos >= 0
    post (pos >= a.len()) implies ret
= if pos >= a.len() { true }
  else if a.byte_at(pos) != b.byte_at(pos) { false }
  else { string_eq_from(a, b, pos + 1) };

// ============================================================
// Integer to String Conversion
// ============================================================

/// Convert single digit (0-9) to string
pub fn digit_char(d: i64) -> String
    pre d >= 0 and d <= 9
    post ret.len() == 1
= if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
  else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
  else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
  else { "9" };

/// Convert integer to string representation
pub fn int_to_string(n: i64) -> String
    post (n >= 0 and ret.len() >= 1) or (n < 0 and ret.len() >= 2)
= if n < 0 { "-" + int_to_string(0 - n) }
  else if n < 10 { digit_char(n) }
  else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

/// Get substring length for split by character
pub fn split_first_len(s: String, delim: i64) -> i64
    post ret >= 0 and ret <= s.len()
= let idx = index_of_char(s, delim);
  if idx == -1 { s.len() } else { idx };

/// Get character count (same as len but with explicit name)
pub fn char_count(s: String) -> i64
    post ret >= 0 and ret == s.len()
= s.len();
