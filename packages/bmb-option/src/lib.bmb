// BMB Option Library v0.14.1
// Optional value containers for common types
//
// AI-Native Design:
// - Explicit null handling (no null pointers)
// - Pattern matching for value extraction
// - Contract-guaranteed safe usage
// - Type-specialized versions for i64, String, bool
//
// Note: Generic Option<T> requires advanced generics support.
// This version provides specialized types for bootstrap compatibility.

// ============================================
// Option Constants (tagged encoding)
// ============================================

fn OPTION_NONE() -> i64 = 0;
fn OPTION_SOME() -> i64 = 1;

// ============================================
// i64 Option (most common use case)
// ============================================

// Encoding: "tag|value" where tag is 0 (none) or 1 (some)

/// Create Some(value) for i64
pub fn some_i64(value: i64) -> String =
    "1|" + int_to_string(value);

/// Create None for i64
pub fn none_i64() -> String = "0|";

/// Check if option contains a value
pub fn is_some_i64(opt: String) -> bool
    post ret == (opt.len() >= 2 and opt.byte_at(0) == 49)
= opt.len() >= 2 and opt.byte_at(0) == 49;  // '1'

/// Check if option is None
pub fn is_none_i64(opt: String) -> bool
    post ret == (opt.len() < 2 or opt.byte_at(0) == 48)
= opt.len() < 2 or opt.byte_at(0) == 48;  // '0'

/// Unwrap with default value
pub fn unwrap_or_i64(opt: String, default: i64) -> i64 =
    if is_some_i64(opt) { parse_option_value(opt) }
    else { default };

/// Unsafe unwrap (precondition: must be Some)
pub fn unwrap_i64(opt: String) -> i64
    pre is_some_i64(opt)
= parse_option_value(opt);

/// Map a function over the option (add n)
pub fn map_add_i64(opt: String, n: i64) -> String =
    if is_some_i64(opt) { some_i64(parse_option_value(opt) + n) }
    else { none_i64() };

/// Filter: keep if positive
pub fn filter_positive_i64(opt: String) -> String =
    if is_some_i64(opt) {
        let v = parse_option_value(opt);
        if v > 0 { opt } else { none_i64() }
    } else { none_i64() };

/// Combine two options: return first Some, or None
pub fn or_i64(a: String, b: String) -> String =
    if is_some_i64(a) { a } else { b };

/// Combine two options: return second if both Some, else None
pub fn and_i64(a: String, b: String) -> String =
    if is_some_i64(a) and is_some_i64(b) { b } else { none_i64() };

/// Zip and sum two options
pub fn zip_sum_i64(a: String, b: String) -> String =
    if is_some_i64(a) and is_some_i64(b) {
        some_i64(parse_option_value(a) + parse_option_value(b))
    } else { none_i64() };

// ============================================
// bool Option
// ============================================

/// Create Some(value) for bool
pub fn some_bool(value: bool) -> String =
    if value { "1|1" } else { "1|0" };

/// Create None for bool
pub fn none_bool() -> String = "0|";

/// Check if option contains a value
pub fn is_some_bool(opt: String) -> bool = opt.len() >= 2 and opt.byte_at(0) == 49;

/// Unwrap with default
pub fn unwrap_or_bool(opt: String, default: bool) -> bool =
    if is_some_bool(opt) { opt.len() >= 3 and opt.byte_at(2) == 49 }
    else { default };

// ============================================
// String Option
// ============================================

/// Create Some(value) for String
pub fn some_string(value: String) -> String =
    "1|" + value;

/// Create None for String
pub fn none_string() -> String = "0|";

/// Check if option contains a value
pub fn is_some_string(opt: String) -> bool = opt.len() >= 2 and opt.byte_at(0) == 49;

/// Unwrap with default
pub fn unwrap_or_string(opt: String, default: String) -> String =
    if is_some_string(opt) { opt.slice(2, opt.len()) }
    else { default };

/// Unsafe unwrap
pub fn unwrap_string(opt: String) -> String
    pre is_some_string(opt)
= opt.slice(2, opt.len());

// ============================================
// Internal Helpers
// ============================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn parse_option_value(opt: String) -> i64 =
    parse_int_from(opt, 2, 0);

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc }
    else {
        let c = s.byte_at(pos);
        if c == 45 { 0 - parse_int_from(s, pos + 1, 0) }  // '-'
        else if c >= 48 and c <= 57 { parse_int_from(s, pos + 1, acc * 10 + (c - 48)) }
        else { acc }
    };
