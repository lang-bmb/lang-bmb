// bmb-json: JSON parser and serializer for BMB
// Version: 0.1.0
//
// This package provides JSON parsing and serialization:
// - Parse JSON strings to internal representation
// - Serialize values back to JSON strings
// - Support for: objects, arrays, strings, numbers, booleans, null
//
// JSON Value Encoding:
// Since BMB doesn't have algebraic data types yet, JSON values are
// represented as strings with type tags:
//   "n:123"     - number
//   "s:hello"   - string
//   "b:true"    - boolean
//   "null"      - null
//   "a:[...]"   - array (nested JSON)
//   "o:{...}"   - object (nested JSON)
//
// All functions have explicit contracts for verification.

// ============================================================
// Constants
// ============================================================

/// JSON type tags
pub fn JSON_NULL() -> String = "null";
pub fn JSON_TRUE() -> String = "b:true";
pub fn JSON_FALSE() -> String = "b:false";

/// Character codes
fn CHAR_QUOTE() -> i64 = 34;      // "
fn CHAR_COLON() -> i64 = 58;      // :
fn CHAR_COMMA() -> i64 = 44;      // ,
fn CHAR_LBRACE() -> i64 = 123;    // {
fn CHAR_RBRACE() -> i64 = 125;    // }
fn CHAR_LBRACKET() -> i64 = 91;   // [
fn CHAR_RBRACKET() -> i64 = 93;   // ]
fn CHAR_BACKSLASH() -> i64 = 92;  // \
fn CHAR_N() -> i64 = 110;         // n
fn CHAR_T() -> i64 = 116;         // t
fn CHAR_F() -> i64 = 102;         // f
fn CHAR_MINUS() -> i64 = 45;      // -
fn CHAR_DOT() -> i64 = 46;        // .
fn CHAR_PIPE() -> i64 = 124;      // | (for result encoding)

// ============================================================
// Character Utilities
// ============================================================

fn char_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn char_is_digit(c: i64) -> bool = c >= 48 and c <= 57;

fn digit_to_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_to_char(n) }
    else { int_to_string(n / 10) + digit_to_char(n - (n / 10) * 10) };

fn parse_int_simple(s: String) -> i64 =
    parse_int_acc(s, 0, 0, false);

fn parse_int_acc(s: String, pos: i64, acc: i64, neg: bool) -> i64 =
    if pos >= s.len() { if neg { 0 - acc } else { acc } }
    else {
        let c = s.byte_at(pos);
        if c == CHAR_MINUS() and pos == 0 { parse_int_acc(s, pos + 1, acc, true) }
        else if char_is_digit(c) { parse_int_acc(s, pos + 1, acc * 10 + (c - 48), neg) }
        else { if neg { 0 - acc } else { acc } }
    };

// ============================================================
// JSON Value Constructors
// ============================================================

/// Create a JSON null value
pub fn json_null() -> String
    post ret.len() == 4
= "null";

/// Create a JSON boolean value
pub fn json_bool(b: bool) -> String
    post ret.len() > 0
= if b { "b:true" } else { "b:false" };

/// Create a JSON number value from integer
pub fn json_int(n: i64) -> String
    post ret.len() > 2
= "n:" + int_to_string(n);

/// Create a JSON string value
pub fn json_string(s: String) -> String
    post ret.len() >= 2
= "s:" + s;

/// Create a JSON array from comma-separated values
pub fn json_array(elements: String) -> String
    post ret.len() >= 3
= "a:[" + elements + "]";

/// Create a JSON object from comma-separated key:value pairs
pub fn json_object(pairs: String) -> String
    post ret.len() >= 3
= "o:{" + pairs + "}";

// ============================================================
// JSON Value Type Checking
// ============================================================

/// Check if value is null
pub fn is_null(json: String) -> bool
    post (json.len() < 4) implies not ret
= json.len() == 4 and
  json.byte_at(0) == 110 and  // n
  json.byte_at(1) == 117 and  // u
  json.byte_at(2) == 108 and  // l
  json.byte_at(3) == 108;     // l

/// Check if value is a boolean
pub fn is_bool(json: String) -> bool
= json.len() >= 2 and json.byte_at(0) == 98 and json.byte_at(1) == 58; // b:

/// Check if value is a number
pub fn is_number(json: String) -> bool
= json.len() >= 2 and json.byte_at(0) == 110 and json.byte_at(1) == 58; // n:

/// Check if value is a string
pub fn is_string(json: String) -> bool
= json.len() >= 2 and json.byte_at(0) == 115 and json.byte_at(1) == 58; // s:

/// Check if value is an array
pub fn is_array(json: String) -> bool
= json.len() >= 3 and json.byte_at(0) == 97 and json.byte_at(1) == 58; // a:

/// Check if value is an object
pub fn is_object(json: String) -> bool
= json.len() >= 3 and json.byte_at(0) == 111 and json.byte_at(1) == 58; // o:

// ============================================================
// JSON Value Accessors
// ============================================================

/// Get boolean value (assumes is_bool is true)
pub fn get_bool(json: String) -> bool
    pre is_bool(json)
= json.len() >= 6 and json.byte_at(2) == 116; // t (true)

/// Get number value as integer (assumes is_number is true)
pub fn get_int(json: String) -> i64
    pre is_number(json)
= parse_int_simple(json.slice(2, json.len()));

/// Get string value (assumes is_string is true)
pub fn get_string(json: String) -> String
    pre is_string(json)
    post ret.len() == json.len() - 2
= json.slice(2, json.len());

/// Get array content (assumes is_array is true)
pub fn get_array_content(json: String) -> String
    pre is_array(json)
= json.slice(3, json.len() - 1);

/// Get object content (assumes is_object is true)
pub fn get_object_content(json: String) -> String
    pre is_object(json)
= json.slice(3, json.len() - 1);

// ============================================================
// Parsing Utilities
// ============================================================

fn skip_whitespace(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if char_is_whitespace(s.byte_at(pos)) { skip_whitespace(s, pos + 1) }
    else { pos };

// Result encoding: "pos|value" where pos is the end position
fn make_parse_result(pos: i64, value: String) -> String =
    int_to_string(pos) + "|" + value;

fn get_result_pos(result: String) -> i64 =
    let pipe = find_pipe(result, 0);
    if pipe < 0 { 0 } else { parse_int_simple(result.slice(0, pipe)) };

fn get_result_value(result: String) -> String =
    let pipe = find_pipe(result, 0);
    if pipe < 0 { "" } else { result.slice(pipe + 1, result.len()) };

fn find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 - 1 }
    else if s.byte_at(pos) == CHAR_PIPE() { pos }
    else { find_pipe(s, pos + 1) };

// ============================================================
// JSON Parsing
// ============================================================

/// Parse a JSON string to internal representation
/// Returns empty string on parse error
pub fn parse_json(input: String) -> String
    post (input.len() == 0) implies ret.len() == 0
= if input.len() == 0 { "" }
  else {
      let start = skip_whitespace(input, 0);
      let result = parse_value(input, start);
      get_result_value(result)
  };

fn parse_value(input: String, pos: i64) -> String =
    if pos >= input.len() { make_parse_result(pos, "") }
    else {
        let c = input.byte_at(pos);
        if c == CHAR_QUOTE() { parse_string_value(input, pos) }
        else if c == CHAR_LBRACE() { parse_object_value(input, pos) }
        else if c == CHAR_LBRACKET() { parse_array_value(input, pos) }
        else if c == CHAR_T() { parse_true(input, pos) }
        else if c == CHAR_F() { parse_false(input, pos) }
        else if c == CHAR_N() { parse_null(input, pos) }
        else if char_is_digit(c) or c == CHAR_MINUS() { parse_number_value(input, pos) }
        else { make_parse_result(pos, "") }
    };

fn parse_null(input: String, pos: i64) -> String =
    if pos + 4 <= input.len() and
       input.byte_at(pos) == 110 and    // n
       input.byte_at(pos + 1) == 117 and // u
       input.byte_at(pos + 2) == 108 and // l
       input.byte_at(pos + 3) == 108     // l
    { make_parse_result(pos + 4, "null") }
    else { make_parse_result(pos, "") };

fn parse_true(input: String, pos: i64) -> String =
    if pos + 4 <= input.len() and
       input.byte_at(pos) == 116 and     // t
       input.byte_at(pos + 1) == 114 and // r
       input.byte_at(pos + 2) == 117 and // u
       input.byte_at(pos + 3) == 101     // e
    { make_parse_result(pos + 4, "b:true") }
    else { make_parse_result(pos, "") };

fn parse_false(input: String, pos: i64) -> String =
    if pos + 5 <= input.len() and
       input.byte_at(pos) == 102 and     // f
       input.byte_at(pos + 1) == 97 and  // a
       input.byte_at(pos + 2) == 108 and // l
       input.byte_at(pos + 3) == 115 and // s
       input.byte_at(pos + 4) == 101     // e
    { make_parse_result(pos + 5, "b:false") }
    else { make_parse_result(pos, "") };

fn parse_number_value(input: String, pos: i64) -> String =
    let end = find_number_end(input, pos);
    if end == pos { make_parse_result(pos, "") }
    else {
        let num_str = input.slice(pos, end);
        make_parse_result(end, "n:" + num_str)
    };

fn find_number_end(s: String, pos: i64) -> i64 =
    find_number_end_inner(s, pos, true);

fn find_number_end_inner(s: String, pos: i64, allow_minus: bool) -> i64 =
    if pos >= s.len() { pos }
    else {
        let c = s.byte_at(pos);
        if char_is_digit(c) { find_number_end_inner(s, pos + 1, false) }
        else if c == CHAR_MINUS() and allow_minus { find_number_end_inner(s, pos + 1, false) }
        else if c == CHAR_DOT() { find_number_end_inner(s, pos + 1, false) }
        else { pos }
    };

fn parse_string_value(input: String, pos: i64) -> String =
    if pos >= input.len() or input.byte_at(pos) != CHAR_QUOTE() { make_parse_result(pos, "") }
    else {
        let end = find_string_end(input, pos + 1);
        if end >= input.len() { make_parse_result(pos, "") }
        else {
            let content = input.slice(pos + 1, end);
            make_parse_result(end + 1, "s:" + content)
        }
    };

fn find_string_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == CHAR_QUOTE() { pos }
    else if s.byte_at(pos) == CHAR_BACKSLASH() and pos + 1 < s.len() {
        find_string_end(s, pos + 2)
    }
    else { find_string_end(s, pos + 1) };

fn parse_array_value(input: String, pos: i64) -> String =
    if pos >= input.len() or input.byte_at(pos) != CHAR_LBRACKET() { make_parse_result(pos, "") }
    else {
        let result = parse_array_elements(input, pos + 1, "");
        let end_pos = get_result_pos(result);
        let elements = get_result_value(result);
        if end_pos >= input.len() or input.byte_at(end_pos) != CHAR_RBRACKET() {
            make_parse_result(pos, "")
        } else {
            make_parse_result(end_pos + 1, "a:[" + elements + "]")
        }
    };

fn parse_array_elements(input: String, pos: i64, acc: String) -> String =
    let p = skip_whitespace(input, pos);
    if p >= input.len() or input.byte_at(p) == CHAR_RBRACKET() { make_parse_result(p, acc) }
    else {
        let elem_result = parse_value(input, p);
        let elem_pos = get_result_pos(elem_result);
        let elem_val = get_result_value(elem_result);
        if elem_val.len() == 0 { make_parse_result(p, acc) }
        else {
            let new_acc = if acc.len() == 0 { elem_val } else { acc + "," + elem_val };
            let after = skip_whitespace(input, elem_pos);
            if after >= input.len() { make_parse_result(after, new_acc) }
            else if input.byte_at(after) == CHAR_COMMA() {
                parse_array_elements(input, after + 1, new_acc)
            }
            else { make_parse_result(after, new_acc) }
        }
    };

fn parse_object_value(input: String, pos: i64) -> String =
    if pos >= input.len() or input.byte_at(pos) != CHAR_LBRACE() { make_parse_result(pos, "") }
    else {
        let result = parse_object_pairs(input, pos + 1, "");
        let end_pos = get_result_pos(result);
        let pairs = get_result_value(result);
        if end_pos >= input.len() or input.byte_at(end_pos) != CHAR_RBRACE() {
            make_parse_result(pos, "")
        } else {
            make_parse_result(end_pos + 1, "o:{" + pairs + "}")
        }
    };

fn parse_object_pairs(input: String, pos: i64, acc: String) -> String =
    let p = skip_whitespace(input, pos);
    if p >= input.len() or input.byte_at(p) == CHAR_RBRACE() { make_parse_result(p, acc) }
    else {
        // Parse key (must be string)
        let key_result = parse_string_value(input, p);
        let key_pos = get_result_pos(key_result);
        let key_val = get_result_value(key_result);
        if key_val.len() == 0 { make_parse_result(p, acc) }
        else {
            let after_key = skip_whitespace(input, key_pos);
            if after_key >= input.len() or input.byte_at(after_key) != CHAR_COLON() {
                make_parse_result(p, acc)
            } else {
                let val_pos = skip_whitespace(input, after_key + 1);
                let val_result = parse_value(input, val_pos);
                let val_end = get_result_pos(val_result);
                let val = get_result_value(val_result);
                if val.len() == 0 { make_parse_result(p, acc) }
                else {
                    let key_str = get_string(key_val);
                    let pair = key_str + ":" + val;
                    let new_acc = if acc.len() == 0 { pair } else { acc + "," + pair };
                    let after = skip_whitespace(input, val_end);
                    if after >= input.len() { make_parse_result(after, new_acc) }
                    else if input.byte_at(after) == CHAR_COMMA() {
                        parse_object_pairs(input, after + 1, new_acc)
                    }
                    else { make_parse_result(after, new_acc) }
                }
            }
        }
    };

// ============================================================
// JSON Serialization
// ============================================================

/// Serialize internal JSON representation to JSON string
pub fn to_json(value: String) -> String
    post (value.len() == 0) implies ret.len() == 0
= if value.len() == 0 { "" }
  else if is_null(value) { "null" }
  else if is_bool(value) { if get_bool(value) { "true" } else { "false" } }
  else if is_number(value) { value.slice(2, value.len()) }
  else if is_string(value) { "\"" + escape_string(get_string(value)) + "\"" }
  else if is_array(value) { serialize_array(value) }
  else if is_object(value) { serialize_object(value) }
  else { "" };

fn escape_string(s: String) -> String =
    escape_string_acc(s, 0, "");

fn escape_string_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc }
    else {
        let c = s.byte_at(pos);
        let escaped = if c == CHAR_QUOTE() { "\\\"" }
                      else if c == CHAR_BACKSLASH() { "\\\\" }
                      else if c == 10 { "\\n" }
                      else if c == 13 { "\\r" }
                      else if c == 9 { "\\t" }
                      else { char_to_str(c) };
        escape_string_acc(s, pos + 1, acc + escaped)
    };

fn char_to_str(c: i64) -> String =
    if c >= 32 and c <= 126 { char_to_str_ascii(c) }
    else { "?" };

fn char_to_str_ascii(c: i64) -> String =
    if c == 32 { " " } else if c == 33 { "!" } else if c == 34 { "\"" }
    else if c == 35 { "#" } else if c == 36 { "$" } else if c == 37 { "%" }
    else if c == 38 { "&" } else if c == 39 { "'" } else if c == 40 { "(" }
    else if c == 41 { ")" } else if c == 42 { "*" } else if c == 43 { "+" }
    else if c == 44 { "," } else if c == 45 { "-" } else if c == 46 { "." }
    else if c == 47 { "/" } else if c >= 48 and c <= 57 { digit_to_char(c - 48) }
    else if c == 58 { ":" } else if c == 59 { ";" } else if c == 60 { "<" }
    else if c == 61 { "=" } else if c == 62 { ">" } else if c == 63 { "?" }
    else if c == 64 { "@" } else if c >= 65 and c <= 90 { upper_to_str(c) }
    else if c == 91 { "[" } else if c == 92 { "\\" } else if c == 93 { "]" }
    else if c == 94 { "^" } else if c == 95 { "_" } else if c == 96 { "`" }
    else if c >= 97 and c <= 122 { lower_to_str(c) }
    else if c == 123 { "{" } else if c == 124 { "|" } else if c == 125 { "}" }
    else { "~" };

fn upper_to_str(c: i64) -> String =
    if c == 65 { "A" } else if c == 66 { "B" } else if c == 67 { "C" }
    else if c == 68 { "D" } else if c == 69 { "E" } else if c == 70 { "F" }
    else if c == 71 { "G" } else if c == 72 { "H" } else if c == 73 { "I" }
    else if c == 74 { "J" } else if c == 75 { "K" } else if c == 76 { "L" }
    else if c == 77 { "M" } else if c == 78 { "N" } else if c == 79 { "O" }
    else if c == 80 { "P" } else if c == 81 { "Q" } else if c == 82 { "R" }
    else if c == 83 { "S" } else if c == 84 { "T" } else if c == 85 { "U" }
    else if c == 86 { "V" } else if c == 87 { "W" } else if c == 88 { "X" }
    else if c == 89 { "Y" } else { "Z" };

fn lower_to_str(c: i64) -> String =
    if c == 97 { "a" } else if c == 98 { "b" } else if c == 99 { "c" }
    else if c == 100 { "d" } else if c == 101 { "e" } else if c == 102 { "f" }
    else if c == 103 { "g" } else if c == 104 { "h" } else if c == 105 { "i" }
    else if c == 106 { "j" } else if c == 107 { "k" } else if c == 108 { "l" }
    else if c == 109 { "m" } else if c == 110 { "n" } else if c == 111 { "o" }
    else if c == 112 { "p" } else if c == 113 { "q" } else if c == 114 { "r" }
    else if c == 115 { "s" } else if c == 116 { "t" } else if c == 117 { "u" }
    else if c == 118 { "v" } else if c == 119 { "w" } else if c == 120 { "x" }
    else if c == 121 { "y" } else { "z" };

fn serialize_array(value: String) -> String =
    let content = get_array_content(value);
    "[" + serialize_array_elements(content, 0, "") + "]";

fn serialize_array_elements(content: String, pos: i64, acc: String) -> String =
    if pos >= content.len() { acc }
    else {
        let elem = extract_next_element(content, pos);
        let elem_val = get_result_value(elem);
        let elem_end = get_result_pos(elem);
        if elem_val.len() == 0 { acc }
        else {
            let serialized = to_json(elem_val);
            let new_acc = if acc.len() == 0 { serialized } else { acc + "," + serialized };
            serialize_array_elements(content, elem_end, new_acc)
        }
    };

fn serialize_object(value: String) -> String =
    let content = get_object_content(value);
    "{" + serialize_object_pairs(content, 0, "") + "}";

fn serialize_object_pairs(content: String, pos: i64, acc: String) -> String =
    if pos >= content.len() { acc }
    else {
        let key_end = find_colon_in_content(content, pos);
        if key_end >= content.len() { acc }
        else {
            let key = content.slice(pos, key_end);
            let val_start = key_end + 1;
            let val_result = extract_next_element(content, val_start);
            let val = get_result_value(val_result);
            let val_end = get_result_pos(val_result);
            if val.len() == 0 { acc }
            else {
                let serialized = "\"" + key + "\":" + to_json(val);
                let new_acc = if acc.len() == 0 { serialized } else { acc + "," + serialized };
                serialize_object_pairs(content, val_end, new_acc)
            }
        }
    };

fn extract_next_element(content: String, pos: i64) -> String =
    let end = find_element_end(content, pos, 0);
    let val = content.slice(pos, end);
    let next_pos = skip_comma_in_content(content, end);
    make_parse_result(next_pos, val);

fn skip_comma_in_content(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == CHAR_COMMA() { pos + 1 }
    else { pos };

fn find_element_end(content: String, pos: i64, depth: i64) -> i64 =
    if pos >= content.len() { pos }
    else {
        let c = content.byte_at(pos);
        if c == CHAR_LBRACE() or c == CHAR_LBRACKET() {
            find_element_end(content, pos + 1, depth + 1)
        }
        else if c == CHAR_RBRACE() or c == CHAR_RBRACKET() {
            if depth > 0 { find_element_end(content, pos + 1, depth - 1) }
            else { pos }
        }
        else if c == CHAR_COMMA() and depth == 0 { pos }
        else { find_element_end(content, pos + 1, depth) }
    };

fn find_colon_in_content(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == CHAR_COLON() { pos }
    else { find_colon_in_content(s, pos + 1) };

// ============================================================
// Convenience Functions
// ============================================================

/// Get object field by key
pub fn get_field(json: String, key: String) -> String
    pre is_object(json)
= get_field_from(get_object_content(json), key, 0);

fn get_field_from(content: String, key: String, pos: i64) -> String =
    if pos >= content.len() { "" }
    else {
        let key_end = find_colon_in_content(content, pos);
        if key_end >= content.len() { "" }
        else {
            let found_key = content.slice(pos, key_end);
            let val_start = key_end + 1;
            let val_result = extract_next_element(content, val_start);
            let val = get_result_value(val_result);
            let val_end = get_result_pos(val_result);
            if string_eq(found_key, key) { val }
            else { get_field_from(content, key, val_end) }
        }
    };

fn string_eq(a: String, b: String) -> bool =
    a.len() == b.len() and string_eq_from(a, b, 0);

fn string_eq_from(a: String, b: String, pos: i64) -> bool =
    if pos >= a.len() { true }
    else if a.byte_at(pos) != b.byte_at(pos) { false }
    else { string_eq_from(a, b, pos + 1) };

/// Get array element by index
pub fn get_element(json: String, index: i64) -> String
    pre is_array(json) and index >= 0
= get_element_from(get_array_content(json), index, 0);

fn get_element_from(content: String, index: i64, pos: i64) -> String =
    if pos >= content.len() { "" }
    else if index == 0 {
        let val_result = extract_next_element(content, pos);
        get_result_value(val_result)
    }
    else {
        let val_result = extract_next_element(content, pos);
        let val_end = get_result_pos(val_result);
        get_element_from(content, index - 1, val_end)
    };

/// Count elements in array
pub fn array_length(json: String) -> i64
    pre is_array(json)
    post ret >= 0
= count_array_elements(get_array_content(json), 0, 0);

fn count_array_elements(content: String, pos: i64, count: i64) -> i64 =
    if pos >= content.len() { count }
    else {
        let val_result = extract_next_element(content, pos);
        let val = get_result_value(val_result);
        let val_end = get_result_pos(val_result);
        if val.len() == 0 { count }
        else { count_array_elements(content, val_end, count + 1) }
    };
