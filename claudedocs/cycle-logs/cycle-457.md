# Cycle 457: Struct Init Support in Bootstrap Compiler

## Date
2026-02-14

## Scope
Add struct initialization expression (`Point { x: 3, y: 4 }`) parsing and codegen to compiler.bmb. This was the last remaining golden test failure.

## Philosophy Alignment
| Dimension | Score |
|-----------|-------|
| Core Mission Fit | 5/5 |
| Scope Boundaries | 5/5 |
| Architecture Patterns | 5/5 |
| Dependency Direction | 5/5 |

## Research Summary
- Studied existing struct infrastructure: `build_struct_registry` pre-scans struct declarations, `field-store`/`field-access` MIR instructions handle field access via GEP
- Reviewed `lower_array_literal_sb` pattern: calloc + element stores — directly applicable to struct init
- Identified `field-store` LLVM codegen name collision: uses `base_fs_p` prefix, causing duplicates when same base is used for multiple stores
- Found `parse_param` didn't handle struct type names (treated as unknown type error)

## Implementation
### Files Modified
- `bootstrap/compiler.bmb` — Struct init support:
  1. **Parser: struct init detection** — Modified `parse_ident_or_call` with two-token lookahead (`IDENT` + `:`) to distinguish `Name { field: val }` (struct init) from `name { ... }` (variable + block)
  2. **Parser: struct init functions** (5 new functions):
     - `parse_struct_init` — entry: starts AST accumulation
     - `parse_struct_fields` — dispatch: field name or `}`
     - `parse_struct_field_colon` — expect `:` after field name
     - `parse_struct_field_value` — parse value expression, accumulate AST
     - `parse_struct_field_sep` — expect `,` or `}`
  3. **AST format**: `(struct_init <Name> <field1> val1 <field2> val2)`
  4. **MIR lowering** (2 new functions):
     - `lower_struct_init_sb` — emit `calloc(field_count, 8)`, lower fields, copy base as result
     - `lower_struct_fields_sb` — for each field: lower value, copy base to unique temp, emit `field-store`
  5. **Step-based lowering**: Added `struct_init` → recursive lowering in `step_expr`
  6. **Dispatch chain**: Added `struct_init` to `lower_expr_sb` and `get_exit_label`
  7. **Parameter type fix**: Added `TK_IDENT()` handling in `parse_param` — treats struct type names as i64 (pointer)

### Key Design Decisions
1. **calloc + field-store**: Struct init allocates heap memory via `calloc(field_count, 8)` and stores each field via `field-store`, reusing the existing field store LLVM codegen (GEP + store). Zero new LLVM codegen code needed.
2. **Unique base temps**: Each `field-store` gets its own copy of the base pointer to avoid LLVM IR name collisions (the `_fs_p`/`_fs_ptr` temps generated by `llvm_gen_field_store` would collide if the same base is used multiple times).
3. **Two-token lookahead**: `Name {` followed by `IDENT :` triggers struct init parsing. Otherwise, `Name` is treated as a variable reference and `{` is left for the caller.

### Bug Found During Implementation
`parse_param` only handled primitive types (`i32`, `i64`, `f64`, `bool`, `String`, `*T`, `[T;N]`, `&T`). Struct type names like `Point` are identifiers that weren't recognized. Fixed by adding `TK_IDENT() → i64` fallback (structs are heap pointers).

## Test Results
| Test | Status |
|------|--------|
| Rust tests | 5,229 passed |
| Bootstrap Stage 1 | Built successfully |
| Stage 1 == Stage 2 | Fixed point verified (68,624 lines) |
| Golden: basic | 220 |
| Golden: strings | 27 |
| Golden: arrays | 150 |
| Golden: float | 1 |
| Golden: break | 33 |
| Golden: for-in | 141 |
| Golden: loop | 18 |
| Golden: match | 200 |
| Golden: struct | 25 (NEW - was FAIL) |
| **All golden tests** | **9/9 PASS** |

## Evaluation
| Criterion | Score | Notes |
|-----------|-------|-------|
| Correctness | 10/10 | All 9 golden tests pass, fixed point verified, struct init produces correct values |
| Architecture | 9/10 | Reuses existing field-store infrastructure, clean separation of parse/lower |
| Philosophy Alignment | 9/10 | Proper implementation, not a workaround; struct types handled correctly |
| Test Quality | 8/10 | Golden test covers basic struct init + field access; no nested struct or multi-struct test |
| Documentation | 8/10 | AST format documented, design decisions recorded |
| Code Quality | 9/10 | Consistent with existing patterns, proper two-token lookahead disambiguation |
| **Average** | **8.8/10** | |

## Issues & Improvements
| # | Severity | Description | Action |
|---|----------|-------------|--------|
| I-01 | L | Struct return types not handled in `parse_return_type` (treats unknown ident as i64, which is correct but implicit) | Add explicit struct type handling if needed |
| I-02 | L | No nested struct golden test (struct containing struct field) | Add test when needed |
| I-03 | L | Struct fields always assumed i64 in init (no f64 field handling) | Extend when f64 struct fields needed |
| I-04 | L | Field order in init must match declaration order for `field-store` to use correct indices | Add field reordering or validation |

## Next Cycle Recommendation
- All 9 golden tests pass — focus can shift to expanding bootstrap feature coverage
- Consider: closures, trait methods, enum patterns, or string matching in match expressions
- OR: Create more complex golden tests that combine features (struct + match, struct + for-in, etc.)
