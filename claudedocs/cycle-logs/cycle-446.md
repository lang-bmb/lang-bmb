# Cycle 446: Bootstrap Performance Benchmark + IR Quality Audit

## Date
2026-02-13

## Scope
Benchmark the bootstrap compiler's performance vs the Rust compiler. Audit the generated IR quality post-optimization.

## Philosophy Alignment
| Dimension | Score |
|-----------|-------|
| Core Mission Fit | 5/5 |
| Scope Boundaries | 5/5 |
| Architecture Patterns | 5/5 |
| Dependency Direction | 5/5 |

## Benchmark Results

### Compilation Time (compiler.bmb, ~7700 lines)

| Compiler | Time | Ratio vs Rust |
|----------|------|---------------|
| Rust compiler | 498ms | 1.0x |
| Stage 1 bootstrap | 2,915ms | 5.9x |
| Stage 2 bootstrap | 3,145ms | 6.3x |

### Compilation Time (optimize.bmb, ~1840 lines)

| Compiler | Time | Ratio vs Rust |
|----------|------|---------------|
| Rust compiler | 88ms | 1.0x |
| Stage 1 bootstrap | 164ms | 1.9x |

### Profile: Where Time is Spent

| Phase | Time | % of Total |
|-------|------|-----------|
| Parse + Type Check | 2,907ms | 99.7% |
| IR Generation | 8ms | 0.3% |

**Key insight**: The type checker (string-based lookup tables) is the bottleneck. IR generation and optimization are essentially free.

### Scaling Analysis

| File Size | Rust | Bootstrap | Ratio |
|-----------|------|-----------|-------|
| ~1,840 LOC | 88ms | 164ms | 1.9x |
| ~7,700 LOC | 498ms | 2,915ms | 5.9x |

The ratio grows with file size, suggesting O(n²) or worse complexity in the type checker's string table lookups.

## IR Quality Audit

### Post-Optimization Metrics

| Metric | Pre-opt | Post-opt | Reduction |
|--------|---------|----------|-----------|
| IR lines | 66,907 | 64,935 | −3% |
| Identity adds (add 0) | 14,223 | 2 | −99.99% |
| Allocas | thousands | 10 | ~99% |
| inttoptr/ptrtoint | — | 3,033 | (unavoidable) |
| Tail calls | 0 | 11,433 | LLVM TCO |

### Post-Optimization Quality Assessment

**Excellent**: LLVM `opt -O2` produces high-quality code:
- Tail recursion → loops with phi nodes
- All inline patterns (byte_at, len) preserved and optimized
- Allocas eliminated by mem2reg
- Identity instructions eliminated by InstCombine
- Functions inlined where marked `inlinehint`

**Known limitations** (not fixable at bootstrap level):
- 3,033 inttoptr/ptrtoint — unavoidable with i64-for-everything convention
- 11,894 copy instructions — generated by bootstrap's codegen pattern, eliminated by opt

## Test Results
- Unit tests: 2845 passed
- Main tests: 47 passed
- Integration tests: 2314 passed
- Gotgan tests: 23 passed
- **Total: 5229 tests — ALL PASSING**
- Clippy: PASS (0 warnings)
- Build: SUCCESS

## Evaluation
| Criterion | Score | Notes |
|-----------|-------|-------|
| Correctness | 10/10 | Benchmark methodology is sound |
| Architecture | 10/10 | Identifies root cause of performance gap |
| Philosophy Alignment | 10/10 | Performance measurement is core to BMB philosophy |
| Test Quality | 9/10 | Repeatable benchmarks |
| Code Quality | 10/10 | No code changes — measurement-only cycle |
| **Average** | **9.8/10** | |

## Issues & Improvements
| # | Severity | Description | Action |
|---|----------|-------------|--------|
| I-01 | H | Type checker is 99.7% of compilation time | Optimize string table lookups |
| I-02 | M | 6x slower than Rust for large files | Superlinear scaling in type checker |
| I-03 | L | inttoptr/ptrtoint overhead in generated code | Architectural: i64-for-everything |

## Next Cycle Recommendation
- Cycle 447: Type checker string table optimization — replace linear scan with hash-based lookup in `types.bmb` for method/type resolution
