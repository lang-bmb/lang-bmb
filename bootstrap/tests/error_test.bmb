fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { chr(n + 48) }
    else { int_to_string(n / 10) + chr((n - (n / 10) * 10) + 48) };

fn quote(s: String) -> String = chr(34) + s + chr(34);

fn slash_to_back(s: String, pos: i64) -> String =
    if pos >= s.len() { s }
    else if s.byte_at(pos) == 47 {
        let before = s.slice(0, pos);
        let after = s.slice(pos + 1, s.len());
        slash_to_back(before + "\\" + after, pos + 1)
    } else {
        slash_to_back(s, pos + 1)
    };

fn win_path(s: String) -> String = quote(slash_to_back(s, 0));

fn contains(haystack: String, needle: String) -> bool =
    contains_from(haystack, needle, 0);

fn contains_from(haystack: String, needle: String, pos: i64) -> bool =
    if pos + needle.len() > haystack.len() { false }
    else if matches_at(haystack, needle, pos) { true }
    else { contains_from(haystack, needle, pos + 1) };

fn matches_at(haystack: String, needle: String, pos: i64) -> bool =
    matches_at_inner(haystack, needle, pos, 0);

fn matches_at_inner(haystack: String, needle: String, pos: i64, i: i64) -> bool =
    if i >= needle.len() { true }
    else if haystack.byte_at(pos + i) != needle.byte_at(i) { false }
    else { matches_at_inner(haystack, needle, pos, i + 1) };

fn BMB_PATH() -> String = "target/release/bmb.exe";
fn TEST_DIR() -> String = "bootstrap/tests/errors";

fn check_file(source_file: String) -> String =
    system_capture(win_path(BMB_PATH()) + " check " + source_file + " 2>&1");

fn test_type_mismatch() -> i64 =
    let output = check_file(TEST_DIR() + "/type_mismatch.bmb");
    if contains(output, "Type error") and contains(output, "expected i64") {
        let p1 = println_str("  PASS: type mismatch error");
        1
    } else {
        let p2 = println_str("  FAIL: type mismatch error not detected");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_undefined_var() -> i64 =
    let output = check_file(TEST_DIR() + "/undefined_var.bmb");
    if contains(output, "undefined variable") {
        let p1 = println_str("  PASS: undefined variable error");
        1
    } else {
        let p2 = println_str("  FAIL: undefined variable error not detected");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_syntax_error() -> i64 =
    let output = check_file(TEST_DIR() + "/syntax_error.bmb");
    if contains(output, "Parser error") {
        let p1 = println_str("  PASS: syntax error");
        1
    } else {
        let p2 = println_str("  FAIL: syntax error not detected");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_missing_return() -> i64 =
    let output = check_file(TEST_DIR() + "/missing_return.bmb");
    if contains(output, "Parser error") and contains(output, "Expected") {
        let p1 = println_str("  PASS: missing return error");
        1
    } else {
        let p2 = println_str("  FAIL: missing return error not detected");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_wrong_arg_count() -> i64 =
    let output = check_file(TEST_DIR() + "/wrong_arg_count.bmb");
    if contains(output, "expected 2 arguments") {
        let p1 = println_str("  PASS: wrong argument count error");
        1
    } else {
        let p2 = println_str("  FAIL: wrong argument count error not detected");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_duplicate_fn() -> i64 =
    let output = check_file(TEST_DIR() + "/duplicate_fn.bmb");
    if contains(output, "duplicate") or contains(output, "defined multiple times") {
        let p1 = println_str("  PASS: duplicate function warning");
        1
    } else {
        let p2 = println_str("  FAIL: duplicate function warning not detected");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_arg_type_mismatch() -> i64 =
    let output = check_file(TEST_DIR() + "/arg_type_mismatch.bmb");
    if contains(output, "Type error") and contains(output, "expected i64") {
        let p1 = println_str("  PASS: argument type mismatch error");
        1
    } else {
        let p2 = println_str("  FAIL: argument type mismatch error not detected");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_error_span() -> i64 =
    let output = check_file(TEST_DIR() + "/type_mismatch.bmb");
    if contains(output, "Span") or contains(output, "start") {
        let p1 = println_str("  PASS: error contains span info");
        1
    } else {
        let p2 = println_str("  FAIL: error span info not found");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_json_format() -> i64 =
    let output = check_file(TEST_DIR() + "/type_mismatch.bmb");
    if contains(output, "type") and contains(output, "message") {
        let p1 = println_str("  PASS: error is JSON formatted");
        1
    } else {
        let p2 = println_str("  FAIL: error not JSON formatted");
        let p3 = println_str("    got: " + output);
        0
    };

fn test_type_names() -> i64 =
    let output = check_file(TEST_DIR() + "/type_mismatch.bmb");
    if contains(output, "String") and contains(output, "i64") {
        let p1 = println_str("  PASS: error contains type names");
        1
    } else {
        let p2 = println_str("  FAIL: type names not in error");
        let p3 = println_str("    got: " + output);
        0
    };

fn run_all_tests() -> i64 =
    let p0 = println_str("=== Error Message Tests ===");
    let t1 = test_type_mismatch();
    let t2 = test_undefined_var();
    let t3 = test_syntax_error();
    let t4 = test_missing_return();
    let t5 = test_wrong_arg_count();
    let t6 = test_duplicate_fn();
    let t7 = test_arg_type_mismatch();
    let t8 = test_error_span();
    let t9 = test_json_format();
    let t10 = test_type_names();
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

fn main() -> i64 =
    let m0 = println(777);
    let passed = run_all_tests();
    let p1 = println_str("Passed: " + int_to_string(passed) + "/10");
    let p2 = println(passed);
    let m1 = println(999);
    passed;
