// BMB Unified Compiler (v0.60.235: Fix int_to_string runtime function mapping)
// v0.60.235 changes:
// - Removed int_to_string -> bmb_int_to_string runtime mapping
// - BMB program's int_to_string should call itself, not the runtime function
// - Runtime bmb_int_to_string returns char*, not BmbString*, causing type mismatch
// v0.60.234 changes:
// - Fixed find_marker_limited to search from END instead of beginning
// - String markers are appended at end, so must search backwards
// - Fixes Stage 3 "add nsw i64" instead of bmb_string_concat bug
// v0.60.230 changes:
// - Split is_string_returning_fn into 5 helper functions (is_string_fn_group1-5)
// - Reduces work stack depth during compilation to prevent stack overflow
// - Enables Stage 2 to compile full compiler.bmb with 400+ functions
// v0.60.224 changes:
// - Removed target triple from IR header (let LLVM use host default)
// - Fixes Windows linking issues caused by Linux target triple
// v0.60.223 changes:
// - Added llvm_gen_add_with_strings for string concatenation detection
// - String marker propagation through copy operations
// - Enabled call string tracking (llvm_gen_call_with_string_tracking)
// - Expanded is_string_returning_fn list
// - Fixed void function handling in error messages
// Complete compilation pipeline: Source -> AST -> MIR -> LLVM IR
//
// ARCHITECTURE:
// 1. Source (BMB) -> parse_source() -> S-expression AST
// 2. AST -> lower_program() -> MIR text
// 3. MIR -> gen_program() -> LLVM IR text
// 4. Assembly: header + declarations + functions
//
// This file integrates pipeline.bmb and llvm_ir.bmb to provide
// a unified entry point for BMB compilation.
//
// Note: Uses | as separator instead of newlines (BMB string limitation)

// ============================================================================
// SECTION 1: String Utilities (required - no imports in bootstrap)
// ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.byte_at(pos)) { skip_ws(s, pos + 1) } else { pos };

// Error handling utilities
fn is_error(s: String) -> bool = s.len() >= 3 and s.slice(0, 3) == "ERR";
fn make_error(msg: String) -> String = "ERR:" + msg;

// v0.88.8: Position-aware error with line:col info
fn count_line_at(src: String, pos: i64, cur: i64, line: i64) -> i64 =
    if cur >= pos or cur >= src.len() { line }
    else if src.byte_at(cur) == 10 { count_line_at(src, pos, cur + 1, line + 1) }
    else { count_line_at(src, pos, cur + 1, line) };

fn count_col_at(src: String, pos: i64, cur: i64) -> i64 =
    if cur >= pos or cur >= src.len() { pos - cur }
    else if src.byte_at(cur) == 10 { count_col_at(src, pos, cur + 1) }
    else { count_col_at(src, pos, cur) };

fn find_line_start(src: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if src.byte_at(pos - 1) == 10 { pos }
    else { find_line_start(src, pos - 1) };

fn find_line_end(src: String, pos: i64) -> i64 =
    if pos >= src.len() { pos }
    else if src.byte_at(pos) == 10 { pos }
    else { find_line_end(src, pos + 1) };

fn make_error_at(msg: String, src: String, pos: i64) -> String =
    let line = count_line_at(src, pos, 0, 1);
    let ls = find_line_start(src, pos);
    let col = pos - ls + 1;
    "ERR:" + msg + " at line " + int_to_string(line) + ":" + int_to_string(col);

// Check if string starts with pattern
fn starts_with(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else { s.slice(pos, pos + pat.len()) == pat };

fn has_pattern(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else if starts_with(s, pat, pos) { true } else { has_pattern(s, pat, pos + 1) };

// v0.60.222: Safe if-chain accumulation (no recursion, no find/replace)
// Uses prefix+suffix approach: prefix="(if c1 t1 (if c2 t2 " suffix="))"
// Final AST = prefix + else_body + suffix

// ============================================================================
// SECTION 2: Token Constants (from pipeline.bmb)
// ============================================================================

// v0.90.11: Token constants in 2000000000-2000000999 range
// Moved from 10000000 range to avoid collision with integer literal 10000000
// Token packing: kind * 1000000 + pos, so token kind must not collide with any i64 literal value
// 2 billion is safely above all realistic integer literal values used in BMB programs
fn TK_BASE() -> i64 = 2000000000;
fn TK_FN() -> i64 = 2000000000 + 100;
fn TK_LET() -> i64 = 2000000000 + 101;
fn TK_IF() -> i64 = 2000000000 + 102;
fn TK_THEN() -> i64 = 2000000000 + 103;
fn TK_ELSE() -> i64 = 2000000000 + 104;
fn TK_TRUE() -> i64 = 2000000000 + 105;
fn TK_FALSE() -> i64 = 2000000000 + 106;
fn TK_AND() -> i64 = 2000000000 + 107;
fn TK_OR() -> i64 = 2000000000 + 108;
fn TK_NOT() -> i64 = 2000000000 + 109;
fn TK_PRE() -> i64 = 2000000000 + 110;
fn TK_POST() -> i64 = 2000000000 + 111;
fn TK_MUT() -> i64 = 2000000000 + 117;
fn TK_WHILE() -> i64 = 2000000000 + 118;
fn TK_BREAK() -> i64 = 2000000000 + 127;
fn TK_FOR() -> i64 = 2000000000 + 125;
fn TK_IN() -> i64 = 2000000000 + 126;
fn TK_ASYNC() -> i64 = 2000000000 + 119;
fn TK_AWAIT() -> i64 = 2000000000 + 120;
fn TK_SELECT() -> i64 = 2000000000 + 121;

fn TK_I32() -> i64 = 2000000000 + 150;
fn TK_I64() -> i64 = 2000000000 + 151;
fn TK_F64() -> i64 = 2000000000 + 152;
fn TK_BOOL() -> i64 = 2000000000 + 153;
fn TK_STRING_TYPE() -> i64 = 2000000000 + 154;
fn TK_FUTURE() -> i64 = 2000000000 + 155;
fn TK_MUTEX() -> i64 = 2000000000 + 156;
fn TK_ATOMIC() -> i64 = 2000000000 + 157;
fn TK_CHANNEL() -> i64 = 2000000000 + 158;
fn TK_SENDER() -> i64 = 2000000000 + 159;
fn TK_RECEIVER() -> i64 = 2000000000 + 160;
fn TK_RWLOCK() -> i64 = 2000000000 + 161;
fn TK_THREADPOOL() -> i64 = 2000000000 + 162;
fn TK_SCOPE() -> i64 = 2000000000 + 163;

fn TK_INT() -> i64 = 2000000000 + 200;
fn TK_IDENT() -> i64 = 2000000000 + 201;
fn TK_STRING_LIT() -> i64 = 2000000000 + 202;
fn TK_FLOAT_LIT() -> i64 = 2000000000 + 203;

fn TK_COLON() -> i64 = 2000000000 + 300;
fn TK_EQ() -> i64 = 2000000000 + 302;
fn TK_SEMI() -> i64 = 2000000000 + 303;
fn TK_COMMA() -> i64 = 2000000000 + 304;
fn TK_LPAREN() -> i64 = 2000000000 + 305;
fn TK_RPAREN() -> i64 = 2000000000 + 306;
// v0.46: Brace tokens for v0.32 braced if-else syntax
fn TK_LBRACE() -> i64 = 2000000000 + 307;
fn TK_RBRACE() -> i64 = 2000000000 + 308;

// v0.90.2: Bracket tokens for array indexing
fn TK_LBRACKET() -> i64 = 2000000000 + 309;
fn TK_RBRACKET() -> i64 = 2000000000 + 310;
// v0.90.2: set keyword for assignment expressions
fn TK_SET() -> i64 = 2000000000 + 164;
// v0.90.2: struct and null keywords
fn TK_STRUCT() -> i64 = 2000000000 + 165;
fn TK_NULL() -> i64 = 2000000000 + 166;

fn TK_ARROW() -> i64 = 2000000000 + 321;
fn TK_DOT() -> i64 = 2000000000 + 322;
fn TK_DOTDOT() -> i64 = 2000000000 + 323;

fn TK_PLUS() -> i64 = 2000000000 + 400;
fn TK_MINUS() -> i64 = 2000000000 + 401;
fn TK_STAR() -> i64 = 2000000000 + 402;
fn TK_SLASH() -> i64 = 2000000000 + 403;
fn TK_PERCENT() -> i64 = 2000000000 + 404;
fn TK_LT() -> i64 = 2000000000 + 405;
fn TK_GT() -> i64 = 2000000000 + 406;

fn TK_EQEQ() -> i64 = 2000000000 + 410;
fn TK_NEQ() -> i64 = 2000000000 + 411;
fn TK_LTEQ() -> i64 = 2000000000 + 412;
fn TK_GTEQ() -> i64 = 2000000000 + 413;

// v0.90.1: Cast and bitwise operator tokens
fn TK_AS() -> i64 = 2000000000 + 127;
fn TK_BAND() -> i64 = 2000000000 + 128;
fn TK_BOR() -> i64 = 2000000000 + 129;
fn TK_BNOT() -> i64 = 2000000000 + 130;
fn TK_BXOR() -> i64 = 2000000000 + 131;  // v0.90.2: bitwise xor
fn TK_SHL() -> i64 = 2000000000 + 431;
fn TK_SHR() -> i64 = 2000000000 + 432;

// v0.90.11: Ampersand token for reference types
fn TK_AMP() -> i64 = 2000000000 + 433;
// v0.90.11: extern keyword for FFI declarations
fn TK_EXTERN() -> i64 = 2000000000 + 167;

fn TK_EOF() -> i64 = 2000000000 + 900;

// ============================================================================
// SECTION 3: Lexer (from pipeline.bmb)
// ============================================================================

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 10 { pos + 1 } else { skip_to_eol(s, pos + 1) };

// v0.46: Support both -- (legacy) and // (v0.32) comment styles
fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 45 { skip_comment(s, skip_to_eol(s, pos + 2)) }
    else if pos + 1 < s.len() and s.byte_at(pos) == 47 and s.byte_at(pos + 1) == 47 { skip_comment(s, skip_to_eol(s, pos + 2)) }
    else { pos };

fn skip_ws_comments(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == p1 { p1 } else { skip_ws_comments(s, p2) };

// v0.90.2: Cap large ints to avoid overflow in token packing (value * 1000000 + pos)
// Actual value is reconstructed from source text in parse_int_lit
// Safe max: 9223372036854 * 1000000 = 9.22e18 < i64 MAX (9.22e18)
fn scan_int(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { pack_int_tok(acc, pos) } else {
        let c = s.byte_at(pos);
        if is_digit(c) {
            let new_acc = if acc < 9000000000000 { acc * 10 + (c - 48) } else { 9200000000000 };
            scan_int(s, pos + 1, new_acc)
        } else { pack_int_tok(acc, pos) }
    };

fn pack_int_tok(acc: i64, pos: i64) -> i64 =
    if acc >= 9000000000000 { 9200000000000 * 1000000 + pos }
    else { acc * 1000000 + pos };

// v0.91: Scan number - detects float if '.' followed by digit
// Returns packed int token OR TK_FLOAT_LIT token
fn scan_number(s: String, pos: i64) -> i64 =
    let int_result = scan_int(s, pos, 0);
    let int_end = tok_end(int_result);
    // Check for '.' followed by digit (float literal)
    if int_end + 1 < s.len() and s.byte_at(int_end) == 46 and is_digit(s.byte_at(int_end + 1)) {
        let frac_end = scan_digits_end(s, int_end + 1);
        // v0.90.2: Check for exponent part (e/E followed by optional +/- and digits)
        let exp_end = scan_exponent(s, frac_end);
        make_tok(TK_FLOAT_LIT(), exp_end)
    } else { int_result };

// v0.91: Scan digits to end (helper for float fractional part)
fn scan_digits_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { scan_digits_end(s, pos + 1) } else { pos };

// v0.90.2: Scan exponent part of float (e.g., e0, e-1, E+10)
fn scan_exponent(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 101 or s.byte_at(pos) == 69 {
        // 'e' (101) or 'E' (69)
        let after_e = pos + 1;
        if after_e >= s.len() { pos }
        else {
            let sign_end = if s.byte_at(after_e) == 43 or s.byte_at(after_e) == 45 { after_e + 1 } else { after_e };
            if sign_end >= s.len() { pos }
            else if is_digit(s.byte_at(sign_end)) { scan_digits_end(s, sign_end) }
            else { pos }
        }
    } else { pos };

fn scan_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_alnum_or_underscore(s.byte_at(pos)) { scan_ident_end(s, pos + 1) } else { pos };

// v0.60.109: Scan string literal - find closing quote
// v0.90.11: Handle escape sequences (\" doesn't end the string)
// Returns position after closing quote, or s.len() if not found
fn scan_string_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 92 and pos + 1 < s.len() { scan_string_end(s, pos + 2) }
    else if s.byte_at(pos) == 34 { pos + 1 }
    else { scan_string_end(s, pos + 1) };

fn tok_val(r: i64) -> i64 = r / 1000000;
fn tok_end(r: i64) -> i64 = r - (r / 1000000) * 1000000;
fn tok_kind(r: i64) -> i64 = tok_val(r);
fn make_tok(kind: i64, endpos: i64) -> i64 = kind * 1000000 + endpos;

// v0.60.243: Optimized keyword matching with length-based dispatch
// Reduces average comparisons from 9.5 to ~2-3 by checking length first
fn keyword_or_ident(s: String, start: i64, endpos: i64) -> i64 =
    let word = s.slice(start, endpos);
    let len = endpos - start;
    if len == 2 { keyword_len2(word, endpos) }
    else if len == 3 { keyword_len3(word, endpos) }
    else if len == 4 { keyword_len4(word, endpos) }
    else if len == 5 { keyword_len5(word, endpos) }
    else if len == 6 { keyword_len6(word, endpos) }
    else if len == 7 { keyword_len7(word, endpos) }  // v0.88
    else if len == 8 { keyword_len8(word, endpos) }  // v0.88
    else if len == 10 { keyword_len10(word, endpos) }  // v0.88
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len2(word: String, endpos: i64) -> i64 =
    if word == "fn" { make_tok(TK_FN(), endpos) }
    else if word == "if" { make_tok(TK_IF(), endpos) }
    else if word == "or" { make_tok(TK_OR(), endpos) }
    else if word == "in" { make_tok(TK_IN(), endpos) }  // v0.95: for-loop
    else if word == "as" { make_tok(TK_AS(), endpos) }  // v0.90.1: cast
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len3(word: String, endpos: i64) -> i64 =
    if word == "let" { make_tok(TK_LET(), endpos) }
    else if word == "and" { make_tok(TK_AND(), endpos) }
    else if word == "not" { make_tok(TK_NOT(), endpos) }
    else if word == "pre" { make_tok(TK_PRE(), endpos) }
    else if word == "mut" { make_tok(TK_MUT(), endpos) }
    else if word == "for" { make_tok(TK_FOR(), endpos) }  // v0.95: for-loop
    else if word == "i32" { make_tok(TK_I32(), endpos) }
    else if word == "i64" { make_tok(TK_I64(), endpos) }
    else if word == "f64" { make_tok(TK_F64(), endpos) }
    else if word == "bor" { make_tok(TK_BOR(), endpos) }  // v0.90.1: bitwise or
    else if word == "set" { make_tok(TK_SET(), endpos) }  // v0.90.2: set expression
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len4(word: String, endpos: i64) -> i64 =
    if word == "then" { make_tok(TK_THEN(), endpos) }
    else if word == "else" { make_tok(TK_ELSE(), endpos) }
    else if word == "true" { make_tok(TK_TRUE(), endpos) }
    else if word == "bool" { make_tok(TK_BOOL(), endpos) }
    else if word == "post" { make_tok(TK_POST(), endpos) }
    else if word == "band" { make_tok(TK_BAND(), endpos) }  // v0.90.1: bitwise and
    else if word == "bnot" { make_tok(TK_BNOT(), endpos) }  // v0.90.1: bitwise not
    else if word == "null" { make_tok(TK_NULL(), endpos) }  // v0.90.2: null literal
    else if word == "bxor" { make_tok(TK_BXOR(), endpos) }  // v0.90.2: bitwise xor
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len5(word: String, endpos: i64) -> i64 =
    if word == "false" { make_tok(TK_FALSE(), endpos) }
    else if word == "while" { make_tok(TK_WHILE(), endpos) }  // v0.60.248
    else if word == "break" { make_tok(TK_BREAK(), endpos) }  // v0.90.8
    else if word == "async" { make_tok(TK_ASYNC(), endpos) }  // v0.88
    else if word == "await" { make_tok(TK_AWAIT(), endpos) }  // v0.88
    else if word == "Mutex" { make_tok(TK_MUTEX(), endpos) }  // v0.88
    else if word == "Scope" { make_tok(TK_SCOPE(), endpos) }  // v0.88
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len6(word: String, endpos: i64) -> i64 =
    if word == "String" { make_tok(TK_STRING_TYPE(), endpos) }
    else if word == "select" { make_tok(TK_SELECT(), endpos) }  // v0.88
    else if word == "Future" { make_tok(TK_FUTURE(), endpos) }  // v0.88
    else if word == "Atomic" { make_tok(TK_ATOMIC(), endpos) }  // v0.88
    else if word == "Sender" { make_tok(TK_SENDER(), endpos) }  // v0.88
    else if word == "RwLock" { make_tok(TK_RWLOCK(), endpos) }  // v0.88
    else if word == "struct" { make_tok(TK_STRUCT(), endpos) }  // v0.90.2: struct declaration
    else if word == "extern" { make_tok(TK_EXTERN(), endpos) }  // v0.90.11: extern fn
    else { make_tok(TK_IDENT(), endpos) };

// v0.88: Concurrency type keywords
fn keyword_len7(word: String, endpos: i64) -> i64 =
    if word == "Channel" { make_tok(TK_CHANNEL(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len8(word: String, endpos: i64) -> i64 =
    if word == "Receiver" { make_tok(TK_RECEIVER(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len10(word: String, endpos: i64) -> i64 =
    if word == "ThreadPool" { make_tok(TK_THREADPOOL(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_ws_comments(s, pos);
    if p >= s.len() { make_tok(TK_EOF(), p) } else {
        let c = s.byte_at(p);
        if is_digit(c) { scan_number(s, p) } else if is_ident_start(c) {
            let ident_end = scan_ident_end(s, p + 1);
            keyword_or_ident(s, p, ident_end)
        } else if c == 34 {
            // v0.60.109: String literal - scan to closing quote
            let str_end = scan_string_end(s, p + 1);
            make_tok(TK_STRING_LIT(), str_end)
        } else if c == 58 { make_tok(TK_COLON(), p + 1) } else if c == 61 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_EQEQ(), p + 2) } else { make_tok(TK_EQ(), p + 1) } } else if c == 59 { make_tok(TK_SEMI(), p + 1) } else if c == 44 { make_tok(TK_COMMA(), p + 1) } else if c == 40 { make_tok(TK_LPAREN(), p + 1) } else if c == 41 { make_tok(TK_RPAREN(), p + 1) } else if c == 43 { make_tok(TK_PLUS(), p + 1) } else if c == 45 { if p + 1 < s.len() and s.byte_at(p + 1) == 62 { make_tok(TK_ARROW(), p + 2) } else { make_tok(TK_MINUS(), p + 1) } } else if c == 42 { make_tok(TK_STAR(), p + 1) } else if c == 47 { make_tok(TK_SLASH(), p + 1) } else if c == 37 { make_tok(TK_PERCENT(), p + 1) } else if c == 60 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_LTEQ(), p + 2) } else if p + 1 < s.len() and s.byte_at(p + 1) == 60 { make_tok(TK_SHL(), p + 2) } else { make_tok(TK_LT(), p + 1) } } else if c == 62 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_GTEQ(), p + 2) } else if p + 1 < s.len() and s.byte_at(p + 1) == 62 { make_tok(TK_SHR(), p + 2) } else { make_tok(TK_GT(), p + 1) } } else if c == 33 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_NEQ(), p + 2) } else { make_tok(TK_EOF(), p) } } else if c == 46 { if p + 1 < s.len() and s.byte_at(p + 1) == 46 { make_tok(TK_DOTDOT(), p + 2) } else { make_tok(TK_DOT(), p + 1) } } else if c == 91 { make_tok(TK_LBRACKET(), p + 1) } else if c == 93 { make_tok(TK_RBRACKET(), p + 1) } else if c == 123 { make_tok(TK_LBRACE(), p + 1) } else if c == 125 { make_tok(TK_RBRACE(), p + 1) } else if c == 38 { make_tok(TK_AMP(), p + 1) } else { make_tok(TK_EOF(), p) }
    };

fn get_ident_text(s: String, pos: i64, tok: i64) -> String =
    let start = tok_end(tok) - (tok_val(tok) / 1000000);
    let p = skip_ws_comments(s, pos);
    let endp = scan_ident_end(s, p + 1);
    s.slice(p, endp);

// v0.90.11: Extract integer text from source (for tuple field access .0, .1)
fn get_int_text(s: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(s, pos);
    let endpos = tok_end(tok);
    s.slice(p, endpos);

// v0.60.109: Extract string literal content (without quotes)
fn get_string_text(s: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(s, pos);
    let endpos = tok_end(tok);
    s.slice(p + 1, endpos - 1);

// v0.91: Extract float literal text from source (e.g., "3.14")
fn get_float_text(s: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(s, pos);
    let endpos = tok_end(tok);
    s.slice(p, endpos);

// v0.60.120: Escape parens in string content for AST representation
// This prevents unbalanced parens in strings from breaking AST parsing
// Uses \L for (, \R for ), \B for \ to avoid actual parens in escaped content
// v0.60.245: Rewritten with StringBuilder for O(n) instead of O(n²)
fn escape_parens_for_ast(s: String) -> String =
    let sb = sb_new();
    let _p1 = escape_parens_sb(s, 0, sb);
    sb_build(sb);

fn escape_parens_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else {
        let c = s.byte_at(pos);
        // 92=\, 40=(, 41=), 76=L, 82=R, 66=B
        let _p2 = if c == 92 {
            let _p3 = sb_push(sb, chr(92));
            sb_push(sb, chr(66))
        } else if c == 40 {
            let _p4 = sb_push(sb, chr(92));
            sb_push(sb, chr(76))
        } else if c == 41 {
            let _p5 = sb_push(sb, chr(92));
            sb_push(sb, chr(82))
        } else {
            sb_push(sb, chr(c))
        };
        escape_parens_sb(s, pos + 1, sb)
    };

// v0.60.120: Unescape parens from AST string content
// \L -> (, \R -> ), \B -> \
// v0.60.245: Rewritten with StringBuilder for O(n) instead of O(n²)
fn unescape_parens_from_ast(s: String) -> String =
    let sb = sb_new();
    let _q1 = unescape_parens_sb(s, 0, sb);
    sb_build(sb);

fn unescape_parens_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else if s.byte_at(pos) == 92 and pos + 1 < s.len() {
        let next = s.byte_at(pos + 1);
        // 76=L -> 40=(, 82=R -> 41=), 66=B -> 92=\
        let _q2 = if next == 76 { sb_push(sb, chr(40)) }
                  else if next == 82 { sb_push(sb, chr(41)) }
                  else if next == 66 { sb_push(sb, chr(92)) }
                  else {
                      let _q3 = sb_push(sb, chr(92));
                      sb_push(sb, chr(next))
                  };
        unescape_parens_sb(s, pos + 2, sb)
    }
    else {
        let _q4 = sb_push(sb, chr(s.byte_at(pos)));
        unescape_parens_sb(s, pos + 1, sb)
    };

// ============================================================================
// SECTION 4: Parser Result Packing
// ============================================================================

fn pack_result(pos: i64, ast: String) -> String = int_to_string(pos) + ":" + ast;

fn unpack_pos(r: String) -> i64 = unpack_pos_acc(r, 0, 0);

fn unpack_pos_acc(r: String, pos: i64, acc: i64) -> i64 =
    if pos >= r.len() { acc } else {
        let c = r.byte_at(pos);
        if c == 58 { acc } else if is_digit(c) { unpack_pos_acc(r, pos + 1, acc * 10 + (c - 48)) } else { acc }
    };

fn unpack_ast(r: String) -> String =
    let cpos = find_colon(r, 0);
    if cpos >= r.len() { r } else { r.slice(cpos + 1, r.len()) };

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 58 { pos } else { find_colon(s, pos + 1) };

// ============================================================================
// SECTION 5: Expression Parser (recursive descent)
// ============================================================================

// v0.90.11: Helper to check if token kind is an integer literal
// Token constants use 2000000100-2000000999 range (offset 100-999 from base)
// So integers are < 2000000100 OR >= 2000001000
fn is_int_literal(kind: i64) -> bool = kind < 2000000000 + 100 or kind >= 2000000000 + 1000;

// v0.60.117: Parse integer literal
// v0.90.2: Use source text for int literals to avoid overflow in token packing
fn parse_int_lit(src: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(src, pos);
    let endpos = tok_end(tok);
    let text = src.slice(p, endpos);
    pack_result(endpos, "(int " + text + ")");

// v0.91: Parse float literal - extract text from source
fn parse_float_lit(src: String, pos: i64, tok: i64) -> String =
    let text = get_float_text(src, pos, tok);
    pack_result(tok_end(tok), "(float " + text + ")");

// v0.60.117: Parse boolean literal
fn parse_bool_lit(tok: i64, kind: i64) -> String =
    if kind == TK_TRUE() { pack_result(tok_end(tok), "(bool true)") }
    else { pack_result(tok_end(tok), "(bool false)") };

// v0.60.117: Parse identifier or function call
fn parse_ident_or_call(src: String, pos: i64, tok: i64) -> String =
    let name = get_ident_text(src, pos, tok);
    let next = next_token_raw(src, tok_end(tok));
    if tok_kind(next) == TK_LPAREN() {
        let rargs = parse_args(src, tok_end(next), "");
        pack_result(unpack_pos(rargs), "(call <" + name + ">" + unpack_ast(rargs) + ")")
    } else {
        pack_result(tok_end(tok), "(var <" + name + ">)")
    };

// v0.60.117: Parse unary expression (not or minus)
fn parse_unary(src: String, tok: i64, op: String) -> String =
    let re = parse_atom(src, tok_end(tok));
    pack_result(unpack_pos(re), "(unary " + op + " " + unpack_ast(re) + ")");

// v0.60.117: Parse parenthesized expression
fn parse_paren_expr(src: String, tok: i64) -> String =
    let re = parse_expr(src, tok_end(tok));
    if is_error(re) { re } else {
        let next = next_token_raw(src, unpack_pos(re));
        if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), unpack_ast(re)) }
        else if tok_kind(next) == TK_COMMA() {
            // v0.90.11: Tuple expression (e1, e2, ...) → (tuple e1 e2 ...)
            parse_tuple_rest(src, tok_end(next), unpack_ast(re))
        }
        else { make_error_at("expected ')' or ',' after expression", src, unpack_pos(re)) }
    };

// v0.90.11: Parse remaining tuple elements after first comma
fn parse_tuple_rest(src: String, pos: i64, acc: String) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re } else {
        let new_acc = acc + " " + unpack_ast(re);
        let next = next_token_raw(src, unpack_pos(re));
        if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), "(tuple " + new_acc + ")") }
        else if tok_kind(next) == TK_COMMA() { parse_tuple_rest(src, tok_end(next), new_acc) }
        else { make_error_at("expected ')' or ',' in tuple", src, unpack_pos(re)) }
    };

// v0.90.2: Parse set expression: set target = value
// target can be: arr[i] or obj.field
// Produces (set_index base index value) or (set_field obj field value)
fn parse_set_expr(src: String, pos: i64) -> String =
    // Parse the target (lvalue) - it's an ident optionally followed by [i] or .field
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { make_error_at("expected identifier after 'set'", src, pos) }
    else {
        let target_name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LBRACKET() {
            // set arr[i] = val
            let ri = parse_expr(src, tok_end(t2));
            if is_error(ri) { ri } else {
                let t_close = next_token_raw(src, unpack_pos(ri));
                if tok_kind(t_close) != TK_RBRACKET() { make_error_at("expected ']' in set", src, unpack_pos(ri)) } else {
                    let t_eq = next_token_raw(src, tok_end(t_close));
                    if tok_kind(t_eq) != TK_EQ() { make_error_at("expected '=' in set expression", src, tok_end(t_close)) } else {
                        let rv = parse_expr(src, tok_end(t_eq));
                        if is_error(rv) { rv } else {
                            pack_result(unpack_pos(rv), "(set_index (var <" + target_name + ">) " + unpack_ast(ri) + " " + unpack_ast(rv) + ")")
                        }
                    }
                }
            }
        } else if tok_kind(t2) == TK_DOT() {
            // set obj.field = val
            let t3 = next_token_raw(src, tok_end(t2));
            let field_name = get_ident_text(src, tok_end(t2), t3);
            let t_eq = next_token_raw(src, tok_end(t3));
            if tok_kind(t_eq) != TK_EQ() { make_error_at("expected '=' in set expression", src, tok_end(t3)) } else {
                let rv = parse_expr(src, tok_end(t_eq));
                if is_error(rv) { rv } else {
                    pack_result(unpack_pos(rv), "(set_field (var <" + target_name + ">) " + field_name + " " + unpack_ast(rv) + ")")
                }
            }
        } else { make_error_at("expected '[' or '.' after set target", src, tok_end(t1)) }
    };

// v0.60.126: Block expression parser
// Block syntax: { stmt; stmt; ... final_expr }
// Where stmt is: let name = expr; or { lhs = rhs }; or expr;
fn parse_block_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RBRACE() {
        // Empty block: { } -> unit
        pack_result(tok_end(tok), "(unit)")
    } else {
        // Parse block contents
        let rb = parse_block_stmts(src, pos);
        if is_error(rb) { rb } else {
            let t2 = next_token_raw(src, unpack_pos(rb));
            if tok_kind(t2) != TK_RBRACE() {
                make_error_at("expected '}' to close block", src, unpack_pos(rb))
            } else {
                pack_result(tok_end(t2), "(block " + unpack_ast(rb) + ")")
            }
        }
    };

// Parse block statements: let binding or assignment or expression
fn parse_block_stmts(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    // v0.90.2: If we see '}', the block ends with unit (no final expression)
    if kind == TK_RBRACE() {
        pack_result(pos, "(unit)")
    } else if kind == TK_LET() {
        // Let binding: let name = val; body
        parse_block_let(src, tok_end(tok))
    } else if kind == TK_LBRACE() {
        // Assignment block: { lhs = rhs }; rest
        parse_block_assign(src, pos)
    } else if kind == TK_IDENT() {
        // v0.90.1: Check if this is a bare assignment: name = expr
        let peek = next_token_raw(src, tok_end(tok));
        if tok_kind(peek) == TK_EQ() {
            parse_bare_assign(src, pos)
        } else {
            // Expression or expression-statement
            parse_block_expr_stmt(src, pos)
        }
    } else {
        // Expression or expression-statement
        parse_block_expr_stmt(src, pos)
    };

// Parse let binding inside block: let name = val; rest
// v0.91: Support type annotations: let name: type = val; rest
fn parse_block_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_MUT() {
        // v0.91: let mut name ...
        parse_block_let_mut(src, tok_end(t1))
    } else if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_EQ() {
            parse_block_let_value(src, tok_end(t2), name, false)
        } else if tok_kind(t2) == TK_COLON() {
            // Skip type annotation until '='
            parse_block_let_skip_type(src, tok_end(t2), name, false)
        } else { make_error_at("expected '=' or ':' in let binding", src, tok_end(t1)) }
    } else { make_error_at("expected variable name after 'let'", src, pos) };

// v0.91: let mut name ...
fn parse_block_let_mut(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_EQ() {
            parse_block_let_value(src, tok_end(t2), name, true)
        } else if tok_kind(t2) == TK_COLON() {
            parse_block_let_skip_type(src, tok_end(t2), name, true)
        } else { make_error_at("expected '=' or ':' in let mut binding", src, tok_end(t1)) }
    } else { make_error_at("expected variable name after 'let mut'", src, pos) };

// v0.91: Skip type tokens until '=' in block let binding
fn parse_block_let_skip_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() {
        parse_block_let_value(src, tok_end(t), name, is_mut)
    } else if k == TK_IDENT() or k == TK_I64() or k == TK_I32() or k == TK_F64() or k == TK_BOOL() or k == TK_STRING_TYPE() or k == TK_STAR() or k == TK_AMP() or k == TK_MUT() {
        parse_block_let_skip_type(src, tok_end(t), name, is_mut)
    } else if k == TK_LBRACKET() {
        // v0.90.9: Skip array type [T; N]
        parse_block_let_skip_array_type(src, tok_end(t), name, is_mut)
    } else if k == TK_LPAREN() {
        // v0.90.11: Skip tuple type (T, T, ...)
        parse_block_let_skip_tuple_type(src, tok_end(t), name, is_mut)
    } else { make_error_at("expected '=' after type in let binding", src, pos) };

// v0.90.11: Skip tokens inside tuple type until ')', then continue skip_type
fn parse_block_let_skip_tuple_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RPAREN() { parse_block_let_skip_type(src, tok_end(t), name, is_mut) }
    else { parse_block_let_skip_tuple_type(src, tok_end(t), name, is_mut) };

// v0.90.9: Skip tokens inside array type until ']', then continue skip_type
fn parse_block_let_skip_array_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_RBRACKET() {
        parse_block_let_skip_type(src, tok_end(t), name, is_mut)
    } else {
        parse_block_let_skip_array_type(src, tok_end(t), name, is_mut)
    };

// v0.91: Parse value and body for block let
fn parse_block_let_value(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv } else {
        let t3 = next_token_raw(src, unpack_pos(rv));
        if tok_kind(t3) == TK_SEMI() {
            let rb = parse_block_stmts(src, tok_end(t3));
            let tag = if is_mut { "let_mut" } else { "let" };
            pack_result(unpack_pos(rb), "(" + tag + " <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")")
        } else { make_error_at("expected ';' after let binding", src, unpack_pos(rv)) }
    };

// Parse assignment inside block: { lhs = rhs }; rest
fn parse_block_assign(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' for assignment", src, pos) } else {
        // v0.90.1: Peek to decide: simple assignment { name = val } or block expression { stmts; ... }
        let peek1 = next_token_raw(src, tok_end(t1));
        let peek2 = if tok_kind(peek1) == TK_IDENT() { next_token_raw(src, tok_end(peek1)) } else { make_tok(TK_EOF(), 0) };
        if tok_kind(peek1) == TK_IDENT() and tok_kind(peek2) == TK_EQ() {
            // Looks like assignment - parse as { name = expr }
            parse_simple_assign_block(src, t1, peek1, peek2)
        } else {
            // Not an assignment - parse as block expression { stmts; ... final_expr }
            // Fall back to parsing as a block expression within an expr-stmt
            let rb = parse_block_stmts(src, tok_end(t1));
            if is_error(rb) { rb } else {
                let t_close = next_token_raw(src, unpack_pos(rb));
                if tok_kind(t_close) != TK_RBRACE() { make_error_at("expected '}' to close block", src, unpack_pos(rb)) } else {
                    let block_ast = "(block " + unpack_ast(rb) + ")";
                    let after_block = tok_end(t_close);
                    let t4 = next_token_raw(src, after_block);
                    if tok_kind(t4) == TK_SEMI() {
                        let rest = parse_block_stmts(src, tok_end(t4));
                        pack_result(unpack_pos(rest), "(seq " + block_ast + " " + unpack_ast(rest) + ")")
                    } else {
                        pack_result(after_block, block_ast)
                    }
                }
            }
        }
    };

fn parse_simple_assign_block(src: String, t1: i64, peek1: i64, peek2: i64) -> String =
    let name = get_ident_text(src, tok_end(t1), peek1);
    let rr = parse_expr(src, tok_end(peek2));
    if is_error(rr) { rr } else {
        let t3 = next_token_raw(src, unpack_pos(rr));
        if tok_kind(t3) == TK_RBRACE() {
            // Simple: { name = value }
            let assign_ast = "(assign (var <" + name + ">) " + unpack_ast(rr) + ")";
            let after_assign = tok_end(t3);
            let t4 = next_token_raw(src, after_assign);
            if tok_kind(t4) == TK_SEMI() {
                let rest = parse_block_stmts(src, tok_end(t4));
                pack_result(unpack_pos(rest), "(seq " + assign_ast + " " + unpack_ast(rest) + ")")
            } else {
                pack_result(after_assign, assign_ast)
            }
        } else if tok_kind(t3) == TK_SEMI() {
            // Multi-statement: { name = value; more_stmts... }
            let assign_ast = "(assign (var <" + name + ">) " + unpack_ast(rr) + ")";
            let rest = parse_block_stmts(src, tok_end(t3));
            if is_error(rest) { rest } else {
                let t_close = next_token_raw(src, unpack_pos(rest));
                if tok_kind(t_close) != TK_RBRACE() { make_error_at("expected '}' to close block", src, unpack_pos(rest)) } else {
                    let block_ast = "(block (seq " + assign_ast + " " + unpack_ast(rest) + "))";
                    let after_block = tok_end(t_close);
                    let t5 = next_token_raw(src, after_block);
                    if tok_kind(t5) == TK_SEMI() {
                        let rest2 = parse_block_stmts(src, tok_end(t5));
                        pack_result(unpack_pos(rest2), "(seq " + block_ast + " " + unpack_ast(rest2) + ")")
                    } else {
                        pack_result(after_block, block_ast)
                    }
                }
            }
        } else { make_error_at("expected '}' or ';' after assignment value", src, unpack_pos(rr)) }
    };

// v0.90.1: Parse bare assignment inside block: name = expr; rest
// Used for patterns like { result = result + 1 } without inner braces
fn parse_bare_assign(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let name = get_ident_text(src, pos, t1);
    let t2 = next_token_raw(src, tok_end(t1));
    if tok_kind(t2) != TK_EQ() { make_error_at("expected '=' in bare assignment", src, tok_end(t1)) } else {
        let rr = parse_expr(src, tok_end(t2));
        if is_error(rr) { rr } else {
            let assign_ast = "(assign (var <" + name + ">) " + unpack_ast(rr) + ")";
            let t3 = next_token_raw(src, unpack_pos(rr));
            if tok_kind(t3) == TK_SEMI() {
                let rest = parse_block_stmts(src, tok_end(t3));
                pack_result(unpack_pos(rest), "(seq " + assign_ast + " " + unpack_ast(rest) + ")")
            } else {
                pack_result(unpack_pos(rr), assign_ast)
            }
        }
    };

// Parse expression statement: expr; rest or just expr at end
fn parse_block_expr_stmt(src: String, pos: i64) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re } else {
        let t1 = next_token_raw(src, unpack_pos(re));
        if tok_kind(t1) == TK_SEMI() {
            // Expression statement followed by more
            let rest = parse_block_stmts(src, tok_end(t1));
            pack_result(unpack_pos(rest), "(seq " + unpack_ast(re) + " " + unpack_ast(rest) + ")")
        } else {
            // Final expression (no semicolon)
            re
        }
    };

fn parse_atom(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    // v0.60.117: Refactored to use helper functions to reduce nesting depth
    // v0.60.126: Add block expression support
    if is_int_literal(kind) { parse_int_lit(src, pos, tok) }
    else if kind == TK_FLOAT_LIT() { parse_float_lit(src, pos, tok) }
    else if kind == TK_TRUE() or kind == TK_FALSE() { parse_bool_lit(tok, kind) }
    else if kind == TK_IDENT() { parse_ident_or_call(src, pos, tok) }
    else if kind == TK_STRING_LIT() { pack_result(tok_end(tok), "(string " + escape_parens_for_ast(get_string_text(src, pos, tok)) + ")") }
    else if kind == TK_NOT() { parse_unary(src, tok, "not") }
    else if kind == TK_BNOT() { parse_unary(src, tok, "bnot") }  // v0.90.1
    else if kind == TK_MINUS() { parse_unary(src, tok, "-") }
    else if kind == TK_LPAREN() {
        // v0.90.1: Check for () unit expression
        let peek = next_token_raw(src, tok_end(tok));
        if tok_kind(peek) == TK_RPAREN() { pack_result(tok_end(peek), "(unit)") }
        else { parse_paren_expr(src, tok) }
    }
    else if kind == TK_LBRACE() { parse_block_expr(src, tok_end(tok)) }
    else if kind == TK_SET() { parse_set_expr(src, tok_end(tok)) }  // v0.90.2
    else if kind == TK_NULL() { pack_result(tok_end(tok), "(int 0)") }  // v0.90.2: null = 0
    // v0.90.9: Array repeat literal [val; count]
    else if kind == TK_LBRACKET() { parse_array_or_repeat(src, tok_end(tok)) }
    // v0.90.11: &expr — address-of/reference. Since arrays are already pointers,
    // &x just evaluates to x. Parse the inner atom and pass through.
    else if kind == TK_AMP() {
        let peek = next_token_raw(src, tok_end(tok));
        if tok_kind(peek) == TK_MUT() {
            // &mut x — skip mut, parse atom
            parse_atom(src, tok_end(peek))
        } else {
            parse_atom(src, tok_end(tok))
        }
    }
    else { make_error_at("unexpected token in expression", src, pos) };

// v0.90.10: Parse array literal or array repeat
// [val; count] → (array_repeat val count)
// [expr1, expr2, ...] → (array expr1 expr2 ...)
// [] → (array)
fn parse_array_or_repeat(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RBRACKET() {
        // Empty array []
        pack_result(tok_end(tok), "(array)")
    } else {
        let rv = parse_expr(src, pos);
        if is_error(rv) { rv }
        else {
            let val_ast = unpack_ast(rv);
            let next = next_token_raw(src, unpack_pos(rv));
            let nk = tok_kind(next);
            if nk == TK_SEMI() {
                // Array repeat: [val; count]
                let count_tok = next_token_raw(src, tok_end(next));
                let count_start = tok_end(next);
                let count_str = src.slice(count_start, tok_end(count_tok));
                let close = next_token_raw(src, tok_end(count_tok));
                if tok_kind(close) != TK_RBRACKET() { make_error_at("expected ']' in array repeat", src, tok_end(count_tok)) }
                else { pack_result(tok_end(close), "(array_repeat " + val_ast + " " + count_str + ")") }
            } else if nk == TK_COMMA() {
                // Array literal: [expr1, expr2, ...]
                parse_array_rest(src, tok_end(next), val_ast)
            } else if nk == TK_RBRACKET() {
                // Single-element array: [expr]
                pack_result(tok_end(next), "(array " + val_ast + ")")
            } else { make_error_at("expected ';', ',' or ']' in array", src, unpack_pos(rv)) }
        }
    };

// Parse remaining elements of array literal after first element and comma
fn parse_array_rest(src: String, pos: i64, acc: String) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else {
        let new_acc = acc + " " + unpack_ast(rv);
        let next = next_token_raw(src, unpack_pos(rv));
        if tok_kind(next) == TK_RBRACKET() {
            pack_result(tok_end(next), "(array " + new_acc + ")")
        } else if tok_kind(next) == TK_COMMA() {
            parse_array_rest(src, tok_end(next), new_acc)
        } else { make_error_at("expected ',' or ']' in array literal", src, unpack_pos(rv)) }
    };

fn parse_args(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), acc) } else {
        let re = parse_expr(src, pos);
        if is_error(re) { re } else {
            let new_acc = acc + " " + unpack_ast(re);
            let next = next_token_raw(src, unpack_pos(re));
            if tok_kind(next) == TK_COMMA() { parse_args(src, tok_end(next), new_acc) } else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) } else { make_error_at("expected ',' or ')' in arguments", src, unpack_pos(re)) }
        }
    };

// v0.60.110: Parse postfix operators (method calls like s.len(), `as` casts)
fn parse_postfix(src: String, pos: i64) -> String =
    let rl = parse_atom(src, pos);
    if is_error(rl) { rl } else { parse_postfix_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_postfix_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_DOT() {
        let method_tok = next_token_raw(src, tok_end(tok));
        if tok_kind(method_tok) == TK_IDENT() {
            let method_name = get_ident_text(src, tok_end(tok), method_tok);
            let next = next_token_raw(src, tok_end(method_tok));
            if tok_kind(next) == TK_LPAREN() {
                // Method call with args: s.slice(0, 1)
                let rargs = parse_args(src, tok_end(next), "");
                let ast = "(method " + method_name + " " + left + unpack_ast(rargs) + ")";
                parse_postfix_rest(src, unpack_pos(rargs), ast)
            } else {
                // v0.90.2: Bare field access: obj.field (no parens)
                let ast = "(field " + left + " " + method_name + ")";
                parse_postfix_rest(src, tok_end(method_tok), ast)
            }
        } else if is_int_literal(tok_kind(method_tok)) {
            // v0.90.11: Tuple field access: result.0, result.1
            let field_text = get_int_text(src, tok_end(tok), method_tok);
            let ast = "(field " + left + " " + field_text + ")";
            parse_postfix_rest(src, tok_end(method_tok), ast)
        } else { make_error_at("expected method name after '.'", src, tok_end(tok)) }
    } else if tok_kind(tok) == TK_LBRACKET() {
        // v0.90.2: Array indexing: arr[i]
        let ri = parse_expr(src, tok_end(tok));
        if is_error(ri) { ri } else {
            let t_close = next_token_raw(src, unpack_pos(ri));
            if tok_kind(t_close) != TK_RBRACKET() { make_error_at("expected ']' after index", src, unpack_pos(ri)) }
            else {
                let ast = "(index " + left + " " + unpack_ast(ri) + ")";
                parse_postfix_rest(src, tok_end(t_close), ast)
            }
        }
    } else if tok_kind(tok) == TK_AS() {
        // v0.90.1: Cast expression: expr as type
        let type_tok = next_token_raw(src, tok_end(tok));
        if tok_kind(type_tok) == TK_STAR() {
            // v0.90.2: as *T - pointer cast (no-op, everything is i64/ptr)
            // v0.90.9: Track *f64 casts for double load/store
            let t_type_start = tok_end(type_tok);
            let t_type = next_token_raw(src, t_type_start);
            let type_name = src.slice(t_type_start, tok_end(t_type));
            if type_name == "f64" {
                parse_postfix_rest(src, tok_end(t_type), "(cast_ptr_f64 " + left + ")")
            } else {
                parse_postfix_rest(src, tok_end(t_type), left)
            }
        } else {
            // as i64, as f64, etc. - no-op in bootstrap
            parse_postfix_rest(src, tok_end(type_tok), left)
        }
    } else { pack_result(pos, left) };

fn parse_mul(src: String, pos: i64) -> String =
    let rl = parse_postfix(src, pos);
    if is_error(rl) { rl } else { parse_mul_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_mul_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_STAR() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop * " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_SLASH() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop / " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_PERCENT() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop % " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_add(src: String, pos: i64) -> String =
    let rl = parse_mul(src, pos);
    if is_error(rl) { rl } else { parse_add_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_add_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PLUS() {
        let rr = parse_mul(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_add_rest(src, unpack_pos(rr), "(binop + " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_MINUS() {
        let rr = parse_mul(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_add_rest(src, unpack_pos(rr), "(binop - " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

// v0.90.1: Shift operators (<< >>)
fn parse_shift(src: String, pos: i64) -> String =
    let rl = parse_add(src, pos);
    if is_error(rl) { rl } else { parse_shift_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_shift_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_SHL() {
        let rr = parse_add(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_shift_rest(src, unpack_pos(rr), "(binop << " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_SHR() {
        let rr = parse_add(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_shift_rest(src, unpack_pos(rr), "(binop >> " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_cmp(src: String, pos: i64) -> String =
    let rl = parse_shift(src, pos);
    if is_error(rl) { rl } else { parse_cmp_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_cmp_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LT() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop < " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_GT() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop > " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_LTEQ() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop <= " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_GTEQ() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop >= " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_EQEQ() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop == " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_NEQ() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop != " + left + " " + unpack_ast(rr) + ")")
    } else { pack_result(pos, left) };

// v0.90.1: Bitwise AND (band)
fn parse_bitand(src: String, pos: i64) -> String =
    let rl = parse_cmp(src, pos);
    if is_error(rl) { rl } else { parse_bitand_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_bitand_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_BAND() {
        let rr = parse_cmp(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_bitand_rest(src, unpack_pos(rr), "(binop band " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

// v0.90.2: Bitwise XOR (bxor) — between band and bor in precedence
fn parse_bitxor(src: String, pos: i64) -> String =
    let rl = parse_bitand(src, pos);
    if is_error(rl) { rl } else { parse_bitxor_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_bitxor_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_BXOR() {
        let rr = parse_bitand(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_bitxor_rest(src, unpack_pos(rr), "(binop bxor " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

// v0.90.1: Bitwise OR (bor)
fn parse_bitor(src: String, pos: i64) -> String =
    let rl = parse_bitxor(src, pos);
    if is_error(rl) { rl } else { parse_bitor_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_bitor_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_BOR() {
        let rr = parse_bitxor(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_bitor_rest(src, unpack_pos(rr), "(binop bor " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_and(src: String, pos: i64) -> String =
    let rl = parse_bitor(src, pos);
    if is_error(rl) { rl } else { parse_and_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_and_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_AND() {
        let rr = parse_cmp(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_and_rest(src, unpack_pos(rr), "(binop and " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_or(src: String, pos: i64) -> String =
    let rl = parse_and(src, pos);
    if is_error(rl) { rl } else { parse_or_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_or_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_OR() {
        let rr = parse_and(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_or_rest(src, unpack_pos(rr), "(binop or " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

// v0.60.238: Refactored if-chain parser with reduced nesting depth
// Split into helper functions to avoid exponential compilation time
// prefix = "(if c1 t1 (if c2 t2 ...", suffix = "))"
// Final AST = prefix + else_body + suffix

fn parse_if_chain_iter(src: String, pos: i64, prefix: String, suffix: String) -> String =
    // pos is right after 'if' keyword, parse: cond { then } else ...
    let rc = parse_or(src, pos);
    if is_error(rc) { rc }
    else { parse_if_chain_then(src, unpack_pos(rc), unpack_ast(rc), prefix, suffix) };

fn parse_if_chain_then(src: String, pos: i64, cond_ast: String, prefix: String, suffix: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' after if condition", src, pos) }
    else {
        // v0.90.2: Use parse_block_stmts for if body to support assignments
        let rt = parse_block_stmts(src, tok_end(t1));
        if is_error(rt) { rt }
        else { parse_if_chain_after_then(src, unpack_pos(rt), cond_ast, unpack_ast(rt), prefix, suffix) }
    };

fn parse_if_chain_after_then(src: String, pos: i64, cond_ast: String, then_ast: String, prefix: String, suffix: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after then branch", src, pos) }
    else {
        let new_prefix = prefix + "(if " + cond_ast + " " + then_ast + " ";
        let new_suffix = ")" + suffix;
        parse_if_chain_else(src, tok_end(t2), new_prefix, new_suffix)
    };

fn parse_if_chain_else(src: String, pos: i64, new_prefix: String, new_suffix: String) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) == TK_ELSE() {
        let t4 = next_token_raw(src, tok_end(t3));
        let k4 = tok_kind(t4);
        if k4 == TK_IF() { parse_if_chain_iter(src, tok_end(t4), new_prefix, new_suffix) }
        else if k4 == TK_LBRACE() { parse_if_chain_final_else(src, tok_end(t4), new_prefix, new_suffix) }
        else { make_error_at("expected 'if' or '{' after 'else'", src, tok_end(t3)) }
    } else {
        // v0.90.12: if-else chain without final else: default to (int 0)
        pack_result(pos, new_prefix + "(int 0)" + new_suffix)
    };

fn parse_if_chain_final_else(src: String, pos: i64, new_prefix: String, new_suffix: String) -> String =
    // v0.90.2: Use parse_block_stmts for else body to support assignments
    let re = parse_block_stmts(src, pos);
    if is_error(re) { re }
    else { parse_if_chain_finish(src, unpack_pos(re), unpack_ast(re), new_prefix, new_suffix) };

fn parse_if_chain_finish(src: String, pos: i64, else_ast: String, new_prefix: String, new_suffix: String) -> String =
    let t5 = next_token_raw(src, pos);
    if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after else branch", src, pos) }
    else {
        let middle = new_prefix + else_ast;
        let full = middle + new_suffix;
        pack_result(tok_end(t5), full)
    };

// v0.60.238: Refactored parse_expr to reduce nesting depth

fn parse_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_IF() { parse_if_expr(src, tok_end(tok)) }
    else if kind == TK_LET() { parse_let_expr(src, tok_end(tok), pos) }
    else if kind == TK_WHILE() { parse_while_expr(src, tok_end(tok)) }  // v0.60.248
    else if kind == TK_FOR() { parse_for_expr(src, tok_end(tok)) }  // v0.95: for-loop
    else if kind == TK_BREAK() { pack_result(tok_end(tok), "(break)") }  // v0.90.8: break
    else { parse_or(src, pos) };

fn parse_if_expr(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(rc) { rc }
    else { parse_if_after_cond(src, unpack_pos(rc), unpack_ast(rc)) };

fn parse_if_after_cond(src: String, pos: i64, cond_ast: String) -> String =
    let t1 = next_token_raw(src, pos);
    let k1 = tok_kind(t1);
    // v0.46: Support both 'then/else' (legacy) and '{ } else { }' (v0.32) syntax
    if k1 == TK_THEN() { parse_if_then_syntax(src, tok_end(t1), cond_ast) }
    else if k1 == TK_LBRACE() { parse_if_brace_syntax(src, tok_end(t1), cond_ast) }
    else { make_error_at("expected '{' or 'then' after if condition", src, pos) };

fn parse_if_then_syntax(src: String, pos: i64, cond_ast: String) -> String =
    let rt = parse_expr(src, pos);
    if is_error(rt) { rt }
    else { parse_if_then_else(src, unpack_pos(rt), cond_ast, unpack_ast(rt)) };

fn parse_if_then_else(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_ELSE() { make_error_at("expected 'else' after then expression", src, pos) }
    else {
        let re = parse_expr(src, tok_end(t2));
        make_if_ast(unpack_pos(re), cond_ast, then_ast, unpack_ast(re))
    };

fn parse_if_brace_syntax(src: String, pos: i64, cond_ast: String) -> String =
    // v0.90.2: Use parse_block_stmts for if body to support assignments
    let rt = parse_block_stmts(src, pos);
    if is_error(rt) { rt }
    else { parse_if_brace_then(src, unpack_pos(rt), cond_ast, unpack_ast(rt)) };

fn parse_if_brace_then(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after if body", src, pos) }
    else { parse_if_brace_else(src, tok_end(t2), cond_ast, then_ast) };

fn parse_if_brace_else(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) == TK_ELSE() { parse_if_brace_else_body(src, tok_end(t3), cond_ast, then_ast) }
    else {
        // v0.90.12: if-without-else: default else to (int 0)
        make_if_ast(pos, cond_ast, then_ast, "(int 0)")
    };

fn parse_if_brace_else_body(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t4 = next_token_raw(src, pos);
    let k4 = tok_kind(t4);
    if k4 == TK_LBRACE() { parse_if_brace_final(src, tok_end(t4), cond_ast, then_ast) }
    else if k4 == TK_IF() {
        // v0.60.222: Use iterative chain parser for else-if
        let init_prefix = "(if " + cond_ast + " " + then_ast + " ";
        parse_if_chain_iter(src, tok_end(t4), init_prefix, ")")
    }
    else { make_error_at("expected '{' or 'if' after 'else'", src, pos) };

fn parse_if_brace_final(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    // v0.90.2: Use parse_block_stmts for else body to support assignments
    let re = parse_block_stmts(src, pos);
    if is_error(re) { re }
    else { parse_if_brace_finish(src, unpack_pos(re), cond_ast, then_ast, unpack_ast(re)) };

fn parse_if_brace_finish(src: String, pos: i64, cond_ast: String, then_ast: String, else_ast: String) -> String =
    let t5 = next_token_raw(src, pos);
    if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after else body", src, pos) }
    else { make_if_ast(tok_end(t5), cond_ast, then_ast, else_ast) };

fn make_if_ast(pos: i64, cond_ast: String, then_ast: String, else_ast: String) -> String =
    let p1 = "(if " + cond_ast;
    let p2 = p1 + " " + then_ast;
    let p3 = p2 + " " + else_ast;
    pack_result(pos, p3 + ")");

// v0.60.248: Support 'let mut' syntax for mutable variables
fn parse_let_expr(src: String, pos: i64, start_pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let k1 = tok_kind(t1);
    if k1 == TK_MUT() {
        // let mut name = ...
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_IDENT() { make_error_at("expected variable name after 'mut'", src, tok_end(t1)) }
        else { parse_let_name_mut(src, tok_end(t1), t2) }
    } else if k1 == TK_IDENT() {
        // let name = ...
        parse_let_name(src, pos, t1)
    } else { make_error_at("expected variable name after 'let'", src, pos) };

fn parse_let_name(src: String, pos: i64, t1: i64) -> String =
    let name = get_ident_text(src, pos, t1);
    parse_let_after_name(src, tok_end(t1), name, false);

fn parse_let_name_mut(src: String, pos: i64, t2: i64) -> String =
    let name = get_ident_text(src, pos, t2);
    parse_let_after_name(src, tok_end(t2), name, true);

// v0.60.248: Handle optional type annotation and continue to value
fn parse_let_after_name(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t2 = next_token_raw(src, pos);
    let k2 = tok_kind(t2);
    if k2 == TK_EQ() {
        // let name = value
        parse_let_value_mut(src, tok_end(t2), name, is_mut)
    } else if k2 == TK_COLON() {
        // let name: type = value - skip type annotation
        parse_let_skip_type(src, tok_end(t2), name, is_mut)
    } else { make_error_at("expected '=' or ':' after let binding name", src, pos) };

fn parse_let_skip_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    // Skip type token(s) until we find '='
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() {
        parse_let_value_mut(src, tok_end(t), name, is_mut)
    } else if k == TK_IDENT() or k == TK_I64() or k == TK_I32() or k == TK_F64() or k == TK_BOOL() or k == TK_STRING_TYPE() or k == TK_STAR() or k == TK_AMP() or k == TK_MUT() {
        // Skip the type and continue looking for '='
        parse_let_skip_type(src, tok_end(t), name, is_mut)
    } else if k == TK_LBRACKET() {
        // v0.90.9: Skip array type [T; N] - skip until matching ']'
        parse_let_skip_array_type(src, tok_end(t), name, is_mut)
    } else if k == TK_LPAREN() {
        // v0.90.11: Skip tuple type (T, T, ...)
        parse_let_skip_tuple_type(src, tok_end(t), name, is_mut)
    } else { make_error_at("expected '=' after type in let binding", src, pos) };

// v0.90.11: Skip tokens inside tuple type until ')', then continue skip_type
fn parse_let_skip_tuple_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RPAREN() { parse_let_skip_type(src, tok_end(t), name, is_mut) }
    else { parse_let_skip_tuple_type(src, tok_end(t), name, is_mut) };

// v0.90.9: Skip tokens inside array type until ']', then continue skip_type
fn parse_let_skip_array_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_RBRACKET() {
        parse_let_skip_type(src, tok_end(t), name, is_mut)
    } else {
        // Skip any token inside array type annotation (type name, semicolon, number)
        parse_let_skip_array_type(src, tok_end(t), name, is_mut)
    };

fn parse_let_value_mut(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else { parse_let_body_mut(src, unpack_pos(rv), name, unpack_ast(rv), is_mut) };

fn parse_let_body_mut(src: String, pos: i64, name: String, val_ast: String, is_mut: bool) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) != TK_SEMI() { make_error_at("expected ';' after let binding value", src, pos) }
    else {
        let rb = parse_expr(src, tok_end(t3));
        if is_mut {
            make_let_mut_ast(unpack_pos(rb), name, val_ast, unpack_ast(rb))
        } else {
            make_let_ast(unpack_pos(rb), name, val_ast, unpack_ast(rb))
        }
    };

fn parse_let_value(src: String, pos: i64, name: String) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else { parse_let_body(src, unpack_pos(rv), name, unpack_ast(rv)) };

fn parse_let_body(src: String, pos: i64, name: String, val_ast: String) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) != TK_SEMI() { make_error_at("expected ';' after let binding value", src, pos) }
    else {
        let rb = parse_expr(src, tok_end(t3));
        make_let_ast(unpack_pos(rb), name, val_ast, unpack_ast(rb))
    };

fn make_let_ast(pos: i64, name: String, val_ast: String, body_ast: String) -> String =
    let p1 = "(let <" + name + "> ";
    let p2 = p1 + val_ast + " ";
    pack_result(pos, p2 + body_ast + ")");

// v0.60.248: let mut creates (let_mut ...) AST node
fn make_let_mut_ast(pos: i64, name: String, val_ast: String, body_ast: String) -> String =
    let p1 = "(let_mut <" + name + "> ";
    let p2 = p1 + val_ast + " ";
    pack_result(pos, p2 + body_ast + ")");

// ============================================================================
// v0.60.248: While Expression Parser
// ============================================================================

// Parse while expression: while condition { body }
// AST format: (while condition body)
fn parse_while_expr(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(rc) { rc }
    else { parse_while_body(src, unpack_pos(rc), unpack_ast(rc)) };

fn parse_while_body(src: String, pos: i64, cond_ast: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' after while condition", src, pos) }
    else { parse_while_body_inner(src, tok_end(t1), cond_ast) };

// v0.91: While body uses parse_block_stmts for let/assign/expr support
fn parse_while_body_inner(src: String, pos: i64, cond_ast: String) -> String =
    let rb = parse_block_stmts(src, pos);
    if is_error(rb) { rb }
    else { parse_while_finish(src, unpack_pos(rb), cond_ast, unpack_ast(rb)) };

fn parse_while_finish(src: String, pos: i64, cond_ast: String, body_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after while body", src, pos) }
    else { pack_result(tok_end(t2), "(while " + cond_ast + " " + body_ast + ")") };

// v0.95: for-loop parser
// Syntax: for <ident> in <start> .. <end> { <body> }
// Produces AST: (for <varname> start_ast end_ast body_ast)
fn parse_for_expr(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { make_error_at("expected variable name after 'for'", src, pos) }
    else {
        let varname = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_IN() { make_error_at("expected 'in' after for variable", src, tok_end(t1)) }
        else { parse_for_range(src, tok_end(t2), varname) }
    };

fn parse_for_range(src: String, pos: i64, varname: String) -> String =
    let rs = parse_or(src, pos);
    if is_error(rs) { rs }
    else {
        let start_ast = unpack_ast(rs);
        let t3 = next_token_raw(src, unpack_pos(rs));
        if tok_kind(t3) != TK_DOTDOT() { make_error_at("expected '..' in for range", src, unpack_pos(rs)) }
        else { parse_for_end(src, tok_end(t3), varname, start_ast) }
    };

fn parse_for_end(src: String, pos: i64, varname: String, start_ast: String) -> String =
    let re = parse_or(src, pos);
    if is_error(re) { re }
    else {
        let end_ast = unpack_ast(re);
        let t4 = next_token_raw(src, unpack_pos(re));
        if tok_kind(t4) != TK_LBRACE() { make_error_at("expected '{' after for range", src, unpack_pos(re)) }
        else { parse_for_body(src, tok_end(t4), varname, start_ast, end_ast) }
    };

fn parse_for_body(src: String, pos: i64, varname: String, start_ast: String, end_ast: String) -> String =
    let rb = parse_block_stmts(src, pos);
    if is_error(rb) { rb }
    else {
        let body_ast = unpack_ast(rb);
        let t5 = next_token_raw(src, unpack_pos(rb));
        if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after for body", src, unpack_pos(rb)) }
        else { pack_result(tok_end(t5), "(for <" + varname + "> " + start_ast + " " + end_ast + " " + body_ast + ")") }
    };

// ============================================================================
// SECTION 6: Function and Program Parser
// ============================================================================

fn parse_param(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_COLON() {
            let t3 = next_token_raw(src, tok_end(t2));
            let kind = tok_kind(t3);
            // v0.90.2: Support typed pointers *T
            // v0.90.7: Preserve struct name for ptr arithmetic scaling
            if kind == TK_I32() { pack_result(tok_end(t3), "(param <" + name + "> i32)") } else if kind == TK_I64() { pack_result(tok_end(t3), "(param <" + name + "> i64)") } else if kind == TK_F64() { pack_result(tok_end(t3), "(param <" + name + "> f64)") } else if kind == TK_BOOL() { pack_result(tok_end(t3), "(param <" + name + "> bool)") } else if kind == TK_STRING_TYPE() { pack_result(tok_end(t3), "(param <" + name + "> String)") } else if kind == TK_STAR() { let t4 = next_token_raw(src, tok_end(t3)); let struct_name = get_ident_text(src, tok_end(t3), t4); pack_result(tok_end(t4), "(param <" + name + "> *" + struct_name + ")") } else if kind == TK_LBRACKET() { parse_param_array_type(src, tok_end(t3), name) } else if kind == TK_AMP() { parse_param_ref_type(src, tok_end(t3), name) } else { make_error_at("expected parameter type (i32, i64, f64, bool, String, *T, [T;N], &T, &[T;N])", src, tok_end(t2)) }
        } else { make_error_at("expected ':' after parameter name", src, tok_end(t1)) }
    } else { make_error_at("expected parameter name", src, pos) };

// v0.90.10: Parse array type [T; N] in function parameter position
// Skip tokens until ']' and emit param as i64 (array is heap pointer)
fn parse_param_array_type(src: String, pos: i64, name: String) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_RBRACKET() {
        pack_result(tok_end(t), "(param <" + name + "> i64)")
    } else {
        parse_param_array_type(src, tok_end(t), name)
    };

// v0.90.11: Parse reference type &T or &[T; N] or &mut T in function parameter position
// All reference types treated as i64 (pointer) at MIR/codegen level
fn parse_param_ref_type(src: String, pos: i64, name: String) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_MUT() {
        // &mut T — skip 'mut', then parse the base type as i64
        let t2 = next_token_raw(src, tok_end(t));
        let k2 = tok_kind(t2);
        if k2 == TK_LBRACKET() { parse_param_array_type(src, tok_end(t2), name) }
        else { pack_result(tok_end(t2), "(param <" + name + "> i64)") }
    } else if k == TK_LBRACKET() {
        // &[T; N] — delegate to array type parser
        parse_param_array_type(src, tok_end(t), name)
    } else {
        // &T — just consume the type name and emit i64
        pack_result(tok_end(t), "(param <" + name + "> i64)")
    };

fn parse_params(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), acc) } else {
        let rp = parse_param(src, pos);
        if is_error(rp) { rp } else {
            let new_acc = acc + " " + unpack_ast(rp);
            let next = next_token_raw(src, unpack_pos(rp));
            if tok_kind(next) == TK_COMMA() { parse_params(src, tok_end(next), new_acc) } else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) } else { make_error_at("expected ',' or ')' in parameter list", src, unpack_pos(rp)) }
        }
    };

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LPAREN() {
            let rp = parse_params(src, tok_end(t2), "");
            if is_error(rp) { rp } else {
                let t3 = next_token_raw(src, unpack_pos(rp));
                if tok_kind(t3) == TK_ARROW() {
                    let t4 = next_token_raw(src, tok_end(t3));
                    // v0.90.2: Support typed pointer return types *T
                    let ret_type_and_end = parse_return_type(src, tok_end(t3));
                    let ret_type = unpack_ast(ret_type_and_end);
                    let t5 = next_token_raw(src, unpack_pos(ret_type_and_end));
                    // v0.90.10: Skip pre/post contract clauses
                    let eq_pos = skip_contracts(src, unpack_pos(ret_type_and_end));
                    let rb = parse_expr(src, eq_pos);
                    if is_error(rb) { rb } else {
                        let t6 = next_token_raw(src, unpack_pos(rb));
                        if tok_kind(t6) == TK_SEMI() { pack_result(tok_end(t6), "(fn <" + name + ">" + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") } else { pack_result(unpack_pos(rb), "(fn <" + name + ">" + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") }
                    }
                } else { make_error_at("expected '->' after parameters", src, unpack_pos(rp)) }
            }
        } else { make_error_at("expected '(' after function name", src, tok_end(t1)) }
    } else { make_error_at("expected function name after 'fn'", src, pos) };

// v0.90.10: Skip tokens inside [T; N] array type, return pack_result with given type
fn skip_array_type_tokens(src: String, pos: i64, type_str: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RBRACKET() { pack_result(tok_end(t), type_str) }
    else { skip_array_type_tokens(src, tok_end(t), type_str) };

// v0.90.10: Skip pre/post contract clauses until '=' is found
// Returns position after the '=' token
fn skip_contracts(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() { tok_end(t) }
    else if k == TK_PRE() or k == TK_POST() {
        // Skip the contract expression (parse and discard)
        let re = parse_expr(src, tok_end(t));
        if is_error(re) { tok_end(t) }
        else { skip_contracts(src, unpack_pos(re)) }
    }
    else { tok_end(t) };  // Unexpected token, try advancing

// v0.90.2: Parse return type including typed pointers
fn parse_return_type(src: String, pos: i64) -> String =
    let t4 = next_token_raw(src, pos);
    if tok_kind(t4) == TK_I32() { pack_result(tok_end(t4), "i32") }
    else if tok_kind(t4) == TK_I64() { pack_result(tok_end(t4), "i64") }
    else if tok_kind(t4) == TK_F64() { pack_result(tok_end(t4), "f64") }
    else if tok_kind(t4) == TK_BOOL() { pack_result(tok_end(t4), "bool") }
    else if tok_kind(t4) == TK_STRING_TYPE() { pack_result(tok_end(t4), "String") }
    else if tok_kind(t4) == TK_STAR() {
        // v0.90.7: *T typed pointer → preserve struct name for ptr arithmetic
        let t5 = next_token_raw(src, tok_end(t4));
        let sname = get_ident_text(src, tok_end(t4), t5);
        pack_result(tok_end(t5), "*" + sname)
    }
    // v0.90.10: Array return type [T; N] → treat as i64 (pointer)
    else if tok_kind(t4) == TK_LBRACKET() {
        skip_array_type_tokens(src, tok_end(t4), "i64")
    }
    // v0.90.11: Reference return type &T, &[T; N] → treat as i64 (pointer)
    else if tok_kind(t4) == TK_AMP() {
        let t5 = next_token_raw(src, tok_end(t4));
        if tok_kind(t5) == TK_LBRACKET() { skip_array_type_tokens(src, tok_end(t5), "i64") }
        else if tok_kind(t5) == TK_MUT() {
            let t6 = next_token_raw(src, tok_end(t5));
            if tok_kind(t6) == TK_LBRACKET() { skip_array_type_tokens(src, tok_end(t6), "i64") }
            else { pack_result(tok_end(t6), "i64") }
        }
        else { pack_result(tok_end(t5), "i64") }
    }
    // v0.90.11: Tuple return type (T1, T2, ...) → treat as i64
    else if tok_kind(t4) == TK_LPAREN() {
        skip_tuple_type_tokens(src, tok_end(t4), "i64")
    }
    else { pack_result(tok_end(t4), "i64") };

// v0.90.11: Skip tokens inside tuple type until matching ')'
fn skip_tuple_type_tokens(src: String, pos: i64, type_str: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RPAREN() { pack_result(tok_end(t), type_str) }
    else if tok_kind(t) == TK_EOF() { pack_result(pos, type_str) }
    else { skip_tuple_type_tokens(src, tok_end(t), type_str) };

// v0.90.1: Parse function with annotation (@pure, @const, @inline)
// Emits (fn-pure <name> ...) or (fn-inline <name> ...) etc.
fn parse_fn_with_annotation(src: String, pos: i64, ann: String) -> String =
    let rf = parse_fn(src, pos);
    if is_error(rf) { rf } else {
        let ast = unpack_ast(rf);
        // Replace "(fn " prefix with "(fn-annotation "
        let new_ast = "(fn-" + ann + " " + ast.slice(4, ast.len());
        pack_result(unpack_pos(rf), new_ast)
    };

// v0.60.241: Refactored to use StringBuilder for O(1) amortized accumulation
// Previously O(N²) due to fns + " " + unpack_ast(rf) pattern
// v0.90.1: Skip annotation and return its name, or "" if no annotation
// Handles @pure, @const, @inline at the source level (before tokenizer)
fn skip_annotation(src: String, pos: i64) -> String =
    let p = skip_ws_comments(src, pos);
    if p >= src.len() { "" }
    else if src.byte_at(p) == 64 {
        // @ found, scan annotation name
        let name_start = p + 1;
        let name_end = scan_ident_end(src, name_start);
        src.slice(name_start, name_end)
    } else { "" };

// v0.90.1: Get position after annotation (past @name)
fn pos_after_annotation(src: String, pos: i64) -> i64 =
    let p = skip_ws_comments(src, pos);
    if p >= src.len() { p }
    else if src.byte_at(p) == 64 {
        let name_start = p + 1;
        scan_ident_end(src, name_start)
    } else { p };

fn parse_program_sb(src: String, pos: i64, sb: i64) -> String =
    // v0.90.1: Check for annotation FIRST (before tokenizer, since @ is not a token)
    let ann = skip_annotation(src, pos);
    if ann.len() > 0 {
        let after_ann = pos_after_annotation(src, pos);
        let tok2 = next_token_raw(src, after_ann);
        if tok_kind(tok2) == TK_FN() {
            let rf = parse_fn_with_annotation(src, tok_end(tok2), ann);
            if is_error(rf) { rf } else {
                let w1 = sb_push(sb, " ");
                let w2 = sb_push(sb, unpack_ast(rf));
                parse_program_sb(src, unpack_pos(rf), sb)
            }
        } else { make_error_at("expected 'fn' after @" + ann, src, after_ann) }
    } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() {
            let w1 = sb_push(sb, ")");
            sb_build(sb)
        } else if kind == TK_FN() {
            let rf = parse_fn(src, tok_end(tok));
            if is_error(rf) { rf } else {
                let w1 = sb_push(sb, " ");
                let w2 = sb_push(sb, unpack_ast(rf));
                parse_program_sb(src, unpack_pos(rf), sb)
            }
        } else if kind == TK_STRUCT() {
            // v0.90.2: Skip struct declarations (not needed for bootstrap codegen)
            let end_pos = skip_struct_decl(src, tok_end(tok));
            parse_program_sb(src, end_pos, sb)
        } else if kind == TK_EXTERN() {
            // v0.90.11: Skip extern fn declarations (runtime provides these)
            let end_pos = skip_extern_fn(src, tok_end(tok));
            parse_program_sb(src, end_pos, sb)
        } else { make_error_at("expected 'fn' declaration", src, pos) }
    };

// v0.90.11: Skip extern fn declaration: extern fn name(params) -> Type;
fn skip_extern_fn(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_SEMI() { tok_end(t) }
    else if k == TK_EOF() { pos }
    else { skip_extern_fn(src, tok_end(t)) };

// v0.90.2: Skip struct declaration: struct Name { field: Type, ... }
fn skip_struct_decl(src: String, pos: i64) -> i64 =
    // Skip name
    let t1 = next_token_raw(src, pos);
    // Skip to opening brace
    let t2 = next_token_raw(src, tok_end(t1));
    if tok_kind(t2) == TK_LBRACE() {
        skip_to_rbrace(src, tok_end(t2))
    } else { tok_end(t2) };

fn skip_to_rbrace(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RBRACE() { tok_end(tok) }
    else if tok_kind(tok) == TK_EOF() { pos }
    else { skip_to_rbrace(src, tok_end(tok)) };

// v0.90.5: Build struct registry from source code
// Pre-scans for struct declarations and builds registry:
// Format: "StructName:field0,field1,...;StructName2:field0,field1,...;"
fn build_struct_registry(src: String) -> String =
    let rsb = sb_new();
    let w = scan_structs(src, 0, rsb);
    sb_build(rsb);

fn scan_structs(src: String, pos: i64, rsb: i64) -> i64 =
    if pos >= src.len() { 0 } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() {
            // Unrecognized char (e.g. '@') returns TK_EOF before actual EOF
            // Skip it and continue scanning
            if tok_end(tok) < src.len() { scan_structs(src, tok_end(tok) + 1, rsb) }
            else { 0 }
        }
        else if kind == TK_STRUCT() {
            let end_pos = parse_struct_to_registry(src, tok_end(tok), rsb);
            scan_structs(src, end_pos, rsb)
        } else {
            scan_structs(src, tok_end(tok), rsb)
        }
    };

// Parse struct Name { field: Type, ... } and register fields
fn parse_struct_to_registry(src: String, pos: i64, rsb: i64) -> i64 =
    let t1 = next_token_raw(src, pos);
    let name = get_ident_text(src, pos, t1);
    let t2 = next_token_raw(src, tok_end(t1));
    if tok_kind(t2) == TK_LBRACE() {
        let w1 = sb_push(rsb, name + ":");
        let end = parse_struct_fields_to_registry(src, tok_end(t2), rsb, 0);
        let w2 = sb_push(rsb, ";");
        end
    } else { tok_end(t2) };

fn parse_struct_fields_to_registry(src: String, pos: i64, rsb: i64, idx: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { tok_end(tok) }
    else if kind == TK_EOF() {
        // Handle unrecognized chars in struct body
        if tok_end(tok) < src.len() { parse_struct_fields_to_registry(src, tok_end(tok) + 1, rsb, idx) }
        else { pos }
    }
    else if kind == TK_IDENT() {
        let field_name = get_ident_text(src, pos, tok);
        // Check field type (after : token) for f64 or *StructName marker
        let type_info = check_field_type(src, tok_end(tok));
        let ptr_type = get_field_ptr_type(src, tok_end(tok));
        let type_suffix = if type_info == 1 { "~d" } else if ptr_type != "" { "~p-" + ptr_type } else { "" };
        let w1 = if idx > 0 { sb_push(rsb, ",") } else { 0 };
        let w2 = sb_push(rsb, field_name + type_suffix);
        let after_field = skip_field_type(src, tok_end(tok));
        parse_struct_fields_to_registry(src, after_field, rsb, idx + 1)
    } else {
        // Skip commas, colons, etc.
        parse_struct_fields_to_registry(src, tok_end(tok), rsb, idx)
    };

// Check if field type is f64 (returns 1 if f64, 0 otherwise)
fn check_field_type(src: String, pos: i64) -> i64 =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_COLON() {
        let t2 = next_token_raw(src, tok_end(t1));
        // f64 is tokenized as TK_F64, not TK_IDENT
        if tok_kind(t2) == TK_F64() { 1 } else { 0 }
    } else { 0 };

// v0.90.7: Check if field type is *StructName (returns struct name or "")
fn get_field_ptr_type(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_COLON() {
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_STAR() {
            let t3 = next_token_raw(src, tok_end(t2));
            if tok_kind(t3) == TK_IDENT() { get_ident_text(src, tok_end(t2), t3) }
            else { "" }
        } else { "" }
    } else { "" };

// Skip field type annotation (: Type) until , or }
fn skip_field_type(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_COMMA() { tok_end(tok) }
    else if kind == TK_RBRACE() { pos }
    else if kind == TK_EOF() { pos }
    else { skip_field_type(src, tok_end(tok)) };

// Look up field index from struct registry
// Registry format: "Node:left,right;Body:x,y,z;"
fn lookup_field_index(registry: String, struct_name: String, field_name: String) -> i64 =
    lookup_struct_entry(registry, 0, struct_name, field_name);

fn lookup_struct_entry(registry: String, pos: i64, struct_name: String, field_name: String) -> i64 =
    if pos >= registry.len() { 0 } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let entry_name = entry.slice(0, colon_pos);
        if entry_name == struct_name {
            let fields = entry.slice(colon_pos + 1, entry.len());
            find_field_index(fields, 0, 0, field_name)
        } else {
            if semi_pos + 1 >= registry.len() { 0 }
            else { lookup_struct_entry(registry, semi_pos + 1, struct_name, field_name) }
        }
    };

fn find_field_index(fields: String, pos: i64, idx: i64, target: String) -> i64 =
    if pos >= fields.len() { 0 } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        let name = strip_type_suffix(raw_name);
        if name == target { idx }
        else if comma_pos >= fields.len() { 0 }
        else { find_field_index(fields, comma_pos + 1, idx + 1, target) }
    };

fn parse_source(src: String) -> String =
    let sb = sb_new();
    let w1 = sb_push(sb, "(program");
    parse_program_sb(src, 0, sb);

// ============================================================================
// SECTION 7: S-Expression Utilities (for lowering)
// ============================================================================

fn low_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

fn low_skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_whitespace(s.byte_at(pos)) { low_skip_ws(s, pos + 1) } else { pos };

fn low_is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

fn low_is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
    c == 60 or c == 62 or c == 61 or c == 33;

fn low_find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_ident_char(s.byte_at(pos)) { low_find_ident_end(s, pos + 1) } else { pos };

fn low_find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_op_char(s.byte_at(pos)) { low_find_op_end(s, pos + 1) } else { pos };

fn low_starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() { false } else { s.slice(pos, pos + prefix.len()) == prefix };

fn low_find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() { pos } else {
        let c = s.byte_at(pos);
        if c == 40 { low_find_close_paren(s, pos + 1, depth + 1) } else if c == 41 { if depth == 1 { pos } else { low_find_close_paren(s, pos + 1, depth - 1) } } else { low_find_close_paren(s, pos + 1, depth) }
    };

fn extract_paren_content(s: String) -> String =
    if s.len() < 2 { "" } else if s.byte_at(0) == 40 {
        let end = low_find_close_paren(s, 0, 0);
        s.slice(1, end)
    } else { "" };

fn get_node_type(ast: String) -> String =
    if ast.len() == 0 { "" } else {
        let content = extract_paren_content(ast);
        let pos = low_skip_ws(content, 0);
        if pos >= content.len() { "" } else {
            let c = content.byte_at(pos);
            if low_is_ident_char(c) {
                let endp = low_find_ident_end(content, pos);
                content.slice(pos, endp)
            } else if low_is_op_char(c) {
                let endp = low_find_op_end(content, pos);
                content.slice(pos, endp)
            } else { "" }
        }
    };

// v0.92: Check if AST expression produces a float value
// Detects float literals and binops on float operands (recursive)
fn is_float_expr(ast: String) -> bool =
    let ntype = get_node_type(ast);
    if ntype == "float" { true }
    else if ntype == "unary" { is_float_expr(get_child(ast, 1)) }
    else if ntype == "binop" { is_float_expr(get_child(ast, 1)) }
    else { false };

fn get_child(ast: String, idx: i64) -> String =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let after_type = if end1 > pos { end1 } else { low_find_op_end(content, pos) };
    get_child_at(content, after_type, idx);

fn get_child_at(content: String, pos: i64, idx: i64) -> String =
    if idx < 0 { "" } else {
        let p = low_skip_ws(content, pos);
        if p >= content.len() { "" } else if idx == 0 { read_sexp_at(content, p) } else {
            let child = read_sexp_at(content, p);
            let next_pos = p + child.len();
            get_child_at(content, next_pos, idx - 1)
        }
    };

fn read_sexp_at(s: String, pos: i64) -> String =
    let p = low_skip_ws(s, pos);
    if p >= s.len() { "" } else {
        let c = s.byte_at(p);
        if c == 40 {
            let end = low_find_close_paren(s, p, 0);
            s.slice(p, end + 1)
        } else if c == 60 and p + 1 < s.len() and is_ident_start(s.byte_at(p + 1)) {
            // v0.60.117: Only treat <...> as angle-bracketed name if < is followed by identifier
            // This fixes parsing of < operator in AST like (binop < ...)
            let end = find_angle_end(s, p);
            s.slice(p, end)
        } else if is_digit(c) or c == 45 {
            let end = find_number_end(s, p);
            s.slice(p, end)
        } else if low_is_ident_char(c) {
            let end = low_find_ident_end(s, p);
            s.slice(p, end)
        } else if low_is_op_char(c) {
            let end = low_find_op_end(s, p);
            s.slice(p, end)
        } else { "" }
    };

fn find_angle_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 62 { pos + 1 } else { find_angle_end(s, pos + 1) };

fn find_number_end(s: String, pos: i64) -> i64 =
    let p = if pos < s.len() and s.byte_at(pos) == 45 { pos + 1 } else { pos };
    let int_end = find_digits_end(s, p);
    // v0.91: Check for '.' followed by digit (float literal)
    if int_end + 1 < s.len() and s.byte_at(int_end) == 46 and is_digit(s.byte_at(int_end + 1)) {
        find_digits_end(s, int_end + 1)
    } else { int_end };

fn find_digits_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { find_digits_end(s, pos + 1) } else { pos };

fn extract_name(ast: String) -> String =
    let child = get_child(ast, 0);
    if child.len() >= 2 and child.byte_at(0) == 60 { child.slice(1, child.len() - 1) } else { child };

// v0.88.1: Rename variable references in AST for SSA-compatible let bindings
// Finds all "(var <oldname>)" patterns and replaces with "(var <newname>)"
fn rename_var_in_ast(ast: String, oldname: String, newname: String) -> String =
    rename_var_in_ast_at(ast, oldname, newname, 0, "");

fn rename_var_in_ast_at(ast: String, oldname: String, newname: String, pos: i64, acc: String) -> String =
    if pos >= ast.len() { acc } else {
        let var_pos = find_var_pattern_at(ast, pos);
        if var_pos < 0 {
            acc + ast.slice(pos, ast.len())
        } else {
            let name_start = var_pos + 6;
            let name_end = find_char_at(ast, 62, name_start);
            if name_end <= name_start {
                rename_var_in_ast_at(ast, oldname, newname, var_pos + 1, acc + ast.slice(pos, var_pos + 1))
            } else {
                let found_name = ast.slice(name_start, name_end);
                if found_name == oldname {
                    let before = ast.slice(pos, var_pos);
                    let replaced = "(var <" + newname + ">";
                    rename_var_in_ast_at(ast, oldname, newname, name_end + 1, acc + before + replaced)
                } else {
                    rename_var_in_ast_at(ast, oldname, newname, name_end + 1, acc + ast.slice(pos, name_end + 1))
                }
            }
        }
    };

// Find "(var <" pattern starting from pos (returns -1 if not found)
fn find_var_pattern_at(ast: String, pos: i64) -> i64 =
    if pos + 5 >= ast.len() { 0 - 1 }
    else if ast.byte_at(pos) == 40 and ast.byte_at(pos+1) == 118 and
            ast.byte_at(pos+2) == 97 and ast.byte_at(pos+3) == 114 and
            ast.byte_at(pos+4) == 32 and ast.byte_at(pos+5) == 60 { pos }
    else { find_var_pattern_at(ast, pos + 1) };

// Find character c starting from pos (returns -1 if not found)
fn find_char_at(ast: String, c: i64, pos: i64) -> i64 =
    if pos >= ast.len() { 0 - 1 }
    else if ast.byte_at(pos) == c { pos }
    else { find_char_at(ast, c, pos + 1) };

fn extract_int_value(ast: String) -> i64 =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let num_start = low_skip_ws(content, end1);
    parse_int_from(content, num_start, 0);

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if is_digit(c) { parse_int_from(s, pos + 1, acc * 10 + (c - 48)) } else { acc }
    };

// v0.91: Extract float value text from AST node "(float 3.14)" → "3.14"
fn extract_float_value_text(ast: String) -> String =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let val_start = low_skip_ws(content, end1);
    content.slice(val_start, content.len());

// v0.90.1: Also recognize annotated function nodes (fn-pure, fn-const, fn-inline)
fn is_fn_node(ast: String) -> bool =
    let nt = get_node_type(ast);
    nt == "fn" or nt == "fn-pure" or nt == "fn-const" or nt == "fn-inline";

// ============================================================================
// SECTION 8: MIR Result Packing
// ============================================================================

fn pack_lower_result(text: String, temp_id: i64) -> String =
    int_to_string(temp_id) + ":" + text;

fn unpack_temp_id(r: String) -> i64 = unpack_pos_acc(r, 0, 0);

fn unpack_text(r: String) -> String =
    let cpos = find_colon(r, 0);
    if cpos >= r.len() { r } else { r.slice(cpos + 1, r.len()) };

// ============================================================================
// SECTION 8B: StringBuilder-aware Lowering (v0.31.20)
// ============================================================================
// Uses StringBuilder builtins for O(1) amortized string concatenation.
// Returns just temp_id (MIR text is pushed to StringBuilder).

fn pack_lower_result_sb(temp_id: i64) -> i64 = temp_id;

// v0.60.200: Pack temp_id and block_id for tracking block label uniqueness
// temp_id in upper bits, block_id in lower bits (supports up to 1M each)
fn pack_ids(temp_id: i64, block_id: i64) -> i64 = temp_id * 1000000 + block_id;
fn unpack_temp(packed: i64) -> i64 = packed / 1000000;
fn unpack_block(packed: i64) -> i64 = packed % 1000000;

// v0.60.201: Exit label computation for correct PHI predecessors
// v0.60.203: Simplified to only check immediate node type to avoid deep recursion
fn get_exit_label(ast: String, entry_label: String, block_id: i64) -> String =
    let ntype = get_node_type(ast);
    if ntype == "if" {
        "merge_" + int_to_string(block_id)
    } else if ntype == "while" {
        "exit_" + int_to_string(block_id)
    } else if ntype == "for" {
        "for_end_" + int_to_string(block_id)
    // v0.90.8: break creates an after_break_N block that becomes the actual predecessor
    } else if ntype == "break" {
        "after_break_" + int_to_string(block_id)
    } else if ntype == "block" {
        let inner = block_inner(ast);
        get_exit_label(inner, entry_label, block_id)
    } else if ntype == "seq" {
        // Check last expr first; if it doesn't create blocks, check first expr
        let last = seq_second(ast);
        let last_type = get_node_type(last);
        if last_type == "if" or last_type == "while" or last_type == "for" or last_type == "block" or last_type == "seq" or last_type == "let" or last_type == "let_mut" or last_type == "break" {
            get_exit_label(last, entry_label, block_id)
        } else {
            // Last expr is simple (unit, int, var, etc.) — exit comes from first
            let first = seq_first(ast);
            get_exit_label(first, entry_label, block_id)
        }
    } else if ntype == "let_mut" {
        let body = get_child(ast, 2);
        get_exit_label(body, entry_label, block_id)
    } else if ntype == "let" {
        let body = get_child(ast, 2);
        get_exit_label(body, entry_label, block_id)
    // v0.90.12: Compound nodes that lower children in order
    } else if ntype == "tuple" or ntype == "array" or ntype == "call" or ntype == "method" {
        scan_exit_children(ast, 0, count_children(ast), entry_label, block_id)
    } else if ntype == "binop" {
        // Left then right operand
        let left_exit = get_exit_label(get_child(ast, 1), entry_label, block_id);
        if left_exit == entry_label { get_exit_label(get_child(ast, 2), entry_label, block_id) }
        else { left_exit }
    } else if ntype == "unary" {
        get_exit_label(get_child(ast, 1), entry_label, block_id)
    } else if ntype == "assign" {
        get_exit_label(get_child(ast, 1), entry_label, block_id)
    } else {
        entry_label
    };

// v0.90.12: Scan children of compound node for block-creating expressions
fn scan_exit_children(ast: String, idx: i64, count: i64, entry_label: String, block_id: i64) -> String =
    if idx >= count { entry_label }
    else {
        let child = get_child(ast, idx);
        let child_exit = get_exit_label(child, entry_label, block_id);
        if child_exit == entry_label { scan_exit_children(ast, idx + 1, count, entry_label, block_id) }
        else { child_exit }
    };

fn sb_push_mir(sb: i64, text: String) -> i64 =
    if text.len() > 0 {
        let len = sb_len(sb);
        let w0 = if len > 0 { sb_push(sb, "|") } else { 0 };
        sb_push(sb, text)
    } else { 0 };

// ============================================================================
// SECTION 8a: Iterative Expression Lowering (v0.60.300)
// ============================================================================
// Trampolining approach to avoid stack overflow on deeply nested expressions.
// Uses string-encoded work stack and result stack.
// Work items use TILDE (~) as field separator, TAB (chr(9)) as item separator.
// This allows the trampoline to be tail-recursive, which LLVM optimizes to a loop.

// Work item types:
// EX~ast~temp_id~block_id - Evaluate expression
// IN~ast~temp_id~block_id - Evaluate int literal
// BO~ast~temp_id~block_id - Evaluate bool literal
// ST~ast~temp_id~block_id - Evaluate string literal
// VA~ast~temp_id~block_id - Evaluate variable
// BI~op~temp_id~block_id~left_ast~right_ast - Start binop
// BM~op~left_id~temp_id~block_id~right_ast - Binop: left done, do right
// BF~op~left_id~right_id~temp_id~block_id - Binop: finalize
// UN~op~temp_id~block_id~operand_ast - Start unary
// UF~op~operand_id~temp_id~block_id - Unary: finalize
// IF~ast~temp_id~block_id - Start if
// IC~my_bid~cond_id~cond_temp~then_ast~else_ast - If: cond done, do then
// IT~my_bid~cond_id~then_label~else_label~merge_label~then_id~then_exit~then_temp~then_block~else_ast - If: then done
// IX~my_bid~then_id~then_exit~else_id~else_exit~else_temp~else_block - If: finalize
// LE~name~temp_id~block_id~value_ast~body_ast - Start let
// LB~name~val_id~val_temp~val_block~body_ast - Let: value done, do body
// CA~name~temp_id~block_id~idx~args_acc~ast - Call: start/continue
// CF~name~temp_id~block_id~args_acc - Call: finalize
// ME~fn_name~temp_id~block_id~recv_ast~idx~ast - Method: start
// MA~fn_name~recv_id~temp_id~block_id~idx~args_acc~ast - Method: continue
// MF~fn_name~temp_id~block_id~args_acc - Method: finalize

fn work_sep() -> String = chr(9);
fn field_sep() -> String = "~";

fn push_work(stack: String, item: String) -> String =
    if stack == "" { item } else { item + work_sep() + stack };

fn pop_work_item(stack: String) -> String =
    if stack == "" { "" } else {
        let sep_pos = find_work_sep(stack, 0);
        if sep_pos >= stack.len() { stack } else { stack.slice(0, sep_pos) }
    };

fn pop_work_rest(stack: String) -> String =
    if stack == "" { "" } else {
        let sep_pos = find_work_sep(stack, 0);
        if sep_pos >= stack.len() { "" } else { stack.slice(sep_pos + 1, stack.len()) }
    };

fn find_work_sep(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 9 { pos }
    else { find_work_sep(s, pos + 1) };

fn get_field(item: String, idx: i64) -> String =
    let raw = get_field_at(item, 0, idx);
    // v0.60.237: Unescape field to restore tildes
    if idx == 0 { raw } else { unescape_field(raw) };

fn get_field_at(item: String, pos: i64, idx: i64) -> String =
    if pos >= item.len() { "" }
    else if idx == 0 {
        let end = find_field_sep(item, pos);
        item.slice(pos, end)
    } else {
        let sep = find_field_sep(item, pos);
        if sep >= item.len() { "" } else { get_field_at(item, sep + 1, idx - 1) }
    };

fn find_field_sep(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 126 { pos }
    else { find_field_sep(s, pos + 1) };

// v0.60.237: Escape/unescape tilde in work item fields to prevent confusion with separator
// ~ (126) -> \^ (92, 94), \ (92) -> \\ (92, 92)
// v0.60.245: Rewritten with StringBuilder for O(n) instead of O(n²)
fn escape_field(s: String) -> String =
    let sb = sb_new();
    let _e1 = escape_field_sb(s, 0, sb);
    sb_build(sb);

fn escape_field_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else {
        let c = s.byte_at(pos);
        if c == 126 {
            let _e2 = sb_push(sb, chr(92));
            let _e3 = sb_push(sb, chr(94));
            escape_field_sb(s, pos + 1, sb)
        }
        else if c == 92 {
            let _e4 = sb_push(sb, chr(92));
            let _e5 = sb_push(sb, chr(92));
            escape_field_sb(s, pos + 1, sb)
        }
        else {
            let _e6 = sb_push(sb, chr(c));
            escape_field_sb(s, pos + 1, sb)
        }
    };

fn unescape_field(s: String) -> String =
    let sb = sb_new();
    let _u1 = unescape_field_sb(s, 0, sb);
    sb_build(sb);

fn unescape_field_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else {
        let c = s.byte_at(pos);
        if c == 92 and pos + 1 < s.len() {
            let next = s.byte_at(pos + 1);
            if next == 94 {
                let _u2 = sb_push(sb, chr(126));
                unescape_field_sb(s, pos + 2, sb)
            }
            else if next == 92 {
                let _u3 = sb_push(sb, chr(92));
                unescape_field_sb(s, pos + 2, sb)
            }
            else {
                let _u4 = sb_push(sb, chr(c));
                unescape_field_sb(s, pos + 1, sb)
            }
        }
        else {
            let _u5 = sb_push(sb, chr(c));
            unescape_field_sb(s, pos + 1, sb)
        }
    };

fn make_work(t: String, f1: String, f2: String, f3: String, f4: String, f5: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4) + "~" + escape_field(f5);

fn make_work3(t: String, f1: String, f2: String, f3: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3);

fn make_work4(t: String, f1: String, f2: String, f3: String, f4: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4);

fn make_work6(t: String, f1: String, f2: String, f3: String, f4: String, f5: String, f6: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4) + "~" + escape_field(f5) + "~" + escape_field(f6);

fn make_work7(t: String, f1: String, f2: String, f3: String, f4: String, f5: String, f6: String, f7: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4) + "~" + escape_field(f5) + "~" + escape_field(f6) + "~" + escape_field(f7);

fn make_work10(t: String, f1: String, f2: String, f3: String, f4: String, f5: String, f6: String, f7: String, f8: String, f9: String, f10: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4) + "~" + escape_field(f5) + "~" + escape_field(f6) + "~" + escape_field(f7) + "~" + escape_field(f8) + "~" + escape_field(f9) + "~" + escape_field(f10);

fn i2s(n: i64) -> String = int_to_string(n);
fn s2i(s: String) -> i64 = parse_int_simple(s, 0, 0);

fn parse_int_simple(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc }
    else {
        let c = s.byte_at(pos);
        if c >= 48 and c <= 57 { parse_int_simple(s, pos + 1, acc * 10 + (c - 48)) }
        else { acc }
    };

// Main iterative lowering entry point
// Uses a result-threaded trampoline: each step receives and returns (temp_id, block_id, exit_label)
fn lower_expr_iter(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let init_work = make_work3("EX", ast, i2s(temp_id), i2s(block_id));
    trampoline_v2(init_work, temp_id, block_id, "", sb);

// Trampoline v2: threads result (temp_id, block_id, exit_label) through work items
// Work stack format: items separated by TAB
// Each item is processed with current result, producing new result
// v0.88.6: arena_save/restore per step to bound memory for large functions
fn trampoline_v2(work_stack: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> i64 =
    if work_stack == "" { pack_ids(cur_temp, cur_block) }
    else {
        let _save = bmb_arena_save();
        let item = pop_work_item(work_stack);
        let rest = pop_work_rest(work_stack);
        // Process item with current result (MIR pushed to sb which is malloc-based)
        let step = do_step(item, cur_temp, cur_block, cur_exit_label, sb);
        let new_temp = step_temp(step);
        let new_block = step_block(step);
        // Copy exit_label to SB (survives restore)
        let exit_sb = sb_new();
        let _ep = sb_push(exit_sb, step_exit_label(step));
        // Build combined work stack in SB (survives restore)
        let work_sb = sb_new();
        let new_work = step_work(step);
        let _wp = if new_work == "" and rest == "" { 0 }
                  else if new_work == "" { sb_push(work_sb, rest) }
                  else if rest == "" { sb_push(work_sb, new_work) }
                  else { let _a = sb_push(work_sb, new_work); let _b = sb_push(work_sb, work_sep()); sb_push(work_sb, rest) };
        let _restore = bmb_arena_restore();
        // Rebuild strings from SBs in fresh arena
        let new_exit_label = sb_build(exit_sb);
        let _ef = sb_free(exit_sb);
        let combined = if sb_len(work_sb) == 0 { "" } else { sb_build(work_sb) };
        let _wf = sb_free(work_sb);
        trampoline_v2(combined, new_temp, new_block, new_exit_label, sb)
    };

// Step result: encodes new work items and result
// Format: "new_temp|new_block|exit_label|new_work"
fn make_step(temp: i64, block: i64, exit_label: String, work: String) -> String =
    i2s(temp) + "|" + i2s(block) + "|" + exit_label + "|" + work;

fn step_temp(s: String) -> i64 =
    let p1 = find_single_pipe(s, 0);
    s2i(s.slice(0, p1));

fn step_block(s: String) -> i64 =
    let p1 = find_single_pipe(s, 0);
    let p2 = find_single_pipe(s, p1 + 1);
    s2i(s.slice(p1 + 1, p2));

fn step_exit_label(s: String) -> String =
    let p1 = find_single_pipe(s, 0);
    let p2 = find_single_pipe(s, p1 + 1);
    let p3 = find_single_pipe(s, p2 + 1);
    s.slice(p2 + 1, p3);

fn step_work(s: String) -> String =
    let p1 = find_single_pipe(s, 0);
    let p2 = find_single_pipe(s, p1 + 1);
    let p3 = find_single_pipe(s, p2 + 1);
    if p3 >= s.len() { "" } else { s.slice(p3 + 1, s.len()) };

fn find_single_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 124 { pos }
    else { find_single_pipe(s, pos + 1) };

// Process a single work item with current result
fn do_step(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 0);
    if op == "EX" { step_expr(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IN" { step_int(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "FL" { step_float(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "BO" { step_bool(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "ST" { step_string(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "VA" { step_var(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "BI" { step_binop_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "BR" { step_binop_right(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "BF" { step_binop_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "UN" { step_unary_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "UF" { step_unary_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IS" { step_if_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IT" { step_if_then(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IE" { step_if_else(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IX" { step_if_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "LS" { step_let_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "LB" { step_let_body(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.92: Mutable variable (alloca/store/load)
    else if op == "VM" { step_mut_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "VB" { step_mut_body(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "CS" { step_call_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "CA" { step_call_arg(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "CF" { step_call_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "MS" { step_method_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "MA" { step_method_arg(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "MF" { step_method_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.60.126: Block expression step handlers
    else if op == "UT" { step_unit(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "SQ" { step_seq_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "S2" { step_seq_second(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "AS" { step_assign_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "AF" { step_assign_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.90.2: Array indexing and set expressions
    else if op == "AI" { step_array_index_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "A2" { step_array_index_idx(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "A3" { step_array_index_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "SI" { step_set_index_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "S3" { step_set_index_idx(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "S4" { step_set_index_val(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "S5" { step_set_index_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.90.5: Field access and set_field
    else if op == "FA" { step_field_access_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "F2" { step_field_access_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "SF" { step_set_field_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "G2" { step_set_field_val(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "G3" { step_set_field_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.90.8: Break statement
    else if op == "BK" { step_break(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.90.9: *f64 pointer cast - eval inner then mark
    else if op == "FP" { step_cast_ptr_f64_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "FQ" { step_cast_ptr_f64_finish(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.90.9: Array repeat [val; count] → calloc
    else if op == "AR" { step_array_repeat(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.90.10: Array literal [e1, e2, ...] → calloc + store
    else if op == "AL" { step_array_literal(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "TU" { step_tuple(item, cur_temp, cur_block, cur_exit_label, sb) }
    else { make_step(cur_temp, cur_block, cur_exit_label, "") };

// EX: Dispatch based on node type - expand to specific handler
fn step_expr(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let ntype = get_node_type(ast);
    if ntype == "int" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("IN", ast, "", "")) }
    else if ntype == "float" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("FL", ast, "", "")) }
    else if ntype == "bool" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("BO", ast, "", "")) }
    else if ntype == "string" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("ST", ast, "", "")) }
    else if ntype == "var" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("VA", ast, "", "")) }
    else if ntype == "binop" {
        let op = get_child(ast, 0);
        let left = get_child(ast, 1);
        let right = get_child(ast, 2);
        // v0.92: Float-aware binop - prefix op with "f" for float operands
        let mir_op = if is_float_expr(left) { "f" + op } else { op };
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("BI", mir_op, left, right, ""))
    }
    else if ntype == "unary" {
        let op = get_child(ast, 0);
        let operand = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("UN", op, operand, ""))
    }
    else if ntype == "if" {
        let cond = get_child(ast, 0);
        let then_br = get_child(ast, 1);
        let else_br = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("IS", cond, then_br, else_br, ""))
    }
    else if ntype == "let" {
        let name = extract_name(ast);
        let value = get_child(ast, 1);
        let body = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("LS", name, value, body, ""))
    }
    // v0.92: let_mut uses alloca/store/load for correct loop behavior
    else if ntype == "let_mut" {
        let name = extract_name(ast);
        let value = get_child(ast, 1);
        let body = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("VM", name, value, body, ""))
    }
    else if ntype == "call" {
        let name = extract_name(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("CS", name, ast, "1", ""))
    }
    else if ntype == "method" {
        let method_name = get_child(ast, 0);
        let receiver = get_child(ast, 1);
        let fn_name = method_to_runtime_fn(method_name);
        make_step(cur_temp, cur_block, cur_exit_label, make_work("MS", fn_name, receiver, ast, "2", ""))
    }
    // v0.60.126: Block, unit, seq, assign support
    else if ntype == "block" {
        let inner = block_inner(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("EX", inner, "", ""))
    }
    else if ntype == "unit" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("UT", "", "", ""))
    }
    else if ntype == "seq" {
        let e1 = seq_first(ast);
        let e2 = seq_second(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("SQ", e1, e2, ""))
    }
    else if ntype == "assign" {
        let lhs = assign_lhs_expr(ast);
        let rhs = assign_rhs_expr(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AS", lhs, rhs, ""))
    }
    // v0.60.248: While loop support - use recursive lowering
    // v0.90.3: Propagate exit_N as the exit label for correct PHI predecessors
    else if ntype == "while" {
        let while_exit = "exit_" + i2s(cur_block);
        let result = lower_while_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, while_exit, "")
    }
    // v0.95: For-loop support - use recursive lowering
    // v0.90.3: Propagate for_end_N as the exit label for correct PHI predecessors
    else if ntype == "for" {
        let for_exit = "for_end_" + i2s(cur_block);
        let result = lower_for_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, for_exit, "")
    }
    // v0.90.2: Array indexing and set expressions
    else if ntype == "index" {
        let base = get_child(ast, 0);
        let idx = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AI", base, idx, ""))
    }
    else if ntype == "set_index" {
        let base = get_child(ast, 0);
        let idx = get_child(ast, 1);
        let val = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("SI", base, idx, val, ""))
    }
    else if ntype == "set_field" {
        let obj = get_child(ast, 0);
        let field = get_child(ast, 1);
        let val = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("SF", obj, field, val, ""))
    }
    // v0.90.5: Field access: node.left -> (field (var <node>) left)
    else if ntype == "field" {
        let base_expr = get_child(ast, 0);
        let field_name = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("FA", base_expr, field_name, ""))
    }
    // v0.90.8: Break statement - emit goto to exit label
    else if ntype == "break" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("BK", "", "", ""))
    }
    // v0.90.9: *f64 pointer cast - evaluate inner expr and mark as f64 ptr
    else if ntype == "cast_ptr_f64" {
        let inner = get_child(ast, 0);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("FP", inner, "", ""))
    }
    // v0.90.9: Array repeat [val; count] - emit calloc(count, 8)
    else if ntype == "array_repeat" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AR", ast, "", ""))
    }
    // v0.90.10: Array literal [expr1, expr2, ...] - emit calloc + store
    else if ntype == "array" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AL", ast, "", ""))
    }
    // v0.90.11: Tuple expression (tuple e1 e2 ...) - same as array literal
    else if ntype == "tuple" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("TU", ast, "", ""))
    }
    else { make_step(cur_temp, cur_block, cur_exit_label, "") };

// IN: Integer literal - emit MIR, advance temp
fn step_int(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let val = extract_int_value(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + i2s(val));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// FL: Float literal - emit MIR const F:value, advance temp
fn step_float(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let text = extract_float_value_text(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const F:" + text);
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// BO: Boolean literal
fn step_bool(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + i2s(val));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// ST: String literal
fn step_string(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let str_content = extract_string_content(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = string " + chr(34) + str_content + chr(34));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// VA: Variable reference
fn step_var(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let name = extract_name(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = copy %" + name);
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// BI: Start binop - push left expr, then BR continuation
fn step_binop_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let left = get_field(item, 2);
    let right = get_field(item, 3);
    // After left, cur_temp will have advanced. BR needs to know where left result is.
    let cont = make_work("BR", op, right, i2s(cur_temp), "", "");
    let do_left = make_work3("EX", left, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_left + work_sep() + cont);

// BR: Binop right - left done, do right. cur_temp-1 is left result.
fn step_binop_right(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let right = get_field(item, 2);
    let left_start = s2i(get_field(item, 3));
    let left_id = cur_temp - 1;
    // Push right, then BF finalize
    let cont = make_work4("BF", op, i2s(left_id), i2s(cur_temp), "");
    let do_right = make_work3("EX", right, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_right + work_sep() + cont);

// BF: Binop final - both done, emit binop MIR
fn step_binop_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let left_id = s2i(get_field(item, 2));
    let right_start = s2i(get_field(item, 3));
    let right_id = cur_temp - 1;
    let result_tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + op + " %_t" + i2s(left_id) + ", %_t" + i2s(right_id));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// UN: Start unary - push operand, then UF
fn step_unary_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let operand = get_field(item, 2);
    let cont = make_work3("UF", op, i2s(cur_temp), "");
    let do_op = make_work3("EX", operand, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_op + work_sep() + cont);

// UF: Unary final - emit unary MIR
fn step_unary_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let operand_id = cur_temp - 1;
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let result_tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + i2s(operand_id));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// IS: Start if - push cond, then IT
fn step_if_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let cond = get_field(item, 1);
    let then_br = get_field(item, 2);
    let else_br = get_field(item, 3);
    // After cond, we'll have cond_id and need to emit branch then do branches
    let cont = make_work("IT", then_br, else_br, i2s(cur_temp), i2s(cur_block), "");
    let do_cond = make_work3("EX", cond, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_cond + work_sep() + cont);

// IT: If then - cond done, emit branch, do then branch
// Sets exit_label to then_label for the then branch execution
fn step_if_then(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let then_br = get_field(item, 1);
    let else_br = get_field(item, 2);
    let orig_temp = s2i(get_field(item, 3));
    let orig_block = s2i(get_field(item, 4));
    let cond_id = cur_temp - 1;
    let my_block = cur_block;
    let then_label = "then_" + i2s(my_block);
    let else_label = "else_" + i2s(my_block);
    let merge_label = "merge_" + i2s(my_block);
    let w1 = sb_push_mir(sb, "  branch %_t" + i2s(cond_id) + ", " + then_label + ", " + else_label);
    let w2 = sb_push_mir(sb, then_label + ":");
    // Continue with then, then IE
    // Pass merge_label as the expected exit for then branch (will be updated by nested ifs)
    let cont = make_work7("IE", else_br, i2s(my_block), then_label, else_label, merge_label, i2s(cur_temp), then_br);
    let do_then = make_work3("EX", then_br, "", "");
    // Set exit_label to then_label - the then branch will update this if it contains nested ifs
    make_step(cur_temp, my_block + 1, then_label, do_then + work_sep() + cont);

// IE: If else - then done, emit goto, do else
// Uses cur_exit_label as the actual then_exit (propagated through trampoline)
fn step_if_else(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let else_br = get_field(item, 1);
    let my_block = s2i(get_field(item, 2));
    let then_label = get_field(item, 3);
    let else_label = get_field(item, 4);
    let merge_label = get_field(item, 5);
    let then_start = s2i(get_field(item, 6));
    let then_ast = get_field(item, 7);
    let then_id = cur_temp - 1;
    // Use the propagated exit_label from trampoline - this is the actual exit point of the then branch
    let then_exit = if cur_exit_label == "" { then_label } else { cur_exit_label };
    let w1 = sb_push_mir(sb, "  goto " + merge_label);
    let w2 = sb_push_mir(sb, else_label + ":");
    // Continue with else, then IX final
    let cont = make_work7("IX", i2s(my_block), merge_label, i2s(then_id), then_exit, i2s(cur_temp), i2s(cur_block), else_br);
    let do_else = make_work3("EX", else_br, "", "");
    // Set exit_label to else_label - the else branch will update this if it contains nested ifs
    make_step(cur_temp, cur_block, else_label, do_else + work_sep() + cont);

// IX: If final - else done, emit goto and phi
// Uses cur_exit_label as the actual else_exit (propagated through trampoline)
fn step_if_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let my_block = s2i(get_field(item, 1));
    let merge_label = get_field(item, 2);
    let then_id = s2i(get_field(item, 3));
    let then_exit = get_field(item, 4);
    let else_start = s2i(get_field(item, 5));
    let else_entry_block = s2i(get_field(item, 6));
    let else_ast = get_field(item, 7);
    let else_id = cur_temp - 1;
    // Use the propagated exit_label from trampoline - this is the actual exit point of the else branch
    let else_exit = if cur_exit_label == "" { "else_" + i2s(my_block) } else { cur_exit_label };
    let w1 = sb_push_mir(sb, "  goto " + merge_label);
    let w2 = sb_push_mir(sb, merge_label + ":");
    let phi_tmp = "%_t" + i2s(cur_temp);
    let w3 = sb_push_mir(sb, "  " + phi_tmp + " = phi [%_t" + i2s(then_id) + ", " + then_exit + "], [%_t" + i2s(else_id) + ", " + else_exit + "]");
    // After if completes, exit_label is merge_label
    make_step(cur_temp + 1, cur_block, merge_label, "");

// LS: Start let - push value, then LB
// v0.88.1: Create unique SSA-compatible variable names to avoid duplicate definitions
fn step_let_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let value = get_field(item, 2);
    let body = get_field(item, 3);
    // v0.88.1: Generate unique name: name_v{cur_temp} and rename references in body
    let unique_name = name + "_v" + i2s(cur_temp);
    let body_renamed = rename_var_in_ast(body, name, unique_name);
    let cont = make_work4("LB", unique_name, body_renamed, i2s(cur_temp), "");
    let do_val = make_work3("EX", value, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_val + work_sep() + cont);

// LB: Let body - value done, emit copy, do body
// v0.88.1: Uses unique SSA-compatible name passed from step_let_start
fn step_let_body(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let unique_name = get_field(item, 1);
    let body = get_field(item, 2);
    let val_id = cur_temp - 1;
    let w1 = sb_push_mir(sb, "  %" + unique_name + " = copy %_t" + i2s(val_id));
    let do_body = make_work3("EX", body, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_body);

// VM: Start mutable variable - push value, then VB
// v0.92: Mutable variables use alloca/store/load for correct loop behavior
fn step_mut_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let value = get_field(item, 2);
    let body = get_field(item, 3);
    // For mutable vars, keep original name (no SSA rename) - alloca handles redefinition
    let body_renamed = body;
    let cont = make_work4("VB", name, body_renamed, i2s(cur_temp), "");
    let do_val = make_work3("EX", value, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_val + work_sep() + cont);

// VB: Mutable variable body - value done, emit alloca + store, do body
// v0.92: Uses alloca/store/load pattern instead of copy for correct SSA in loops
fn step_mut_body(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let body = get_field(item, 2);
    let val_id = cur_temp - 1;
    // Emit alloca for the mutable variable
    let w1 = sb_push_mir(sb, "  alloca %" + name);
    // Emit store initial value
    let w2 = sb_push_mir(sb, "  store %" + name + ", %_t" + i2s(val_id));
    let do_body = make_work3("EX", body, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_body);

// CS: Start call - begin processing args
// v0.60.211: Fixed to track actual arg result temps, not a range
fn step_call_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let arg = get_child(ast, idx);
    if arg == "" {
        // No args, emit call
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "()");
        make_step(cur_temp + 1, cur_block, cur_exit_label, "")
    } else {
        // Has args, start processing
        // Field 4: collected arg temps (starts empty)
        let cont = make_work("CA", name, ast, i2s(idx + 1), "", "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// CA: Call arg - process next arg or finalize
// v0.60.211: Fixed to collect actual arg temps, not use range
fn step_call_arg(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let collected = get_field(item, 4);
    // Append the result of the just-evaluated arg (cur_temp - 1)
    let this_arg = "%_t" + i2s(cur_temp - 1);
    let new_collected = if collected == "" { this_arg } else { collected + ", " + this_arg };
    let arg = get_child(ast, idx);
    if arg == "" {
        // Done with args, emit call
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "(" + new_collected + ")");
        make_step(cur_temp + 1, cur_block, cur_exit_label, "")
    } else {
        // More args
        let cont = make_work("CA", name, ast, i2s(idx + 1), new_collected, "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// CF: Call final (unused in new design, kept for compatibility)
fn step_call_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    make_step(cur_temp, cur_block, cur_exit_label, "");

// MS: Start method - do receiver
// v0.60.211: Fixed method call to track actual arg temps
fn step_method_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let fn_name = get_field(item, 1);
    let receiver = get_field(item, 2);
    let ast = get_field(item, 3);
    let idx = s2i(get_field(item, 4));
    // Field 4: collected arg temps (starts empty, receiver added after eval)
    let cont = make_work("MA", fn_name, ast, i2s(idx), "", "");
    let do_recv = make_work3("EX", receiver, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_recv + work_sep() + cont);

// MA: Method arg - process next arg or finalize
// v0.60.211: Fixed to collect actual arg temps
fn step_method_arg(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let fn_name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let collected = get_field(item, 4);
    // Append the result of the just-evaluated arg/receiver (cur_temp - 1)
    let this_arg = "%_t" + i2s(cur_temp - 1);
    let new_collected = if collected == "" { this_arg } else { collected + ", " + this_arg };
    let arg = get_child(ast, idx);
    if arg == "" {
        // Done with args
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + fn_name + "(" + new_collected + ")");
        make_step(cur_temp + 1, cur_block, cur_exit_label, "")
    } else {
        // More args
        let cont = make_work("MA", fn_name, ast, i2s(idx + 1), new_collected, "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// MF: Method final (unused)
fn step_method_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    make_step(cur_temp, cur_block, cur_exit_label, "");

// v0.60.126: Unit expression step - returns 0
fn step_unit(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const 0");
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// v0.60.126: Sequence start - lower first expression, queue second
fn step_seq_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let e1 = get_field(item, 1);
    let e2 = get_field(item, 2);
    // First lower e1, then continue with e2
    let cont = make_work3("S2", e2, "", "");
    let eval = make_work3("EX", e1, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.60.126: Sequence second - lower second expression (first already done)
fn step_seq_second(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let e2 = get_field(item, 1);
    make_step(cur_temp, cur_block, cur_exit_label, make_work3("EX", e2, "", ""));

// v0.60.126: Assignment start - lower RHS, queue final
fn step_assign_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let lhs = get_field(item, 1);
    let rhs = get_field(item, 2);
    // Lower RHS, then do assignment
    let cont = make_work3("AF", lhs, "", "");
    let eval = make_work3("EX", rhs, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.60.126: Assignment final - store value and return unit
// v0.92: Use store instead of copy for mutable variable assignments
fn step_assign_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let lhs = get_field(item, 1);
    // RHS value is in %_t(cur_temp-1)
    let rhs_temp = cur_temp - 1;
    let name = extract_var_from_assign(lhs);
    let w1 = sb_push_mir(sb, "  store %" + name + ", %_t" + i2s(rhs_temp));
    // Assignment returns unit
    let tmp = "%_t" + i2s(cur_temp);
    let w2 = sb_push_mir(sb, "  " + tmp + " = const 0");
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// v0.90.2: Array index - step 1: evaluate base
fn step_array_index_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base = get_field(item, 1);
    let idx = get_field(item, 2);
    let cont = make_work3("A2", idx, "", "");
    let eval = make_work3("EX", base, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.2: Array index - step 2: evaluate index
fn step_array_index_idx(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let idx = get_field(item, 1);
    let base_temp = cur_temp - 1;
    let cont = make_work3("A3", i2s(base_temp), "", "");
    let eval = make_work3("EX", idx, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.2: Array index - step 3: emit GEP + load
fn step_array_index_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base_t = get_field(item, 1);
    let idx_temp = cur_temp - 1;
    let gep = "%_t" + i2s(cur_temp);
    let load_tmp = "%_t" + i2s(cur_temp + 1);
    let w1 = sb_push_mir(sb, "  " + gep + " = gep %_t" + base_t + ", %_t" + i2s(idx_temp));
    let w2 = sb_push_mir(sb, "  " + load_tmp + " = load_ptr " + gep);
    make_step(cur_temp + 2, cur_block, cur_exit_label, "");

// v0.90.2: Set index - step 1: evaluate base
fn step_set_index_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base = get_field(item, 1);
    let idx = get_field(item, 2);
    let val = get_field(item, 3);
    let cont = make_work4("S3", idx, val, "", "");
    let eval = make_work3("EX", base, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.2: Set index - step 2: evaluate index
fn step_set_index_idx(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let idx = get_field(item, 1);
    let val = get_field(item, 2);
    let base_temp = cur_temp - 1;
    let cont = make_work4("S4", i2s(base_temp), val, "", "");
    let eval = make_work3("EX", idx, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.2: Set index - step 3: evaluate value
fn step_set_index_val(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base_t = get_field(item, 1);
    let val = get_field(item, 2);
    let idx_temp = cur_temp - 1;
    let cont = make_work4("S5", base_t, i2s(idx_temp), "", "");
    let eval = make_work3("EX", val, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.2: Set index - step 4: emit GEP + store
fn step_set_index_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base_t = get_field(item, 1);
    let idx_t = get_field(item, 2);
    let val_temp = cur_temp - 1;
    let gep = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + gep + " = gep %_t" + base_t + ", %_t" + idx_t);
    let w2 = sb_push_mir(sb, "  store_ptr " + gep + ", %_t" + i2s(val_temp));
    // set returns 0 (unit)
    let result = "%_t" + i2s(cur_temp + 1);
    let w3 = sb_push_mir(sb, "  " + result + " = const 0");
    make_step(cur_temp + 2, cur_block, cur_exit_label, "");

// v0.90.5: Field access - step 1: evaluate base expression
fn step_field_access_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base_expr = get_field(item, 1);
    let field_name = get_field(item, 2);
    let cont = make_work3("F2", field_name, "", "");
    let eval = make_work3("EX", base_expr, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.5: Field access - step 2: emit field-access MIR
fn step_field_access_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let field_name = get_field(item, 1);
    let base_temp = cur_temp - 1;
    let dest = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + dest + " = field-access %_t" + i2s(base_temp) + "." + field_name);
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// v0.90.5: Set field - step 1: evaluate object expression
fn step_set_field_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let obj = get_field(item, 1);
    let field = get_field(item, 2);
    let val = get_field(item, 3);
    let cont = make_work4("G2", field, val, "", "");
    let eval = make_work3("EX", obj, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.5: Set field - step 2: evaluate value expression
fn step_set_field_val(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let field = get_field(item, 1);
    let val = get_field(item, 2);
    let obj_temp = cur_temp - 1;
    let cont = make_work4("G3", i2s(obj_temp), field, "", "");
    let eval = make_work3("EX", val, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.5: Set field - step 3: emit field-store MIR
fn step_set_field_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let obj_t = get_field(item, 1);
    let field = get_field(item, 2);
    let val_temp = cur_temp - 1;
    let w1 = sb_push_mir(sb, "  field-store %_t" + obj_t + "." + field + ", %_t" + i2s(val_temp));
    // set returns 0 (unit)
    let result = "%_t" + i2s(cur_temp);
    let w2 = sb_push_mir(sb, "  " + result + " = const 0");
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// v0.90.8: Break statement step handler for iterative lowerer
// cur_exit_label should contain the while/for exit label
fn step_break(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let w1 = sb_push_mir(sb, "  goto " + cur_exit_label);
    let after_label = "after_break_" + i2s(cur_block);
    let w2 = sb_push_mir(sb, after_label + ":");
    let tmp = "%_t" + i2s(cur_temp);
    let w3 = sb_push_mir(sb, "  " + tmp + " = const 0");
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// v0.90.9: Recursive: cast_ptr_f64 - evaluate inner and emit marker
fn lower_cast_ptr_f64_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let inner = get_child(ast, 0);
    let result = lower_expr_sb(inner, temp_id, block_id, sb, loop_exit);
    let inner_temp = unpack_temp(result);
    let inner_block = unpack_block(result);
    let result_id = inner_temp - 1;
    let w1 = sb_push_mir(sb, "  mark_f64_ptr %_t" + int_to_string(result_id));
    pack_ids(inner_temp, inner_block);

// v0.90.9: Recursive: array_repeat - emit calloc(count, 8)
fn lower_array_repeat_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let val_ast = get_child(ast, 0);
    let count_str = get_child(ast, 1);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = call @calloc(" + count_str + ", 8)");
    pack_ids(temp_id + 1, block_id);

// v0.90.10: Array literal [expr1, expr2, ...] → calloc + store each element
fn lower_array_literal_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let count = count_children(ast);
    let arr_tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + arr_tmp + " = call @calloc(" + int_to_string(count) + ", 8)");
    let ids = lower_array_elements_sb(ast, 0, count, arr_tmp, temp_id + 1, block_id, sb, loop_exit);
    // Emit copy of array base as result so callers get the pointer
    let result_temp = unpack_temp(ids);
    let result_tmp = "%_t" + int_to_string(result_temp);
    let w2 = sb_push_mir(sb, "  " + result_tmp + " = copy " + arr_tmp);
    pack_ids(result_temp + 1, unpack_block(ids));

// Store each element of array literal
fn lower_array_elements_sb(ast: String, idx: i64, count: i64, arr_tmp: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    if idx >= count { pack_ids(temp_id, block_id) }
    else {
        let elem = get_child(ast, idx);
        let ids = lower_expr_sb(elem, temp_id, block_id, sb, loop_exit);
        let new_temp = unpack_temp(ids);
        let new_block = unpack_block(ids);
        let elem_tmp = "%_t" + int_to_string(new_temp - 1);
        // Emit const for index, gep for pointer, store_ptr for value
        let idx_tmp = "%_t" + int_to_string(new_temp);
        let w1 = sb_push_mir(sb, "  " + idx_tmp + " = const " + int_to_string(idx));
        let gep_tmp = "%_t" + int_to_string(new_temp + 1);
        let w2 = sb_push_mir(sb, "  " + gep_tmp + " = gep " + arr_tmp + ", " + idx_tmp);
        let w3 = sb_push_mir(sb, "  store_ptr " + gep_tmp + ", " + elem_tmp);
        lower_array_elements_sb(ast, idx + 1, count, arr_tmp, new_temp + 2, new_block, sb, loop_exit)
    };

// v0.90.11: Tuple expression (tuple e1 e2 ...) → calloc + store elements
// Same structure as array literal but semantically a tuple
fn lower_tuple_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let count = count_children(ast);
    let tup_tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tup_tmp + " = call @calloc(" + int_to_string(count) + ", 8)");
    let ids = lower_array_elements_sb(ast, 0, count, tup_tmp, temp_id + 1, block_id, sb, loop_exit);
    let result_temp = unpack_temp(ids);
    let result_tmp = "%_t" + int_to_string(result_temp);
    let w2 = sb_push_mir(sb, "  " + result_tmp + " = copy " + tup_tmp);
    pack_ids(result_temp + 1, unpack_block(ids));

// Count children in AST node (array, call, etc.)
fn count_children(ast: String) -> i64 =
    count_children_at(ast, 0, 0);

fn count_children_at(ast: String, idx: i64, count: i64) -> i64 =
    let child = get_child(ast, idx);
    if child == "" or child.len() == 0 { count }
    else { count_children_at(ast, idx + 1, count + 1) };

// v0.90.9: Cast *f64 - step 1: evaluate inner expression
fn step_cast_ptr_f64_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let inner = get_field(item, 1);
    let cont = make_work3("FQ", "", "", "");
    let eval = make_work3("EX", inner, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.90.9: Cast *f64 - step 2: emit mark_f64_ptr for result
fn step_cast_ptr_f64_finish(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let result_id = cur_temp - 1;
    let result = "%_t" + i2s(result_id);
    let w1 = sb_push_mir(sb, "  mark_f64_ptr " + result);
    make_step(cur_temp, cur_block, cur_exit_label, "");

// v0.90.10: Array literal - delegate to recursive lowerer
// v0.90.12: Update exit_label if array elements created blocks
fn step_array_literal(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let ids = lower_array_literal_sb(ast, cur_temp, cur_block, sb, cur_exit_label);
    let new_block = unpack_block(ids);
    let new_exit = if new_block > cur_block { get_exit_label(ast, cur_exit_label, cur_block) } else { cur_exit_label };
    make_step(unpack_temp(ids), new_block, new_exit, "");

// v0.90.11: Tuple expression - delegate to tuple lowerer (same as array literal)
// v0.90.12: Update exit_label if tuple elements created blocks (e.g. nested if-else)
fn step_tuple(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let ids = lower_tuple_sb(ast, cur_temp, cur_block, sb, cur_exit_label);
    let new_block = unpack_block(ids);
    let new_exit = if new_block > cur_block { get_exit_label(ast, cur_exit_label, cur_block) } else { cur_exit_label };
    make_step(unpack_temp(ids), new_block, new_exit, "");

// v0.90.9: Array repeat [val; count] → calloc(count, elem_size)
// For now: always zero-init via calloc (all benchmarks use [0.0; N] or [0; N])
fn step_array_repeat(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    // AST: (array_repeat val_expr count_str)
    let val_ast = get_child(ast, 0);
    let count_str = get_child(ast, 1);
    let tmp = "%_t" + i2s(cur_temp);
    // Emit: %tmp = call ptr @calloc(i64 count, i64 8)
    let w1 = sb_push_mir(sb, "  " + tmp + " = call @calloc(" + count_str + ", 8)");
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// Build argument string from temp range [start, end)
fn build_args_str(start: i64, end: i64) -> String =
    build_args_str_acc(start, end, "");

fn build_args_str_acc(cur: i64, end: i64, acc: String) -> String =
    if cur >= end { acc }
    else {
        let arg = "%_t" + i2s(cur);
        let new_acc = if acc == "" { arg } else { acc + ", " + arg };
        build_args_str_acc(cur + 1, end, new_acc)
    };

// ===========================================================================
// SECTION 8b: Original Recursive Lowering (fallback)
// ===========================================================================

// v0.60.126: Added block, unit, seq, assign support
// v0.90.8: Added loop_exit parameter for break statement support
fn lower_expr_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let ntype = get_node_type(ast);
    if ntype == "int" { lower_int_sb(ast, temp_id, block_id, sb) } else if ntype == "float" { lower_float_sb(ast, temp_id, block_id, sb) } else if ntype == "bool" { lower_bool_sb(ast, temp_id, block_id, sb) } else if ntype == "string" { lower_string_sb(ast, temp_id, block_id, sb) } else if ntype == "var" { lower_var_sb(ast, temp_id, block_id, sb) } else if ntype == "binop" { lower_binop_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "unary" { lower_unary_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "if" { lower_if_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "let" { lower_let_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "let_mut" { lower_let_mut_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "call" { lower_call_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "method" { lower_method_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "block" { lower_block_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "unit" { lower_unit_sb(ast, temp_id, block_id, sb) } else if ntype == "seq" { lower_seq_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "assign" { lower_assign_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "while" { lower_while_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "for" { lower_for_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "field" { lower_field_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "set_field" { lower_set_field_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "index" { lower_index_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "set_index" { lower_set_index_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "break" { lower_break_sb(loop_exit, temp_id, block_id, sb) } else if ntype == "cast_ptr_f64" { lower_cast_ptr_f64_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "array_repeat" { lower_array_repeat_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "array" { lower_array_literal_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "tuple" { lower_tuple_sb(ast, temp_id, block_id, sb, loop_exit) } else { pack_ids(temp_id, block_id) };

fn lower_int_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let val = extract_int_value(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + int_to_string(val));
    pack_ids(temp_id + 1, block_id);

// v0.91: Lower float literal to MIR: (float 3.14) → %_t0 = const F:3.14
fn lower_float_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let text = extract_float_value_text(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const F:" + text);
    pack_ids(temp_id + 1, block_id);

fn lower_bool_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + int_to_string(val));
    pack_ids(temp_id + 1, block_id);

// v0.60.109: Lower string literal to MIR
fn lower_string_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let str_content = extract_string_content(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = string " + chr(34) + str_content + chr(34));
    pack_ids(temp_id + 1, block_id);

// v0.60.109: Extract string content from AST node "(string content)"
// v0.60.120: Updated to unescape parens that were escaped for AST representation
fn extract_string_content(ast: String) -> String =
    let start = 8;
    let end = ast.len() - 1;
    if end > start { unescape_parens_from_ast(ast.slice(start, end)) } else { "" };

fn lower_var_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let name = extract_name(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = copy %" + name);
    pack_ids(temp_id + 1, block_id);

// v0.92: Float-aware binop lowering - detect float operands and use f+/f-/f*/f/ MIR operators
fn lower_binop_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let op = get_child(ast, 0);
    let left_ast = get_child(ast, 1);
    let right_ast = get_child(ast, 2);
    let left_result = lower_expr_sb(left_ast, temp_id, block_id, sb, loop_exit);
    let left_temp = unpack_temp(left_result);
    let left_block = unpack_block(left_result);
    let left_id = left_temp - 1;
    let right_result = lower_expr_sb(right_ast, left_temp, left_block, sb, loop_exit);
    let right_temp = unpack_temp(right_result);
    let right_block = unpack_block(right_result);
    let right_id = right_temp - 1;
    let result_tmp = "%_t" + int_to_string(right_temp);
    // v0.92: Use float MIR operator (f+, f-, etc) when operands are float
    let mir_op = if is_float_expr(left_ast) { "f" + op } else { op };
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(left_id) + ", %_t" + int_to_string(right_id));
    pack_ids(right_temp + 1, right_block);

fn lower_unary_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let op = get_child(ast, 0);
    let operand = get_child(ast, 1);
    let operand_result = lower_expr_sb(operand, temp_id, block_id, sb, loop_exit);
    let operand_temp = unpack_temp(operand_result);
    let operand_block = unpack_block(operand_result);
    let operand_id = operand_temp - 1;
    let result_tmp = "%_t" + int_to_string(operand_temp);
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(operand_id));
    pack_ids(operand_temp + 1, operand_block);

fn lower_if_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let cond = get_child(ast, 0);
    let then_branch = get_child(ast, 1);
    let else_branch = get_child(ast, 2);
    let cond_result = lower_expr_sb(cond, temp_id, block_id, sb, loop_exit);
    let cond_temp = unpack_temp(cond_result);
    let my_block_id = unpack_block(cond_result);
    let cond_id = cond_temp - 1;
    let then_label = "then_" + int_to_string(my_block_id);
    let else_label = "else_" + int_to_string(my_block_id);
    let merge_label = "merge_" + int_to_string(my_block_id);
    let w1 = sb_push_mir(sb, "  branch %_t" + int_to_string(cond_id) + ", " + then_label + ", " + else_label);
    let w2 = sb_push_mir(sb, then_label + ":");
    let then_result = lower_expr_sb(then_branch, cond_temp, my_block_id + 1, sb, loop_exit);
    let then_temp = unpack_temp(then_result);
    let then_block = unpack_block(then_result);
    let then_id = then_temp - 1;
    let then_exit = get_exit_label(then_branch, then_label, my_block_id + 1);
    let w3 = sb_push_mir(sb, "  goto " + merge_label);
    let w4 = sb_push_mir(sb, else_label + ":");
    let else_result = lower_expr_sb(else_branch, then_temp, then_block, sb, loop_exit);
    let else_temp = unpack_temp(else_result);
    let else_block = unpack_block(else_result);
    let else_id = else_temp - 1;
    let else_exit = get_exit_label(else_branch, else_label, then_block);
    let w5 = sb_push_mir(sb, "  goto " + merge_label);
    let w6 = sb_push_mir(sb, merge_label + ":");
    let phi_tmp = "%_t" + int_to_string(else_temp);
    let w7 = sb_push_mir(sb, "  " + phi_tmp + " = phi [%_t" + int_to_string(then_id) + ", " + then_exit + "], [%_t" + int_to_string(else_id) + ", " + else_exit + "]");
    pack_ids(else_temp + 1, else_block);

fn lower_let_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let name = extract_name(ast);
    let value_ast = get_child(ast, 1);
    let body_ast = get_child(ast, 2);
    let val_result = lower_expr_sb(value_ast, temp_id, block_id, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let w1 = sb_push_mir(sb, "  %" + name + " = copy %_t" + int_to_string(val_id));
    lower_expr_sb(body_ast, val_temp, val_block, sb, loop_exit);

// v0.92: Mutable let - emit alloca + store instead of copy
fn lower_let_mut_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let name = extract_name(ast);
    let value_ast = get_child(ast, 1);
    let body_ast = get_child(ast, 2);
    let val_result = lower_expr_sb(value_ast, temp_id, block_id, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let w1 = sb_push_mir(sb, "  alloca %" + name);
    let w2 = sb_push_mir(sb, "  store %" + name + ", %_t" + int_to_string(val_id));
    lower_expr_sb(body_ast, val_temp, val_block, sb, loop_exit);

fn lower_call_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let name = extract_name(ast);
    lower_call_args_sb(ast, name, temp_id, block_id, 1, "", sb, loop_exit);

fn lower_call_args_sb(ast: String, name: String, temp_id: i64, block_id: i64, idx: i64, args_acc: String, sb: i64, loop_exit: String) -> i64 =
    let arg = get_child(ast, idx);
    if arg == "" {
        let result_tmp = "%_t" + int_to_string(temp_id);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "(" + args_acc + ")");
        pack_ids(temp_id + 1, block_id)
    } else {
        let arg_result = lower_expr_sb(arg, temp_id, block_id, sb, loop_exit);
        let arg_temp = unpack_temp(arg_result);
        let arg_block = unpack_block(arg_result);
        let arg_id = arg_temp - 1;
        let new_args = if args_acc == "" { "%_t" + int_to_string(arg_id) } else { args_acc + ", %_t" + int_to_string(arg_id) };
        lower_call_args_sb(ast, name, arg_temp, arg_block, idx + 1, new_args, sb, loop_exit)
    };

// v0.60.110: Lower method call to runtime function call
// Method AST: (method name receiver arg1 arg2 ...)
// String methods map to bmb_string_* functions
fn lower_method_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let method_name = get_child(ast, 0);
    let receiver = get_child(ast, 1);
    let runtime_fn = method_to_runtime_fn(method_name);
    lower_method_args_sb(ast, runtime_fn, receiver, temp_id, block_id, 2, sb, loop_exit);

fn method_to_runtime_fn(method: String) -> String =
    if method == "len" { "bmb_string_len" }
    else if method == "byte_at" { "bmb_string_char_at" }
    else if method == "slice" { "bmb_string_slice" }
    else if method == "concat" { "bmb_string_concat" }
    else { "bmb_" + method };

fn lower_method_args_sb(ast: String, fn_name: String, receiver: String, temp_id: i64, block_id: i64, idx: i64, sb: i64, loop_exit: String) -> i64 =
    let recv_result = lower_expr_sb(receiver, temp_id, block_id, sb, loop_exit);
    let recv_temp = unpack_temp(recv_result);
    let recv_block = unpack_block(recv_result);
    let recv_id = recv_temp - 1;
    let args_acc = "%_t" + int_to_string(recv_id);
    lower_method_extra_args_sb(ast, fn_name, recv_temp, recv_block, idx, args_acc, sb, loop_exit);

fn lower_method_extra_args_sb(ast: String, fn_name: String, temp_id: i64, block_id: i64, idx: i64, args_acc: String, sb: i64, loop_exit: String) -> i64 =
    let arg = get_child(ast, idx);
    if arg == "" {
        let result_tmp = "%_t" + int_to_string(temp_id);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + fn_name + "(" + args_acc + ")");
        pack_ids(temp_id + 1, block_id)
    } else {
        let arg_result = lower_expr_sb(arg, temp_id, block_id, sb, loop_exit);
        let arg_temp = unpack_temp(arg_result);
        let arg_block = unpack_block(arg_result);
        let arg_id = arg_temp - 1;
        let new_args = args_acc + ", %_t" + int_to_string(arg_id);
        lower_method_extra_args_sb(ast, fn_name, arg_temp, arg_block, idx + 1, new_args, sb, loop_exit)
    };

// v0.60.126: Block expression lowering
// Block format: (block inner_expr)
fn lower_block_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let inner = block_inner(ast);
    lower_expr_sb(inner, temp_id, block_id, sb, loop_exit);

// Extract inner expression from (block inner)
fn block_inner(ast: String) -> String =
    let len = ast.len();
    if len < 9 { "" } else { ast.slice(7, len - 1) };

// v0.60.126: Unit expression lowering
fn lower_unit_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const 0");
    pack_ids(temp_id + 1, block_id);

// v0.60.126: Sequence expression lowering
// Seq format: (seq expr1 expr2)
fn lower_seq_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let e1 = seq_first(ast);
    let e2 = seq_second(ast);
    let r1 = lower_expr_sb(e1, temp_id, block_id, sb, loop_exit);
    let t1 = unpack_temp(r1);
    let b1 = unpack_block(r1);
    lower_expr_sb(e2, t1, b1, sb, loop_exit);

// Extract first expression from (seq e1 e2)
fn seq_first(ast: String) -> String =
    let len = ast.len();
    if len < 10 { "" } else {
        let content = ast.slice(5, len - 1);
        find_first_balanced(content, 0, 0, "")
    };

// Extract second expression from (seq e1 e2)
fn seq_second(ast: String) -> String =
    let len = ast.len();
    if len < 10 { "" } else {
        let content = ast.slice(5, len - 1);
        find_rest_balanced(content, 0, 0)
    };

// Find first balanced expression (stop at top-level space)
fn find_first_balanced(s: String, idx: i64, depth: i64, acc: String) -> String =
    if idx >= s.len() { acc } else {
        let c = s.byte_at(idx);
        if c == 40 { find_first_balanced(s, idx + 1, depth + 1, acc + chr(c)) }
        else if c == 41 { find_first_balanced(s, idx + 1, depth - 1, acc + chr(c)) }
        else if c == 32 and depth == 0 { acc }
        else { find_first_balanced(s, idx + 1, depth, acc + chr(c)) }
    };

// Find rest after first balanced expression
fn find_rest_balanced(s: String, idx: i64, depth: i64) -> String =
    if idx >= s.len() { "" } else {
        let c = s.byte_at(idx);
        if c == 40 { find_rest_balanced(s, idx + 1, depth + 1) }
        else if c == 41 { find_rest_balanced(s, idx + 1, depth - 1) }
        else if c == 32 and depth == 0 { s.slice(idx + 1, s.len()) }
        else { find_rest_balanced(s, idx + 1, depth) }
    };

// v0.60.126: Assignment expression lowering
// Assign format: (assign lhs rhs)
// v0.92: Use store instead of copy for mutable variable assignments
fn lower_assign_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let lhs = assign_lhs_expr(ast);
    let rhs = assign_rhs_expr(ast);
    let rr = lower_expr_sb(rhs, temp_id, block_id, sb, loop_exit);
    let tr = unpack_temp(rr);
    let br = unpack_block(rr);
    let rhs_id = tr - 1;
    // Extract target name from lhs (var <name>)
    let name = extract_var_from_assign(lhs);
    let w1 = sb_push_mir(sb, "  store %" + name + ", %_t" + int_to_string(rhs_id));
    // Assignment returns unit
    let tmp = "%_t" + int_to_string(tr);
    let w2 = sb_push_mir(sb, "  " + tmp + " = const 0");
    pack_ids(tr + 1, br);

// ============================================================================
// v0.60.248: While Loop Lowering
// ============================================================================
// MIR format:
//   goto loop_N
//   loop_N:
//     <cond code>
//     branch %cond, body_N, exit_N
//   body_N:
//     <body code>
//     goto loop_N
//   exit_N:
//     %result = const 0   ; while returns unit

// v0.90.8: Added loop_exit parameter; passes exit_label to body for break support
fn lower_while_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let cond_ast = get_child(ast, 0);
    let body_ast = get_child(ast, 1);
    let loop_label = "loop_" + int_to_string(block_id);
    let body_label = "body_" + int_to_string(block_id);
    let exit_label = "exit_" + int_to_string(block_id);
    // Jump to loop header
    let w1 = sb_push_mir(sb, "  goto " + loop_label);
    let w2 = sb_push_mir(sb, loop_label + ":");
    // Lower condition (condition doesn't need break)
    let cond_result = lower_expr_sb(cond_ast, temp_id, block_id + 1, sb, "");
    let cond_temp = unpack_temp(cond_result);
    let cond_block = unpack_block(cond_result);
    let cond_id = cond_temp - 1;
    // Branch on condition
    let w3 = sb_push_mir(sb, "  branch %_t" + int_to_string(cond_id) + ", " + body_label + ", " + exit_label);
    let w4 = sb_push_mir(sb, body_label + ":");
    // Lower body - pass THIS while's exit_label so break can jump to it
    let body_result = lower_expr_sb(body_ast, cond_temp, cond_block, sb, exit_label);
    let body_temp = unpack_temp(body_result);
    let body_block = unpack_block(body_result);
    // Jump back to loop header
    let w5 = sb_push_mir(sb, "  goto " + loop_label);
    let w6 = sb_push_mir(sb, exit_label + ":");
    // While returns unit
    let result_tmp = "%_t" + int_to_string(body_temp);
    let w7 = sb_push_mir(sb, "  " + result_tmp + " = const 0");
    pack_ids(body_temp + 1, body_block);

// v0.90.8: Break statement - jump to loop exit label
// AST: (break) → MIR: goto <exit_label> + unreachable block
fn lower_break_sb(loop_exit: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let w1 = sb_push_mir(sb, "  goto " + loop_exit);
    // Start unreachable block for code after break (required for LLVM IR validity)
    let after_label = "after_break_" + int_to_string(block_id);
    let w2 = sb_push_mir(sb, after_label + ":");
    // Return unit value in unreachable block
    let tmp = "%_t" + int_to_string(temp_id);
    let w3 = sb_push_mir(sb, "  " + tmp + " = const 0");
    pack_ids(temp_id + 1, block_id);

// v0.90.7: Field access lowering for SB path (used inside while/for loops)
// AST: (field base_expr field_name) → MIR: %dest = field-access %base.field_name
fn lower_field_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let field_name = get_child(ast, 1);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let dest = "%_t" + int_to_string(base_temp);
    let w1 = sb_push_mir(sb, "  " + dest + " = field-access %_t" + int_to_string(base_id) + "." + field_name);
    pack_ids(base_temp + 1, base_block);

fn lower_set_field_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let field_name = get_child(ast, 1);
    let val_expr = get_child(ast, 2);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let val_result = lower_expr_sb(val_expr, base_temp, base_block, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let w1 = sb_push_mir(sb, "  field-store %_t" + int_to_string(base_id) + "." + field_name + ", %_t" + int_to_string(val_id));
    let dest = "%_t" + int_to_string(val_temp);
    let w2 = sb_push_mir(sb, "  " + dest + " = const 0");
    pack_ids(val_temp + 1, val_block);

fn lower_index_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let idx_expr = get_child(ast, 1);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let idx_result = lower_expr_sb(idx_expr, base_temp, base_block, sb, loop_exit);
    let idx_temp = unpack_temp(idx_result);
    let idx_block = unpack_block(idx_result);
    let idx_id = idx_temp - 1;
    let gep_dest = "%_t" + int_to_string(idx_temp);
    let load_dest = "%_t" + int_to_string(idx_temp + 1);
    let w1 = sb_push_mir(sb, "  " + gep_dest + " = gep %_t" + int_to_string(base_id) + ", %_t" + int_to_string(idx_id));
    let w2 = sb_push_mir(sb, "  " + load_dest + " = load_ptr " + gep_dest);
    pack_ids(idx_temp + 2, idx_block);

fn lower_set_index_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let idx_expr = get_child(ast, 1);
    let val_expr = get_child(ast, 2);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let idx_result = lower_expr_sb(idx_expr, base_temp, base_block, sb, loop_exit);
    let idx_temp = unpack_temp(idx_result);
    let idx_block = unpack_block(idx_result);
    let idx_id = idx_temp - 1;
    let val_result = lower_expr_sb(val_expr, idx_temp, idx_block, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let gep_dest = "%_t" + int_to_string(val_temp);
    let w1 = sb_push_mir(sb, "  " + gep_dest + " = gep %_t" + int_to_string(base_id) + ", %_t" + int_to_string(idx_id));
    let w2 = sb_push_mir(sb, "  store_ptr " + gep_dest + ", %_t" + int_to_string(val_id));
    let result_dest = "%_t" + int_to_string(val_temp + 1);
    let w3 = sb_push_mir(sb, "  " + result_dest + " = const 0");
    pack_ids(val_temp + 2, val_block);

// ============================================================================
// v0.95: For-Loop Range Lowering
// ============================================================================
// AST: (for <varname> start_ast end_ast body_ast)
// MIR:
//   alloca %varname
//   <start code> → %_tS
//   store %varname, %_tS
//   <end code> → %_tE
//   goto for_start_N
// for_start_N:
//   %_tL = load %varname → resolves via alloca/load in codegen
//   %_tC = < %_tL, %_tE
//   branch %_tC, for_body_N, for_end_N
// for_body_N:
//   <body code>
//   %_tI = load %varname
//   %_tI+1 = const 1
//   %_tI+2 = + %_tI, %_tI+1
//   store %varname, %_tI+2
//   goto for_start_N
// for_end_N:
//   %_tR = const 0  ; for returns unit

fn extract_for_varname_from_ast(ast: String) -> String =
    let raw = get_child(ast, 0);
    if raw.len() < 3 { "" } else if raw.byte_at(0) != 60 { raw } else { raw.slice(1, raw.len() - 1) };

// v0.90.8: Added loop_exit parameter; passes for_end_lbl to body for break support
fn lower_for_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let varname = extract_for_varname_from_ast(ast);
    let start_ast = get_child(ast, 1);
    let end_ast = get_child(ast, 2);
    let body_ast = get_child(ast, 3);

    let for_start_lbl = "for_start_" + int_to_string(block_id);
    let for_body_lbl = "for_body_" + int_to_string(block_id);
    let for_end_lbl = "for_end_" + int_to_string(block_id);

    let w0 = sb_push_mir(sb, "  alloca %" + varname);

    let start_result = lower_expr_sb(start_ast, temp_id, block_id + 1, sb, "");
    let start_temp = unpack_temp(start_result);
    let start_block = unpack_block(start_result);
    let start_id = start_temp - 1;
    let w1 = sb_push_mir(sb, "  store %" + varname + ", %_t" + int_to_string(start_id));

    let end_result = lower_expr_sb(end_ast, start_temp, start_block, sb, "");
    let end_temp = unpack_temp(end_result);
    let end_block = unpack_block(end_result);
    let end_id = end_temp - 1;

    let w2 = sb_push_mir(sb, "  goto " + for_start_lbl);
    let w3 = sb_push_mir(sb, for_start_lbl + ":");

    let load_tmp = "%_t" + int_to_string(end_temp);
    let w4 = sb_push_mir(sb, "  " + load_tmp + " = copy %" + varname);
    let cmp_tmp = "%_t" + int_to_string(end_temp + 1);
    let w5 = sb_push_mir(sb, "  " + cmp_tmp + " = < " + load_tmp + ", %_t" + int_to_string(end_id));
    let w6 = sb_push_mir(sb, "  branch " + cmp_tmp + ", " + for_body_lbl + ", " + for_end_lbl);

    let w7 = sb_push_mir(sb, for_body_lbl + ":");

    // Lower body - pass THIS for's end label so break can jump to it
    let body_result = lower_expr_sb(body_ast, end_temp + 2, end_block, sb, for_end_lbl);
    let body_temp = unpack_temp(body_result);
    let body_block = unpack_block(body_result);

    let inc_load_tmp = "%_t" + int_to_string(body_temp);
    let w8 = sb_push_mir(sb, "  " + inc_load_tmp + " = copy %" + varname);
    let one_tmp = "%_t" + int_to_string(body_temp + 1);
    let w9 = sb_push_mir(sb, "  " + one_tmp + " = const 1");
    let inc_tmp = "%_t" + int_to_string(body_temp + 2);
    let w10 = sb_push_mir(sb, "  " + inc_tmp + " = + " + inc_load_tmp + ", " + one_tmp);
    let w11 = sb_push_mir(sb, "  store %" + varname + ", " + inc_tmp);

    let w12 = sb_push_mir(sb, "  goto " + for_start_lbl);

    let w13 = sb_push_mir(sb, for_end_lbl + ":");
    let result_tmp = "%_t" + int_to_string(body_temp + 3);
    let w14 = sb_push_mir(sb, "  " + result_tmp + " = const 0");
    pack_ids(body_temp + 4, body_block);

// Extract lhs from (assign lhs rhs)
fn assign_lhs_expr(ast: String) -> String =
    let len = ast.len();
    if len < 15 { "" } else {
        let content = ast.slice(8, len - 1);
        find_first_balanced(content, 0, 0, "")
    };

// Extract rhs from (assign lhs rhs)
fn assign_rhs_expr(ast: String) -> String =
    let len = ast.len();
    if len < 15 { "" } else {
        let content = ast.slice(8, len - 1);
        find_rest_balanced(content, 0, 0)
    };

// Extract variable name from (var <name>)
// v0.92: Fixed guard from < 10 to < 9 to handle single-char variable names
fn extract_var_from_assign(ast: String) -> String =
    let len = ast.len();
    if len < 9 { "" } else {
        // (var <name>) -> skip "(var <" = 6, remove ">)" = 2
        ast.slice(6, len - 2)
    };

// v0.90.1: Extract annotation from AST node type (fn-pure -> "pure", fn -> "")
fn get_fn_annotation(ast: String) -> String =
    let nt = get_node_type(ast);
    if nt == "fn-pure" { "pure" }
    else if nt == "fn-const" { "const" }
    else if nt == "fn-inline" { "inline" }
    else { "" };

fn lower_function_sb(ast: String) -> String =
    let name = extract_name(ast);
    let params = collect_params(ast, 1, "");
    let ret_type = get_fn_return_type(ast);
    let ann = get_fn_annotation(ast);
    let body_ast = get_fn_body(ast);
    let sb = sb_new();
    // v0.60.300: Use iterative lowering to avoid stack overflow
    let final_result = lower_expr_iter(body_ast, 0, 0, sb);
    let final_temp = unpack_temp(final_result);
    let result_id = final_temp - 1;
    let w1 = sb_push_mir(sb, "  return %_t" + int_to_string(result_id));
    let body_mir = sb_build(sb);
    // v0.90.1: Include annotation in MIR header for LLVM codegen
    let ann_suffix = if ann == "" { "" } else { " @" + ann };
    "fn " + name + "(" + params + ") -> " + ret_type + ann_suffix + " {|entry:|" + body_mir + "|}";

fn lower_program_sb(ast: String) -> String =
    let sb = sb_new();
    let w1 = lower_program_inner_sb(ast, 0, sb);
    sb_build(sb);

// v0.88.6: arena_save/arena_restore per function to free lowering intermediates
fn lower_program_inner_sb(ast: String, idx: i64, sb: i64) -> i64 =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" { 0 } else if not is_fn_node(fn_ast) { 0 } else {
        let _save = bmb_arena_save();
        let fn_mir = lower_function_sb(fn_ast);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_mir);
        let _restore = bmb_arena_restore();
        lower_program_inner_sb(ast, idx + 1, sb)
    };

// ============================================================================
// SECTION 9: Expression Lowering
// ============================================================================

fn lower_expr(ast: String, temp_id: i64, block_id: i64) -> String =
    let ntype = get_node_type(ast);
    if ntype == "int" { lower_int(ast, temp_id) } else if ntype == "float" { lower_float_expr(ast, temp_id) } else if ntype == "bool" { lower_bool(ast, temp_id) } else if ntype == "var" { lower_var(ast, temp_id) } else if ntype == "binop" { lower_binop(ast, temp_id, block_id) } else if ntype == "unary" { lower_unary(ast, temp_id, block_id) } else if ntype == "if" { lower_if(ast, temp_id, block_id) } else if ntype == "let" { lower_let(ast, temp_id, block_id) } else if ntype == "call" { lower_call(ast, temp_id, block_id) } else { pack_lower_result("ERR:unknown-" + ntype, temp_id) };

fn lower_int(ast: String, temp_id: i64) -> String =
    let val = extract_int_value(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = const " + int_to_string(val), temp_id + 1);

// v0.91: Float literal lowering
fn lower_float_expr(ast: String, temp_id: i64) -> String =
    let text = extract_float_value_text(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = const F:" + text, temp_id + 1);

fn lower_bool(ast: String, temp_id: i64) -> String =
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = const " + int_to_string(val), temp_id + 1);

fn lower_var(ast: String, temp_id: i64) -> String =
    let name = extract_name(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = copy %" + name, temp_id + 1);

fn lower_binop(ast: String, temp_id: i64, block_id: i64) -> String =
    let op = get_child(ast, 0);
    let left_ast = get_child(ast, 1);
    let right_ast = get_child(ast, 2);
    let rl = lower_expr(left_ast, temp_id, block_id);
    let left_id = unpack_temp_id(rl) - 1;
    let rr = lower_expr(right_ast, unpack_temp_id(rl), block_id);
    let right_id = unpack_temp_id(rr) - 1;
    let result_tmp = "%_t" + int_to_string(unpack_temp_id(rr));
    let mir = unpack_text(rl) + "|" + unpack_text(rr) + "|" +
        "  " + result_tmp + " = " + op + " %_t" + int_to_string(left_id) + ", %_t" + int_to_string(right_id);
    pack_lower_result(mir, unpack_temp_id(rr) + 1);

fn lower_unary(ast: String, temp_id: i64, block_id: i64) -> String =
    let op = get_child(ast, 0);
    let operand = get_child(ast, 1);
    let ro = lower_expr(operand, temp_id, block_id);
    let operand_id = unpack_temp_id(ro) - 1;
    let result_tmp = "%_t" + int_to_string(unpack_temp_id(ro));
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let mir = unpack_text(ro) + "|" +
        "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(operand_id);
    pack_lower_result(mir, unpack_temp_id(ro) + 1);

fn lower_if(ast: String, temp_id: i64, block_id: i64) -> String =
    let cond = get_child(ast, 0);
    let then_branch = get_child(ast, 1);
    let else_branch = get_child(ast, 2);
    let rc = lower_expr(cond, temp_id, block_id);
    let cond_id = unpack_temp_id(rc) - 1;
    let then_label = "then_" + int_to_string(block_id);
    let else_label = "else_" + int_to_string(block_id);
    let merge_label = "merge_" + int_to_string(block_id);
    let branch = "  branch %_t" + int_to_string(cond_id) + ", " + then_label + ", " + else_label;
    let rt = lower_expr(then_branch, unpack_temp_id(rc), block_id + 1);
    let then_id = unpack_temp_id(rt) - 1;
    // v0.60.128: Determine then exit label for phi node
    let then_type = get_node_type(then_branch);
    let then_exit = if then_type == "if" { "merge_" + int_to_string(block_id + 1) } else { then_label };
    let re = lower_expr(else_branch, unpack_temp_id(rt), block_id + 2);
    let else_id = unpack_temp_id(re) - 1;
    // v0.60.128: Determine else exit label for phi node
    let else_type = get_node_type(else_branch);
    let else_exit = if else_type == "if" { "merge_" + int_to_string(block_id + 2) } else { else_label };
    let phi_tmp = "%_t" + int_to_string(unpack_temp_id(re));
    let phi = "  " + phi_tmp + " = phi [%_t" + int_to_string(then_id) + ", " + then_exit + "], [%_t" + int_to_string(else_id) + ", " + else_exit + "]";
    let mir = unpack_text(rc) + "|" + branch + "|" +
        then_label + ":|" + unpack_text(rt) + "|  goto " + merge_label + "|" +
        else_label + ":|" + unpack_text(re) + "|  goto " + merge_label + "|" +
        merge_label + ":|" + phi;
    pack_lower_result(mir, unpack_temp_id(re) + 1);

fn lower_let(ast: String, temp_id: i64, block_id: i64) -> String =
    let name = extract_name(ast);
    let value_ast = get_child(ast, 1);
    let body_ast = get_child(ast, 2);
    let rv = lower_expr(value_ast, temp_id, block_id);
    let val_id = unpack_temp_id(rv) - 1;
    let assign = "  %" + name + " = copy %_t" + int_to_string(val_id);
    let rb = lower_expr(body_ast, unpack_temp_id(rv), block_id);
    let mir = unpack_text(rv) + "|" + assign + "|" + unpack_text(rb);
    pack_lower_result(mir, unpack_temp_id(rb));

fn lower_call(ast: String, temp_id: i64, block_id: i64) -> String =
    let name = extract_name(ast);
    lower_call_args(ast, name, temp_id, block_id, 1, "", "");

fn lower_call_args(ast: String, name: String, temp_id: i64, block_id: i64, idx: i64, mir_acc: String, args_acc: String) -> String =
    let arg = get_child(ast, idx);
    if arg == "" {
        let result_tmp = "%_t" + int_to_string(temp_id);
        let call_mir = "  " + result_tmp + " = call @" + name + "(" + args_acc + ")";
        let full_mir = if mir_acc == "" { call_mir } else { mir_acc + "|" + call_mir };
        pack_lower_result(full_mir, temp_id + 1)
    } else {
        let ra = lower_expr(arg, temp_id, block_id);
        let arg_id = unpack_temp_id(ra) - 1;
        let new_args = if args_acc == "" { "%_t" + int_to_string(arg_id) } else { args_acc + ", %_t" + int_to_string(arg_id) };
        let new_mir = if mir_acc == "" { unpack_text(ra) } else { mir_acc + "|" + unpack_text(ra) };
        lower_call_args(ast, name, unpack_temp_id(ra), block_id, idx + 1, new_mir, new_args)
    };

// ============================================================================
// SECTION 10: Function Lowering
// ============================================================================

fn lower_function(ast: String) -> String =
    let name = extract_name(ast);
    let params = collect_params(ast, 1, "");
    let ret_type = get_fn_return_type(ast);
    let body_ast = get_fn_body(ast);
    let rb = lower_expr(body_ast, 0, 0);
    let body_mir = unpack_text(rb);
    let result_id = unpack_temp_id(rb) - 1;
    "fn " + name + "(" + params + ") -> " + ret_type + " {|entry:|" + body_mir + "|  return %_t" + int_to_string(result_id) + "|}";

fn collect_params(ast: String, idx: i64, acc: String) -> String =
    let child = get_child(ast, idx);
    if child == "" or get_node_type(child) != "param" { acc } else {
        let param_name = get_child(child, 0);
        let name = if param_name.len() >= 2 and param_name.byte_at(0) == 60 { param_name.slice(1, param_name.len() - 1) } else { param_name };
        let param_type_raw = get_child(child, 1);
        // v0.90.7: Handle *StructName split by s-expression tokenizer (* and Name are separate tokens)
        let param_type = if param_type_raw == "*" { let sname = get_child(child, 2); "*" + sname } else { param_type_raw };
        let entry = name + ": " + param_type;
        let new_acc = if acc == "" { entry } else { acc + ", " + entry };
        collect_params(ast, idx + 1, new_acc)
    };

fn get_fn_return_type(ast: String) -> String =
    let content = extract_paren_content(ast);
    get_fn_return_scan(content, 0);

// v0.46: Added String return type support
// v0.90.7: Added *StructName return type support
fn get_fn_return_scan(content: String, pos: i64) -> String =
    let p = low_skip_ws(content, pos);
    if p >= content.len() { "i64" } else {
        // v0.90.7: Check for * prefix (typed pointer return like *Body)
        if content.byte_at(p) == 42 {
            // Read the struct name after *
            let name_start = p + 1;
            let name_end = low_find_ident_end(content, name_start);
            if name_end > name_start { "*" + content.slice(name_start, name_end) }
            else { "i64" }
        } else {
            let child = read_sexp_at(content, p);
            if child == "" { "i64" } else if child == "i32" or child == "i64" or child == "f64" or child == "bool" or child == "String" or child == "ptr" { child } else if child.byte_at(0) == 40 { get_fn_return_scan(content, p + child.len()) } else if child.byte_at(0) == 60 { get_fn_return_scan(content, p + child.len()) } else { get_fn_return_scan(content, p + child.len()) }
        }
    };

fn get_fn_body(ast: String) -> String =
    let content = extract_paren_content(ast);
    get_fn_body_scan(content, 0, "");

fn get_fn_body_scan(content: String, pos: i64, last_expr: String) -> String =
    let p = low_skip_ws(content, pos);
    if p >= content.len() { last_expr } else {
        let child = read_sexp_at(content, p);
        if child == "" { last_expr } else if child.len() > 0 and child.byte_at(0) == 40 {
            let ntype = get_node_type(child);
            if ntype == "param" { get_fn_body_scan(content, p + child.len(), last_expr) } else { get_fn_body_scan(content, p + child.len(), child) }
        } else {
            get_fn_body_scan(content, p + child.len(), last_expr)
        }
    };

fn lower_program(ast: String) -> String =
    lower_program_inner(ast, 0, "");

fn lower_program_inner(ast: String, idx: i64, acc: String) -> String =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" { acc } else if not is_fn_node(fn_ast) { acc } else {
        let fn_mir = lower_function(fn_ast);
        let new_acc = if acc.len() > 0 { acc + "||" + fn_mir } else { fn_mir };
        lower_program_inner(ast, idx + 1, new_acc)
    };

// ============================================================================
// SECTION 11: LLVM IR Generation
// ============================================================================

fn find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 124 { pos } else { find_pipe(s, pos + 1) };

// v0.60.123: Find pipe character but skip over quoted strings
// This is needed because MIR lines can contain string literals with pipe characters like string "|"
fn find_pipe_skip_quotes(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 124 { pos }
    else if s.byte_at(pos) == 34 { find_pipe_skip_quotes(s, skip_quoted_string(s, pos + 1)) }
    else { find_pipe_skip_quotes(s, pos + 1) };

fn skip_quoted_string(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 34 { pos + 1 }
    else if s.byte_at(pos) == 92 { skip_quoted_string(s, pos + 2) }
    else { skip_quoted_string(s, pos + 1) };

// v0.46: Extract return type from MIR function signature
// MIR format: fn name(params) -> RetType {|...|}
fn extract_mir_return_type(mir: String) -> String =
    let arrow_pos = find_arrow(mir, 0);
    let brace_pos = find_char(mir, arrow_pos, 123);
    if arrow_pos >= mir.len() or brace_pos <= arrow_pos + 2 { "i64" }
    else {
        let raw = trim(mir.slice(arrow_pos + 2, brace_pos));
        let ann = find_mir_annotation(raw);
        if ann == "" { raw } else { strip_annotation(raw) }
    };

// v0.46: llvm_gen_line with return type awareness
fn llvm_gen_line_with_ret(line: String, ret_type: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" }
    // v0.60.118: Pass ret_type to assign for proper phi type
    else if line.byte_at(p) == 37 { llvm_gen_assign_typed(line, p, ret_type) }
    else if low_starts_with_at(line, p, "return") { llvm_gen_return_typed(line, p, ret_type) }
    else if low_starts_with_at(line, p, "branch") { llvm_gen_branch(line, p) }
    else if low_starts_with_at(line, p, "goto") { llvm_gen_goto(line, p) }
    else { line };

fn llvm_gen_line(line: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" } else if line.byte_at(p) == 37 { llvm_gen_assign(line, p) } else if low_starts_with_at(line, p, "return") { llvm_gen_return(line, p) } else if low_starts_with_at(line, p, "branch") { llvm_gen_branch(line, p) } else if low_starts_with_at(line, p, "goto") { llvm_gen_goto(line, p) } else { line };

fn llvm_gen_assign(line: String, pos: i64) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs(line, after_eq, dest);

// v0.60.118: Typed version for proper phi type
fn llvm_gen_assign_typed(line: String, pos: i64, ret_type: String) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs_typed(line, after_eq, dest, ret_type);

fn find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 61 { pos } else { find_eq(s, pos + 1) };

// v0.31.19: Added nsw for const/copy to match Rust compiler
fn llvm_gen_rhs(line: String, pos: i64, dest: String) -> String =
    llvm_gen_rhs_typed(line, pos, dest, "i64");

// v0.60.118: Typed version for proper phi type
fn llvm_gen_rhs_typed(line: String, pos: i64, dest: String, ret_type: String) -> String =
    if low_starts_with_at(line, pos, "const") {
        let val_start = low_skip_ws(line, pos + 5);
        let val = line.slice(val_start, line.len());
        let trimmed_val = trim_end(val);
        // v0.91: Float constant: const F:3.14 → fadd double 0.0, 3.14
        if trimmed_val.len() >= 2 and trimmed_val.byte_at(0) == 70 and trimmed_val.byte_at(1) == 58 {
            let float_val = trimmed_val.slice(2, trimmed_val.len());
            "  " + dest + " = fadd nsz double 0.0, " + float_val
        } else {
            "  " + dest + " = add nsw i64 0, " + trimmed_val
        }
    } else if low_starts_with_at(line, pos, "copy") {
        let src_start = low_skip_ws(line, pos + 4);
        let src = line.slice(src_start, line.len());
        "  " + dest + " = add nsw i64 0, " + trim_end(src)
    } else if low_starts_with_at(line, pos, "string") {
        // v0.60.109: String literal - emit call to bmb_string_from_cstr
        let str_start = low_skip_ws(line, pos + 6);
        let str_content = line.slice(str_start + 1, line.len() - 1);
        llvm_gen_string_literal(dest, str_content)
    // v0.90.2: Float operations (must be checked before integer ops due to 'f' prefix)
    } else if low_starts_with_at(line, pos, "f+") { llvm_gen_float_binop("fadd", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f-") { llvm_gen_float_binop("fsub", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f*") { llvm_gen_float_binop("fmul", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f/") { llvm_gen_float_binop("fdiv", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f<=") { llvm_gen_float_cmp("ole", line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "f>=") { llvm_gen_float_cmp("oge", line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "f<") { llvm_gen_float_cmp("olt", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f>") { llvm_gen_float_cmp("ogt", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f==") { llvm_gen_float_cmp("oeq", line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "f!=") { llvm_gen_float_cmp("one", line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "+") { llvm_gen_binop("add", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "-") { llvm_gen_binop("sub", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "*") { llvm_gen_binop("mul", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "/") { llvm_gen_binop("sdiv", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "%") { llvm_gen_binop("srem", line, pos + 1, dest)
    // v0.32.1: Fix comparison operator order - check longer operators first
    // v0.90.1: Bitwise operations and shifts (must check << >> before < >)
    } else if low_starts_with_at(line, pos, "bxor") { llvm_gen_binop("xor", line, pos + 4, dest) } else if low_starts_with_at(line, pos, "band") { llvm_gen_binop("and", line, pos + 4, dest) } else if low_starts_with_at(line, pos, "bor") { llvm_gen_binop("or", line, pos + 3, dest) } else if low_starts_with_at(line, pos, "bnot") { llvm_gen_bnot(line, pos + 4, dest) } else if low_starts_with_at(line, pos, "<<") { llvm_gen_binop("shl", line, pos + 2, dest) } else if low_starts_with_at(line, pos, ">>") { llvm_gen_binop("ashr", line, pos + 2, dest)
    // v0.32.1: Fix comparison operator order - check longer operators first
    } else if low_starts_with_at(line, pos, "<=") { llvm_gen_cmp("sle", line, pos + 2, dest) } else if low_starts_with_at(line, pos, ">=") { llvm_gen_cmp("sge", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "<") { llvm_gen_cmp("slt", line, pos + 1, dest) } else if low_starts_with_at(line, pos, ">") { llvm_gen_cmp("sgt", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "==") { llvm_gen_cmp("eq", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "!=") { llvm_gen_cmp("ne", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "and") { llvm_gen_binop("and", line, pos + 3, dest) } else if low_starts_with_at(line, pos, "or") { llvm_gen_binop("or", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "not") { llvm_gen_not(line, pos + 3, dest) } else if low_starts_with_at(line, pos, "neg") { llvm_gen_neg(line, pos + 3, dest)
    // v0.90.2: GEP and pointer load/store for array indexing
    } else if low_starts_with_at(line, pos, "gep") { llvm_gen_gep(line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "load_ptr") { llvm_gen_load_ptr(line, pos + 8, dest)
    } else if low_starts_with_at(line, pos, "store_ptr") { llvm_gen_store_ptr(line, pos + 9)
    } else if low_starts_with_at(line, pos, "phi") { llvm_gen_phi_typed(line, pos, dest, ret_type) } else if low_starts_with_at(line, pos, "call") { llvm_gen_call(line, pos, dest) } else { "  ; unknown: " + line };

// v0.31.19: Added nsw (no signed wrap) for add/sub/mul to match Rust compiler
fn llvm_gen_binop(op: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let op_with_nsw = if op == "add" { "add nsw" } else if op == "sub" { "sub nsw" } else if op == "mul" { "mul nsw" } else { op };
    "  " + dest + " = " + op_with_nsw + " i64 " + trim_end(left) + ", " + trim_end(right);

// v0.60.118: Add zext to convert i1 comparison result to i64 for consistency
fn llvm_gen_cmp(pred: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    "  " + dest + "_cmp = icmp " + pred + " i64 " + trim_end(left) + ", " + trim_end(right) + "|  " + dest + " = zext i1 " + dest + "_cmp to i64";

fn llvm_gen_not(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = xor i64 " + trim_end(operand) + ", 1";

// v0.31.19: Added nsw for negation to match Rust compiler
fn llvm_gen_neg(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = sub nsw i64 0, " + trim_end(operand);

// v0.90.1: Bitwise NOT (complement all bits)
fn llvm_gen_bnot(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = xor i64 " + trim_end(operand) + ", -1";

// v0.90.2: GEP - getelementptr for array indexing
// MIR: gep %base, %idx → LLVM: getelementptr i64, ptr %base, i64 %idx
fn llvm_gen_gep(line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let base = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let idx = trim_end(line.slice(p2, line.len()));
    // v0.90.10: Use dest-based name for inttoptr to avoid duplicates
    let conv = "  " + dest + "_gp = inttoptr i64 " + base + " to ptr";
    let gep = "  " + dest + " = getelementptr i64, ptr " + dest + "_gp, i64 " + idx;
    conv + "|" + gep;

// v0.90.2: Load from pointer
// MIR: load_ptr %ptr → LLVM: load i64, ptr %ptr
fn llvm_gen_load_ptr(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let ptr = line.slice(p, line.len());
    "  " + dest + " = load i64, ptr " + trim_end(ptr);

// v0.90.2: Store to pointer
// MIR: store_ptr %ptr, %val → LLVM: store i64 %val, ptr %ptr
fn llvm_gen_store_ptr(line: String, pos: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let ptr = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let val = line.slice(p2, line.len());
    "  store i64 " + trim_end(val) + ", ptr " + trim_end(ptr);

// v0.90.9: Double-aware store_ptr - checks if value is double OR ptr is *f64
fn llvm_gen_store_ptr_sb(line: String, pos: i64, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let ptr = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let val = trim_end(line.slice(p2, line.len()));
    let val_is_double = is_double_var_sb(val, str_sb);
    let ptr_is_f64 = is_f64_ptr_sb(trim_end(ptr), str_sb);
    if val_is_double or ptr_is_f64 {
        same_mapping("  store double " + val + ", ptr " + trim_end(ptr))
    } else {
        same_mapping("  store i64 " + val + ", ptr " + trim_end(ptr))
    };

// v0.90.9: Double-aware load_ptr - checks if ptr is *f64
fn llvm_gen_load_ptr_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p = low_skip_ws(line, pos);
    let ptr = trim_end(line.slice(p, line.len()));
    let ptr_is_f64 = is_f64_ptr_sb(ptr, str_sb);
    if ptr_is_f64 {
        let w = push_double_marker(str_sb, dest);
        same_mapping("  " + dest + " = load double, ptr " + ptr)
    } else {
        same_mapping("  " + dest + " = load i64, ptr " + ptr)
    };

// v0.90.9: GEP with *f64 pointer propagation
fn llvm_gen_gep_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let base = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let idx = trim_end(line.slice(p2, line.len()));
    let base_is_f64 = is_f64_ptr_sb(base, str_sb);
    // Propagate *f64 marker to GEP result
    let w = if base_is_f64 { push_f64_ptr_marker(str_sb, dest) } else { 0 };
    // Both i64 and f64 are 8 bytes, GEP scaling is the same
    same_mapping(llvm_gen_gep(line, pos, dest));

// v0.60.109: String literal (stub - use llvm_gen_string_ref with string table instead)
fn llvm_gen_string_literal(dest: String, str_content: String) -> String =
    "  ; ERROR: string literal without string table: " + str_content;

fn llvm_gen_phi(line: String, pos: i64, dest: String) -> String =
    llvm_gen_phi_typed(line, pos, dest, "i64");

// v0.60.231: PHI with string marker propagation
// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_phi_with_strings(line: String, pos: i64, dest: String, mapping: String) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let first_val = extract_phi_val(first_content);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    let second_val = extract_phi_val(second_content);
    let first_is_string = is_string_var_fast(first_val, mapping);
    let second_is_string = is_string_var_fast(second_val, mapping);
    if first_is_string or second_is_string {
        changed_mapping(add_string_marker(mapping, dest), llvm_gen_phi(line, pos, dest))
    } else {
        same_mapping(llvm_gen_phi(line, pos, dest))
    };

// v0.60.231: Extract value from PHI content "val, label"
fn extract_phi_val(content: String) -> String =
    let comma_pos = find_char(content, 0, 44);
    content.slice(0, comma_pos);

// v0.60.118: Typed phi instruction with correct type for String-returning functions
fn llvm_gen_phi_typed(line: String, pos: i64, dest: String, ret_type: String) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    let first_fixed = fix_phi_label(first_content);
    let second_fixed = fix_phi_label(second_content);
    let llvm_type = if ret_type == "String" { "ptr" } else if ret_type == "f64" { "double" } else { "i64" };
    "  " + dest + " = phi " + llvm_type + " [ " + first_fixed + " ], [ " + second_fixed + " ]";

// v0.60.118: Add % prefix to phi label
fn fix_phi_label(content: String) -> String =
    let comma_pos = find_char(content, 0, 44);
    let val = content.slice(0, comma_pos);
    let label = content.slice(comma_pos + 2, content.len());
    val + ", %" + label;

// v0.46: Determine LLVM return type from function name
fn get_call_return_type(fn_name: String) -> String =
    // Void functions (no return value assignment)
    if fn_name == "@println" or fn_name == "@print_str" or fn_name == "@println_str" or fn_name == "@bmb_panic" { "void" }
    // v0.90.2: C library void functions
    else if fn_name == "@free" or fn_name == "@println_f64" or fn_name == "@bmb_print_i64" or fn_name == "@puts_cstr" { "void" }
    else if fn_name == "@store_u8" or fn_name == "@store_i64" { "void" }
    else if fn_name == "@hashmap_insert" or fn_name == "@hashmap_free" { "void" }
    else if fn_name == "@vec_push" or fn_name == "@vec_set" or fn_name == "@vec_free" { "void" }
    // v0.88.10: Void concurrency functions
    else if fn_name == "@bmb_mutex_unlock" or fn_name == "@bmb_mutex_free" { "void" }
    else if fn_name == "@bmb_channel_send" or fn_name == "@bmb_channel_close" { "void" }
    else if fn_name == "@bmb_arc_drop" { "void" }
    else if fn_name == "@bmb_rwlock_read_unlock" or fn_name == "@bmb_rwlock_write_unlock" or fn_name == "@bmb_rwlock_free" { "void" }
    else if fn_name == "@bmb_barrier_free" or fn_name == "@bmb_condvar_notify_one" or fn_name == "@bmb_condvar_notify_all" or fn_name == "@bmb_condvar_free" { "void" }
    else if fn_name == "@bmb_async_file_write" or fn_name == "@bmb_async_file_close" { "void" }
    else if fn_name == "@bmb_async_socket_write" or fn_name == "@bmb_async_socket_close" { "void" }
    else if fn_name == "@bmb_thread_pool_execute" or fn_name == "@bmb_thread_pool_join" or fn_name == "@bmb_thread_pool_shutdown" { "void" }
    else if fn_name == "@bmb_scope_spawn" or fn_name == "@bmb_scope_wait" { "void" }
    // Pointer-returning functions (String type)
    else if fn_name == "@get_arg" or fn_name == "@bmb_read_file" or fn_name == "@bmb_getenv" or fn_name == "@bmb_system_capture" { "ptr" }
    else if fn_name == "@bmb_string_new" or fn_name == "@bmb_string_from_cstr" or fn_name == "@bmb_string_slice" { "ptr" }
    else if fn_name == "@bmb_string_concat" or fn_name == "@bmb_chr" or fn_name == "@bmb_int_to_string" { "ptr" }
    else if fn_name == "@bmb_sb_build" or fn_name == "@bmb_read_file" or fn_name == "@bmb_getenv" or fn_name == "@get_arg" { "ptr" }
    // v0.90.2: C library pointer-returning functions
    else if fn_name == "@malloc" or fn_name == "@calloc" { "ptr" }
    else if fn_name == "@hashmap_new" or fn_name == "@vec_new" { "ptr" }
    // v0.90.2: Double-returning functions
    // v0.90.9: Added i64_to_f64 intrinsic
    else if fn_name == "@sqrt" or fn_name == "@i64_to_f64" { "double" }
    // v0.90.10: Bool-returning functions use i64 (0/1) - no special handling needed
    // All other functions return i64
    else { "i64" };

// v0.60.226: Check if a function returns bool
fn is_bool_returning_fn(name: String) -> bool =
    name == "@is_whitespace" or name == "@is_digit" or name == "@is_alpha" or
    name == "@is_alnum_or_underscore" or name == "@is_ident_start" or name == "@is_error" or
    name == "@starts_with" or name == "@has_pattern" or name == "@is_int_literal" or
    name == "@low_is_whitespace" or name == "@low_is_ident_char" or name == "@low_is_op_char" or
    name == "@low_starts_with_at" or name == "@is_fn_node" or name == "@ends_with_colon" or
    name == "@matches_string_pattern" or name == "@is_string_var" or name == "@string_in_mapping" or
    name == "@is_string_var_fast" or name == "@has_prefix_or_contains_marker" or
    name == "@find_marker_limited" or name == "@is_string_returning_fn" or
    name == "@is_user_variable" or name == "@is_compile_error" or name == "@is_bool_returning_fn";

// v0.60.120: Map user-facing function names to runtime function names
// v0.60.235: Removed int_to_string -> bmb_int_to_string mapping
// The BMB program defines its own int_to_string, so calls should go there
fn map_runtime_fn(fn_name: String) -> String =
    if fn_name == "@main" { "@bmb_user_main" }
    else if fn_name == "@chr" { "@bmb_chr" }
    else if fn_name == "@ord" { "@bmb_ord" }
    else if fn_name == "@println" { "@println" }
    else if fn_name == "@print" { "@bmb_print_i64" }  // v0.90.8: Map print to runtime
    else if fn_name == "@print_str" { "@print_str" }
    else if fn_name == "@println_str" { "@println_str" }
    else if fn_name == "@read_file" { "@bmb_read_file" }
    else if fn_name == "@write_file" { "@bmb_write_file" }
    else if fn_name == "@write_file_newlines" { "@write_file_newlines" }
    else if fn_name == "@file_exists" { "@bmb_file_exists" }
    else if fn_name == "@sb_new" { "@bmb_sb_new" }
    else if fn_name == "@sb_push" { "@bmb_sb_push" }
    else if fn_name == "@sb_push_int" { "@bmb_sb_push_int" }
    else if fn_name == "@sb_push_char" { "@bmb_sb_push_char" }
    else if fn_name == "@sb_push_escaped" { "@bmb_sb_push_escaped" }
    else if fn_name == "@sb_len" { "@bmb_sb_len" }
    else if fn_name == "@sb_build" { "@bmb_sb_build" }
    else if fn_name == "@sb_clear" { "@bmb_sb_clear" }
    else if fn_name == "@sb_contains" { "@bmb_sb_contains" }
    else if fn_name == "@arg_count" { "@arg_count" }
    else if fn_name == "@get_arg" { "@get_arg" }
    else if fn_name == "@getenv" { "@bmb_getenv" }
    else if fn_name == "@system" { "@bmb_system" }
    else if fn_name == "@system_capture" { "@bmb_system_capture" }
    else if fn_name == "@free_string" { "@bmb_string_free" }
    else if fn_name == "@sb_free" { "@bmb_sb_free" }
    else if fn_name == "@arena_mode" { "@bmb_arena_mode" }
    else if fn_name == "@arena_reset" { "@bmb_arena_reset" }
    else if fn_name == "@arena_save" { "@bmb_arena_save" }
    else if fn_name == "@arena_restore" { "@bmb_arena_restore" }
    else if fn_name == "@arena_usage" { "@bmb_arena_usage" }
    // v0.88.10: Concurrency runtime - Thread
    else if fn_name == "@thread_spawn" { "@bmb_thread_spawn" }
    else if fn_name == "@thread_join" { "@bmb_thread_join" }
    // v0.88.10: Concurrency runtime - Mutex
    else if fn_name == "@mutex_new" { "@bmb_mutex_new" }
    else if fn_name == "@mutex_lock" { "@bmb_mutex_lock" }
    else if fn_name == "@mutex_unlock" { "@bmb_mutex_unlock" }
    else if fn_name == "@mutex_try_lock" { "@bmb_mutex_try_lock" }
    else if fn_name == "@mutex_free" { "@bmb_mutex_free" }
    // v0.88.10: Concurrency runtime - Channel
    else if fn_name == "@channel_new" { "@bmb_channel_new" }
    else if fn_name == "@channel_send" { "@bmb_channel_send" }
    else if fn_name == "@channel_recv" { "@bmb_channel_recv" }
    else if fn_name == "@channel_try_send" { "@bmb_channel_try_send" }
    else if fn_name == "@channel_try_recv" { "@bmb_channel_try_recv" }
    else if fn_name == "@channel_recv_timeout" { "@bmb_channel_recv_timeout" }
    else if fn_name == "@channel_send_timeout" { "@bmb_channel_send_timeout" }
    else if fn_name == "@channel_close" { "@bmb_channel_close" }
    else if fn_name == "@channel_is_closed" { "@bmb_channel_is_closed" }
    else if fn_name == "@channel_recv_opt" { "@bmb_channel_recv_opt" }
    else if fn_name == "@sender_clone" { "@bmb_sender_clone" }
    // v0.88.10: Concurrency runtime - Arc
    else if fn_name == "@arc_new" { "@bmb_arc_new" }
    else if fn_name == "@arc_clone" { "@bmb_arc_clone" }
    else if fn_name == "@arc_get" { "@bmb_arc_get" }
    else if fn_name == "@arc_drop" { "@bmb_arc_drop" }
    else if fn_name == "@arc_strong_count" { "@bmb_arc_strong_count" }
    // v0.88.10: Concurrency runtime - RwLock
    else if fn_name == "@rwlock_new" { "@bmb_rwlock_new" }
    else if fn_name == "@rwlock_read" { "@bmb_rwlock_read" }
    else if fn_name == "@rwlock_read_unlock" { "@bmb_rwlock_read_unlock" }
    else if fn_name == "@rwlock_write" { "@bmb_rwlock_write" }
    else if fn_name == "@rwlock_write_unlock" { "@bmb_rwlock_write_unlock" }
    else if fn_name == "@rwlock_free" { "@bmb_rwlock_free" }
    // v0.88.10: Concurrency runtime - Barrier & Condvar
    else if fn_name == "@barrier_new" { "@bmb_barrier_new" }
    else if fn_name == "@barrier_wait" { "@bmb_barrier_wait" }
    else if fn_name == "@barrier_free" { "@bmb_barrier_free" }
    else if fn_name == "@condvar_new" { "@bmb_condvar_new" }
    else if fn_name == "@condvar_wait" { "@bmb_condvar_wait" }
    else if fn_name == "@condvar_notify_one" { "@bmb_condvar_notify_one" }
    else if fn_name == "@condvar_notify_all" { "@bmb_condvar_notify_all" }
    else if fn_name == "@condvar_free" { "@bmb_condvar_free" }
    // v0.88.10: Concurrency runtime - Async I/O
    else if fn_name == "@async_file_open" { "@bmb_async_file_open" }
    else if fn_name == "@async_file_read" { "@bmb_async_file_read" }
    else if fn_name == "@async_file_write" { "@bmb_async_file_write" }
    else if fn_name == "@async_file_close" { "@bmb_async_file_close" }
    else if fn_name == "@async_socket_connect" { "@bmb_async_socket_connect" }
    else if fn_name == "@async_socket_read" { "@bmb_async_socket_read" }
    else if fn_name == "@async_socket_write" { "@bmb_async_socket_write" }
    else if fn_name == "@async_socket_close" { "@bmb_async_socket_close" }
    // v0.88.10: Concurrency runtime - ThreadPool, Scope, BlockOn
    else if fn_name == "@thread_pool_new" { "@bmb_thread_pool_new" }
    else if fn_name == "@thread_pool_execute" { "@bmb_thread_pool_execute" }
    else if fn_name == "@thread_pool_join" { "@bmb_thread_pool_join" }
    else if fn_name == "@thread_pool_shutdown" { "@bmb_thread_pool_shutdown" }
    else if fn_name == "@scope_new" { "@bmb_scope_new" }
    else if fn_name == "@scope_spawn" { "@bmb_scope_spawn" }
    else if fn_name == "@scope_wait" { "@bmb_scope_wait" }
    else if fn_name == "@block_on" { "@bmb_block_on" }
    else { fn_name };

// v0.32.1: Rename @main calls to @bmb_user_main for runtime compatibility
// v0.46: Handle different return types (i64, ptr, void)
// v0.60.119: Add type conversions for ptr-returning functions and ptr arguments
fn llvm_gen_call(line: String, pos: i64, dest: String) -> String =
    let at_pos = find_char(line, pos, 64);
    let paren_pos = find_char(line, at_pos, 40);
    let close_pos = find_char(line, paren_pos, 41);
    let fn_name = line.slice(at_pos, paren_pos);
    // v0.90.9: Intercept i64_to_f64/f64_to_i64 intrinsics - emit sitofp/fptosi
    // v0.90.14: ord() is identity - char_at/byte_at already return byte values
    // v0.90.15: Native LLVM store/load for store_u8/load_u8/store_i64/load_i64
    if fn_name == "@store_u8" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let addr = trim_end(args.slice(0, comma));
        let value = trim(args.slice(comma + 1, args.len()));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + "_v = trunc i64 " + value + " to i8|  store i8 " + dest + "_v, ptr " + dest + "_p, align 1|  " + dest + " = add nsw i64 0, 0"
    } else if fn_name == "@load_u8" {
        let addr = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + "_b = load i8, ptr " + dest + "_p, align 1|  " + dest + " = zext i8 " + dest + "_b to i64"
    } else if fn_name == "@store_i64" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let addr = trim_end(args.slice(0, comma));
        let value = trim(args.slice(comma + 1, args.len()));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  store i64 " + value + ", ptr " + dest + "_p, align 8|  " + dest + " = add nsw i64 0, 0"
    } else if fn_name == "@load_i64" {
        let addr = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + " = load i64, ptr " + dest + "_p, align 8"
    } else if fn_name == "@ord" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = add nsw i64 0, " + arg
    } else if fn_name == "@i64_to_f64" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = sitofp i64 " + arg + " to double"
    } else if fn_name == "@f64_to_i64" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = fptosi double " + arg + " to i64"
    } else {
    let emitted_fn = map_runtime_fn(fn_name);
    let args = line.slice(paren_pos + 1, close_pos);
    let arg_types = get_call_arg_types(emitted_fn);
    let formatted = format_call_args_typed(args, arg_types, 0, 0, "", "");
    let conversions = call_arg_conversions(formatted);
    let formatted_args = call_arg_formatted(formatted);
    let ret_type = get_call_return_type(emitted_fn);
    if ret_type == "void" {
        // v0.90.8: Void calls still need dest defined (as 0) for subsequent MIR refs
        conversions + "  call void " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = add nsw i64 0, 0"
    } else if ret_type == "ptr" {
        // ptr-returning functions need ptrtoint conversion to i64
        conversions + "  " + dest + "_ptr = call ptr " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = ptrtoint ptr " + dest + "_ptr to i64"
    } else {
        conversions + "  " + dest + " = call " + ret_type + " " + emitted_fn + "(" + formatted_args + ")"
    }
    }; // v0.90.9: close i64_to_f64/f64_to_i64 else

// v0.90.2: Registry-aware call generation for user-defined f64 functions
fn llvm_gen_call_reg(line: String, pos: i64, dest: String, registry: String) -> String =
    let at_pos = find_char(line, pos, 64);
    let paren_pos = find_char(line, at_pos, 40);
    let close_pos = find_char(line, paren_pos, 41);
    let fn_name = line.slice(at_pos, paren_pos);
    // v0.90.9: Intercept i64_to_f64/f64_to_i64 intrinsics
    // v0.90.14: ord() is identity - char_at/byte_at already return byte values
    // v0.90.15: Native LLVM store/load for store_u8/load_u8/store_i64/load_i64
    if fn_name == "@store_u8" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let addr = trim_end(args.slice(0, comma));
        let value = trim(args.slice(comma + 1, args.len()));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + "_v = trunc i64 " + value + " to i8|  store i8 " + dest + "_v, ptr " + dest + "_p, align 1|  " + dest + " = add nsw i64 0, 0"
    } else if fn_name == "@load_u8" {
        let addr = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + "_b = load i8, ptr " + dest + "_p, align 1|  " + dest + " = zext i8 " + dest + "_b to i64"
    } else if fn_name == "@store_i64" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let addr = trim_end(args.slice(0, comma));
        let value = trim(args.slice(comma + 1, args.len()));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  store i64 " + value + ", ptr " + dest + "_p, align 8|  " + dest + " = add nsw i64 0, 0"
    } else if fn_name == "@load_i64" {
        let addr = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + " = load i64, ptr " + dest + "_p, align 8"
    } else if fn_name == "@ord" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = add nsw i64 0, " + arg
    } else if fn_name == "@i64_to_f64" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = sitofp i64 " + arg + " to double"
    } else if fn_name == "@f64_to_i64" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = fptosi double " + arg + " to i64"
    } else {
    let emitted_fn = map_runtime_fn(fn_name);
    let args = line.slice(paren_pos + 1, close_pos);
    // Check registry first for user-defined function types
    let reg_ret = lookup_fn_ret(registry, emitted_fn);
    let reg_params = lookup_fn_params(registry, emitted_fn);
    if reg_ret != "" {
        // Use registry types
        let arg_types = if reg_params != "" { reg_params } else { get_call_arg_types(emitted_fn) };
        let formatted = format_call_args_typed(args, arg_types, 0, 0, "", "");
        let conversions = call_arg_conversions(formatted);
        let formatted_args = call_arg_formatted(formatted);
        if reg_ret == "void" {
            // v0.90.8: Void calls still need dest defined (as 0) for subsequent MIR refs
            conversions + "  call void " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = add nsw i64 0, 0"
        } else if reg_ret == "ptr" {
            conversions + "  " + dest + "_ptr = call ptr " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = ptrtoint ptr " + dest + "_ptr to i64"
        } else if reg_ret == "double" {
            conversions + "  " + dest + " = call double " + emitted_fn + "(" + formatted_args + ")"
        } else {
            conversions + "  " + dest + " = call " + reg_ret + " " + emitted_fn + "(" + formatted_args + ")"
        }
    } else {
        // Fall back to existing logic
        llvm_gen_call(line, pos, dest)
    }
    }; // v0.90.9: close i64_to_f64/f64_to_i64 else

// v0.60.119: Get argument type signature for a function (p=ptr, i=i64)
fn get_call_arg_types(fn_name: String) -> String =
    // String functions with ptr first arg
    if fn_name == "@bmb_string_slice" { "pii" }
    else if fn_name == "@bmb_string_concat" { "pp" }
    else if fn_name == "@bmb_string_new" { "pi" }
    else if fn_name == "@bmb_string_from_cstr" { "p" }
    else if fn_name == "@bmb_string_eq" { "pp" }
    else if fn_name == "@bmb_ord" { "p" }
    else if fn_name == "@bmb_sb_contains" { "ip" }
    else if fn_name == "@bmb_string_len" { "p" }
    else if fn_name == "@bmb_string_char_at" { "pi" }
    else if fn_name == "@bmb_read_file" { "p" }
    else if fn_name == "@bmb_write_file" { "pp" }
    else if fn_name == "@write_file_newlines" { "pp" }
    else if fn_name == "@bmb_append_file" { "pp" }
    else if fn_name == "@bmb_file_exists" { "p" }
    else if fn_name == "@bmb_file_size" { "p" }
    else if fn_name == "@bmb_getenv" { "p" }
    else if fn_name == "@bmb_system" { "p" }
    else if fn_name == "@bmb_system_capture" { "p" }
    else if fn_name == "@bmb_string_free" { "p" }
    else if fn_name == "@bmb_sb_free" { "i" }
    else if fn_name == "@bmb_arena_mode" { "i" }
    else if fn_name == "@bmb_sb_push" { "ip" }
    else if fn_name == "@bmb_sb_push_escaped" { "ip" }
    else if fn_name == "@print_str" { "p" }
    else if fn_name == "@println_str" { "p" }
    else if fn_name == "@bmb_panic" { "p" }
    // v0.90.2: C library and runtime arg types
    else if fn_name == "@malloc" { "i" }
    else if fn_name == "@calloc" { "ii" }
    else if fn_name == "@free" { "p" }
    else if fn_name == "@sqrt" { "d" }
    else if fn_name == "@println_f64" { "d" }
    else if fn_name == "@bmb_print_i64" { "i" }  // v0.90.8: mapped from print
    else if fn_name == "@puts_cstr" { "p" }
    else if fn_name == "@store_u8" { "pii" }
    else if fn_name == "@load_u8" { "pi" }
    else if fn_name == "@store_i64" { "pii" }
    else if fn_name == "@load_i64" { "pi" }
    else if fn_name == "@char_at" { "pi" }
    else if fn_name == "@hashmap_insert" { "ppi" }
    else if fn_name == "@hashmap_get" { "pp" }
    else if fn_name == "@hashmap_free" { "p" }
    else if fn_name == "@vec_push" { "pi" }
    else if fn_name == "@vec_get" { "pi" }
    else if fn_name == "@vec_set" { "pii" }
    else if fn_name == "@vec_len" { "p" }
    else if fn_name == "@vec_free" { "p" }
    // Default: all i64
    else { "" };

// v0.60.119: Format args with type conversions
// Returns pair: (conversions_string, formatted_args_string)
// Uses separator "###" to split conversions from args
fn format_call_args_typed(args: String, types: String, pos: i64, idx: i64, conv_acc: String, arg_acc: String) -> String =
    let p = low_skip_ws(args, pos);
    if p >= args.len() { conv_acc + "###" + arg_acc } else {
        let comma = find_comma_or_end(args, p);
        let arg = trim_end(args.slice(p, comma));
        let typ = if idx < types.len() { types.byte_at(idx) } else { 105 };
        let pair = if typ == 112 {
            // 'p' = ptr: need inttoptr conversion
            let ptr_name = arg + "_p" + int_to_string(idx);
            let conv = "  " + ptr_name + " = inttoptr i64 " + arg + " to ptr|";
            let typed_arg = "ptr " + ptr_name;
            pack_conv_arg(conv, typed_arg)
        } else if typ == 100 {
            // 'd' = double: no conversion, just use double type
            pack_conv_arg("", "double " + arg)
        } else {
            // 'i' or default = i64: no conversion needed
            pack_conv_arg("", "i64 " + arg)
        };
        let new_conv = conv_acc + unpack_conv(pair);
        let typed_arg = unpack_arg(pair);
        let new_arg = if arg_acc == "" { typed_arg } else { arg_acc + ", " + typed_arg };
        if comma >= args.len() { new_conv + "###" + new_arg } else { format_call_args_typed(args, types, comma + 1, idx + 1, new_conv, new_arg) }
    };

// Helper to pack conversion and arg into a pair string
fn pack_conv_arg(conv: String, arg: String) -> String = conv + "###" + arg;

// Helper to unpack conversion from pair
fn unpack_conv(pair: String) -> String =
    let sep = find_separator(pair, 0);
    pair.slice(0, sep);

// Helper to unpack arg from pair
fn unpack_arg(pair: String) -> String =
    let sep = find_separator(pair, 0);
    pair.slice(sep + 3, pair.len());

// Find "###" separator
fn find_separator(s: String, pos: i64) -> i64 =
    if pos + 2 >= s.len() { s.len() }
    else if s.byte_at(pos) == 35 and s.byte_at(pos + 1) == 35 and s.byte_at(pos + 2) == 35 { pos }
    else { find_separator(s, pos + 1) };

// v0.60.119: Extract conversions part from "conversions###args"
fn call_arg_conversions(formatted: String) -> String =
    let sep = find_separator(formatted, 0);
    formatted.slice(0, sep);

// v0.60.119: Extract args part from "conversions###args"
fn call_arg_formatted(formatted: String) -> String =
    let sep = find_separator(formatted, 0);
    formatted.slice(sep + 3, formatted.len());

fn format_call_args(args: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(args, pos);
    if p >= args.len() { acc } else {
        let comma = find_comma_or_end(args, p);
        let arg = trim_end(args.slice(p, comma));
        let typed_arg = "i64 " + arg;
        let new_acc = if acc == "" { typed_arg } else { acc + ", " + typed_arg };
        if comma >= args.len() { new_acc } else { format_call_args(args, comma + 1, new_acc) }
    };

fn find_comma(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { pos } else { find_comma(s, pos + 1) };

fn find_comma_or_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { pos } else { find_comma_or_end(s, pos + 1) };

fn find_char(s: String, pos: i64, ch: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == ch { pos } else { find_char(s, pos + 1, ch) };

fn trim_end(s: String) -> String =
    trim_end_at(s, s.len() - 1);

fn trim_end_at(s: String, pos: i64) -> String =
    if pos < 0 { "" } else if low_is_whitespace(s.byte_at(pos)) { trim_end_at(s, pos - 1) } else { s.slice(0, pos + 1) };

// v0.46: Trim both leading and trailing whitespace
fn trim(s: String) -> String =
    let start = low_skip_ws(s, 0);
    if start >= s.len() { "" } else { trim_end(s.slice(start, s.len())) };

fn llvm_gen_return(line: String, pos: i64) -> String =
    let val_start = low_skip_ws(line, pos + 6);
    let val = line.slice(val_start, line.len());
    "  ret i64 " + trim_end(val);

// v0.46: Return with proper type for String functions
// v0.60.118: Add inttoptr conversion for String returns (values are i64 internally)
// v0.60.225: Simplified - String returns i64 directly (no ptr conversion)
// v0.92: Added f64/double return type support
fn llvm_gen_return_typed(line: String, pos: i64, ret_type: String) -> String =
    let val_start = low_skip_ws(line, pos + 6);
    let val = trim_end(line.slice(val_start, line.len()));
    // v0.90.10: Bool returns use i64 (0/1) - no trunc needed
    if ret_type == "f64" {
        "  ret double " + val
    } else {
        "  ret i64 " + val
    };

// v0.60.118: Add trunc to convert i64 condition to i1 for branch
fn llvm_gen_branch(line: String, pos: i64) -> String =
    let after = low_skip_ws(line, pos + 6);
    let comma1 = find_comma(line, after);
    let cond = trim_end(line.slice(after, comma1));
    let after1 = low_skip_ws(line, comma1 + 1);
    let comma2 = find_comma(line, after1);
    let then_label = line.slice(after1, comma2);
    let after2 = low_skip_ws(line, comma2 + 1);
    let else_label = trim_end(line.slice(after2, line.len()));
    "  " + cond + "_i1 = trunc i64 " + cond + " to i1|  br i1 " + cond + "_i1, label %" + trim_end(then_label) + ", label %" + else_label;

fn llvm_gen_goto(line: String, pos: i64) -> String =
    let label_start = low_skip_ws(line, pos + 4);
    let label = line.slice(label_start, line.len());
    "  br label %" + trim_end(label);

// v0.92: Float binary operation
// MIR: f+ %a, %b → LLVM: fadd double %a, %b
fn llvm_gen_float_binop(op: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    "  " + dest + " = " + op + " double " + trim_end(left) + ", " + trim_end(right);

// v0.92: Float comparison operation
// MIR: f< %a, %b → LLVM: fcmp olt double %a, %b + zext i1 to i64
fn llvm_gen_float_cmp(pred: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    "  " + dest + "_cmp = fcmp " + pred + " double " + trim_end(left) + ", " + trim_end(right) + "|  " + dest + " = zext i1 " + dest + "_cmp to i64";

// v0.92: Alloca for mutable variables - emit LLVM alloca and mark in mapping
// MIR: alloca %name → LLVM: %name = alloca i64 + mapping[%name] = ALLOCA
fn llvm_gen_alloca(line: String, pos: i64, mapping: String) -> String =
    let name_start = low_skip_ws(line, pos + 6);
    let name = trim_end(line.slice(name_start, line.len()));
    let new_mapping = add_mapping(mapping, name, "ALLOCA");
    changed_mapping(new_mapping, "  " + name + " = alloca i64");

// v0.92: Store for mutable variables
// MIR: store %name, %_tN → LLVM: store i64 %resolved_src, ptr %name
fn llvm_gen_store(line: String, pos: i64, mapping: String) -> String =
    let after_store = low_skip_ws(line, pos + 5);
    let comma_pos = find_comma(line, after_store);
    let dest_name = trim_end(line.slice(after_store, comma_pos));
    let src_start = low_skip_ws(line, comma_pos + 1);
    let src = trim_end(line.slice(src_start, line.len()));
    let resolved_src = resolve_variable(src, mapping);
    same_mapping("  store i64 " + resolved_src + ", ptr " + dest_name);

// v0.90.4: Double-aware store - checks if source is double, marks dest alloca as double
fn llvm_gen_store_sb(line: String, pos: i64, mapping: String, str_sb: i64) -> String =
    let after_store = low_skip_ws(line, pos + 5);
    let comma_pos = find_comma(line, after_store);
    let dest_name = trim_end(line.slice(after_store, comma_pos));
    let src_start = low_skip_ws(line, comma_pos + 1);
    let src = trim_end(line.slice(src_start, line.len()));
    let resolved_src = resolve_variable(src, mapping);
    let src_is_double = is_double_var_sb(src, str_sb);
    if src_is_double {
        let w = push_double_marker(str_sb, dest_name);
        same_mapping("  store double " + resolved_src + ", ptr " + dest_name)
    } else {
        same_mapping("  store i64 " + resolved_src + ", ptr " + dest_name)
    };

// v0.46: Updated to pass return type for proper LLVM IR generation
fn gen_function(mir: String) -> String =
    let ret_type = extract_mir_return_type(mir);
    gen_function_lines_typed(mir, 0, "", ret_type);

fn gen_function_lines(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line(line);
        let new_acc = if acc == "" { llvm_line } else { acc + "|" + llvm_line };
        if pipe_pos >= mir.len() { new_acc } else { gen_function_lines(mir, pipe_pos + 1, new_acc) }
    };

// v0.46: Type-aware function line generation
fn gen_function_lines_typed(mir: String, pos: i64, acc: String, ret_type: String) -> String =
    if pos >= mir.len() { acc } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line_typed(line, ret_type);
        let new_acc = if acc == "" { llvm_line } else { acc + "|" + llvm_line };
        if pipe_pos >= mir.len() { new_acc } else { gen_function_lines_typed(mir, pipe_pos + 1, new_acc, ret_type) }
    };

// ============================================================================
// SECTION 11B: StringBuilder-aware LLVM Generation (v0.31.20)
// ============================================================================
// O(1) amortized string concatenation for LLVM IR generation

// v0.46: Updated to pass return type for proper LLVM IR generation
fn gen_function_sb(mir: String) -> String =
    let sb = sb_new();
    let ret_type = extract_mir_return_type(mir);
    let w1 = gen_function_lines_sb_typed(mir, 0, sb, ret_type);
    sb_build(sb);

fn gen_function_lines_sb(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line(line);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, llvm_line);
        if pipe_pos >= mir.len() { 0 } else { gen_function_lines_sb(mir, pipe_pos + 1, sb) }
    };

// v0.46: Type-aware StringBuilder function line generation
fn gen_function_lines_sb_typed(mir: String, pos: i64, sb: i64, ret_type: String) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line_typed(line, ret_type);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, llvm_line);
        if pipe_pos >= mir.len() { 0 } else { gen_function_lines_sb_typed(mir, pipe_pos + 1, sb, ret_type) }
    };

// v0.90.2: Build function type registry from MIR (maps fn name -> return type)
// Format: "@name:ret_type:param_types,..." where param_types uses d=double,i=i64,p=ptr
fn build_fn_registry(mir: String) -> String =
    let rsb = sb_new();
    let w1 = build_fn_registry_acc(mir, 0, rsb);
    sb_build(rsb);

fn build_fn_registry_acc(mir: String, pos: i64, rsb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let w1 = register_fn_type(fn_mir, rsb);
        if fn_end + 2 >= mir.len() { 0 } else { build_fn_registry_acc(mir, fn_end + 2, rsb) }
    };

fn register_fn_type(fn_mir: String, rsb: i64) -> i64 =
    let first_pipe = find_char(fn_mir, 0, 124);
    let header = fn_mir.slice(0, first_pipe);
    if header.len() < 4 { 0 }
    else if low_starts_with_at(header, 0, "fn ") {
        let name_start = 3;
        let paren_pos = find_char(header, name_start, 40);
        let fn_name = header.slice(name_start, paren_pos);
        let close_pos = find_char(header, paren_pos, 41);
        let arrow_pos = find_arrow(header, close_pos);
        let brace_pos = find_char(header, arrow_pos, 123);
        let raw_ret = trim(header.slice(arrow_pos + 2, brace_pos));
        let ann = find_mir_annotation(raw_ret);
        let ret_type = if ann == "" { raw_ret } else { strip_annotation(raw_ret) };
        let llvm_ret = if ret_type == "f64" { "double" } else if ret_type == "ptr" { "ptr" } else { "i64" };
        let params = header.slice(paren_pos + 1, close_pos);
        let param_sig = build_param_sig(params, 0, "");
        let w1 = sb_push(rsb, "@" + fn_name + ":" + llvm_ret + ":" + param_sig + ",");
        0
    } else { 0 };

// ============================================================================
// v0.90.17: ConstFunctionEval - replace @const 0-arg functions at compile time
// Scans MIR for functions with @const annotation, 0 params, returning a constant.
// Replaces all call @name() with const <value> in the MIR.
// ============================================================================

// Main entry point: optimize MIR by inlining const functions
fn optimize_const_inlining(mir: String) -> String =
    let const_map = build_const_map(mir);
    if const_map == "" { mir }
    else { apply_const_map_to_mir(mir, const_map, 0) };

// Build map of const function name -> value from MIR
// Format: "@name=value,@name2=value2,"
fn build_const_map(mir: String) -> String =
    let sb = sb_new();
    let w1 = build_const_map_acc(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

fn build_const_map_acc(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let w1 = try_register_const_fn(fn_mir, sb);
        if fn_end + 2 >= mir.len() { 0 } else { build_const_map_acc(mir, fn_end + 2, sb) }
    };

// Check if a function MIR is a 0-arg @const returning a constant
// Must have ONLY: entry: | %_tN = const <value> | return %_tN | }
// Reject functions with calls, arithmetic, etc.
fn try_register_const_fn(fn_mir: String, sb: i64) -> i64 =
    let first_pipe = find_char(fn_mir, 0, 124);
    let header = if first_pipe >= fn_mir.len() { fn_mir } else { fn_mir.slice(0, first_pipe) };
    let has_const = find_pattern_at(header, "@const", 0);
    if has_const < 0 { 0 }
    else {
        let paren_pos = find_char(header, 3, 40);
        let fn_name = header.slice(3, paren_pos);
        let close_pos = find_char(header, paren_pos, 41);
        let params = trim(header.slice(paren_pos + 1, close_pos));
        if params.len() > 0 { 0 }
        else {
            // Verify body has no calls or complex instructions
            let has_call = find_pattern_at(fn_mir, "= call ", first_pipe);
            if has_call >= 0 { 0 }
            else {
                let const_pos = find_pattern_at(fn_mir, "= const ", first_pipe);
                if const_pos < 0 { 0 }
                else {
                    let value_start = const_pos + 8;
                    let line_end = find_char(fn_mir, value_start, 124);
                    let value = trim(fn_mir.slice(value_start, line_end));
                    if value.len() == 0 { 0 }
                    else {
                        let first_ch = value.byte_at(0);
                        // Support both integer (123) and float (F:3.14) constants
                        let is_num = if first_ch >= 48 and first_ch <= 57 { true }
                            else if first_ch == 45 and value.len() > 1 and value.byte_at(1) >= 48 and value.byte_at(1) <= 57 { true }
                            else if first_ch == 70 and value.len() > 2 and value.byte_at(1) == 58 { true }
                            else { false };
                        if is_num {
                            let w1 = sb_push(sb, "@");
                            let w2 = sb_push(sb, fn_name);
                            let w3 = sb_push(sb, "=");
                            let w4 = sb_push(sb, value);
                            let w5 = sb_push(sb, ",");
                            0
                        } else { 0 }
                    }
                }
            }
        }
    };

// Apply all const map entries to MIR
fn apply_const_map_to_mir(mir: String, const_map: String, pos: i64) -> String =
    if pos >= const_map.len() { mir }
    else {
        let at_pos = find_char(const_map, pos, 64);
        if at_pos >= const_map.len() { mir }
        else {
            let eq_pos = find_char(const_map, at_pos, 61);
            let comma_pos = find_char(const_map, eq_pos, 44);
            let fn_name = const_map.slice(at_pos + 1, eq_pos);
            let value = const_map.slice(eq_pos + 1, comma_pos);
            let pattern = "call @" + fn_name + "()";
            let replacement = "const " + value;
            let new_mir = replace_all_in_mir(mir, pattern, replacement);
            apply_const_map_to_mir(new_mir, const_map, comma_pos + 1)
        }
    };

// Replace all occurrences of pattern in string with replacement
fn replace_all_in_mir(s: String, pattern: String, replacement: String) -> String =
    let first = find_pattern_at(s, pattern, 0);
    if first < 0 { s }
    else {
        let sb = sb_new();
        let w1 = replace_all_in_mir_acc(s, 0, pattern, replacement, sb);
        let result = sb_build(sb);
        let _f = sb_free(sb);
        result
    };

fn replace_all_in_mir_acc(s: String, pos: i64, pattern: String, replacement: String, sb: i64) -> i64 =
    let found = find_pattern_at(s, pattern, pos);
    if found < 0 {
        sb_push(sb, s.slice(pos, s.len()))
    } else {
        let w1 = sb_push(sb, s.slice(pos, found));
        let w2 = sb_push(sb, replacement);
        replace_all_in_mir_acc(s, found + pattern.len(), pattern, replacement, sb)
    };

fn build_param_sig(params: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { acc } else {
        let comma = find_comma_or_end(params, p);
        let param = trim_end(params.slice(p, comma));
        let colon_pos = find_char(param, 0, 58);
        let param_type = trim(param.slice(colon_pos + 1, param.len()));
        // v0.90.7: *StructName types map to "i" (passed as i64)
        let sig = if param_type == "f64" { "d" } else if param_type == "ptr" { "p" } else if is_struct_ptr_type(param_type) { "i" } else { "i" };
        let new_acc = acc + sig;
        if comma >= params.len() { new_acc } else { build_param_sig(params, comma + 1, new_acc) }
    };

// v0.90.2: Look up function return type from registry
fn lookup_fn_ret(registry: String, fn_name: String) -> String =
    // v0.90.4: Normalize fn_name - strip @ prefix for consistent comparison
    let clean_fn = if fn_name.len() > 0 and fn_name.byte_at(0) == 64 { fn_name.slice(1, fn_name.len()) } else { fn_name };
    lookup_fn_ret_at(registry, 0, clean_fn);

fn lookup_fn_ret_at(registry: String, pos: i64, fn_name: String) -> String =
    if pos >= registry.len() { "" } else {
        let comma_pos = find_char(registry, pos, 44);
        let entry = registry.slice(pos, comma_pos);
        let colon1 = find_char(entry, 0, 58);
        let entry_name = entry.slice(0, colon1);
        // v0.90.4: Strip @ prefix from entry_name for comparison
        let clean_name = if entry_name.len() > 0 and entry_name.byte_at(0) == 64 { entry_name.slice(1, entry_name.len()) } else { entry_name };
        if clean_name == fn_name {
            let colon2 = find_char(entry, colon1 + 1, 58);
            entry.slice(colon1 + 1, colon2)
        } else {
            if comma_pos >= registry.len() { "" } else { lookup_fn_ret_at(registry, comma_pos + 1, fn_name) }
        }
    };

// v0.90.2: Look up function param signature from registry
fn lookup_fn_params(registry: String, fn_name: String) -> String =
    // v0.90.4: Normalize fn_name - strip @ prefix for consistent comparison
    let clean_fn = if fn_name.len() > 0 and fn_name.byte_at(0) == 64 { fn_name.slice(1, fn_name.len()) } else { fn_name };
    lookup_fn_params_at(registry, 0, clean_fn);

fn lookup_fn_params_at(registry: String, pos: i64, fn_name: String) -> String =
    if pos >= registry.len() { "" } else {
        let comma_pos = find_char(registry, pos, 44);
        let entry = registry.slice(pos, comma_pos);
        let colon1 = find_char(entry, 0, 58);
        let entry_name = entry.slice(0, colon1);
        // v0.90.4: Strip @ prefix from entry_name for comparison
        let clean_name = if entry_name.len() > 0 and entry_name.byte_at(0) == 64 { entry_name.slice(1, entry_name.len()) } else { entry_name };
        if clean_name == fn_name {
            let colon2 = find_char(entry, colon1 + 1, 58);
            entry.slice(colon2 + 1, entry.len())
        } else {
            if comma_pos >= registry.len() { "" } else { lookup_fn_params_at(registry, comma_pos + 1, fn_name) }
        }
    };

fn gen_program_sb(mir: String) -> String =
    let registry = build_fn_registry(mir);
    let sb = sb_new();
    let w1 = gen_program_acc_sb_reg(mir, 0, sb, registry);
    sb_build(sb);

fn gen_program_acc_sb(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function_sb(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_llvm);
        if fn_end + 2 >= mir.len() { 0 } else { gen_program_acc_sb(mir, fn_end + 2, sb) }
    };

fn gen_program_acc_sb_reg(mir: String, pos: i64, sb: i64, registry: String) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function_sb_reg(fn_mir, registry);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_llvm);
        if fn_end + 2 >= mir.len() { 0 } else { gen_program_acc_sb_reg(mir, fn_end + 2, sb, registry) }
    };

fn gen_function_sb_reg(mir: String, registry: String) -> String =
    let sb = sb_new();
    let ret_type = extract_mir_return_type(mir);
    let w1 = gen_function_lines_sb_reg(mir, 0, sb, ret_type, registry);
    sb_build(sb);

fn gen_function_lines_sb_reg(mir: String, pos: i64, sb: i64, ret_type: String, registry: String) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line_reg(line, ret_type, registry);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, llvm_line);
        if pipe_pos >= mir.len() { 0 } else { gen_function_lines_sb_reg(mir, pipe_pos + 1, sb, ret_type, registry) }
    };

fn llvm_gen_fn_line_reg(line: String, ret_type: String, registry: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" }
    else if low_starts_with_at(line, p, "fn ") { llvm_gen_fn_header(line, p) }
    else if ends_with_colon(line) { line }
    else if line == "}" { "}" }
    else { llvm_gen_line_with_ret_reg(line, ret_type, registry) };

fn llvm_gen_line_with_ret_reg(line: String, ret_type: String, registry: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" }
    else if line.byte_at(p) == 37 { llvm_gen_assign_typed_reg(line, p, ret_type, registry) }
    else if low_starts_with_at(line, p, "return") { llvm_gen_return_typed(line, p, ret_type) }
    else if low_starts_with_at(line, p, "branch") { llvm_gen_branch(line, p) }
    else if low_starts_with_at(line, p, "goto") { llvm_gen_goto(line, p) }
    else { line };

fn llvm_gen_assign_typed_reg(line: String, pos: i64, ret_type: String, registry: String) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs_typed_reg(line, after_eq, dest, ret_type, registry);

fn llvm_gen_rhs_typed_reg(line: String, pos: i64, dest: String, ret_type: String, registry: String) -> String =
    if low_starts_with_at(line, pos, "const") {
        let val_start = low_skip_ws(line, pos + 5);
        let val = line.slice(val_start, line.len());
        let trimmed_val = trim_end(val);
        if trimmed_val.len() >= 2 and trimmed_val.byte_at(0) == 70 and trimmed_val.byte_at(1) == 58 {
            let float_val = trimmed_val.slice(2, trimmed_val.len());
            "  " + dest + " = fadd nsz double 0.0, " + float_val
        } else {
            "  " + dest + " = add nsw i64 0, " + trimmed_val
        }
    } else if low_starts_with_at(line, pos, "copy") {
        let src_start = low_skip_ws(line, pos + 4);
        let src = line.slice(src_start, line.len());
        "  " + dest + " = add nsw i64 0, " + trim_end(src)
    } else if low_starts_with_at(line, pos, "string") {
        let str_start = low_skip_ws(line, pos + 6);
        let str_content = line.slice(str_start + 1, line.len() - 1);
        llvm_gen_string_literal(dest, str_content)
    // v0.90.2: Float operations
    } else if low_starts_with_at(line, pos, "f+") { llvm_gen_float_binop("fadd", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f-") { llvm_gen_float_binop("fsub", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f*") { llvm_gen_float_binop("fmul", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f/") { llvm_gen_float_binop("fdiv", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f<=") { llvm_gen_float_cmp("ole", line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "f>=") { llvm_gen_float_cmp("oge", line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "f<") { llvm_gen_float_cmp("olt", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f>") { llvm_gen_float_cmp("ogt", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "f==") { llvm_gen_float_cmp("oeq", line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "f!=") { llvm_gen_float_cmp("one", line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "+") { llvm_gen_binop("add", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "-") { llvm_gen_binop("sub", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "*") { llvm_gen_binop("mul", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "/") { llvm_gen_binop("sdiv", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "%") { llvm_gen_binop("srem", line, pos + 1, dest)
    // v0.90.1: Bitwise operations and shifts (must check << >> before < >)
    } else if low_starts_with_at(line, pos, "bxor") { llvm_gen_binop("xor", line, pos + 4, dest) } else if low_starts_with_at(line, pos, "band") { llvm_gen_binop("and", line, pos + 4, dest) } else if low_starts_with_at(line, pos, "bor") { llvm_gen_binop("or", line, pos + 3, dest) } else if low_starts_with_at(line, pos, "bnot") { llvm_gen_bnot(line, pos + 4, dest) } else if low_starts_with_at(line, pos, "<<") { llvm_gen_binop("shl", line, pos + 2, dest) } else if low_starts_with_at(line, pos, ">>") { llvm_gen_binop("ashr", line, pos + 2, dest)
    } else if low_starts_with_at(line, pos, "<=") { llvm_gen_cmp("sle", line, pos + 2, dest) } else if low_starts_with_at(line, pos, ">=") { llvm_gen_cmp("sge", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "<") { llvm_gen_cmp("slt", line, pos + 1, dest) } else if low_starts_with_at(line, pos, ">") { llvm_gen_cmp("sgt", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "==") { llvm_gen_cmp("eq", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "!=") { llvm_gen_cmp("ne", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "and") { llvm_gen_binop("and", line, pos + 3, dest) } else if low_starts_with_at(line, pos, "or") { llvm_gen_binop("or", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "not") { llvm_gen_not(line, pos + 3, dest) } else if low_starts_with_at(line, pos, "neg") { llvm_gen_neg(line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "gep") { llvm_gen_gep(line, pos + 3, dest)
    } else if low_starts_with_at(line, pos, "load_ptr") { llvm_gen_load_ptr(line, pos + 8, dest)
    } else if low_starts_with_at(line, pos, "store_ptr") { llvm_gen_store_ptr(line, pos + 9)
    } else if low_starts_with_at(line, pos, "phi") { llvm_gen_phi_typed(line, pos, dest, ret_type) } else if low_starts_with_at(line, pos, "call") { llvm_gen_call_reg(line, pos, dest, registry) } else { "  ; unknown: " + line };

fn llvm_gen_fn_line(line: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" } else if low_starts_with_at(line, p, "fn ") { llvm_gen_fn_header(line, p) } else if ends_with_colon(line) { line } else if line == "}" { "}" } else { llvm_gen_line(line) };

// v0.46: Type-aware line generation for proper return types
fn llvm_gen_fn_line_typed(line: String, ret_type: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" }
    else if low_starts_with_at(line, p, "fn ") { llvm_gen_fn_header(line, p) }
    else if ends_with_colon(line) { line }
    else if line == "}" { "}" }
    else { llvm_gen_line_with_ret(line, ret_type) };

// v0.90.1: Find @annotation in a string, return annotation name or ""
fn find_mir_annotation(s: String) -> String =
    find_mir_annotation_at(s, 0);

fn find_mir_annotation_at(s: String, pos: i64) -> String =
    if pos >= s.len() { "" }
    else if s.byte_at(pos) == 64 {
        let name_end = low_find_ident_end(s, pos + 1);
        s.slice(pos + 1, name_end)
    } else { find_mir_annotation_at(s, pos + 1) };

// v0.90.1: Strip @annotation from return type string
fn strip_annotation(s: String) -> String =
    strip_annotation_at(s, 0);

fn strip_annotation_at(s: String, pos: i64) -> String =
    if pos >= s.len() { s }
    else if s.byte_at(pos) == 64 { trim(s.slice(0, pos)) }
    else { strip_annotation_at(s, pos + 1) };

// v0.31.19: Added nounwind attribute for non-main functions
// v0.32.1: Rename main to bmb_user_main for runtime compatibility
// v0.90.1: Support @pure/@const/@inline annotations in MIR
fn llvm_gen_fn_header(line: String, pos: i64) -> String =
    let name_start = pos + 3;
    let paren_pos = find_char(line, name_start, 40);
    let fn_name = line.slice(name_start, paren_pos);
    let close_pos = find_char(line, paren_pos, 41);
    let params = line.slice(paren_pos + 1, close_pos);
    let formatted_params = format_fn_params(params, 0, "");
    let arrow_pos = find_arrow(line, close_pos);
    let brace_pos = find_char(line, arrow_pos, 123);
    // v0.46: Use trim to handle leading/trailing whitespace in return type
    let raw_ret_type = trim(line.slice(arrow_pos + 2, brace_pos));
    // v0.90.1: Extract annotation from return type area (e.g., "i64 @pure" -> ann="pure", ret="i64")
    let ann = find_mir_annotation(raw_ret_type);
    let ret_type = if ann == "" { raw_ret_type } else { strip_annotation(raw_ret_type) };
    // v0.90.10: Use i64 for all return types (bool is 0/1 as i64)
    let llvm_ret = if ret_type == "f64" { "double" } else { "i64" };
    let emitted_name = if fn_name == "main" { "bmb_user_main" } else { fn_name };
    // v0.90.1: Build attributes based on annotation
    // v0.90.17: Add mustprogress to all functions (enables LLVM loop optimizations)
    let base_attrs = if fn_name == "main" { " mustprogress" } else { " mustprogress nounwind" };
    let pure_attrs = if ann == "pure" or ann == "const" { " willreturn memory(none)" } else { "" };
    let inline_attrs = if ann == "inline" { " alwaysinline" } else { "" };
    let attrs = base_attrs + pure_attrs + inline_attrs;
    "define " + llvm_ret + " @" + emitted_name + "(" + formatted_params + ")" + attrs + " {";

// v0.46: Added String parameter type support
fn format_fn_params(params: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { acc } else {
        let comma = find_comma_or_end(params, p);
        let param = trim_end(params.slice(p, comma));
        let colon_pos = find_char(param, 0, 58);
        let name = param.slice(0, colon_pos);
        let param_type = trim(param.slice(colon_pos + 1, param.len()));
        // v0.60.225: Use i64 for String params (consistency with internal representation)
        // v0.90.10: Bool params use i64 (0/1) - consistent with internal representation
        let llvm_type = if param_type == "f64" { "double" } else { "i64" };
        let typed_param = llvm_type + " %" + name;
        let new_acc = if acc == "" { typed_param } else { acc + ", " + typed_param };
        if comma >= params.len() { new_acc } else { format_fn_params(params, comma + 1, new_acc) }
    };

fn find_arrow(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { pos } else if s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 62 { pos } else { find_arrow(s, pos + 1) };

fn ends_with_colon(s: String) -> bool =
    if s.len() == 0 { false } else {
        let last = trim_end(s);
        if last.len() == 0 { false } else { last.byte_at(last.len() - 1) == 58 }
    };

// v0.60.124: Skip quoted strings to avoid treating "||" inside strings as function separator
fn find_double_pipe(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { s.len() }
    else if s.byte_at(pos) == 124 and s.byte_at(pos + 1) == 124 { pos }
    else if s.byte_at(pos) == 34 { find_double_pipe(s, skip_quoted_string(s, pos + 1)) }
    else { find_double_pipe(s, pos + 1) };

fn gen_program(mir: String) -> String =
    gen_program_acc(mir, 0, "");

fn gen_program_acc(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function(fn_mir);
        let new_acc = if acc == "" { fn_llvm } else { acc + "||" + fn_llvm };
        if fn_end + 2 >= mir.len() { new_acc } else { gen_program_acc(mir, fn_end + 2, new_acc) }
    };

// ============================================================================
// SECTION 12: Module Generation
// ============================================================================

fn gen_module_header() -> String =
    // v0.60.224: Removed target triple - let LLVM use host default
    "; ModuleID = bmb_bootstrap";

// v0.46: Complete runtime declarations for 3-stage bootstrap
// Basic I/O
fn gen_extern_println() -> String = "declare void @println(i64)";
fn gen_extern_print_str() -> String = "declare void @print_str(ptr)";
fn gen_extern_println_str() -> String = "declare void @println_str(ptr)";

// Math functions
fn gen_extern_abs() -> String = "declare i64 @bmb_abs(i64)";
fn gen_extern_min() -> String = "declare i64 @min(i64, i64)";
fn gen_extern_max() -> String = "declare i64 @max(i64, i64)";

// String operations
fn gen_extern_string_new() -> String = "declare ptr @bmb_string_new(ptr, i64)";
fn gen_extern_string_from_cstr() -> String = "declare ptr @bmb_string_from_cstr(ptr)";
fn gen_extern_string_len() -> String = "declare i64 @bmb_string_len(ptr)";
fn gen_extern_string_char_at() -> String = "declare i64 @bmb_string_char_at(ptr, i64)";
fn gen_extern_string_slice() -> String = "declare ptr @bmb_string_slice(ptr, i64, i64)";
fn gen_extern_string_concat() -> String = "declare ptr @bmb_string_concat(ptr, ptr)";
fn gen_extern_string_eq() -> String = "declare i64 @bmb_string_eq(ptr, ptr)";
fn gen_extern_chr() -> String = "declare ptr @bmb_chr(i64)";
fn gen_extern_ord() -> String = "declare i64 @bmb_ord(ptr)";
fn gen_extern_int_to_string() -> String = "declare ptr @bmb_int_to_string(i64)";
// v0.60.244: Fast i2s that returns BmbString* (matches String type)
fn gen_extern_fast_i2s() -> String = "declare ptr @bmb_fast_i2s(i64)";

// File I/O
fn gen_extern_file_exists() -> String = "declare i64 @bmb_file_exists(ptr)";
fn gen_extern_file_size() -> String = "declare i64 @bmb_file_size(ptr)";
fn gen_extern_read_file() -> String = "declare ptr @bmb_read_file(ptr)";
fn gen_extern_write_file() -> String = "declare i64 @bmb_write_file(ptr, ptr)";
fn gen_extern_append_file() -> String = "declare i64 @bmb_append_file(ptr, ptr)";
// v0.60.134: write_file_newlines converts | to newlines during write
fn gen_extern_write_file_newlines() -> String = "declare i64 @write_file_newlines(ptr, ptr)";

// StringBuilder
fn gen_extern_sb_new() -> String = "declare i64 @bmb_sb_new()";
fn gen_extern_sb_push() -> String = "declare i64 @bmb_sb_push(i64, ptr)";
fn gen_extern_sb_push_int() -> String = "declare i64 @bmb_sb_push_int(i64, i64)";
fn gen_extern_sb_push_char() -> String = "declare i64 @bmb_sb_push_char(i64, i64)";
fn gen_extern_sb_push_escaped() -> String = "declare i64 @bmb_sb_push_escaped(i64, ptr)";
fn gen_extern_sb_len() -> String = "declare i64 @bmb_sb_len(i64)";
fn gen_extern_sb_build() -> String = "declare ptr @bmb_sb_build(i64)";
fn gen_extern_sb_clear() -> String = "declare i64 @bmb_sb_clear(i64)";
fn gen_extern_sb_contains() -> String = "declare i64 @bmb_sb_contains(i64, ptr)";

// Process/System
fn gen_extern_system() -> String = "declare i64 @bmb_system(ptr)";
fn gen_extern_getenv() -> String = "declare ptr @bmb_getenv(ptr)";
// v0.88.2: system_capture, free_string, arena management
fn gen_extern_system_capture() -> String = "declare ptr @bmb_system_capture(ptr)";
fn gen_extern_free_string() -> String = "declare i64 @bmb_string_free(ptr)";
fn gen_extern_sb_free() -> String = "declare i64 @bmb_sb_free(i64)";
fn gen_extern_arena_mode() -> String = "declare i64 @bmb_arena_mode(i64)";
fn gen_extern_arena_reset() -> String = "declare i64 @bmb_arena_reset()";
fn gen_extern_arena_save() -> String = "declare i64 @bmb_arena_save()";
fn gen_extern_arena_restore() -> String = "declare i64 @bmb_arena_restore()";
fn gen_extern_arena_usage() -> String = "declare i64 @bmb_arena_usage()";

// CLI arguments
fn gen_extern_arg_count() -> String = "declare i64 @arg_count()";
fn gen_extern_get_arg() -> String = "declare ptr @get_arg(i64)";

// Panic/Error handling
fn gen_extern_panic() -> String = "declare void @bmb_panic(ptr)";

// v0.90.2: C library / memory allocation functions
fn gen_extern_malloc() -> String = "declare ptr @malloc(i64)";
fn gen_extern_calloc() -> String = "declare ptr @calloc(i64, i64)";
fn gen_extern_free() -> String = "declare void @free(ptr)";
fn gen_extern_sqrt() -> String = "declare double @sqrt(double)";
fn gen_extern_println_f64() -> String = "declare void @println_f64(double)";
fn gen_extern_print() -> String = "declare void @bmb_print_i64(i64)";
fn gen_extern_puts_cstr() -> String = "declare void @puts_cstr(ptr)";
// v0.90.2: Typed array load/store
fn gen_extern_store_u8() -> String = "declare void @store_u8(ptr, i64, i64)";
fn gen_extern_load_u8() -> String = "declare i64 @load_u8(ptr, i64)";
fn gen_extern_store_i64() -> String = "declare void @store_i64(ptr, i64, i64)";
fn gen_extern_load_i64() -> String = "declare i64 @load_i64(ptr, i64)";
fn gen_extern_char_at() -> String = "declare i64 @char_at(ptr, i64)";
// v0.90.2: Hashmap/Vector stdlib
fn gen_extern_hashmap_new() -> String = "declare ptr @hashmap_new()";
fn gen_extern_hashmap_insert() -> String = "declare void @hashmap_insert(ptr, ptr, i64)";
fn gen_extern_hashmap_get() -> String = "declare i64 @hashmap_get(ptr, ptr)";
fn gen_extern_hashmap_free() -> String = "declare void @hashmap_free(ptr)";
fn gen_extern_vec_new() -> String = "declare ptr @vec_new()";
fn gen_extern_vec_push() -> String = "declare void @vec_push(ptr, i64)";
fn gen_extern_vec_get() -> String = "declare i64 @vec_get(ptr, i64)";
fn gen_extern_vec_set() -> String = "declare void @vec_set(ptr, i64, i64)";
fn gen_extern_vec_len() -> String = "declare i64 @vec_len(ptr)";
fn gen_extern_vec_free() -> String = "declare void @vec_free(ptr)";

// v0.60.238: Split to avoid deep concat nesting
fn gen_runtime_decls() -> String =
    let io = gen_runtime_decls_io();
    let str = gen_runtime_decls_string();
    let file = gen_runtime_decls_file();
    let rest = gen_runtime_decls_rest();
    let ext = gen_runtime_decls_ext();
    io + str + file + rest + "|" + ext;

fn gen_runtime_decls_io() -> String =
    gen_extern_println() + "|" + gen_extern_print_str() + "|" + gen_extern_println_str() + "|" +
    gen_extern_abs() + "|" + gen_extern_min() + "|" + gen_extern_max() + "|";

fn gen_runtime_decls_string() -> String =
    gen_extern_string_new() + "|" + gen_extern_string_from_cstr() + "|" +
    gen_extern_string_len() + "|" + gen_extern_string_char_at() + "|" +
    gen_extern_string_slice() + "|" + gen_extern_string_concat() + "|" +
    gen_extern_string_eq() + "|" + gen_extern_chr() + "|" + gen_extern_ord() + "|" +
    gen_extern_int_to_string() + "|" + gen_extern_fast_i2s() + "|";

fn gen_runtime_decls_file() -> String =
    gen_extern_file_exists() + "|" + gen_extern_file_size() + "|" +
    gen_extern_read_file() + "|" + gen_extern_write_file() + "|" + gen_extern_append_file() + "|" +
    gen_extern_write_file_newlines() + "|";

// v0.60.244: Added sb_push_int and sb_push_char for faster int-to-string conversion
fn gen_runtime_decls_rest() -> String =
    gen_extern_sb_new() + "|" + gen_extern_sb_push() + "|" +
    gen_extern_sb_push_int() + "|" + gen_extern_sb_push_char() + "|" + gen_extern_sb_push_escaped() + "|" +
    gen_extern_sb_len() + "|" +
    gen_extern_sb_build() + "|" + gen_extern_sb_clear() + "|" + gen_extern_sb_contains() + "|" +
    gen_extern_system() + "|" + gen_extern_getenv() + "|" +
    gen_extern_system_capture() + "|" + gen_extern_free_string() + "|" +
    gen_extern_sb_free() + "|" +
    gen_extern_arena_mode() + "|" + gen_extern_arena_reset() + "|" +
    gen_extern_arena_save() + "|" + gen_extern_arena_restore() + "|" +
    gen_extern_arena_usage() + "|" +
    gen_extern_arg_count() + "|" + gen_extern_get_arg() + "|" +
    gen_extern_panic();

// v0.90.2: External C library and runtime declarations for benchmark programs
fn gen_runtime_decls_ext() -> String =
    gen_extern_malloc() + "|" + gen_extern_calloc() + "|" + gen_extern_free() + "|" +
    gen_extern_sqrt() + "|" + gen_extern_println_f64() + "|" +
    gen_extern_print() + "|" + gen_extern_puts_cstr() + "|" +
    gen_extern_store_u8() + "|" + gen_extern_load_u8() + "|" +
    gen_extern_store_i64() + "|" + gen_extern_load_i64() + "|" +
    gen_extern_char_at() + "|" +
    gen_extern_hashmap_new() + "|" + gen_extern_hashmap_insert() + "|" +
    gen_extern_hashmap_get() + "|" + gen_extern_hashmap_free() + "|" +
    gen_extern_vec_new() + "|" + gen_extern_vec_push() + "|" +
    gen_extern_vec_get() + "|" + gen_extern_vec_set() + "|" +
    gen_extern_vec_len() + "|" + gen_extern_vec_free();

// ============================================================================
// SECTION 12b: String Literal Handling (v0.60.109)
// ============================================================================

// Collect all string literals from MIR, returns tab-separated list
// v0.60.242: Optimized to avoid O(N²) sb_build calls during collection
// Now passes current list as parameter instead of rebuilding every iteration
fn collect_strings_from_mir(mir: String) -> String =
    collect_strings_acc_v2(mir, 0, "");

// v0.60.242: Rewritten to avoid sb_build on every iteration
// Uses String accumulator directly, trading some allocation for avoiding
// the O(N) sb_build call that was happening on every string found
fn collect_strings_acc_v2(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else {
        let next = find_string_in_mir(mir, pos);
        if next < 0 { acc } else {
            let str_start = next + 8;
            let str_end = find_quote_in_mir(mir, str_start);
            let str_content = mir.slice(str_start, str_end);
            let is_dup = string_in_list(acc, str_content);
            let new_acc = if is_dup == 0 {
                if acc == "" { str_content } else { acc + chr(9) + str_content }
            } else { acc };
            collect_strings_acc_v2(mir, str_end + 1, new_acc)
        }
    };

// Find "string " pattern in MIR (returns position or -1)
fn find_string_in_mir(mir: String, pos: i64) -> i64 =
    if pos + 8 > mir.len() { 0 - 1 }
    else if matches_string_pattern(mir, pos) { pos }
    else { find_string_in_mir(mir, pos + 1) };

fn matches_string_pattern(s: String, pos: i64) -> bool =
    s.byte_at(pos) == 115 and s.byte_at(pos + 1) == 116 and
    s.byte_at(pos + 2) == 114 and s.byte_at(pos + 3) == 105 and
    s.byte_at(pos + 4) == 110 and s.byte_at(pos + 5) == 103 and
    s.byte_at(pos + 6) == 32 and s.byte_at(pos + 7) == 34;

// v0.90.12: Handle escape sequences when scanning for closing quote in MIR strings
fn find_quote_in_mir(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 92 and pos + 1 < s.len() { find_quote_in_mir(s, pos + 2) }
    else if s.byte_at(pos) == 34 { pos }
    else { find_quote_in_mir(s, pos + 1) };

fn string_in_list(list: String, target: String) -> i64 =
    if list == "" { 0 } else { string_in_list_scan(list, target, 0) };

fn string_in_list_scan(list: String, target: String, pos: i64) -> i64 =
    if pos >= list.len() { 0 } else {
        let pipe = find_tab_in_list(list, pos);
        let end = if pipe >= list.len() { list.len() } else { pipe };
        let item = list.slice(pos, end);
        if item == target { 1 }
        else if pipe >= list.len() { 0 }
        else { string_in_list_scan(list, target, pipe + 1) }
    };

// v0.60.123: Renamed to find_tab_in_list, uses tab (byte 9) as separator
fn find_tab_in_list(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 9 { pos }
    else { find_tab_in_list(s, pos + 1) };

// Find index of string in list
fn find_string_index(list: String, target: String) -> i64 =
    find_string_index_scan(list, target, 0, 0);

fn find_string_index_scan(list: String, target: String, pos: i64, idx: i64) -> i64 =
    if pos >= list.len() { 0 } else {
        let pipe = find_tab_in_list(list, pos);
        let end = if pipe >= list.len() { list.len() } else { pipe };
        let item = list.slice(pos, end);
        if item == target { idx }
        else if pipe >= list.len() { 0 }
        else { find_string_index_scan(list, target, pipe + 1, idx + 1) }
    };

// v0.60.233: Collect all functions that return String from MIR
// Returns comma-separated list of function names
fn collect_string_fns_from_mir(mir: String) -> String =
    collect_string_fns_acc(mir, 0, "");

fn collect_string_fns_acc(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc }
    else {
        // Find next function definition
        let fn_start = find_fn_start(mir, pos);
        if fn_start < 0 { acc }
        else {
            let fn_name = extract_fn_name_from_mir(mir, fn_start);
            let ret_type = extract_fn_ret_type_from_mir(mir, fn_start);
            let new_acc = if ret_type == "String" {
                if acc == "" { fn_name } else { acc + "," + fn_name }
            } else { acc };
            // Find end of this function and continue
            let fn_end = find_fn_end(mir, fn_start);
            if fn_end < 0 { new_acc } else { collect_string_fns_acc(mir, fn_end, new_acc) }
        }
    };

// Find "fn " at or after pos
fn find_fn_start(mir: String, pos: i64) -> i64 =
    if pos + 3 > mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 102 and mir.byte_at(pos + 1) == 110 and mir.byte_at(pos + 2) == 32 { pos }
    else { find_fn_start(mir, pos + 1) };

// Extract function name after "fn "
fn extract_fn_name_from_mir(mir: String, fn_start: i64) -> String =
    let name_start = fn_start + 3;
    let paren = find_char(mir, name_start, 40);
    if paren < name_start { "" } else { mir.slice(name_start, paren) };

// Extract return type after "-> "
fn extract_fn_ret_type_from_mir(mir: String, fn_start: i64) -> String =
    let arrow = find_arrow_in_mir(mir, fn_start);
    if arrow < 0 { "i64" }
    else {
        let type_start = arrow + 3;
        let brace = find_char(mir, type_start, 123);
        if brace < type_start { "i64" } else { trim(mir.slice(type_start, brace)) }
    };

// Find "-> " after fn_start
fn find_arrow_in_mir(mir: String, pos: i64) -> i64 =
    if pos + 3 > mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 45 and mir.byte_at(pos + 1) == 62 and mir.byte_at(pos + 2) == 32 { pos }
    else if mir.byte_at(pos) == 123 { 0 - 1 }  // Hit '{' before finding arrow
    else { find_arrow_in_mir(mir, pos + 1) };

// Find end of function (||)
fn find_fn_end(mir: String, pos: i64) -> i64 =
    if pos + 1 >= mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 124 and mir.byte_at(pos + 1) == 124 { pos + 2 }
    else { find_fn_end(mir, pos + 1) };

// Check if function name is in dynamic string functions list
fn is_dynamic_string_fn(fn_name: String, string_fns: String) -> bool =
    if string_fns == "" { false }
    else { check_fn_in_list(fn_name, string_fns, 0) };

fn check_fn_in_list(fn_name: String, list: String, pos: i64) -> bool =
    if pos >= list.len() { false }
    else {
        let comma = find_comma_or_end(list, pos);
        let item = list.slice(pos, comma);
        if item == fn_name { true }
        else if comma >= list.len() { false }
        else { check_fn_in_list(fn_name, list, comma + 1) }
    };

// Generate global string constants
fn gen_string_globals(strings: String) -> String =
    if strings == "" { "" } else {
        let sb = sb_new();
        let w1 = gen_string_globals_acc(strings, 0, 0, sb);
        sb_build(sb)
    };

// v0.60.124: Escape pipe character in LLVM IR string constants to avoid
// confusion with the output line separator. Use \7C for | (byte 124).
fn escape_llvm_string(s: String) -> String =
    escape_llvm_string_acc(s, 0, "");

// v0.90.12: Handle escape sequences: \n→\0A, \t→\09, \r→\0D, \0→\00, \\→\5C, \"→\22
fn escape_llvm_string_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc }
    else {
        let ch = s.byte_at(pos);
        if ch == 92 and pos + 1 < s.len() {
            let next = s.byte_at(pos + 1);
            if next == 110 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "0A") }
            else if next == 116 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "09") }
            else if next == 114 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "0D") }
            else if next == 48 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "00") }
            else if next == 92 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "5C") }
            else if next == 34 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "22") }
            else { escape_llvm_string_acc(s, pos + 1, acc + chr(92) + "5C") }
        } else if ch == 124 { escape_llvm_string_acc(s, pos + 1, acc + chr(92) + "7C") }
        else if ch == 34 { escape_llvm_string_acc(s, pos + 1, acc + chr(92) + "22") }
        else { escape_llvm_string_acc(s, pos + 1, acc + chr(ch)) }
    };

// v0.90.12: Count actual bytes after escape sequence processing
fn count_string_bytes(s: String) -> i64 =
    count_string_bytes_acc(s, 0, 0);

fn count_string_bytes_acc(s: String, pos: i64, count: i64) -> i64 =
    if pos >= s.len() { count }
    else {
        let ch = s.byte_at(pos);
        if ch == 92 and pos + 1 < s.len() {
            let next = s.byte_at(pos + 1);
            if next == 110 or next == 116 or next == 114 or next == 48 or next == 92 or next == 34 {
                count_string_bytes_acc(s, pos + 2, count + 1)
            } else { count_string_bytes_acc(s, pos + 1, count + 1) }
        } else { count_string_bytes_acc(s, pos + 1, count + 1) }
    };

fn gen_string_globals_acc(strings: String, pos: i64, idx: i64, sb: i64) -> i64 =
    if pos >= strings.len() { 0 } else {
        let pipe = find_tab_in_list(strings, pos);
        let end = if pipe >= strings.len() { strings.len() } else { pipe };
        let str_content = strings.slice(pos, end);
        let escaped_content = escape_llvm_string(str_content);
        let str_len = count_string_bytes(str_content) + 1;
        let global = "@str_data_" + int_to_string(idx) + " = private unnamed_addr constant [" +
            int_to_string(str_len) + " x i8] c" + chr(34) + escaped_content + chr(92) + "00" + chr(34);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, global);
        if pipe >= strings.len() { 0 } else { gen_string_globals_acc(strings, pipe + 1, idx + 1, sb) }
    };

// Generate program with string table
fn gen_program_sb_with_strings(mir: String, strings: String) -> String =
    gen_program_sb_with_strings_and_fns(mir, strings, "");

// v0.60.233: Generate program with string table and dynamic string functions
// v0.90.2: Build fn registry for proper f64 call types
fn gen_program_sb_with_strings_and_fns(mir: String, strings: String, string_fns: String) -> String =
    let registry = build_fn_registry(mir);
    let sb = sb_new();
    let w1 = gen_program_acc_sb_with_strings_and_fns(mir, 0, strings, string_fns, sb, registry);
    sb_build(sb);

// v0.90.5: Generate program with struct registry for field access codegen
fn gen_program_sb_with_strings_fns_structs(mir: String, strings: String, string_fns: String, struct_reg: String) -> String =
    let registry = build_fn_registry(mir);
    // v0.90.7: Build ptr return registry for struct pointer call tracking
    let ptr_ret_reg = build_ptr_return_registry(mir);
    let sb = sb_new();
    let w1 = gen_program_acc_sb_structs(mir, 0, strings, string_fns, sb, registry, struct_reg, ptr_ret_reg);
    sb_build(sb);

fn gen_program_acc_sb_structs(mir: String, pos: i64, strings: String, string_fns: String, sb: i64, registry: String, struct_reg: String, ptr_ret_reg: String) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let _save = bmb_arena_save();
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function_sb_structs(fn_mir, strings, string_fns, registry, struct_reg, ptr_ret_reg);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_llvm);
        let _restore = bmb_arena_restore();
        if fn_end + 2 >= mir.len() { 0 } else { gen_program_acc_sb_structs(mir, fn_end + 2, strings, string_fns, sb, registry, struct_reg, ptr_ret_reg) }
    };

fn gen_program_acc_sb_with_strings(mir: String, pos: i64, strings: String, sb: i64) -> i64 =
    gen_program_acc_sb_with_strings_and_fns(mir, pos, strings, "", sb, "");

// v0.88.6: arena_save/arena_restore per function to free intermediates
// v0.90.2: Added registry parameter for f64 call types
fn gen_program_acc_sb_with_strings_and_fns(mir: String, pos: i64, strings: String, string_fns: String, sb: i64, registry: String) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let _save = bmb_arena_save();
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function_sb_with_strings_and_fns(fn_mir, strings, string_fns, registry);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_llvm);
        let _restore = bmb_arena_restore();
        if fn_end + 2 >= mir.len() { 0 } else { gen_program_acc_sb_with_strings_and_fns(mir, fn_end + 2, strings, string_fns, sb, registry) }
    };

// v0.60.121: Copy elimination to fix SSA conflicts with user variables
// Mapping format: "name1:src1,name2:src2,..." where name is user var and src is the temp it copies from
// v0.60.202: Also includes "S:varname" for string type tracking
fn gen_function_sb_with_strings(mir: String, strings: String) -> String =
    gen_function_sb_with_strings_and_fns(mir, strings, "", "");

// v0.60.233: Generate function with string table and dynamic string functions
// v0.88.6: Separated string markers into SB for O(1) append, zero-arena lookup
// v0.90.2: Added registry parameter for f64 call types
fn gen_function_sb_with_strings_and_fns(mir: String, strings: String, string_fns: String, registry: String) -> String =
    let sb = sb_new();
    let str_sb = sb_new();
    let ret_type = extract_mir_return_type(mir);
    // Extract string parameters to initialize the string marker SB
    let w0 = init_string_params_sb(mir, str_sb);
    let w1 = gen_function_lines_sb_with_strings_map_and_fns(mir, 0, sb, ret_type, strings, string_fns, "", str_sb, registry);
    let result = sb_build(sb);
    let _f1 = sb_free(sb);
    let _f2 = sb_free(str_sb);
    result;

// v0.90.5: Generate function with struct registry
fn gen_function_sb_structs(mir: String, strings: String, string_fns: String, registry: String, struct_reg: String, ptr_ret_reg: String) -> String =
    let sb = sb_new();
    let str_sb = sb_new();
    let ptr_sb = sb_new();
    let ret_type = extract_mir_return_type(mir);
    let w0 = init_string_params_sb(mir, str_sb);
    let w0p = init_ptr_params_sb(mir, ptr_sb);
    // v0.90.7: Pre-populate ptr_sb with function return types from ptr_ret_reg
    let w0r = init_fn_ptr_returns(ptr_ret_reg, ptr_sb);
    let w1 = gen_fn_lines_structs(mir, 0, sb, ret_type, strings, string_fns, "", str_sb, registry, struct_reg, ptr_sb);
    let result = sb_build(sb);
    let _f1 = sb_free(sb);
    let _f2 = sb_free(str_sb);
    let _f3 = sb_free(ptr_sb);
    result;

// v0.88.6: Push string parameter markers to SB
fn init_string_params_sb(mir: String, str_sb: i64) -> i64 =
    let fn_start = find_pattern_at(mir, "fn ", 0);
    if fn_start < 0 { 0 } else {
        let paren_start = find_char(mir, fn_start, 40);
        let paren_end = find_char(mir, paren_start, 41);
        if paren_start < 0 or paren_end < 0 { 0 }
        else {
            let params = mir.slice(paren_start + 1, paren_end);
            collect_string_params_sb(params, 0, str_sb)
        }
    };

// Collect string parameters and push "S:%name," markers to SB
fn collect_string_params_sb(params: String, pos: i64, str_sb: i64) -> i64 =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { 0 }
    else {
        let comma_pos = find_comma_or_end(params, p);
        let param = params.slice(p, comma_pos);
        let colon_pos = find_char(param, 0, 58);
        if colon_pos < param.len() {
            let param_name = trim(param.slice(0, colon_pos));
            let param_type = trim(param.slice(colon_pos + 1, param.len()));
            let w = if param_type == "String" {
                let w1 = sb_push(str_sb, "S:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else if param_type == "f64" {
                // v0.90.3: Track double parameters for type-correct codegen
                let w1 = sb_push(str_sb, "D:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else if param_type == "*f64" {
                // v0.90.9: Track *f64 pointer parameters for double load/store
                let w1 = sb_push(str_sb, "F:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else { 0 };
            if comma_pos >= params.len() { 0 }
            else { collect_string_params_sb(params, comma_pos + 1, str_sb) }
        } else {
            if comma_pos >= params.len() { 0 }
            else { collect_string_params_sb(params, comma_pos + 1, str_sb) }
        }
    };

// v0.90.7: Build registry of functions that return struct pointers
// Format: "fn_name:StructName,fn_name2:StructName2,"
fn build_ptr_return_registry(mir: String) -> String =
    let rsb = sb_new();
    let w1 = build_ptr_return_acc(mir, 0, rsb);
    let result = sb_build(rsb);
    let _f = sb_free(rsb);
    result;

fn build_ptr_return_acc(mir: String, pos: i64, rsb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let w1 = register_ptr_return(fn_mir, rsb);
        if fn_end + 2 >= mir.len() { 0 } else { build_ptr_return_acc(mir, fn_end + 2, rsb) }
    };

fn register_ptr_return(fn_mir: String, rsb: i64) -> i64 =
    let first_pipe = find_char(fn_mir, 0, 124);
    let header = fn_mir.slice(0, first_pipe);
    if header.len() < 4 { 0 }
    else if low_starts_with_at(header, 0, "fn ") {
        let name_start = 3;
        let paren_pos = find_char(header, name_start, 40);
        let fn_name = header.slice(name_start, paren_pos);
        let close_pos = find_char(header, paren_pos, 41);
        let arrow_pos = find_arrow(header, close_pos);
        let brace_pos = find_char(header, arrow_pos, 123);
        let raw_ret = trim(header.slice(arrow_pos + 2, brace_pos));
        let ann = find_mir_annotation(raw_ret);
        let ret_type = if ann == "" { raw_ret } else { strip_annotation(raw_ret) };
        if is_struct_ptr_type(ret_type) {
            let struct_name = extract_struct_name_from_ptr_type(ret_type);
            let w1 = sb_push(rsb, fn_name);
            let w2 = sb_push(rsb, ":");
            let w3 = sb_push(rsb, struct_name);
            sb_push(rsb, ",")
        } else { 0 }
    } else { 0 };

// v0.90.7: Initialize ptr_sb with function return type entries (F:@fn_name:StructName)
fn init_fn_ptr_returns(ptr_ret_reg: String, ptr_sb: i64) -> i64 =
    init_fn_ptr_returns_at(ptr_ret_reg, 0, ptr_sb);

fn init_fn_ptr_returns_at(reg: String, pos: i64, ptr_sb: i64) -> i64 =
    if pos >= reg.len() { 0 } else {
        let comma_pos = find_comma_or_end(reg, pos);
        let entry = reg.slice(pos, comma_pos);
        let colon_pos = find_char(entry, 0, 58);
        if colon_pos < entry.len() {
            let fn_name = entry.slice(0, colon_pos);
            let struct_name = entry.slice(colon_pos + 1, entry.len());
            let w1 = sb_push(ptr_sb, "F:@");
            let w2 = sb_push(ptr_sb, fn_name);
            let w3 = sb_push(ptr_sb, ":");
            let w4 = sb_push(ptr_sb, struct_name);
            let w5 = sb_push(ptr_sb, ",");
            if comma_pos >= reg.len() { 0 }
            else { init_fn_ptr_returns_at(reg, comma_pos + 1, ptr_sb) }
        } else {
            if comma_pos >= reg.len() { 0 }
            else { init_fn_ptr_returns_at(reg, comma_pos + 1, ptr_sb) }
        }
    };

// v0.90.7: Check if type string is a struct pointer type (starts with *)
fn is_struct_ptr_type(t: String) -> bool =
    t.len() >= 2 and t.byte_at(0) == 42;

// v0.90.7: Extract struct name from *StructName type
fn extract_struct_name_from_ptr_type(t: String) -> String =
    if t.len() >= 2 and t.byte_at(0) == 42 { t.slice(1, t.len()) }
    else { "" };

// v0.90.7: Initialize struct pointer param tracking
// Format: "P:%name:StructName," for each *StructName parameter
fn init_ptr_params_sb(mir: String, ptr_sb: i64) -> i64 =
    let fn_start = find_pattern_at(mir, "fn ", 0);
    if fn_start < 0 { 0 } else {
        let paren_start = find_char(mir, fn_start, 40);
        let paren_end = find_char(mir, paren_start, 41);
        if paren_start < 0 or paren_end < 0 { 0 }
        else {
            let params = mir.slice(paren_start + 1, paren_end);
            collect_ptr_params_sb(params, 0, ptr_sb)
        }
    };

fn collect_ptr_params_sb(params: String, pos: i64, ptr_sb: i64) -> i64 =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { 0 }
    else {
        let comma_pos = find_comma_or_end(params, p);
        let param = params.slice(p, comma_pos);
        let colon_pos = find_char(param, 0, 58);
        if colon_pos < param.len() {
            let param_name = trim(param.slice(0, colon_pos));
            let param_type = trim(param.slice(colon_pos + 1, param.len()));
            let w = if is_struct_ptr_type(param_type) {
                let struct_name = extract_struct_name_from_ptr_type(param_type);
                let w1 = sb_push(ptr_sb, "P:%");
                let w2 = sb_push(ptr_sb, param_name);
                let w3 = sb_push(ptr_sb, ":");
                let w4 = sb_push(ptr_sb, struct_name);
                sb_push(ptr_sb, ",")
            } else { 0 };
            if comma_pos >= params.len() { 0 }
            else { collect_ptr_params_sb(params, comma_pos + 1, ptr_sb) }
        } else {
            if comma_pos >= params.len() { 0 }
            else { collect_ptr_params_sb(params, comma_pos + 1, ptr_sb) }
        }
    };

// v0.90.7: Push struct pointer marker to ptr_sb
fn push_ptr_marker(ptr_sb: i64, varname: String, struct_name: String) -> i64 =
    let w1 = sb_push(ptr_sb, "P:");
    let w2 = sb_push(ptr_sb, varname);
    let w3 = sb_push(ptr_sb, ":");
    let w4 = sb_push(ptr_sb, struct_name);
    sb_push(ptr_sb, ",");

// v0.90.7: Check if variable is a struct pointer, return struct name or ""
fn get_struct_ptr_type(varname: String, ptr_sb: i64) -> String =
    let content = sb_build(ptr_sb);
    get_struct_ptr_type_from(varname, content, 0);

fn get_struct_ptr_type_from(varname: String, content: String, pos: i64) -> String =
    if pos >= content.len() { "" } else {
        let comma_pos = find_comma_or_end(content, pos);
        let entry = content.slice(pos, comma_pos);
        // Entry format: "P:%varname:StructName"
        if entry.len() >= 4 and entry.byte_at(0) == 80 and entry.byte_at(1) == 58 {
            let after_p = 2;
            let second_colon = find_char_from(entry, after_p, 58);
            if second_colon < entry.len() {
                let entry_var = entry.slice(after_p, second_colon);
                let entry_struct = entry.slice(second_colon + 1, entry.len());
                if entry_var == varname { entry_struct }
                else if comma_pos >= content.len() { "" }
                else { get_struct_ptr_type_from(varname, content, comma_pos + 1) }
            }
            else if comma_pos >= content.len() { "" }
            else { get_struct_ptr_type_from(varname, content, comma_pos + 1) }
        }
        else if comma_pos >= content.len() { "" }
        else { get_struct_ptr_type_from(varname, content, comma_pos + 1) }
    };

// v0.90.7: Find char starting from pos (handles entries within entries)
fn find_char_from(s: String, pos: i64, ch: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == ch { pos }
    else { find_char_from(s, pos + 1, ch) };

// v0.90.7: Get struct size from struct registry (count fields * 8 bytes each)
fn get_struct_size(struct_reg: String, struct_name: String) -> i64 =
    let field_count = count_struct_fields(struct_reg, struct_name);
    field_count * 8;

fn count_struct_fields(registry: String, struct_name: String) -> i64 =
    count_struct_fields_at(registry, 0, struct_name);

fn count_struct_fields_at(registry: String, pos: i64, struct_name: String) -> i64 =
    if pos >= registry.len() { 0 } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let name = entry.slice(0, colon_pos);
        if name == struct_name {
            let fields = entry.slice(colon_pos + 1, entry.len());
            count_commas(fields, 0) + 1
        }
        else if semi_pos + 1 >= registry.len() { 0 }
        else { count_struct_fields_at(registry, semi_pos + 1, struct_name) }
    };

fn count_commas(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 }
    else if s.byte_at(pos) == 44 { 1 + count_commas(s, pos + 1) }
    else { count_commas(s, pos + 1) };

// v0.90.7: Build struct type string for GEP: { double, double, ... }
fn build_struct_gep_type(struct_reg: String, struct_name: String) -> String =
    let field_count = count_struct_fields(struct_reg, struct_name);
    "{ " + build_field_types_str(struct_reg, struct_name, field_count) + " }";

fn build_field_types_str(struct_reg: String, struct_name: String, count: i64) -> String =
    build_field_types_acc(struct_reg, struct_name, 0, count, "");

fn build_field_types_acc(struct_reg: String, struct_name: String, idx: i64, count: i64, acc: String) -> String =
    if idx >= count { acc } else {
        let is_f64 = is_field_f64_by_index(struct_reg, struct_name, idx);
        let field_type = if is_f64 { "double" } else { "i64" };
        let new_acc = if acc == "" { field_type } else { acc + ", " + field_type };
        build_field_types_acc(struct_reg, struct_name, idx + 1, count, new_acc)
    };

// v0.90.7: Check if field at given index is f64
fn is_field_f64_by_index(struct_reg: String, struct_name: String, idx: i64) -> bool =
    is_field_f64_by_index_at(struct_reg, 0, struct_name, idx);

fn is_field_f64_by_index_at(registry: String, pos: i64, struct_name: String, idx: i64) -> bool =
    if pos >= registry.len() { false } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let name = entry.slice(0, colon_pos);
        if name == struct_name {
            let fields = entry.slice(colon_pos + 1, entry.len());
            check_field_f64_at_index(fields, 0, 0, idx)
        }
        else if semi_pos + 1 >= registry.len() { false }
        else { is_field_f64_by_index_at(registry, semi_pos + 1, struct_name, idx) }
    };

fn check_field_f64_at_index(fields: String, pos: i64, cur_idx: i64, target_idx: i64) -> bool =
    if pos >= fields.len() { false } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        if cur_idx == target_idx {
            let tilde_pos = find_char(raw_name, 0, 126);
            tilde_pos < raw_name.len()
        }
        else if comma_pos >= fields.len() { false }
        else { check_field_f64_at_index(fields, comma_pos + 1, cur_idx + 1, target_idx) }
    };

// v0.60.202: Iterative pattern finding to avoid stack overflow on large strings
fn find_pattern_at(s: String, pat: String, pos: i64) -> i64 =
    // Check from start - MIR functions always start with "fn "
    if pos == 0 and pat.len() <= s.len() and s.slice(0, pat.len()) == pat { 0 }
    // If not at start, do linear search (shouldn't happen often for "fn ")
    else { find_pattern_at_slow(s, pat, pos) };

fn find_pattern_at_slow(s: String, pat: String, pos: i64) -> i64 =
    if pos + pat.len() > s.len() { 0 - 1 }
    else if s.slice(pos, pos + pat.len()) == pat { pos }
    else { find_pattern_at_slow(s, pat, pos + 1) };

// v0.90.5: Struct-aware line generator
fn gen_fn_lines_structs(mir: String, pos: i64, sb: i64, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let result = llvm_gen_fn_line_structs(line, ret_type, strings, string_fns, mapping, str_sb, registry, struct_reg, ptr_sb);
        let is_changed = result.len() > 0 and result.byte_at(0) == 33;
        let new_mapping = if is_changed { extract_new_mapping(result) } else { mapping };
        let llvm_line = if is_changed { extract_new_llvm_line(result) } else { result };
        let len = sb_len(sb);
        let w1 = if len > 0 and llvm_line != "" { sb_push(sb, "|") } else { 0 };
        let w2 = if llvm_line != "" { sb_push(sb, llvm_line) } else { 0 };
        if pipe_pos >= mir.len() { 0 } else { gen_fn_lines_structs(mir, pipe_pos + 1, sb, ret_type, strings, string_fns, new_mapping, str_sb, registry, struct_reg, ptr_sb) }
    };

// v0.90.5: Struct-aware fn line handler
fn llvm_gen_fn_line_structs(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if low_starts_with_at(line, p, "fn ") { same_mapping(llvm_gen_fn_header(line, p)) }
    else if ends_with_colon(line) { same_mapping(line) }
    else if line == "}" { same_mapping("}") }
    else { llvm_gen_line_structs(line, ret_type, strings, string_fns, mapping, str_sb, registry, struct_reg, ptr_sb) };

// v0.90.5: Struct-aware line handler (non-assignment and assignment)
fn llvm_gen_line_structs(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if line.byte_at(p) == 37 { llvm_gen_assign_structs(line, p, strings, string_fns, mapping, str_sb, registry, struct_reg, ptr_sb) }
    else if low_starts_with_at(line, p, "return") { same_mapping(llvm_gen_return_typed(line, p, ret_type)) }
    else if low_starts_with_at(line, p, "branch") { same_mapping(llvm_gen_branch(line, p)) }
    else if low_starts_with_at(line, p, "goto") { same_mapping(llvm_gen_goto(line, p)) }
    else if low_starts_with_at(line, p, "alloca") { llvm_gen_alloca(line, p, mapping) }
    else if low_starts_with_at(line, p, "store_ptr") { llvm_gen_store_ptr_sb(line, p + 9, str_sb) }
    else if low_starts_with_at(line, p, "store") { llvm_gen_store_sb(line, p, mapping, str_sb) }
    // v0.90.5: field-store (non-assignment form)
    else if low_starts_with_at(line, p, "field-store") { llvm_gen_field_store(line, p + 11, struct_reg, str_sb) }
    // v0.90.9: mark_f64_ptr - register variable as *f64 pointer
    else if low_starts_with_at(line, p, "mark_f64_ptr") { llvm_handle_mark_f64_ptr(line, p, str_sb) }
    else if low_starts_with_at(line, p, "mutex-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "arc-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "atomic-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "channel-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "rwlock-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "condvar-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "async-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-pool-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-join") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "scope-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if line.byte_at(p) == 40 { same_mapping(llvm_gen_channel_new(line, p)) }
    else { same_mapping(line) };

// v0.90.5: Struct-aware assign handler
fn llvm_gen_assign_structs(line: String, pos: i64, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs_structs(line, after_eq, dest, strings, string_fns, mapping, str_sb, registry, struct_reg, ptr_sb);

// v0.90.5: Struct-aware RHS handler (delegates to registry handler, with field-access)
fn llvm_gen_rhs_structs(line: String, pos: i64, dest: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> String =
    // v0.90.5: Check for field-access before delegating
    if low_starts_with_at(line, pos, "field-access") {
        llvm_gen_field_access(line, pos + 12, dest, struct_reg, str_sb, ptr_sb)
    }
    // v0.90.7: Intercept + for struct pointer arithmetic
    else if low_starts_with_at(line, pos, "+") {
        llvm_gen_add_struct_aware(line, pos + 1, dest, mapping, str_sb, struct_reg, ptr_sb)
    }
    // v0.90.7: Propagate struct pointer type through copy
    else if low_starts_with_at(line, pos, "copy") {
        llvm_gen_copy_struct_aware(line, pos, dest, mapping, str_sb, ptr_sb, registry)
    }
    // v0.90.7: Track struct pointer returns from calls
    else if low_starts_with_at(line, pos, "call") {
        llvm_gen_call_struct_aware(line, pos, dest, strings, string_fns, mapping, str_sb, registry, ptr_sb)
    }
    else {
        // Delegate to existing registry-aware RHS handler
        llvm_gen_rhs_with_strings_map_and_fns_reg(line, pos, dest, strings, string_fns, mapping, str_sb, registry)
    };

fn gen_function_lines_sb_with_strings_map(mir: String, pos: i64, sb: i64, ret_type: String, strings: String, mapping: String) -> i64 =
    let str_sb = sb_new();
    gen_function_lines_sb_with_strings_map_and_fns(mir, pos, sb, ret_type, strings, "", mapping, str_sb, "");

// v0.88.6: Added str_sb parameter for string marker tracking
fn gen_function_lines_sb_with_strings_map_and_fns(mir: String, pos: i64, sb: i64, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let result = llvm_gen_fn_line_with_strings_map_and_fns_reg(line, ret_type, strings, string_fns, mapping, str_sb, registry);
        let is_changed = result.len() > 0 and result.byte_at(0) == 33;
        let new_mapping = if is_changed { extract_new_mapping(result) } else { mapping };
        let llvm_line = if is_changed { extract_new_llvm_line(result) } else { result };
        let len = sb_len(sb);
        let w1 = if len > 0 and llvm_line != "" { sb_push(sb, "|") } else { 0 };
        let w2 = if llvm_line != "" { sb_push(sb, llvm_line) } else { 0 };
        if pipe_pos >= mir.len() { 0 } else { gen_function_lines_sb_with_strings_map_and_fns(mir, pipe_pos + 1, sb, ret_type, strings, string_fns, new_mapping, str_sb, registry) }
    };

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_fn_line_with_strings_map(line: String, ret_type: String, strings: String, mapping: String) -> String =
    let str_sb = sb_new();
    llvm_gen_fn_line_with_strings_map_and_fns(line, ret_type, strings, "", mapping, str_sb);

// v0.88.6: Added str_sb parameter
fn llvm_gen_fn_line_with_strings_map_and_fns(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if low_starts_with_at(line, p, "fn ") { same_mapping(llvm_gen_fn_header(line, p)) }
    else if ends_with_colon(line) { same_mapping(line) }
    else if line == "}" { same_mapping("}") }
    else { llvm_gen_line_with_strings_map_and_fns(line, ret_type, strings, string_fns, mapping, str_sb) };

// v0.90.2: Registry-aware version
fn llvm_gen_fn_line_with_strings_map_and_fns_reg(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if low_starts_with_at(line, p, "fn ") { same_mapping(llvm_gen_fn_header(line, p)) }
    else if ends_with_colon(line) { same_mapping(line) }
    else if line == "}" { same_mapping("}") }
    else { llvm_gen_line_with_strings_map_and_fns_reg(line, ret_type, strings, string_fns, mapping, str_sb, registry) };

// v0.90.2: Registry-aware line handler
fn llvm_gen_line_with_strings_map_and_fns_reg(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if line.byte_at(p) == 37 { llvm_gen_assign_with_strings_map_and_fns_reg(line, p, strings, string_fns, mapping, str_sb, registry) }
    else if low_starts_with_at(line, p, "return") { same_mapping(llvm_gen_return_typed(line, p, ret_type)) }
    else if low_starts_with_at(line, p, "branch") { same_mapping(llvm_gen_branch(line, p)) }
    else if low_starts_with_at(line, p, "goto") { same_mapping(llvm_gen_goto(line, p)) }
    else if low_starts_with_at(line, p, "alloca") { llvm_gen_alloca(line, p, mapping) }
    else if low_starts_with_at(line, p, "store_ptr") { llvm_gen_store_ptr_sb(line, p + 9, str_sb) }
    // v0.90.4: Double-aware store
    else if low_starts_with_at(line, p, "store") { llvm_gen_store_sb(line, p, mapping, str_sb) }
    // v0.90.9: mark_f64_ptr - register variable as *f64 pointer
    else if low_starts_with_at(line, p, "mark_f64_ptr") { llvm_handle_mark_f64_ptr(line, p, str_sb) }
    else if low_starts_with_at(line, p, "mutex-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "arc-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "atomic-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "channel-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "rwlock-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "condvar-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "async-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-pool-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-join") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "scope-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if line.byte_at(p) == 40 { same_mapping(llvm_gen_channel_new(line, p)) }
    else { same_mapping(line) };

// v0.90.2: Registry-aware assign handler
fn llvm_gen_assign_with_strings_map_and_fns_reg(line: String, pos: i64, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs_with_strings_map_and_fns_reg(line, after_eq, dest, strings, string_fns, mapping, str_sb, registry);

// v0.90.2: Registry-aware RHS handler (only call is different from original)
fn llvm_gen_rhs_with_strings_map_and_fns_reg(line: String, pos: i64, dest: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String) -> String =
    if low_starts_with_at(line, pos, "const") {
        let val_start = low_skip_ws(line, pos + 5);
        let val = line.slice(val_start, line.len());
        let trimmed_val = trim_end(val);
        if trimmed_val.len() >= 2 and trimmed_val.byte_at(0) == 70 and trimmed_val.byte_at(1) == 58 {
            let float_val = trimmed_val.slice(2, trimmed_val.len());
            // v0.90.4: Mark dest as double for type propagation
            let w = push_double_marker(str_sb, dest);
            same_mapping("  " + dest + " = fadd nsz double 0.0, " + float_val)
        } else {
            same_mapping("  " + dest + " = add nsw i64 0, " + trimmed_val)
        }
    } else if low_starts_with_at(line, pos, "copy") {
        let src_start = low_skip_ws(line, pos + 4);
        let src = trim_end(line.slice(src_start, line.len()));
        if is_user_variable(dest) {
            let resolved_src = resolve_variable(src, mapping);
            let src_is_string = is_string_var_sb(src, str_sb);
            let src_is_double = is_double_var_sb(src, str_sb);
            // v0.90.9: Propagate *f64 pointer marker through copy
            let src_is_f64_ptr = is_f64_ptr_sb(src, str_sb);
            let w = if src_is_string { push_string_marker(str_sb, dest) } else if src_is_double { push_double_marker(str_sb, dest) } else if src_is_f64_ptr { push_f64_ptr_marker(str_sb, dest) } else { 0 };
            let name_mapping = add_mapping(mapping, dest, resolved_src);
            changed_mapping_empty(name_mapping)
        } else {
            let resolved_src = resolve_variable(src, mapping);
            if resolved_src == "ALLOCA" {
                // v0.90.3: Check if alloca var is double type
                let alloca_is_double = is_double_var_sb(src, str_sb);
                if alloca_is_double {
                    let w = push_double_marker(str_sb, dest);
                    same_mapping("  " + dest + " = load double, ptr " + src)
                } else {
                    same_mapping("  " + dest + " = load i64, ptr " + src)
                }
            } else {
                let src_is_string = is_string_var_sb(src, str_sb);
                let src_is_double = is_double_var_sb(src, str_sb);
                // v0.90.9: Propagate *f64 pointer marker through copy
                let src_is_f64_ptr = is_f64_ptr_sb(src, str_sb);
                let w = if src_is_string { push_string_marker(str_sb, dest) } else if src_is_double { push_double_marker(str_sb, dest) } else if src_is_f64_ptr { push_f64_ptr_marker(str_sb, dest) } else { 0 };
                if src_is_double {
                    same_mapping("  " + dest + " = fadd nsz double 0.0, " + resolved_src)
                } else {
                    same_mapping("  " + dest + " = add nsw i64 0, " + resolved_src)
                }
            }
        }
    } else if low_starts_with_at(line, pos, "string") {
        let str_start = low_skip_ws(line, pos + 6);
        let str_content = line.slice(str_start + 1, line.len() - 1);
        let w = push_string_marker(str_sb, dest);
        same_mapping(llvm_gen_string_ref(dest, str_content, strings))
    // v0.90.4: f-prefix float ops with double marker propagation
    } else if low_starts_with_at(line, pos, "f+") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fadd", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f-") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fsub", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f*") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fmul", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f/") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fdiv", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f<=") { same_mapping(llvm_gen_float_cmp("ole", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f>=") { same_mapping(llvm_gen_float_cmp("oge", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f<") { same_mapping(llvm_gen_float_cmp("olt", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f>") { same_mapping(llvm_gen_float_cmp("ogt", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f==") { same_mapping(llvm_gen_float_cmp("oeq", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f!=") { same_mapping(llvm_gen_float_cmp("one", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "+") { llvm_gen_add_with_strings_sb(line, pos + 1, dest, mapping, str_sb) }
    // v0.90.4: Double-aware binops for -, *, /
    else if low_starts_with_at(line, pos, "-") { llvm_gen_binop_sb("sub", "fsub", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "*") { llvm_gen_binop_sb("mul", "fmul", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "/") { llvm_gen_binop_sb("sdiv", "fdiv", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "%") { same_mapping(llvm_gen_binop("srem", line, pos + 1, dest)) }
    // v0.90.1: Bitwise operations and shifts (must check << >> before < >)
    else if low_starts_with_at(line, pos, "bxor") { same_mapping(llvm_gen_binop("xor", line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "band") { same_mapping(llvm_gen_binop("and", line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "bor") { same_mapping(llvm_gen_binop("or", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "bnot") { same_mapping(llvm_gen_bnot(line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "<<") { same_mapping(llvm_gen_binop("shl", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, ">>") { same_mapping(llvm_gen_binop("ashr", line, pos + 2, dest)) }
    // v0.90.4: Double-aware comparisons
    else if low_starts_with_at(line, pos, "<=") { llvm_gen_cmp_sb("sle", "ole", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, ">=") { llvm_gen_cmp_sb("sge", "oge", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "<") { llvm_gen_cmp_sb("slt", "olt", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, ">") { llvm_gen_cmp_sb("sgt", "ogt", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "==") { llvm_gen_cmp_with_strings_sb("eq", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "!=") { llvm_gen_cmp_with_strings_sb("ne", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "and") { same_mapping(llvm_gen_binop("and", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "or") { same_mapping(llvm_gen_binop("or", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "not") { same_mapping(llvm_gen_not(line, pos + 3, dest)) }
    // v0.90.4: Double-aware negation
    else if low_starts_with_at(line, pos, "neg") { llvm_gen_neg_sb(line, pos + 3, dest, str_sb) }
    else if low_starts_with_at(line, pos, "phi") { llvm_gen_phi_with_strings_sb(line, pos, dest, str_sb) }
    // v0.90.2: Use registry-aware call handler
    else if low_starts_with_at(line, pos, "call") { llvm_gen_call_with_string_tracking_sb_reg(line, pos, dest, str_sb, string_fns, registry) }
    else if low_starts_with_at(line, pos, "mutex-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "thread-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "arc-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "atomic-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "channel-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "sender-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "rwlock-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "barrier-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "condvar-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "block-on") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "async-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "thread-pool-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "scope-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    // v0.90.9: Use SB-aware GEP/load/store for *f64 propagation
    else if low_starts_with_at(line, pos, "gep") { llvm_gen_gep_sb(line, pos + 3, dest, str_sb) }
    else if low_starts_with_at(line, pos, "load_ptr") { llvm_gen_load_ptr_sb(line, pos + 8, dest, str_sb) }
    else if low_starts_with_at(line, pos, "store_ptr") { llvm_gen_store_ptr_sb(line, pos + 9, str_sb) }
    else { same_mapping("  ; unknown: " + line) };

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_line_with_strings_map(line: String, ret_type: String, strings: String, mapping: String) -> String =
    let str_sb = sb_new();
    llvm_gen_line_with_strings_map_and_fns(line, ret_type, strings, "", mapping, str_sb);

// v0.88.6: Added str_sb parameter
fn llvm_gen_line_with_strings_map_and_fns(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if line.byte_at(p) == 37 { llvm_gen_assign_with_strings_map_and_fns(line, p, strings, string_fns, mapping, str_sb) }
    else if low_starts_with_at(line, p, "return") { same_mapping(llvm_gen_return_typed(line, p, ret_type)) }
    else if low_starts_with_at(line, p, "branch") { same_mapping(llvm_gen_branch(line, p)) }
    else if low_starts_with_at(line, p, "goto") { same_mapping(llvm_gen_goto(line, p)) }
    // v0.92: alloca/store for mutable variables
    else if low_starts_with_at(line, p, "alloca") { llvm_gen_alloca(line, p, mapping) }
    // v0.90.2: store_ptr BEFORE store (prefix match)
    // v0.90.9: Double-aware store_ptr
    else if low_starts_with_at(line, p, "store_ptr") { llvm_gen_store_ptr_sb(line, p + 9, str_sb) }
    // v0.90.4: Double-aware store
    else if low_starts_with_at(line, p, "store") { llvm_gen_store_sb(line, p, mapping, str_sb) }
    // v0.90.9: mark_f64_ptr - register variable as *f64 pointer
    else if low_starts_with_at(line, p, "mark_f64_ptr") { llvm_handle_mark_f64_ptr(line, p, str_sb) }
    // v0.88.10: Non-assignment concurrency instructions
    else if low_starts_with_at(line, p, "mutex-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "arc-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "atomic-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "channel-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "rwlock-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "condvar-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "async-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-pool-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-join") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "scope-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    // v0.88.10: channel-new dual-dest format: (%sender, %receiver) = channel-new %cap
    else if line.byte_at(p) == 40 { same_mapping(llvm_gen_channel_new(line, p)) }
    else { same_mapping(line) };

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_assign_with_strings_map(line: String, pos: i64, strings: String, mapping: String) -> String =
    let str_sb = sb_new();
    llvm_gen_assign_with_strings_map_and_fns(line, pos, strings, "", mapping, str_sb);

// v0.88.6: Added str_sb parameter
fn llvm_gen_assign_with_strings_map_and_fns(line: String, pos: i64, strings: String, string_fns: String, mapping: String, str_sb: i64) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs_with_strings_map_and_fns(line, after_eq, dest, strings, string_fns, mapping, str_sb);

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
// v0.60.202: Track string temporaries for proper string comparison generation
// Mapping now includes "S:varname" entries to mark string variables
fn llvm_gen_rhs_with_strings_map(line: String, pos: i64, dest: String, strings: String, mapping: String) -> String =
    let str_sb = sb_new();
    llvm_gen_rhs_with_strings_map_and_fns(line, pos, dest, strings, "", mapping, str_sb);

// v0.88.6: String markers tracked via str_sb (SB), mapping only for name:value copy-elimination
fn llvm_gen_rhs_with_strings_map_and_fns(line: String, pos: i64, dest: String, strings: String, string_fns: String, mapping: String, str_sb: i64) -> String =
    if low_starts_with_at(line, pos, "const") {
        let val_start = low_skip_ws(line, pos + 5);
        let val = line.slice(val_start, line.len());
        let trimmed_val = trim_end(val);
        // v0.91: Float constant: const F:3.14 → fadd double 0.0, 3.14
        if trimmed_val.len() >= 2 and trimmed_val.byte_at(0) == 70 and trimmed_val.byte_at(1) == 58 {
            let float_val = trimmed_val.slice(2, trimmed_val.len());
            // v0.90.4: Mark dest as double for type propagation
            let w = push_double_marker(str_sb, dest);
            same_mapping("  " + dest + " = fadd nsz double 0.0, " + float_val)
        } else {
            same_mapping("  " + dest + " = add nsw i64 0, " + trimmed_val)
        }
    } else if low_starts_with_at(line, pos, "copy") {
        let src_start = low_skip_ws(line, pos + 4);
        let src = trim_end(line.slice(src_start, line.len()));
        // Check if this is a copy TO a user variable (not %_t)
        if is_user_variable(dest) {
            // Don't emit code, just update mapping
            let resolved_src = resolve_variable(src, mapping);
            let src_is_string = is_string_var_sb(src, str_sb);
            let src_is_double = is_double_var_sb(src, str_sb);
            // v0.90.9: Propagate *f64 pointer marker through copy
            let src_is_f64_ptr = is_f64_ptr_sb(src, str_sb);
            let w = if src_is_string { push_string_marker(str_sb, dest) } else if src_is_double { push_double_marker(str_sb, dest) } else if src_is_f64_ptr { push_f64_ptr_marker(str_sb, dest) } else { 0 };
            let name_mapping = add_mapping(mapping, dest, resolved_src);
            changed_mapping_empty(name_mapping)
        } else {
            // v0.92: Check if source is an ALLOCA variable (mutable) - emit load instead of copy
            let resolved_src = resolve_variable(src, mapping);
            if resolved_src == "ALLOCA" {
                // v0.90.3: Check if alloca var is double type
                let alloca_is_double_2 = is_double_var_sb(src, str_sb);
                if alloca_is_double_2 {
                    let w = push_double_marker(str_sb, dest);
                    same_mapping("  " + dest + " = load double, ptr " + src)
                } else {
                    same_mapping("  " + dest + " = load i64, ptr " + src)
                }
            } else {
                let src_is_string = is_string_var_sb(src, str_sb);
                let src_is_double_2 = is_double_var_sb(src, str_sb);
                // v0.90.9: Propagate *f64 pointer marker through copy
                let src_is_f64_ptr_2 = is_f64_ptr_sb(src, str_sb);
                let w = if src_is_string { push_string_marker(str_sb, dest) } else if src_is_double_2 { push_double_marker(str_sb, dest) } else if src_is_f64_ptr_2 { push_f64_ptr_marker(str_sb, dest) } else { 0 };
                if src_is_double_2 {
                    same_mapping("  " + dest + " = fadd nsz double 0.0, " + resolved_src)
                } else {
                    same_mapping("  " + dest + " = add nsw i64 0, " + resolved_src)
                }
            }
        }
    } else if low_starts_with_at(line, pos, "string") {
        let str_start = low_skip_ws(line, pos + 6);
        let str_content = line.slice(str_start + 1, line.len() - 1);
        let w = push_string_marker(str_sb, dest);
        same_mapping(llvm_gen_string_ref(dest, str_content, strings))
    // v0.90.4: f-prefix float ops with double marker propagation
    } else if low_starts_with_at(line, pos, "f+") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fadd", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f-") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fsub", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f*") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fmul", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f/") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fdiv", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f<=") { same_mapping(llvm_gen_float_cmp("ole", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f>=") { same_mapping(llvm_gen_float_cmp("oge", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f<") { same_mapping(llvm_gen_float_cmp("olt", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f>") { same_mapping(llvm_gen_float_cmp("ogt", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f==") { same_mapping(llvm_gen_float_cmp("oeq", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f!=") { same_mapping(llvm_gen_float_cmp("one", line, pos + 3, dest)) }
    // Integer/float arithmetic (detect double from operand markers)
    else if low_starts_with_at(line, pos, "+") { llvm_gen_add_with_strings_sb(line, pos + 1, dest, mapping, str_sb) }
    // v0.90.4: Double-aware binops for -, *, /
    else if low_starts_with_at(line, pos, "-") { llvm_gen_binop_sb("sub", "fsub", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "*") { llvm_gen_binop_sb("mul", "fmul", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "/") { llvm_gen_binop_sb("sdiv", "fdiv", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "%") { same_mapping(llvm_gen_binop("srem", line, pos + 1, dest)) }
    // v0.90.1: Bitwise operations and shifts (must check << >> before < >)
    else if low_starts_with_at(line, pos, "bxor") { same_mapping(llvm_gen_binop("xor", line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "band") { same_mapping(llvm_gen_binop("and", line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "bor") { same_mapping(llvm_gen_binop("or", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "bnot") { same_mapping(llvm_gen_bnot(line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "<<") { same_mapping(llvm_gen_binop("shl", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, ">>") { same_mapping(llvm_gen_binop("ashr", line, pos + 2, dest)) }
    // v0.90.4: Double-aware comparisons
    else if low_starts_with_at(line, pos, "<=") { llvm_gen_cmp_sb("sle", "ole", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, ">=") { llvm_gen_cmp_sb("sge", "oge", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "<") { llvm_gen_cmp_sb("slt", "olt", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, ">") { llvm_gen_cmp_sb("sgt", "ogt", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "==") { llvm_gen_cmp_with_strings_sb("eq", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "!=") { llvm_gen_cmp_with_strings_sb("ne", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "and") { same_mapping(llvm_gen_binop("and", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "or") { same_mapping(llvm_gen_binop("or", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "not") { same_mapping(llvm_gen_not(line, pos + 3, dest)) }
    // v0.90.4: Double-aware negation
    else if low_starts_with_at(line, pos, "neg") { llvm_gen_neg_sb(line, pos + 3, dest, str_sb) }
    // v0.60.231: PHI with string marker propagation
    else if low_starts_with_at(line, pos, "phi") { llvm_gen_phi_with_strings_sb(line, pos, dest, str_sb) }
    // v0.60.233: Call with dynamic string function tracking
    else if low_starts_with_at(line, pos, "call") { llvm_gen_call_with_string_tracking_sb(line, pos, dest, str_sb, string_fns) }
    // v0.88.10: Concurrency MIR instructions (assignment form)
    else if low_starts_with_at(line, pos, "mutex-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "thread-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "arc-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "atomic-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "channel-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "sender-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "rwlock-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "barrier-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "condvar-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "block-on") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "async-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "thread-pool-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "scope-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    // v0.90.2: GEP and pointer load for array indexing (string-aware path)
    // v0.90.9: Use SB-aware GEP/load/store for *f64 propagation
    else if low_starts_with_at(line, pos, "gep") { llvm_gen_gep_sb(line, pos + 3, dest, str_sb) }
    else if low_starts_with_at(line, pos, "load_ptr") { llvm_gen_load_ptr_sb(line, pos + 8, dest, str_sb) }
    else if low_starts_with_at(line, pos, "store_ptr") { llvm_gen_store_ptr_sb(line, pos + 9, str_sb) }
    else { same_mapping("  ; unknown: " + line) };

// v0.90.7: Struct-aware add handler
// When left operand is a struct pointer, emit struct-scaled GEP instead of raw add
fn llvm_gen_add_struct_aware(line: String, pos: i64, dest: String, mapping: String, str_sb: i64, struct_reg: String, ptr_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let right = trim_end(line.slice(p2, line.len()));
    // Check if left operand is a struct pointer
    let left_struct = get_struct_ptr_type(left, ptr_sb);
    if left_struct != "" {
        // Struct pointer arithmetic: emit GEP with struct type for proper scaling
        let struct_type = build_struct_gep_type(struct_reg, left_struct);
        let conv = "  " + left + "_p0 = inttoptr i64 " + left + " to ptr";
        let gep = "  " + dest + "_gep = getelementptr " + struct_type + ", ptr " + left + "_p0, i64 " + right;
        let to_int = "  " + dest + " = ptrtoint ptr " + dest + "_gep to i64";
        // Propagate struct pointer type to dest
        let _w = push_ptr_marker(ptr_sb, dest, left_struct);
        same_mapping(conv + "|" + gep + "|" + to_int)
    } else {
        // Regular integer add - delegate to existing handler
        llvm_gen_add_with_strings_sb(line, pos, dest, mapping, str_sb)
    };

// v0.90.7: Copy with struct pointer propagation
fn llvm_gen_copy_struct_aware(line: String, pos: i64, dest: String, mapping: String, str_sb: i64, ptr_sb: i64, registry: String) -> String =
    let src_start = low_skip_ws(line, pos + 4);
    let src = trim_end(line.slice(src_start, line.len()));
    // Propagate struct pointer type through copy
    let src_struct = get_struct_ptr_type(src, ptr_sb);
    let _w = if src_struct != "" { push_ptr_marker(ptr_sb, dest, src_struct) } else { 0 };
    // Delegate to existing copy handler in the struct-aware path
    // Re-dispatch through the main RHS handler for proper string/double tracking
    llvm_gen_rhs_with_strings_map_and_fns_reg(line, pos, dest, "", "", mapping, str_sb, registry);

// v0.90.7: Call with struct pointer return type tracking
fn llvm_gen_call_struct_aware(line: String, pos: i64, dest: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, ptr_sb: i64) -> String =
    // First delegate to existing call handler for proper codegen
    let result = llvm_gen_rhs_with_strings_map_and_fns_reg(line, pos, dest, strings, string_fns, mapping, str_sb, registry);
    // Check if the called function returns a struct pointer
    // Extract function name from MIR: "call @fn_name(...)"
    let call_start = low_skip_ws(line, pos + 4);
    let fn_name_end = find_fn_name_end(line, call_start);
    let fn_name = line.slice(call_start, fn_name_end);
    // Look up the function's return type in MIR (from the MIR function headers)
    // For now, use the ptr_sb to check if any param or call result has been marked
    // The function name should have been registered with its ptr return type
    let fn_ret_struct = get_fn_ptr_return_type(fn_name, ptr_sb);
    let _w = if fn_ret_struct != "" { push_ptr_marker(ptr_sb, dest, fn_ret_struct) } else { 0 };
    result;

// v0.90.7: Find end of function name in call expression
fn find_fn_name_end(line: String, pos: i64) -> i64 =
    if pos >= line.len() { pos }
    else if line.byte_at(pos) == 40 { pos }  // '('
    else { find_fn_name_end(line, pos + 1) };

// v0.90.7: Get struct pointer return type for a function
// This looks in ptr_sb for "F:@fn_name:StructName," entries
fn get_fn_ptr_return_type(fn_name: String, ptr_sb: i64) -> String =
    let content = sb_build(ptr_sb);
    get_fn_ptr_return_from(fn_name, content, 0);

fn get_fn_ptr_return_from(fn_name: String, content: String, pos: i64) -> String =
    if pos >= content.len() { "" } else {
        let comma_pos = find_comma_or_end(content, pos);
        let entry = content.slice(pos, comma_pos);
        // Entry format: "F:@fn_name:StructName"
        if entry.len() >= 4 and entry.byte_at(0) == 70 and entry.byte_at(1) == 58 {
            let after_f = 2;
            let second_colon = find_char_from(entry, after_f, 58);
            if second_colon < entry.len() {
                let entry_fn = entry.slice(after_f, second_colon);
                let entry_struct = entry.slice(second_colon + 1, entry.len());
                if entry_fn == fn_name { entry_struct }
                else if comma_pos >= content.len() { "" }
                else { get_fn_ptr_return_from(fn_name, content, comma_pos + 1) }
            }
            else if comma_pos >= content.len() { "" }
            else { get_fn_ptr_return_from(fn_name, content, comma_pos + 1) }
        }
        else if comma_pos >= content.len() { "" }
        else { get_fn_ptr_return_from(fn_name, content, comma_pos + 1) }
    };

// v0.90.5: Field access handler for LLVM codegen
// MIR: %dest = field-access %base.fieldname
// LLVM: %dest_ptr = getelementptr i64, ptr %base, i32 field_index
//       %dest = load i64, ptr %dest_ptr
fn llvm_gen_field_access(line: String, pos: i64, dest: String, struct_reg: String, str_sb: i64, ptr_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    // Find dot separator in %base.field
    let dot_pos = find_char(line, p1, 46);
    let base = trim_end(line.slice(p1, dot_pos));
    let field = trim_end(line.slice(dot_pos + 1, line.len()));
    // v0.90.11: Check if field is a numeric index (tuple access .0, .1, etc.)
    let field_idx = if field.len() > 0 and is_digit(field.byte_at(0)) { parse_int_simple(field, 0, 0) } else { lookup_field_by_name(struct_reg, field) };
    // v0.90.6: Check if field type is f64
    let field_is_dbl = is_field_f64(struct_reg, field);
    let load_type = if field_is_dbl == 1 { "double" } else { "i64" };
    // Mark result as double if f64 field
    let _dm = if field_is_dbl == 1 { push_double_marker(str_sb, dest) } else { 0 };
    // v0.90.7: Check if field is a pointer-to-struct and track it
    let field_ptr = get_field_ptr_from_registry(struct_reg, field);
    let _pm = if field_ptr != "" { push_ptr_marker(ptr_sb, dest, field_ptr) } else { 0 };
    let ptr_name = dest + "_ptr";
    let conv = "  " + base + "_p = inttoptr i64 " + base + " to ptr";
    let gep_line = "  " + ptr_name + " = getelementptr i64, ptr " + base + "_p, i32 " + i2s(field_idx);
    let load_line = "  " + dest + " = load " + load_type + ", ptr " + ptr_name;
    same_mapping(conv + "|" + gep_line + "|" + load_line);

// v0.90.5: Look up field index by just the field name (search all structs)
fn lookup_field_by_name(registry: String, field_name: String) -> i64 =
    lookup_field_by_name_at(registry, 0, field_name);

fn lookup_field_by_name_at(registry: String, pos: i64, field_name: String) -> i64 =
    if pos >= registry.len() { 0 } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let fields = entry.slice(colon_pos + 1, entry.len());
        let idx = find_field_index_or_neg(fields, 0, 0, field_name);
        if idx >= 0 { idx }
        else if semi_pos + 1 >= registry.len() { 0 }
        else { lookup_field_by_name_at(registry, semi_pos + 1, field_name) }
    };

fn find_field_index_or_neg(fields: String, pos: i64, idx: i64, target: String) -> i64 =
    if pos >= fields.len() { 0 - 1 } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        // Strip ~d suffix for comparison
        let name = strip_type_suffix(raw_name);
        if name == target { idx }
        else if comma_pos >= fields.len() { 0 - 1 }
        else { find_field_index_or_neg(fields, comma_pos + 1, idx + 1, target) }
    };

// Strip ~d type suffix from field name
fn strip_type_suffix(name: String) -> String =
    let tilde_pos = find_char(name, 0, 126);
    if tilde_pos < name.len() { name.slice(0, tilde_pos) } else { name };

// Check if a field is f64 by looking up in registry
fn is_field_f64(registry: String, field_name: String) -> i64 =
    is_field_f64_at(registry, 0, field_name);

fn is_field_f64_at(registry: String, pos: i64, field_name: String) -> i64 =
    if pos >= registry.len() { 0 } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let fields = entry.slice(colon_pos + 1, entry.len());
        let result = check_field_is_f64(fields, 0, field_name);
        if result >= 0 { result }
        else if semi_pos + 1 >= registry.len() { 0 }
        else { is_field_f64_at(registry, semi_pos + 1, field_name) }
    };

// Search fields for name and check if it has ~d suffix. Returns 1 if f64, 0 if found not f64, -1 if not found
fn check_field_is_f64(fields: String, pos: i64, target: String) -> i64 =
    if pos >= fields.len() { 0 - 1 } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        let name = strip_type_suffix(raw_name);
        if name == target {
            // v0.90.7: Specifically check for ~d suffix (not ~p-... or other)
            let suffix = if raw_name.len() > name.len() { raw_name.slice(name.len(), raw_name.len()) } else { "" };
            if suffix == "~d" { 1 } else { 0 }
        }
        else if comma_pos >= fields.len() { 0 - 1 }
        else { check_field_is_f64(fields, comma_pos + 1, target) }
    };

// v0.90.7: Look up field pointer type from registry. Returns struct name or ""
fn get_field_ptr_from_registry(registry: String, field_name: String) -> String =
    get_field_ptr_from_registry_at(registry, 0, field_name);

fn get_field_ptr_from_registry_at(registry: String, pos: i64, field_name: String) -> String =
    if pos >= registry.len() { "" } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let fields = entry.slice(colon_pos + 1, entry.len());
        let result = check_field_ptr_type(fields, 0, field_name);
        if result != "" { result }
        else if semi_pos + 1 >= registry.len() { "" }
        else { get_field_ptr_from_registry_at(registry, semi_pos + 1, field_name) }
    };

// Search fields for name and extract ~p-StructName. Returns struct name or ""
fn check_field_ptr_type(fields: String, pos: i64, target: String) -> String =
    if pos >= fields.len() { "" } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        let name = strip_type_suffix(raw_name);
        if name == target {
            let suffix = if raw_name.len() > name.len() { raw_name.slice(name.len(), raw_name.len()) } else { "" };
            // Check for ~p- prefix (at least 4 chars: ~p-X)
            if suffix.len() >= 4 and suffix.byte_at(0) == 126 and suffix.byte_at(1) == 112 and suffix.byte_at(2) == 45 {
                suffix.slice(3, suffix.len())
            } else { "" }
        }
        else if comma_pos >= fields.len() { "" }
        else { check_field_ptr_type(fields, comma_pos + 1, target) }
    };

// v0.90.5: Field store handler for LLVM codegen
// MIR: field-store %base.fieldname, %value
// LLVM: %_fst_N_p = inttoptr i64 %base to ptr
//       %_fst_N_ptr = getelementptr i64, ptr %_fst_N_p, i32 field_index
//       store i64 %value, ptr %_fst_N_ptr
fn llvm_gen_field_store(line: String, pos: i64, struct_reg: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    // Find dot separator in %base.field
    let dot_pos = find_char(line, p1, 46);
    let base = trim_end(line.slice(p1, dot_pos));
    // Find comma separator between base.field and value
    let comma_pos = find_comma(line, dot_pos);
    let field = trim_end(line.slice(dot_pos + 1, comma_pos));
    let p2 = low_skip_ws(line, comma_pos + 1);
    let value = trim_end(line.slice(p2, line.len()));
    // Look up field index
    let field_idx = lookup_field_by_name(struct_reg, field);
    let prefix = base + "_fs";
    let conv = "  " + prefix + "_p = inttoptr i64 " + base + " to ptr";
    let gep_line = "  " + prefix + "_ptr = getelementptr i64, ptr " + prefix + "_p, i32 " + i2s(field_idx);
    // v0.90.6: Check if value is f64 using double marker OR field type registry
    let is_dbl_val = is_double_var_sb(value, str_sb);
    let is_dbl_field = is_field_f64(struct_reg, field);
    let is_dbl = if is_dbl_val { 1 } else { is_dbl_field };
    let store_type = if is_dbl == 1 { "double" } else { "i64" };
    let store_line = "  store " + store_type + " " + value + ", ptr " + prefix + "_ptr";
    same_mapping(conv + "|" + gep_line + "|" + store_line);

// Add a string marker to the mapping: "S:varname" (prepend for O(1) recent lookup)
fn add_string_marker(mapping: String, varname: String) -> String =
    if mapping == "" { "S:" + varname }
    else { "S:" + varname + "," + mapping };

// v0.88.6: Push string marker to SB (zero mapping copy)
fn push_string_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "S:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

// v0.88.6: Check if variable is marked as string in SB (zero arena allocation)
fn is_string_var_sb(varname: String, str_sb: i64) -> bool =
    let marker = "S:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

// v0.90.3: Push double parameter marker to SB
fn push_double_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "D:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

// v0.90.3: Check if variable is marked as double in SB
fn is_double_var_sb(varname: String, str_sb: i64) -> bool =
    let marker = "D:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

// v0.90.9: Check if variable is a *f64 pointer in SB
fn is_f64_ptr_sb(varname: String, str_sb: i64) -> bool =
    let marker = "F:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

// v0.90.9: Mark variable as *f64 pointer in SB
fn push_f64_ptr_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "F:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

// v0.90.9: Handle mark_f64_ptr MIR instruction - register var as *f64 in str_sb
// "mark_f64_ptr" = 12 chars, then space, then %varname starts at p+13
fn llvm_handle_mark_f64_ptr(line: String, p: i64, str_sb: i64) -> String =
    let varname = trim_end(line.slice(p + 13, line.len()));
    let w = push_f64_ptr_marker(str_sb, varname);
    same_mapping("");

// v0.88.6: SB-based comparison (== / !=)
fn llvm_gen_cmp_with_strings_sb(pred: String, line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_cmp_with_strings_sb_2(pred, line, pos, dest, str_sb, left, comma);

fn llvm_gen_cmp_with_strings_sb_2(pred: String, line: String, pos: i64, dest: String, str_sb: i64, left: String, comma: i64) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_cmp_with_strings_sb_3(pred, line, pos, dest, str_sb, left_trimmed, right_trimmed);

fn llvm_gen_cmp_with_strings_sb_3(pred: String, line: String, pos: i64, dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_sb(left_trimmed, str_sb);
    let right_is_string = is_string_var_sb(right_trimmed, str_sb);
    if left_is_string or right_is_string {
        // Reuse existing string cmp (mapping param unused for string cmp result - it returns same_mapping)
        llvm_gen_string_cmp(pred, left_trimmed, right_trimmed, dest, "")
    } else {
        // v0.90.4: Check for double operands
        let left_is_double = is_double_var_sb(left_trimmed, str_sb);
        let right_is_double = is_double_var_sb(right_trimmed, str_sb);
        if left_is_double or right_is_double {
            let float_pred = if pred == "eq" { "oeq" } else { "one" };
            same_mapping("  " + dest + "_cmp = fcmp " + float_pred + " double " + left_trimmed + ", " + right_trimmed + "|  " + dest + " = zext i1 " + dest + "_cmp to i64")
        } else {
            same_mapping(llvm_gen_cmp(pred, line, pos, dest))
        }
    };

// v0.88.6: SB-based add (string concat detection)
fn llvm_gen_add_with_strings_sb(line: String, pos: i64, dest: String, mapping: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_add_with_strings_sb_2(line, pos, dest, mapping, str_sb, p1, comma, left);

fn llvm_gen_add_with_strings_sb_2(line: String, pos: i64, dest: String, mapping: String, str_sb: i64, p1: i64, comma: i64, left: String) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_add_with_strings_sb_3(dest, mapping, str_sb, left_trimmed, right_trimmed);

fn llvm_gen_add_with_strings_sb_3(dest: String, mapping: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_sb(left_trimmed, str_sb);
    let right_is_string = is_string_var_sb(right_trimmed, str_sb);
    if left_is_string or right_is_string {
        llvm_gen_add_string_concat_sb(dest, str_sb, left_trimmed, right_trimmed)
    } else {
        // v0.90.4: Check for double operands
        let left_is_double = is_double_var_sb(left_trimmed, str_sb);
        let right_is_double = is_double_var_sb(right_trimmed, str_sb);
        if left_is_double or right_is_double {
            let w = push_double_marker(str_sb, dest);
            same_mapping("  " + dest + " = fadd double " + left_trimmed + ", " + right_trimmed)
        } else {
            same_mapping("  " + dest + " = add nsw i64 " + left_trimmed + ", " + right_trimmed)
        }
    };

fn llvm_gen_add_string_concat_sb(dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let lptr = dest + "_l";
    let rptr = dest + "_r";
    let cptr = dest + "_c";
    llvm_gen_add_string_concat_sb_2(dest, str_sb, left_trimmed, right_trimmed, lptr, rptr, cptr);

fn llvm_gen_add_string_concat_sb_2(dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String, lptr: String, rptr: String, cptr: String) -> String =
    let line1 = "  " + lptr + " = inttoptr i64 " + left_trimmed + " to ptr";
    let line2 = "  " + rptr + " = inttoptr i64 " + right_trimmed + " to ptr";
    let line3 = "  " + cptr + " = call ptr @bmb_string_concat(ptr " + lptr + ", ptr " + rptr + ")";
    let line4 = "  " + dest + " = ptrtoint ptr " + cptr + " to i64";
    let w = push_string_marker(str_sb, dest);
    same_mapping(line1 + "|" + line2 + "|" + line3 + "|" + line4);

// v0.90.4: Double-aware binop (sub, mul, sdiv)
// Checks if operands are double-marked; if so, emits float op instead
fn llvm_gen_binop_sb(int_op: String, float_op: String, line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let right = trim_end(line.slice(p2, line.len()));
    let left_is_double = is_double_var_sb(left, str_sb);
    let right_is_double = is_double_var_sb(right, str_sb);
    if left_is_double or right_is_double {
        let w = push_double_marker(str_sb, dest);
        same_mapping("  " + dest + " = " + float_op + " double " + left + ", " + right)
    } else {
        let op_with_nsw = if int_op == "add" { "add nsw" } else if int_op == "sub" { "sub nsw" } else if int_op == "mul" { "mul nsw" } else { int_op };
        same_mapping("  " + dest + " = " + op_with_nsw + " i64 " + left + ", " + right)
    };

// v0.90.4: Double-aware comparison
// Checks if operands are double-marked; if so, emits fcmp instead of icmp
fn llvm_gen_cmp_sb(int_pred: String, float_pred: String, line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let right = trim_end(line.slice(p2, line.len()));
    let left_is_double = is_double_var_sb(left, str_sb);
    let right_is_double = is_double_var_sb(right, str_sb);
    if left_is_double or right_is_double {
        same_mapping("  " + dest + "_cmp = fcmp " + float_pred + " double " + left + ", " + right + "|  " + dest + " = zext i1 " + dest + "_cmp to i64")
    } else {
        same_mapping("  " + dest + "_cmp = icmp " + int_pred + " i64 " + left + ", " + right + "|  " + dest + " = zext i1 " + dest + "_cmp to i64")
    };

// v0.90.4: Double-aware negation
fn llvm_gen_neg_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p = low_skip_ws(line, pos);
    let operand = trim_end(line.slice(p, line.len()));
    let is_double = is_double_var_sb(operand, str_sb);
    if is_double {
        let w = push_double_marker(str_sb, dest);
        same_mapping("  " + dest + " = fneg double " + operand)
    } else {
        same_mapping("  " + dest + " = sub nsw i64 0, " + operand)
    };

// v0.88.6: SB-based PHI with string/double marker
fn llvm_gen_phi_with_strings_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let first_val = extract_phi_val(first_content);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    let second_val = extract_phi_val(second_content);
    let first_is_string = is_string_var_sb(first_val, str_sb);
    let second_is_string = is_string_var_sb(second_val, str_sb);
    // v0.90.4: Also propagate double markers through phi
    let first_is_double = is_double_var_sb(first_val, str_sb);
    let second_is_double = is_double_var_sb(second_val, str_sb);
    let w = if first_is_string or second_is_string { push_string_marker(str_sb, dest) }
            else if first_is_double or second_is_double { push_double_marker(str_sb, dest) }
            else { 0 };
    // v0.90.4: Use double phi type when operands are double
    if first_is_double or second_is_double {
        same_mapping(llvm_gen_phi_typed(line, pos, dest, "f64"))
    } else {
        same_mapping(llvm_gen_phi(line, pos, dest))
    };

// v0.88.6: SB-based call tracking
fn llvm_gen_call_with_string_tracking_sb(line: String, pos: i64, dest: String, str_sb: i64, string_fns: String) -> String =
    let llvm_code = llvm_gen_call(line, pos, dest);
    let fn_name = extract_call_fn_name(line, pos);
    let is_hardcoded_string_fn = is_string_returning_fn(fn_name);
    let is_dynamic_string_fn_result = is_dynamic_string_fn(fn_name, string_fns);
    let is_string_fn = is_hardcoded_string_fn or is_dynamic_string_fn_result;
    // v0.90.4: Track built-in f64-returning functions
    let is_double_fn = fn_name == "sqrt";
    let w = if is_string_fn { push_string_marker(str_sb, dest) }
            else if is_double_fn { push_double_marker(str_sb, dest) }
            else { 0 };
    same_mapping(llvm_code);

// v0.90.2: Registry-aware version for proper f64 call types
fn llvm_gen_call_with_string_tracking_sb_reg(line: String, pos: i64, dest: String, str_sb: i64, string_fns: String, registry: String) -> String =
    let llvm_code = llvm_gen_call_reg(line, pos, dest, registry);
    let fn_name = extract_call_fn_name(line, pos);
    let is_hardcoded_string_fn = is_string_returning_fn(fn_name);
    let is_dynamic_string_fn_result = is_dynamic_string_fn(fn_name, string_fns);
    let is_string_fn = is_hardcoded_string_fn or is_dynamic_string_fn_result;
    // v0.90.4: Also track f64-returning functions via registry
    let ret_type = lookup_fn_ret(registry, fn_name);
    let is_double_fn = ret_type == "double" or is_builtin_double_fn(fn_name);
    let w = if is_string_fn { push_string_marker(str_sb, dest) }
            else if is_double_fn { push_double_marker(str_sb, dest) }
            else { 0 };
    same_mapping(llvm_code);

// v0.90.6: Built-in runtime functions that return double
// v0.90.9: Added i64_to_f64 (sitofp intrinsic)
fn is_builtin_double_fn(name: String) -> bool =
    name == "sqrt" or name == "i64_to_f64";

// Check if a variable is marked as a string in the mapping
fn is_string_var(varname: String, mapping: String) -> bool =
    let marker = "S:" + varname;
    string_in_mapping(mapping, marker);

// Check if a marker string exists in the mapping
fn string_in_mapping(mapping: String, marker: String) -> bool =
    if mapping == "" { false }
    else { find_string_in_list(mapping, marker, 0) >= 0 };

// Find a string in a comma-separated list (iterative to avoid stack overflow)
fn find_string_in_list(list: String, target: String, pos: i64) -> i64 =
    find_string_in_list_iter(list, target, pos);

fn find_string_in_list_iter(list: String, target: String, pos: i64) -> i64 =
    if pos >= list.len() { 0 - 1 }
    else {
        let comma = find_comma_or_end(list, pos);
        // v0.88.6: Length check before slice to avoid allocation on mismatch
        if comma - pos == target.len() and list.slice(pos, comma) == target { pos }
        else if comma >= list.len() { 0 - 1 }
        // Use tail position to help with TCO
        else { find_string_in_list_iter(list, target, comma + 1) }
    };

// v0.60.238: Split to reduce let-chain depth
fn llvm_gen_cmp_with_strings(pred: String, line: String, pos: i64, dest: String, mapping: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_cmp_with_strings_2(pred, line, pos, dest, mapping, left, comma);

fn llvm_gen_cmp_with_strings_2(pred: String, line: String, pos: i64, dest: String, mapping: String, left: String, comma: i64) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_cmp_with_strings_3(pred, line, pos, dest, mapping, left_trimmed, right_trimmed);

fn llvm_gen_cmp_with_strings_3(pred: String, line: String, pos: i64, dest: String, mapping: String, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_fast(left_trimmed, mapping);
    let right_is_string = is_string_var_fast(right_trimmed, mapping);
    if left_is_string or right_is_string {
        llvm_gen_string_cmp(pred, left_trimmed, right_trimmed, dest, mapping)
    } else {
        same_mapping(llvm_gen_cmp(pred, line, pos, dest))
    };

// Fast string variable check - only looks at first few entries to avoid deep recursion
fn is_string_var_fast(varname: String, mapping: String) -> bool =
    let marker = "S:" + varname;
    if mapping == "" { false }
    else { has_prefix_or_contains_marker(mapping, marker) };

// v0.90.3: Check if variable is an f64 parameter
fn is_double_var(varname: String, mapping: String) -> bool =
    let marker = "D:" + varname;
    if mapping == "" { false }
    else { has_prefix_or_contains_marker(mapping, marker) };

// v0.88.6: Search from START since new entries are prepended
fn has_prefix_or_contains_marker(mapping: String, marker: String) -> bool =
    if mapping.len() < marker.len() { false }
    // Check if first entry matches (most common case for recent markers)
    else if starts_with_marker(mapping, marker) { true }
    // Search forward from start for first 100 entries
    else { find_marker_from_start(mapping, marker, 0, 0) };

// v0.88.6: Check if mapping starts with marker, or marker,
fn starts_with_marker(mapping: String, marker: String) -> bool =
    let mlen = mapping.len();
    let klen = marker.len();
    if mlen == klen { mapping == marker }
    else if mlen > klen {
        // Check if starts with marker,
        mapping.byte_at(klen) == 44 and mapping.slice(0, klen) == marker
    }
    else { false };

// v0.88.6: Search forward from start - check first 100 entries
fn find_marker_from_start(mapping: String, marker: String, pos: i64, count: i64) -> bool =
    if count > 100 or pos >= mapping.len() { false }
    else {
        let comma = find_comma_or_end(mapping, pos);
        if comma - pos == marker.len() and mapping.slice(pos, comma) == marker { true }
        else if comma >= mapping.len() { false }
        else { find_marker_from_start(mapping, marker, comma + 1, count + 1) }
    };

// v0.60.238: Simplified to avoid deep parameter nesting
fn llvm_gen_string_cmp(pred: String, left: String, right: String, dest: String, mapping: String) -> String =
    let lptr = dest + "_lp";
    let rptr = dest + "_rp";
    let eq_dest = dest + "_streq";
    let conv_l = "  " + lptr + " = inttoptr i64 " + left + " to ptr";
    llvm_gen_string_cmp_2(pred, right, dest, mapping, lptr, rptr, eq_dest, conv_l);

fn llvm_gen_string_cmp_2(pred: String, right: String, dest: String, mapping: String, lptr: String, rptr: String, eq_dest: String, conv_l: String) -> String =
    let conv_r = "  " + rptr + " = inttoptr i64 " + right + " to ptr";
    let call_ln = "  " + eq_dest + " = call i64 @bmb_string_eq(ptr " + lptr + ", ptr " + rptr + ")";
    let cmp_ln = "  " + dest + "_cmp = icmp ne i64 " + eq_dest + ", 0";
    llvm_gen_string_cmp_3(pred, dest, mapping, conv_l, conv_r, call_ln, cmp_ln);

fn llvm_gen_string_cmp_3(pred: String, dest: String, mapping: String, conv_l: String, conv_r: String, call_ln: String, cmp_ln: String) -> String =
    let res_ln = "  " + dest + " = zext i1 " + dest + "_cmp to i64";
    if pred == "ne" {
        let inv_cmp = "  " + dest + "_cmp = icmp eq i64 " + dest + "_streq, 0";
        same_mapping(conv_l + "|" + conv_r + "|" + call_ln + "|" + inv_cmp + "|" + res_ln)
    } else {
        same_mapping(conv_l + "|" + conv_r + "|" + call_ln + "|" + cmp_ln + "|" + res_ln)
    };

// Track string-returning function calls

// v0.60.238: Split to reduce let-chain depth
fn llvm_gen_add_with_strings(line: String, pos: i64, dest: String, mapping: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_add_with_strings_2(line, pos, dest, mapping, p1, comma, left);

fn llvm_gen_add_with_strings_2(line: String, pos: i64, dest: String, mapping: String, p1: i64, comma: i64, left: String) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_add_with_strings_3(dest, mapping, left_trimmed, right_trimmed);

fn llvm_gen_add_with_strings_3(dest: String, mapping: String, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_fast(left_trimmed, mapping);
    let right_is_string = is_string_var_fast(right_trimmed, mapping);
    if left_is_string or right_is_string {
        llvm_gen_add_string_concat(dest, mapping, left_trimmed, right_trimmed)
    } else {
        same_mapping("  " + dest + " = add nsw i64 " + left_trimmed + ", " + right_trimmed)
    };

fn llvm_gen_add_string_concat(dest: String, mapping: String, left_trimmed: String, right_trimmed: String) -> String =
    let lptr = dest + "_l";
    let rptr = dest + "_r";
    let cptr = dest + "_c";
    llvm_gen_add_string_concat_2(dest, mapping, left_trimmed, right_trimmed, lptr, rptr, cptr);

fn llvm_gen_add_string_concat_2(dest: String, mapping: String, left_trimmed: String, right_trimmed: String, lptr: String, rptr: String, cptr: String) -> String =
    let line1 = "  " + lptr + " = inttoptr i64 " + left_trimmed + " to ptr";
    let line2 = "  " + rptr + " = inttoptr i64 " + right_trimmed + " to ptr";
    let line3 = "  " + cptr + " = call ptr @bmb_string_concat(ptr " + lptr + ", ptr " + rptr + ")";
    let line4 = "  " + dest + " = ptrtoint ptr " + cptr + " to i64";
    changed_mapping(add_string_marker(mapping, dest), line1 + "|" + line2 + "|" + line3 + "|" + line4);

fn llvm_gen_call_with_string_tracking(line: String, pos: i64, dest: String, mapping: String) -> String =
    llvm_gen_call_with_string_tracking_and_fns(line, pos, dest, mapping, "");

// v0.60.233: Call tracking with dynamic string functions
fn llvm_gen_call_with_string_tracking_and_fns(line: String, pos: i64, dest: String, mapping: String, string_fns: String) -> String =
    let llvm_code = llvm_gen_call(line, pos, dest);
    // Check if the called function returns a string
    let fn_name = extract_call_fn_name(line, pos);
    // Check both hardcoded list and dynamic functions
    let is_hardcoded_string_fn = is_string_returning_fn(fn_name);
    let is_dynamic_string_fn_result = is_dynamic_string_fn(fn_name, string_fns);
    let is_string_fn = is_hardcoded_string_fn or is_dynamic_string_fn_result;
    if is_string_fn {
        changed_mapping(add_string_marker(mapping, dest), llvm_code)
    } else {
        same_mapping(llvm_code)
    };

// Check if a function returns a string
// v0.60.230: Split into helper functions to reduce stack depth during compilation
fn is_string_returning_fn(name: String) -> bool =
    is_string_fn_group1(name) or is_string_fn_group2(name) or is_string_fn_group3(name) or
    is_string_fn_group4(name) or is_string_fn_group5(name);

fn is_string_fn_group1(name: String) -> bool =
    name == "get_node_type" or name == "get_child" or name == "extract_name" or
    name == "bmb_string_slice" or name == "bmb_string_concat" or
    name == "bmb_string_from_cstr" or name == "bmb_chr" or name == "bmb_read_file" or
    name == "bmb_getenv" or name == "get_arg" or name == "int_to_string" or
    name == "chr" or name == "slice" or name == "concat";

fn is_string_fn_group2(name: String) -> bool =
    name == "sb_build" or name == "digit_char" or name == "escape_parens" or
    name == "unescape_parens_from_ast" or name == "extract_string_content" or
    name == "get_fn_return_type" or name == "collect_params" or name == "get_fn_body" or
    name == "lower_function_sb" or name == "lower_program_sb" or
    name == "compile_function" or name == "compile_source";

fn is_string_fn_group3(name: String) -> bool =
    name == "parse_source" or name == "gen_function" or name == "gen_program" or
    name == "tokenize" or name == "read_file" or name == "make_error" or
    name == "gen_module_header" or name == "gen_runtime_decls" or
    name == "gen_string_globals" or name == "gen_program_sb_with_strings" or
    name == "collect_strings_from_mir" or name == "compile_program";

fn is_string_fn_group4(name: String) -> bool =
    name == "gen_extern_println" or name == "gen_extern_print_str" or
    name == "llvm_gen_binop" or name == "llvm_gen_cmp" or name == "llvm_gen_call" or
    name == "llvm_gen_not" or name == "llvm_gen_neg" or name == "llvm_gen_phi" or
    name == "llvm_gen_branch" or name == "llvm_gen_goto" or name == "llvm_gen_return_typed" or
    name == "llvm_gen_string_ref" or name == "llvm_gen_line_with_ret";

fn is_string_fn_group5(name: String) -> bool =
    name == "llvm_gen_assign_typed" or name == "llvm_gen_rhs_typed" or
    name == "gen_function_lines_typed" or name == "gen_function_sb_typed" or
    name == "llvm_gen_fn_line_typed" or name == "llvm_gen_fn_header" or
    name == "gen_all_externs" or name == "pack_result" or name == "unpack_ast" or
    name == "make_step" or name == "make_work" or name == "make_work3" or name == "make_work4" or
    name == "step_work" or name == "get_field" or name == "trim_end" or name == "i2s" or
    name == "sb_build" or name == "pack_lower_result" or name == "unescape_parens";

// Extract function name from call instruction
fn extract_call_fn_name(line: String, pos: i64) -> String =
    let after_call = low_skip_ws(line, pos + 4);
    let at_pos = if line.byte_at(after_call) == 64 { after_call + 1 } else { after_call };
    let paren_pos = find_char(line, at_pos, 40);
    if paren_pos > at_pos { line.slice(at_pos, paren_pos) } else { "" };

// Check if a variable name is a user variable (not %_t)
// v0.92: Fixed to handle short names like %i (len=2) - they ARE user vars
fn is_user_variable(name: String) -> bool =
    if name.len() < 2 { false }
    else if name.len() == 2 { true }
    else {
        let after_pct = name.byte_at(1);
        // User vars don't start with _t after the %
        not (after_pct == 95 and name.byte_at(2) == 116)
    };

// Resolve a variable using the mapping
fn resolve_variable(varname: String, mapping: String) -> String =
    if not is_user_variable(varname) { varname }
    else { lookup_mapping(mapping, varname, varname) };

// Look up a variable in the mapping, return default if not found
fn lookup_mapping(mapping: String, name: String, default_val: String) -> String =
    if mapping == "" { default_val }
    else { lookup_mapping_at(mapping, name, 0, default_val) };

// v0.88.6: First-match lookup (prepend order = newest first), index-based to reduce allocations
fn lookup_mapping_at(mapping: String, name: String, pos: i64, default_val: String) -> String =
    if pos >= mapping.len() { default_val }
    else {
        let comma = find_comma_or_end(mapping, pos);
        let colon = find_char(mapping, pos, 58);
        // Compare name directly: mapping[pos..colon] == name?
        if colon - pos == name.len() and mapping.slice(pos, colon) == name {
            // First match = most recent (prepend order), return immediately
            mapping.slice(colon + 1, comma)
        } else if comma >= mapping.len() { default_val }
        else { lookup_mapping_at(mapping, name, comma + 1, default_val) }
    };

// Add a name:value pair to the mapping (prepend for O(1) recent lookup)
fn add_mapping(mapping: String, name: String, value: String) -> String =
    let entry = name + ":" + value;
    if mapping == "" { entry } else { entry + "," + mapping };

// Extract mapping from "mapping@@@llvm_line"
fn extract_mapping(result: String) -> String =
    let sep = find_triple_at(result, 0);
    result.slice(0, sep);

// Extract llvm_line from "mapping@@@llvm_line"
fn extract_llvm_line(result: String) -> String =
    let sep = find_triple_at(result, 0);
    result.slice(sep + 3, result.len());

// Find "@@@" separator
fn find_triple_at(s: String, pos: i64) -> i64 =
    if pos + 2 >= s.len() { s.len() }
    else if s.byte_at(pos) == 64 and s.byte_at(pos + 1) == 64 and s.byte_at(pos + 2) == 64 { pos }
    else { find_triple_at(s, pos + 1) };

// v0.88.5: Two-part return protocol for memory optimization
// No prefix: mapping unchanged, reuse caller's mapping (result IS the llvm_line)
// Tag "!" (byte 33): mapping changed, length-prefixed new mapping
fn same_mapping(llvm_line: String) -> String = llvm_line;
fn same_mapping_empty() -> String = "";
fn changed_mapping(new_mapping: String, llvm_line: String) -> String =
    "!" + int_to_string(new_mapping.len()) + ":" + new_mapping + llvm_line;
fn changed_mapping_empty(new_mapping: String) -> String =
    "!" + int_to_string(new_mapping.len()) + ":" + new_mapping;

fn extract_new_mapping(result: String) -> String =
    let colon_pos = find_char(result, 1, 58);
    let map_len = parse_len_at(result, 1, colon_pos);
    result.slice(colon_pos + 1, colon_pos + 1 + map_len);

fn extract_new_llvm_line(result: String) -> String =
    let colon_pos = find_char(result, 1, 58);
    let map_len = parse_len_at(result, 1, colon_pos);
    result.slice(colon_pos + 1 + map_len, result.len());

fn parse_len_at(s: String, start: i64, end_pos: i64) -> i64 =
    parse_len_acc(s, start, end_pos, 0);

fn parse_len_acc(s: String, pos: i64, end_pos: i64, acc: i64) -> i64 =
    if pos >= end_pos { acc }
    else { parse_len_acc(s, pos + 1, end_pos, acc * 10 + s.byte_at(pos) - 48) };

// v0.88.10: Concurrency MIR instruction helpers
// Extract single operand from "opcode %operand" format
// pos points to start of operand (after opcode + whitespace)
fn conc_extract_single_op(line: String, pos: i64) -> String =
    trim_end(line.slice(pos, line.len()));

// Extract two space-separated operands: "%op1 %op2"
fn conc_extract_two_ops_first(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    line.slice(pos, sp);

fn conc_extract_two_ops_second(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp + 1);
    trim_end(line.slice(p2, line.len()));

// Extract three space-separated operands: "%op1 %op2 %op3"
fn conc_extract_three_first(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    line.slice(pos, sp);

fn conc_extract_three_second(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    line.slice(p2, sp2);

fn conc_extract_three_third(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    let p3 = low_skip_ws(line, sp2 + 1);
    trim_end(line.slice(p3, line.len()));

// Extract four space-separated operands
fn conc_extract_four_first(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    line.slice(pos, sp);

fn conc_extract_four_second(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    line.slice(p2, sp2);

fn conc_extract_four_third(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    let p3 = low_skip_ws(line, sp2 + 1);
    let sp3 = find_char(line, p3, 32);
    line.slice(p3, sp3);

fn conc_extract_four_fourth(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    let p3 = low_skip_ws(line, sp2 + 1);
    let sp3 = find_char(line, p3, 32);
    let p4 = low_skip_ws(line, sp3 + 1);
    trim_end(line.slice(p4, line.len()));

// Generate simple i64 call: %dest = call i64 @fn_name(i64 %op)
fn conc_gen_call_i64_1(dest: String, fn_name: String, op: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op + ")";

// Generate i64 call with 2 args
fn conc_gen_call_i64_2(dest: String, fn_name: String, op1: String, op2: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ")";

// Generate i64 call with 3 args
fn conc_gen_call_i64_3(dest: String, fn_name: String, op1: String, op2: String, op3: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ", i64 " + op3 + ")";

// Generate void call with 1 arg
fn conc_gen_call_void_1(fn_name: String, op: String) -> String =
    "  call void @" + fn_name + "(i64 " + op + ")";

// Generate void call with 2 args
fn conc_gen_call_void_2(fn_name: String, op1: String, op2: String) -> String =
    "  call void @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ")";

// Generate i64 call with 0 args
fn conc_gen_call_i64_0(dest: String, fn_name: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "()";

// v0.88.10: Concurrency RHS handler - dispatches concurrency MIR instructions in assignment form
// Input: line is full MIR line, pos points to start of RHS (after "= "), dest is "%varname"
fn llvm_gen_conc_rhs(line: String, pos: i64, dest: String) -> String =
    // Thread operations
    if low_starts_with_at(line, pos, "thread-spawn") {
        // Phase 1: synchronous. %dest = thread-spawn func(captures...)
        // The first capture is the pre-computed result
        let after = low_skip_ws(line, pos + 12);
        let paren = find_char(line, after, 40);
        let args_start = paren + 1;
        let args_end = find_char(line, args_start, 41);
        let args = line.slice(args_start, args_end);
        let first_arg = if args.len() > 0 {
            let c = find_comma_or_end(args, 0);
            trim_end(args.slice(0, c))
        } else { "0" };
        "  ; Phase 1: ThreadSpawn - body executed synchronously|  " + dest + " = add i64 " + first_arg + ", 0"
    } else if low_starts_with_at(line, pos, "thread-join") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        "  ; Phase 1: ThreadJoin - handle is the result|  " + dest + " = add i64 " + op + ", 0"
    }
    // Mutex operations
    else if low_starts_with_at(line, pos, "mutex-new") {
        let op_start = low_skip_ws(line, pos + 9);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_new", op))
    } else if low_starts_with_at(line, pos, "mutex-try-lock") {
        let op_start = low_skip_ws(line, pos + 14);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_try_lock", op))
    } else if low_starts_with_at(line, pos, "mutex-lock") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_lock", op))
    }
    // Arc operations
    else if low_starts_with_at(line, pos, "arc-new") {
        let op_start = low_skip_ws(line, pos + 7);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_new", op))
    } else if low_starts_with_at(line, pos, "arc-clone") {
        let op_start = low_skip_ws(line, pos + 9);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_clone", op))
    } else if low_starts_with_at(line, pos, "arc-get") {
        let op_start = low_skip_ws(line, pos + 7);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_get", op))
    } else if low_starts_with_at(line, pos, "arc-strong-count") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_strong_count", op))
    }
    // Atomic operations
    else if low_starts_with_at(line, pos, "atomic-new") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        // Allocate heap memory for atomic, store value, return as i64 ptr
        "  " + dest + "_ptr = call ptr @malloc(i64 8)|  store atomic i64 " + op + ", ptr " + dest + "_ptr seq_cst, align 8|  " + dest + " = ptrtoint ptr " + dest + "_ptr to i64"
    } else if low_starts_with_at(line, pos, "atomic-load") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op + " to ptr|  " + dest + " = load atomic i64, ptr " + dest + "_ptr seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-fetch-add") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw add ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-fetch-sub") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw sub ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-swap") {
        let op_start = low_skip_ws(line, pos + 11);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw xchg ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-cmpxchg") {
        let op_start = low_skip_ws(line, pos + 14);
        let op1 = conc_extract_three_first(line, op_start);
        let op2 = conc_extract_three_second(line, op_start);
        let op3 = conc_extract_three_third(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + "_result = cmpxchg ptr " + dest + "_ptr, i64 " + op2 + ", i64 " + op3 + " seq_cst seq_cst, align 8|  " + dest + " = extractvalue { i64, i1 } " + dest + "_result, 0"
    }
    // Channel operations (assignment form)
    else if low_starts_with_at(line, pos, "channel-recv-timeout") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_alloc = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_recv_timeout(i64 " + op1 + ", i64 " + op2 + ", ptr " + dest + "_alloc)|  " + dest + "_loaded = load i64, ptr " + dest + "_alloc|  " + dest + "_is_success = icmp ne i64 " + dest + "_success, 0|  " + dest + " = select i1 " + dest + "_is_success, i64 " + dest + "_loaded, i64 -1"
    } else if low_starts_with_at(line, pos, "channel-recv-opt") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_ptr = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_recv_opt(i64 " + op + ", ptr " + dest + "_ptr)|  " + dest + "_tmp = load i64, ptr " + dest + "_ptr|  " + dest + "_cond = icmp eq i64 " + dest + "_success, 1|  " + dest + " = select i1 " + dest + "_cond, i64 " + dest + "_tmp, i64 -1"
    } else if low_starts_with_at(line, pos, "channel-recv") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_channel_recv", op))
    } else if low_starts_with_at(line, pos, "channel-try-send") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_channel_try_send", op1, op2))
    } else if low_starts_with_at(line, pos, "channel-try-recv") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_alloc = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_try_recv(i64 " + op + ", ptr " + dest + "_alloc)|  " + dest + " = load i64, ptr " + dest + "_alloc"
    } else if low_starts_with_at(line, pos, "channel-send-timeout") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_three_first(line, op_start);
        let op2 = conc_extract_three_second(line, op_start);
        let op3 = conc_extract_three_third(line, op_start);
        same_mapping(conc_gen_call_i64_3(dest, "bmb_channel_send_timeout", op1, op2, op3))
    } else if low_starts_with_at(line, pos, "channel-is-closed") {
        let op_start = low_skip_ws(line, pos + 17);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_channel_is_closed", op))
    } else if low_starts_with_at(line, pos, "sender-clone") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_sender_clone", op))
    }
    // RwLock operations
    else if low_starts_with_at(line, pos, "rwlock-new") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_new", op))
    } else if low_starts_with_at(line, pos, "rwlock-read") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_read", op))
    } else if low_starts_with_at(line, pos, "rwlock-write") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_write", op))
    }
    // Barrier operations
    else if low_starts_with_at(line, pos, "barrier-new") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_barrier_new", op))
    } else if low_starts_with_at(line, pos, "barrier-wait") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_barrier_wait", op))
    }
    // Condvar operations
    else if low_starts_with_at(line, pos, "condvar-new") {
        same_mapping(conc_gen_call_i64_0(dest, "bmb_condvar_new"))
    } else if low_starts_with_at(line, pos, "condvar-wait") {
        let op_start = low_skip_ws(line, pos + 12);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_condvar_wait", op1, op2))
    }
    // Block-on
    else if low_starts_with_at(line, pos, "block-on") {
        let op_start = low_skip_ws(line, pos + 8);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_block_on", op))
    }
    // Async I/O operations
    else if low_starts_with_at(line, pos, "async-file-open") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_file_open", op))
    } else if low_starts_with_at(line, pos, "async-file-read") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_file_read", op))
    } else if low_starts_with_at(line, pos, "async-socket-connect") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_async_socket_connect", op1, op2))
    } else if low_starts_with_at(line, pos, "async-socket-read") {
        let op_start = low_skip_ws(line, pos + 17);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_socket_read", op))
    }
    // ThreadPool
    else if low_starts_with_at(line, pos, "thread-pool-new") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_thread_pool_new", op))
    }
    // Scope
    else if low_starts_with_at(line, pos, "scope-new") {
        same_mapping(conc_gen_call_i64_0(dest, "bmb_scope_new"))
    }
    // Unknown concurrency instruction
    else { same_mapping("  ; unknown-conc: " + line) };

// v0.88.10: Non-assignment concurrency instruction handler
// Handles MIR lines like "mutex-unlock %h = %v", "channel-send %s %v", etc.
fn llvm_gen_conc_stmt(line: String, p: i64) -> String =
    if low_starts_with_at(line, p, "mutex-unlock") {
        // mutex-unlock %handle = %value
        let op_start = low_skip_ws(line, p + 12);
        let eq_pos = find_eq(line, op_start);
        let handle = trim_end(line.slice(op_start, eq_pos - 1));
        let val_start = low_skip_ws(line, eq_pos + 1);
        let value = trim_end(line.slice(val_start, line.len()));
        conc_gen_call_void_2("bmb_mutex_unlock", handle, value)
    } else if low_starts_with_at(line, p, "mutex-free") {
        let op_start = low_skip_ws(line, p + 10);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_mutex_free", op)
    } else if low_starts_with_at(line, p, "arc-drop") {
        let op_start = low_skip_ws(line, p + 8);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_arc_drop", op)
    } else if low_starts_with_at(line, p, "atomic-store") {
        // atomic-store %ptr = %value
        let op_start = low_skip_ws(line, p + 12);
        let eq_pos = find_eq(line, op_start);
        let ptr_op = trim_end(line.slice(op_start, eq_pos - 1));
        let val_start = low_skip_ws(line, eq_pos + 1);
        let value = trim_end(line.slice(val_start, line.len()));
        "  %_atomic_store_ptr = inttoptr i64 " + ptr_op + " to ptr|  store atomic i64 " + value + ", ptr %_atomic_store_ptr seq_cst, align 8"
    } else if low_starts_with_at(line, p, "channel-send") {
        let op_start = low_skip_ws(line, p + 12);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_channel_send", op1, op2)
    } else if low_starts_with_at(line, p, "channel-close") {
        let op_start = low_skip_ws(line, p + 13);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_channel_close", op)
    } else if low_starts_with_at(line, p, "rwlock-read-unlock") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_rwlock_read_unlock", op)
    } else if low_starts_with_at(line, p, "rwlock-write-unlock") {
        let op_start = low_skip_ws(line, p + 19);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_rwlock_write_unlock", op1, op2)
    } else if low_starts_with_at(line, p, "condvar-notify-one") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_condvar_notify_one", op)
    } else if low_starts_with_at(line, p, "condvar-notify-all") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_condvar_notify_all", op)
    } else if low_starts_with_at(line, p, "async-file-write") {
        let op_start = low_skip_ws(line, p + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_async_file_write", op1, op2)
    } else if low_starts_with_at(line, p, "async-file-close") {
        let op_start = low_skip_ws(line, p + 16);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_async_file_close", op)
    } else if low_starts_with_at(line, p, "async-socket-write") {
        let op_start = low_skip_ws(line, p + 18);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_async_socket_write", op1, op2)
    } else if low_starts_with_at(line, p, "async-socket-close") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_async_socket_close", op)
    } else if low_starts_with_at(line, p, "thread-pool-execute") {
        let op_start = low_skip_ws(line, p + 19);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_thread_pool_execute", op1, op2)
    } else if low_starts_with_at(line, p, "thread-pool-join") {
        let op_start = low_skip_ws(line, p + 16);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_thread_pool_join", op)
    } else if low_starts_with_at(line, p, "thread-pool-shutdown") {
        let op_start = low_skip_ws(line, p + 20);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_thread_pool_shutdown", op)
    } else if low_starts_with_at(line, p, "scope-spawn") {
        let op_start = low_skip_ws(line, p + 11);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_scope_spawn", op1, op2)
    } else if low_starts_with_at(line, p, "scope-wait") {
        let op_start = low_skip_ws(line, p + 10);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_scope_wait", op)
    } else if low_starts_with_at(line, p, "thread-join") {
        // thread-join without dest (discard result)
        let op_start = low_skip_ws(line, p + 11);
        let op = conc_extract_single_op(line, op_start);
        "  call i64 @bmb_thread_join(i64 " + op + ")"
    } else { "  ; unknown-conc-stmt: " + line };

// v0.88.10: channel-new handler for dual-dest format: (%sender, %receiver) = channel-new %capacity
fn llvm_gen_channel_new(line: String, p: i64) -> String =
    // Parse: (%sender, %receiver) = channel-new %capacity
    let p1 = p + 1;
    let comma = find_comma(line, p1);
    let sender_dest = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let rparen = find_char(line, p2, 41);
    let receiver_dest = line.slice(p2, rparen);
    let eq_pos = find_eq(line, rparen + 1);
    let rhs_start = low_skip_ws(line, eq_pos + 1);
    // Skip "channel-new"
    let cap_start = low_skip_ws(line, rhs_start + 11);
    let cap = trim_end(line.slice(cap_start, line.len()));
    // Generate alloca + call + load
    "  " + sender_dest + "_alloc = alloca i64, align 8|  " + receiver_dest + "_alloc = alloca i64, align 8|  call void @bmb_channel_new(i64 " + cap + ", ptr " + sender_dest + "_alloc, ptr " + receiver_dest + "_alloc)|  " + sender_dest + " = load i64, ptr " + sender_dest + "_alloc|  " + receiver_dest + " = load i64, ptr " + receiver_dest + "_alloc";

// Legacy versions for compatibility
fn gen_function_lines_sb_with_strings(mir: String, pos: i64, sb: i64, ret_type: String, strings: String) -> i64 =
    gen_function_lines_sb_with_strings_map(mir, pos, sb, ret_type, strings, "");

fn llvm_gen_fn_line_with_strings(line: String, ret_type: String, strings: String) -> String =
    let r = llvm_gen_fn_line_with_strings_map(line, ret_type, strings, "");
    if r.len() > 0 and r.byte_at(0) == 33 { extract_new_llvm_line(r) } else { r };

fn llvm_gen_line_with_strings(line: String, ret_type: String, strings: String) -> String =
    let r = llvm_gen_line_with_strings_map(line, ret_type, strings, "");
    if r.len() > 0 and r.byte_at(0) == 33 { extract_new_llvm_line(r) } else { r };

fn llvm_gen_assign_with_strings(line: String, pos: i64, strings: String) -> String =
    let r = llvm_gen_assign_with_strings_map(line, pos, strings, "");
    if r.len() > 0 and r.byte_at(0) == 33 { extract_new_llvm_line(r) } else { r };

fn llvm_gen_rhs_with_strings(line: String, pos: i64, dest: String, strings: String) -> String =
    let r = llvm_gen_rhs_with_strings_map(line, pos, dest, strings, "");
    if r.len() > 0 and r.byte_at(0) == 33 { extract_new_llvm_line(r) } else { r };

// Generate reference to string global
// v0.90.12: Use count_string_bytes for correct byte length (escape sequences = 1 byte)
fn llvm_gen_string_ref(dest: String, str_content: String, strings: String) -> String =
    let idx = find_string_index(strings, str_content);
    let str_len = count_string_bytes(str_content) + 1;
    let global_name = "@str_data_" + int_to_string(idx);
    let gep_dest = dest + "_gep";
    let call_dest = dest + "_call";
    "  " + gep_dest + " = getelementptr [" + int_to_string(str_len) + " x i8], ptr " + global_name + ", i64 0, i64 0|" +
    "  " + call_dest + " = call ptr @bmb_string_from_cstr(ptr " + gep_dest + ")|" +
    "  " + dest + " = ptrtoint ptr " + call_dest + " to i64";

// ============================================================================
// SECTION 13: Unified Compiler Entry Point (v0.10.9)
// ============================================================================

// Compile BMB source code to LLVM IR module
// Returns complete LLVM IR module text with:
// - Module header
// - Runtime declarations
// - Function definitions
fn compile_program(source: String) -> String =
    let ast = parse_source(source);
    if is_error(ast) { "ERR:PARSE:" + ast } else {
        // v0.90.5: Build struct registry from source for field access codegen
        let struct_reg = build_struct_registry(source);
        let mir_raw = lower_program_sb(ast);
        if mir_raw == "" { "ERR:LOWERING:empty" } else {
            // v0.90.17: ConstFunctionEval - inline @const 0-arg functions
            let mir = optimize_const_inlining(mir_raw);
            let header = gen_module_header();
            let decls = gen_runtime_decls();
            // v0.60.109: Collect string literals and generate globals
            let strings = collect_strings_from_mir(mir);
            let string_globals = gen_string_globals(strings);
            // v0.60.233: Collect dynamic String-returning functions
            let string_fns = collect_string_fns_from_mir(mir);
            // v0.31.20: Use StringBuilder-aware LLVM generation for O(1) IR generation
            let code = gen_program_sb_with_strings_fns_structs(mir, strings, string_fns, struct_reg);
            // v0.60.127: Use step-by-step concatenation to avoid LLVM codegen bug
            // with chained string concat on large strings
            let base = header + "|";
            let base2 = base + decls;
            // Build with_globals without nesting
            let base3 = base2 + "|";
            let base4 = base3 + string_globals;
            let with_globals = if string_globals == "" { base2 } else { base4 };
            let final1 = with_globals + "||";
            final1 + code
        }
    };

// Compile single function source to LLVM IR
fn compile_function(source: String) -> String =
    let full_source = source;
    let ast = parse_source(full_source);
    if is_error(ast) { "ERR:PARSE:" + ast } else {
        let mir = lower_program_sb(ast);
        // v0.31.20: Use StringBuilder-aware LLVM generation for O(1) IR generation
        if mir == "" { "ERR:LOWERING:empty" } else { gen_function_sb(mir) }
    };

// Check if compilation result is an error
fn is_compile_error(result: String) -> bool =
    result.len() >= 4 and result.slice(0, 4) == "ERR:";

// Extract error type from compilation result
fn get_error_type(result: String) -> String =
    if not is_compile_error(result) { "" } else {
        let after_err = result.slice(4, result.len());
        let colon_pos = find_colon(after_err, 0);
        if colon_pos >= after_err.len() { after_err } else { after_err.slice(0, colon_pos) }
    };

// ============================================================================
// SECTION 14: Test Utilities
// ============================================================================


// v0.88: Emit LLVM IR to file
// Note: Full native build requires external tools (opt, clang)
// Use golden-bootstrap.sh for complete native compilation
fn emit_ir(input: String, output: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        { print_str("Error: Cannot read file: "); println_str(input); 1 }
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            // v0.88.8: Show full error detail with parse/lowering context
            let end = if llvm.len() > 500 { 500 } else { llvm.len() };
            let err_detail = llvm.slice(4, end);
            { print_str("error["); print_str(input); print_str("]: "); println_str(err_detail); 1 }
        } else {
            let w1 = write_file_newlines(output, llvm);
            { print_str("Wrote: "); println_str(output); 0 }
        }
    };

// v0.88.10: Check command - type check without emitting IR
fn check_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        { print_str("Error: Cannot read file: "); println_str(input); 1 }
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            let end = if llvm.len() > 500 { 500 } else { llvm.len() };
            let err_detail = llvm.slice(4, end);
            { print_str("error["); print_str(input); print_str("]: "); println_str(err_detail); 1 }
        } else {
            { print_str("OK: "); println_str(input); 0 }
        }
    };

// v0.90: Build command - compile BMB source to native executable
// Pipeline: source -> LLVM IR -> opt -O3 -> clang -> executable
fn build_file(input: String, output: String, fast: bool, runtime_path: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        { print_str("Error: Cannot read file: "); println_str(input); 1 }
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            let end = if llvm.len() > 500 { 500 } else { llvm.len() };
            let err_detail = llvm.slice(4, end);
            { print_str("error["); print_str(input); print_str("]: "); println_str(err_detail); 1 }
        } else {
            // Write IR to temp file
            let ir_file = output + ".ll";
            let w1 = write_file_newlines(ir_file, llvm);
            let runtime_lib = runtime_path + "/libbmb_runtime.a";
            // Build pipeline: opt -> clang
            let result = if fast {
                build_native_fast(ir_file, output, runtime_lib)
            } else {
                build_native_opt(ir_file, output, runtime_lib)
            };
            result
        }
    };

// Build with full optimization: opt -O3 then clang
fn build_native_opt(ir_file: String, output: String, runtime_lib: String) -> i64 =
    let opt_file = output + "_opt.ll";
    // Step 1: Optimize IR
    let opt_cmd = "opt -passes=" + chr(39) + "default<O3>,scalarizer" + chr(39) + " " + ir_file + " -S -o " + opt_file;
    let opt_result = system(opt_cmd);
    if opt_result != 0 {
        // Fallback: try without scalarizer
        let opt_cmd2 = "opt -O3 " + ir_file + " -S -o " + opt_file;
        let opt_result2 = system(opt_cmd2);
        if opt_result2 != 0 {
            { println_str("Error: opt failed. Falling back to direct compilation."); build_native_direct(ir_file, output, runtime_lib) }
        } else {
            build_link(opt_file, output, runtime_lib, ir_file)
        }
    } else {
        build_link(opt_file, output, runtime_lib, ir_file)
    };

// Build fast: skip opt, use clang -O2 directly
fn build_native_fast(ir_file: String, output: String, runtime_lib: String) -> i64 =
    build_link(ir_file, output, runtime_lib, "");

// Build without opt: direct clang on IR
fn build_native_direct(ir_file: String, output: String, runtime_lib: String) -> i64 =
    build_link(ir_file, output, runtime_lib, "");

// Link step: clang IR + runtime -> executable
fn build_link(ir_file: String, output: String, runtime_lib: String, cleanup_file: String) -> i64 =
    let link_cmd = "clang -O3 " + ir_file + " " + runtime_lib + " -o " + output + " -lm -lws2_32";
    let link_result = system(link_cmd);
    if link_result != 0 {
        // Try without ws2_32 (Linux/macOS)
        let link_cmd2 = "clang -O3 " + ir_file + " " + runtime_lib + " -o " + output + " -lm -lpthread";
        let link_result2 = system(link_cmd2);
        if link_result2 != 0 {
            { println_str("Error: linking failed"); 1 }
        } else {
            build_cleanup(output, cleanup_file)
        }
    } else {
        build_cleanup(output, cleanup_file)
    };

// Report success and optionally clean temp files
fn build_cleanup(output: String, cleanup_file: String) -> i64 =
    { print_str("{"); print_str(chr(34)); print_str("type"); print_str(chr(34)); print_str(":"); print_str(chr(34)); print_str("build_success"); print_str(chr(34)); print_str(","); print_str(chr(34)); print_str("output"); print_str(chr(34)); print_str(":"); print_str(chr(34)); print_str(output); print_str(chr(34)); println_str("}"); 0 };

// Derive output name from input: foo.bmb -> foo (or foo.exe on Windows)
fn derive_output_name(input: String) -> String =
    if input.len() > 4 and input.slice(input.len() - 4, input.len()) == ".bmb" {
        input.slice(0, input.len() - 4)
    } else { input + ".out" };

// Bootstrap version - extended CLI
fn main() -> i64 =
    let argc = arg_count();
    if argc < 2 {
        show_help()
    } else {
        let cmd = get_arg(1);
        if cmd == "build" and argc >= 3 {
            // v0.90: Build to native executable
            let input = get_arg(2);
            let output = parse_build_output(argc, input);
            let fast = parse_build_fast(argc);
            let runtime = parse_build_runtime(argc);
            build_file(input, output, fast, runtime)
        } else if cmd == "emit-ir" and argc >= 4 {
            emit_ir(get_arg(2), get_arg(3))
        } else if cmd == "emit-ir" and argc >= 3 {
            // Default output name: replace .bmb with .ll
            let input = get_arg(2);
            let output = if input.len() > 4 and input.slice(input.len() - 4, input.len()) == ".bmb" {
                input.slice(0, input.len() - 4) + ".ll"
            } else { input + ".ll" };
            emit_ir(input, output)
        } else if cmd == "check" and argc >= 3 {
            // v0.88.10: Check command
            check_file(get_arg(2))
        } else if argc >= 3 {
            // Legacy mode: compiler input.bmb output.ll
            compile_file_to(get_arg(1), get_arg(2))
        } else {
            show_help()
        }
    };

// Parse -o flag from build args
fn parse_build_output(argc: i64, input: String) -> String =
    if argc >= 5 and get_arg(3) == "-o" { get_arg(4) }
    else { derive_output_name(input) };

// Parse --fast-compile flag from build args
fn parse_build_fast(argc: i64) -> bool =
    check_arg_flag(argc, 3, "--fast-compile");

// Parse --runtime flag from build args (default: bmb/runtime)
fn parse_build_runtime(argc: i64) -> String =
    find_arg_value(argc, 3, "--runtime", "bmb/runtime");

fn find_arg_value(argc: i64, idx: i64, flag: String, default_val: String) -> String =
    if idx >= argc { default_val }
    else if get_arg(idx) == flag and idx + 1 < argc { get_arg(idx + 1) }
    else { find_arg_value(argc, idx + 1, flag, default_val) };

fn check_arg_flag(argc: i64, idx: i64, flag: String) -> bool =
    if idx >= argc { false }
    else if get_arg(idx) == flag { true }
    else { check_arg_flag(argc, idx + 1, flag) };

fn show_help() -> i64 =
    let x1 = println_str("BMB Bootstrap Compiler v0.90.0");
    let x2 = println_str("");
    let x3 = println_str("Usage:");
    let x3b = println_str("  bmb build <input.bmb> [-o output]     Build native executable");
    let x3c = println_str("      --fast-compile                    Skip opt pass (faster build)");
    let x3d = println_str("      --runtime <path>                  Runtime library directory");
    let x4 = println_str("  bmb emit-ir <input.bmb> [output.ll]   Emit LLVM IR");
    let x5 = println_str("  bmb check <input.bmb>                 Type check only");
    let x5b = println_str("  bmb <input.bmb> <output.ll>           Emit LLVM IR (legacy)");
    0;


// v0.46: Compile with output file
fn compile_file_to(input: String, output: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        { print_str("Error: Cannot read file: "); println_str(input); 1 }
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            { print_str("Compile error: "); println_str(get_error_type(llvm)); 1 }
        } else {
            // v0.60.134: Use write_file_newlines to convert | to newlines
            let w2 = write_file_newlines(output, llvm);
            0
        }
    };
