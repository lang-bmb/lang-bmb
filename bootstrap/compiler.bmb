// BMB Unified Compiler
//
// ARCHITECTURE:
// 1. Source (BMB) -> parse_source() -> S-expression AST
// 2. AST -> lower_program_sb() -> MIR text (pipe-separated)
// 3. MIR -> gen_program_sb_with_strings_fns_structs() -> LLVM IR text
// 4. Assembly: header + declarations + string globals + functions
//
// Note: Uses | as separator instead of newlines (BMB string limitation)

// ============================================================================
// SECTION 1: String Utilities (required - no imports in bootstrap)
// ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_hex_digit(c: i64) -> bool = is_digit(c) or (c >= 65 and c <= 70) or (c >= 97 and c <= 102);
fn hex_digit_val(c: i64) -> i64 = if c >= 48 and c <= 57 { c - 48 } else if c >= 65 and c <= 70 { c - 55 } else { c - 87 };
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.byte_at(pos)) { skip_ws(s, pos + 1) } else { pos };

// Error handling utilities
fn is_error(s: String) -> bool = s.len() >= 3 and s.slice(0, 3) == "ERR";
fn count_line_at(src: String, pos: i64, cur: i64, line: i64) -> i64 =
    if cur >= pos or cur >= src.len() { line }
    else if src.byte_at(cur) == 10 { count_line_at(src, pos, cur + 1, line + 1) }
    else { count_line_at(src, pos, cur + 1, line) };

fn find_line_start(src: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if src.byte_at(pos - 1) == 10 { pos }
    else { find_line_start(src, pos - 1) };

fn find_line_end(src: String, pos: i64) -> i64 =
    if pos >= src.len() { pos }
    else if src.byte_at(pos) == 10 { pos }
    else { find_line_end(src, pos + 1) };

fn make_error_at(msg: String, src: String, pos: i64) -> String =
    let line = count_line_at(src, pos, 0, 1);
    let ls = find_line_start(src, pos);
    let le = find_line_end(src, pos);
    let col = pos - ls + 1;
    let src_line = if ls < le { src.slice(ls, le) } else { "" };
    let caret = make_caret_line(col - 1, "");
    "ERR:" + msg + " at line " + int_to_string(line) + ":" + int_to_string(col) + "\n  | " + src_line + "\n  | " + caret;

// Generate caret indicator: N spaces followed by "^"
fn make_caret_line(n: i64, acc: String) -> String =
    if n <= 0 { acc + "^" } else { make_caret_line(n - 1, acc + " ") };

// Check if string starts with pattern
fn starts_with(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else { match_bytes(s, pat, pos, 0) };

fn has_pattern(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else if match_bytes(s, pat, pos, 0) { true } else { has_pattern(s, pat, pos + 1) };

// Uses prefix+suffix approach: prefix="(if c1 t1 (if c2 t2 " suffix="))"
// Final AST = prefix + else_body + suffix

// ============================================================================
// SECTION 2: Token Constants (from pipeline.bmb)
// ============================================================================

// Moved from 10000000 range to avoid collision with integer literal 10000000
// Token packing: kind * 1000000 + pos, so token kind must not collide with any i64 literal value
// 2 billion is safely above all realistic integer literal values used in BMB programs
fn TK_FN() -> i64 = 2000000000 + 100;
fn TK_LET() -> i64 = 2000000000 + 101;
fn TK_IF() -> i64 = 2000000000 + 102;
fn TK_THEN() -> i64 = 2000000000 + 103;
fn TK_ELSE() -> i64 = 2000000000 + 104;
fn TK_TRUE() -> i64 = 2000000000 + 105;
fn TK_FALSE() -> i64 = 2000000000 + 106;
fn TK_AND() -> i64 = 2000000000 + 107;
fn TK_OR() -> i64 = 2000000000 + 108;
fn TK_NOT() -> i64 = 2000000000 + 109;
fn TK_PRE() -> i64 = 2000000000 + 110;
fn TK_POST() -> i64 = 2000000000 + 111;
fn TK_MUT() -> i64 = 2000000000 + 117;
fn TK_WHILE() -> i64 = 2000000000 + 118;
fn TK_LOOP() -> i64 = 2000000000 + 131;      // v0.90.31: loop keyword
fn TK_CONTINUE() -> i64 = 2000000000 + 132;  // v0.90.31: continue keyword
fn TK_RETURN() -> i64 = 2000000000 + 133;    // v0.90.31: return keyword
fn TK_BREAK() -> i64 = 2000000000 + 127;
fn TK_FOR() -> i64 = 2000000000 + 125;
fn TK_IN() -> i64 = 2000000000 + 126;
fn TK_ASYNC() -> i64 = 2000000000 + 119;
fn TK_AWAIT() -> i64 = 2000000000 + 120;
fn TK_SELECT() -> i64 = 2000000000 + 121;

fn TK_I32() -> i64 = 2000000000 + 150;
fn TK_I64() -> i64 = 2000000000 + 151;
fn TK_F64() -> i64 = 2000000000 + 152;
fn TK_BOOL() -> i64 = 2000000000 + 153;
fn TK_STRING_TYPE() -> i64 = 2000000000 + 154;
fn TK_FUTURE() -> i64 = 2000000000 + 155;
fn TK_MUTEX() -> i64 = 2000000000 + 156;
fn TK_ATOMIC() -> i64 = 2000000000 + 157;
fn TK_CHANNEL() -> i64 = 2000000000 + 158;
fn TK_SENDER() -> i64 = 2000000000 + 159;
fn TK_RECEIVER() -> i64 = 2000000000 + 160;
fn TK_RWLOCK() -> i64 = 2000000000 + 161;
fn TK_THREADPOOL() -> i64 = 2000000000 + 162;
fn TK_SCOPE() -> i64 = 2000000000 + 163;

fn TK_IDENT() -> i64 = 2000000000 + 201;
fn TK_STRING_LIT() -> i64 = 2000000000 + 202;
fn TK_FLOAT_LIT() -> i64 = 2000000000 + 203;
fn TK_CHAR_LIT() -> i64 = 2000000000 + 204;

fn TK_COLON() -> i64 = 2000000000 + 300;
fn TK_EQ() -> i64 = 2000000000 + 302;
fn TK_SEMI() -> i64 = 2000000000 + 303;
fn TK_COMMA() -> i64 = 2000000000 + 304;
fn TK_LPAREN() -> i64 = 2000000000 + 305;
fn TK_RPAREN() -> i64 = 2000000000 + 306;
// v0.46: Brace tokens for v0.32 braced if-else syntax
fn TK_LBRACE() -> i64 = 2000000000 + 307;
fn TK_RBRACE() -> i64 = 2000000000 + 308;

fn TK_LBRACKET() -> i64 = 2000000000 + 309;
fn TK_RBRACKET() -> i64 = 2000000000 + 310;
fn TK_SET() -> i64 = 2000000000 + 164;
fn TK_STRUCT() -> i64 = 2000000000 + 165;
fn TK_NULL() -> i64 = 2000000000 + 166;

fn TK_MATCH() -> i64 = 2000000000 + 168;
fn TK_QUESTION() -> i64 = 2000000000 + 169;
fn TK_PUB() -> i64 = 2000000000 + 170;
fn TK_TYPE() -> i64 = 2000000000 + 171;
fn TK_ENUM() -> i64 = 2000000000 + 172;
fn TK_TRAIT() -> i64 = 2000000000 + 173;
fn TK_IMPL() -> i64 = 2000000000 + 174;
fn TK_CONST() -> i64 = 2000000000 + 175;
fn TK_WHERE() -> i64 = 2000000000 + 176;
fn TK_DCOLON() -> i64 = 2000000000 + 326;
fn TK_PIPE() -> i64 = 2000000000 + 327;

fn TK_ARROW() -> i64 = 2000000000 + 321;
fn TK_DOT() -> i64 = 2000000000 + 322;
fn TK_DOTDOT() -> i64 = 2000000000 + 323;
fn TK_FAT_ARROW() -> i64 = 2000000000 + 324;
fn TK_DOTDOTEQ() -> i64 = 2000000000 + 325;

fn TK_PLUS() -> i64 = 2000000000 + 400;
fn TK_MINUS() -> i64 = 2000000000 + 401;
fn TK_STAR() -> i64 = 2000000000 + 402;
fn TK_SLASH() -> i64 = 2000000000 + 403;
fn TK_PERCENT() -> i64 = 2000000000 + 404;
fn TK_LT() -> i64 = 2000000000 + 405;
fn TK_GT() -> i64 = 2000000000 + 406;

fn TK_EQEQ() -> i64 = 2000000000 + 410;
fn TK_NEQ() -> i64 = 2000000000 + 411;
fn TK_LTEQ() -> i64 = 2000000000 + 412;
fn TK_GTEQ() -> i64 = 2000000000 + 413;

fn TK_AS() -> i64 = 2000000000 + 127;
fn TK_BAND() -> i64 = 2000000000 + 128;
fn TK_BOR() -> i64 = 2000000000 + 129;
fn TK_BNOT() -> i64 = 2000000000 + 130;
fn TK_BXOR() -> i64 = 2000000000 + 131;  // v0.90.2: bitwise xor
fn TK_SHL() -> i64 = 2000000000 + 431;
fn TK_SHR() -> i64 = 2000000000 + 432;

fn TK_AMP() -> i64 = 2000000000 + 433;

fn TK_PLUSEQ() -> i64 = 2000000000 + 440;
fn TK_MINUSEQ() -> i64 = 2000000000 + 441;
fn TK_STAREQ() -> i64 = 2000000000 + 442;
fn TK_SLASHEQ() -> i64 = 2000000000 + 443;
fn TK_PERCENTEQ() -> i64 = 2000000000 + 444;
fn TK_SHLEQ() -> i64 = 2000000000 + 445;     // v0.95: <<=
fn TK_SHREQ() -> i64 = 2000000000 + 446;     // v0.95: >>=
fn TK_EXTERN() -> i64 = 2000000000 + 167;

fn TK_EOF() -> i64 = 2000000000 + 900;

// ============================================================================
// SECTION 3: Lexer (from pipeline.bmb)
// ============================================================================

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 10 { pos + 1 } else { skip_to_eol(s, pos + 1) };

// v0.46: Support both -- (legacy) and // (v0.32) comment styles
fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 45 { skip_comment(s, skip_to_eol(s, pos + 2)) }
    else if pos + 1 < s.len() and s.byte_at(pos) == 47 and s.byte_at(pos + 1) == 47 { skip_comment(s, skip_to_eol(s, pos + 2)) }
    else if pos + 1 < s.len() and s.byte_at(pos) == 47 and s.byte_at(pos + 1) == 42 { skip_comment(s, skip_block_comment(s, pos + 2)) }
    else { pos };

// Skip block comment: find */ (byte 42 + byte 47)
fn skip_block_comment(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { s.len() }
    else if s.byte_at(pos) == 42 and s.byte_at(pos + 1) == 47 { pos + 2 }
    else { skip_block_comment(s, pos + 1) };

fn skip_ws_comments(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == p1 { p1 } else { skip_ws_comments(s, p2) };

// Actual value is reconstructed from source text in parse_int_lit
// Safe max: 9223372036854 * 1000000 = 9.22e18 < i64 MAX (9.22e18)
fn scan_int(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { pack_int_tok(acc, pos) } else {
        let c = s.byte_at(pos);
        if is_digit(c) {
            let new_acc = if acc < 9000000000000 { acc * 10 + (c - 48) } else { 9200000000000 };
            scan_int(s, pos + 1, new_acc)
        } else if c == 95 { scan_int(s, pos + 1, acc) }
        else { pack_int_tok(acc, pos) }
    };

fn pack_int_tok(acc: i64, pos: i64) -> i64 =
    if acc >= 9000000000000 { 9200000000000 * 1000000 + pos }
    else { acc * 1000000 + pos };

// v0.91: Scan number - detects float if '.' followed by digit
fn scan_hex_int(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { pack_int_tok(acc, pos) } else {
        let c = s.byte_at(pos);
        if is_hex_digit(c) {
            let new_acc = if acc < 9000000000000 { acc * 16 + hex_digit_val(c) } else { 9200000000000 };
            scan_hex_int(s, pos + 1, new_acc)
        } else if c == 95 { scan_hex_int(s, pos + 1, acc) }
        else { pack_int_tok(acc, pos) }
    };

fn scan_bin_int(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { pack_int_tok(acc, pos) } else {
        let c = s.byte_at(pos);
        if c == 48 or c == 49 {
            let new_acc = if acc < 9000000000000 { acc * 2 + (c - 48) } else { 9200000000000 };
            scan_bin_int(s, pos + 1, new_acc)
        } else if c == 95 { scan_bin_int(s, pos + 1, acc) }
        else { pack_int_tok(acc, pos) }
    };

// v0.95: Scan octal integer literal (0o...)
fn scan_oct_int(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { pack_int_tok(acc, pos) } else {
        let c = s.byte_at(pos);
        if c >= 48 and c <= 55 {
            let new_acc = if acc < 9000000000000 { acc * 8 + (c - 48) } else { 9200000000000 };
            scan_oct_int(s, pos + 1, new_acc)
        } else if c == 95 { scan_oct_int(s, pos + 1, acc) }
        else { pack_int_tok(acc, pos) }
    };

// Returns packed int token OR TK_FLOAT_LIT token
fn scan_number(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.byte_at(pos) == 48 and (s.byte_at(pos + 1) == 120 or s.byte_at(pos + 1) == 88) {
        scan_hex_int(s, pos + 2, 0)
    } else if pos + 1 < s.len() and s.byte_at(pos) == 48 and (s.byte_at(pos + 1) == 98 or s.byte_at(pos + 1) == 66) {
        scan_bin_int(s, pos + 2, 0)
    } else if pos + 1 < s.len() and s.byte_at(pos) == 48 and (s.byte_at(pos + 1) == 111 or s.byte_at(pos + 1) == 79) {
        scan_oct_int(s, pos + 2, 0)
    } else {
        let int_result = scan_int(s, pos, 0);
        let int_end = tok_end(int_result);
        // Check for '.' followed by digit (float literal)
        if int_end + 1 < s.len() and s.byte_at(int_end) == 46 and is_digit(s.byte_at(int_end + 1)) {
            let frac_end = scan_digits_end(s, int_end + 1);
            let exp_end = scan_exponent(s, frac_end);
            make_tok(TK_FLOAT_LIT(), exp_end)
        } else { int_result }
    };

// v0.91: Scan digits to end (helper for float fractional part)
fn scan_digits_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { scan_digits_end(s, pos + 1) } else { pos };

fn scan_exponent(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 101 or s.byte_at(pos) == 69 {
        // 'e' (101) or 'E' (69)
        let after_e = pos + 1;
        if after_e >= s.len() { pos }
        else {
            let sign_end = if s.byte_at(after_e) == 43 or s.byte_at(after_e) == 45 { after_e + 1 } else { after_e };
            if sign_end >= s.len() { pos }
            else if is_digit(s.byte_at(sign_end)) { scan_digits_end(s, sign_end) }
            else { pos }
        }
    } else { pos };

fn scan_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_alnum_or_underscore(s.byte_at(pos)) { scan_ident_end(s, pos + 1) } else { pos };

// Returns position after closing quote, or s.len() if not found
fn scan_string_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 92 and pos + 1 < s.len() { scan_string_end(s, pos + 2) }
    else if s.byte_at(pos) == 34 { pos + 1 }
    else { scan_string_end(s, pos + 1) };

// Char literal scanner: expects pos right after opening quote
// Handles: 'a', '\n', '\t', '\r', '\\', '\0', '\''
fn scan_char_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 92 { pos + 3 }
    else { pos + 2 };

// Get the ASCII value of a char literal (pos points to opening quote)
fn get_char_value(s: String, pos: i64) -> i64 =
    let p = skip_ws_comments(s, pos);
    let inner = p + 1;
    if inner < s.len() and s.byte_at(inner) == 92 {
        // Escape sequence
        let esc = s.byte_at(inner + 1);
        if esc == 110 { 10 }       // \n
        else if esc == 116 { 9 }   // \t
        else if esc == 114 { 13 }  // \r
        else if esc == 48 { 0 }    // \0
        else if esc == 92 { 92 }   // \\
        else if esc == 39 { 39 }   // \'
        else { esc }
    } else {
        s.byte_at(inner)
    };

fn tok_val(r: i64) -> i64 = r / 1000000;
fn tok_end(r: i64) -> i64 = r - (r / 1000000) * 1000000;
fn tok_kind(r: i64) -> i64 = tok_val(r);
fn make_tok(kind: i64, endpos: i64) -> i64 = kind * 1000000 + endpos;

// Reduces average comparisons from 9.5 to ~2-3 by checking length first
fn keyword_or_ident(s: String, start: i64, endpos: i64) -> i64 =
    let word = s.slice(start, endpos);
    let len = endpos - start;
    if len == 2 { keyword_len2(word, endpos) }
    else if len == 3 { keyword_len3(word, endpos) }
    else if len == 4 { keyword_len4(word, endpos) }
    else if len == 5 { keyword_len5(word, endpos) }
    else if len == 6 { keyword_len6(word, endpos) }
    else if len == 7 { keyword_len7(word, endpos) }  // v0.88
    else if len == 8 { keyword_len8(word, endpos) }  // v0.88
    else if len == 10 { keyword_len10(word, endpos) }  // v0.88
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len2(word: String, endpos: i64) -> i64 =
    if word == "fn" { make_tok(TK_FN(), endpos) }
    else if word == "if" { make_tok(TK_IF(), endpos) }
    else if word == "or" { make_tok(TK_OR(), endpos) }
    else if word == "in" { make_tok(TK_IN(), endpos) }  // v0.95: for-loop
    else if word == "as" { make_tok(TK_AS(), endpos) }  // v0.90.1: cast
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len3(word: String, endpos: i64) -> i64 =
    if word == "let" { make_tok(TK_LET(), endpos) }
    else if word == "and" { make_tok(TK_AND(), endpos) }
    else if word == "not" { make_tok(TK_NOT(), endpos) }
    else if word == "pre" { make_tok(TK_PRE(), endpos) }
    else if word == "mut" { make_tok(TK_MUT(), endpos) }
    else if word == "for" { make_tok(TK_FOR(), endpos) }  // v0.95: for-loop
    else if word == "i32" { make_tok(TK_I32(), endpos) }
    else if word == "i64" { make_tok(TK_I64(), endpos) }
    else if word == "f64" { make_tok(TK_F64(), endpos) }
    else if word == "bor" { make_tok(TK_BOR(), endpos) }  // v0.90.1: bitwise or
    else if word == "set" { make_tok(TK_SET(), endpos) }  // v0.90.2: set expression
    else if word == "pub" { make_tok(TK_PUB(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len4(word: String, endpos: i64) -> i64 =
    if word == "then" { make_tok(TK_THEN(), endpos) }
    else if word == "else" { make_tok(TK_ELSE(), endpos) }
    else if word == "true" { make_tok(TK_TRUE(), endpos) }
    else if word == "bool" { make_tok(TK_BOOL(), endpos) }
    else if word == "post" { make_tok(TK_POST(), endpos) }
    else if word == "band" { make_tok(TK_BAND(), endpos) }  // v0.90.1: bitwise and
    else if word == "bnot" { make_tok(TK_BNOT(), endpos) }  // v0.90.1: bitwise not
    else if word == "null" { make_tok(TK_NULL(), endpos) }  // v0.90.2: null literal
    else if word == "bxor" { make_tok(TK_BXOR(), endpos) }  // v0.90.2: bitwise xor
    else if word == "loop" { make_tok(TK_LOOP(), endpos) }  // v0.90.31: infinite loop
    else if word == "type" { make_tok(TK_TYPE(), endpos) }
    else if word == "enum" { make_tok(TK_ENUM(), endpos) }
    else if word == "impl" { make_tok(TK_IMPL(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len5(word: String, endpos: i64) -> i64 =
    if word == "false" { make_tok(TK_FALSE(), endpos) }
    else if word == "while" { make_tok(TK_WHILE(), endpos) }  // v0.60.248
    else if word == "break" { make_tok(TK_BREAK(), endpos) }  // v0.90.8
    else if word == "const" { make_tok(TK_CONST(), endpos) }
    else if word == "trait" { make_tok(TK_TRAIT(), endpos) }
    else if word == "where" { make_tok(TK_WHERE(), endpos) }  // v0.95
    else if word == "async" { make_tok(TK_ASYNC(), endpos) }  // v0.88
    else if word == "await" { make_tok(TK_AWAIT(), endpos) }  // v0.88
    else if word == "Mutex" { make_tok(TK_MUTEX(), endpos) }  // v0.88
    else if word == "Scope" { make_tok(TK_SCOPE(), endpos) }  // v0.88
    else if word == "match" { make_tok(TK_MATCH(), endpos) }  // v0.90.86: match expression
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len6(word: String, endpos: i64) -> i64 =
    if word == "String" { make_tok(TK_STRING_TYPE(), endpos) }
    else if word == "select" { make_tok(TK_SELECT(), endpos) }  // v0.88
    else if word == "Future" { make_tok(TK_FUTURE(), endpos) }  // v0.88
    else if word == "Atomic" { make_tok(TK_ATOMIC(), endpos) }  // v0.88
    else if word == "Sender" { make_tok(TK_SENDER(), endpos) }  // v0.88
    else if word == "RwLock" { make_tok(TK_RWLOCK(), endpos) }  // v0.88
    else if word == "struct" { make_tok(TK_STRUCT(), endpos) }  // v0.90.2: struct declaration
    else if word == "extern" { make_tok(TK_EXTERN(), endpos) }  // v0.90.11: extern fn
    else if word == "return" { make_tok(TK_RETURN(), endpos) }  // v0.90.31: return expression
    else { make_tok(TK_IDENT(), endpos) };

// v0.88: Concurrency type keywords
fn keyword_len7(word: String, endpos: i64) -> i64 =
    if word == "Channel" { make_tok(TK_CHANNEL(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len8(word: String, endpos: i64) -> i64 =
    if word == "continue" { make_tok(TK_CONTINUE(), endpos) }  // v0.90.31
    else if word == "Receiver" { make_tok(TK_RECEIVER(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len10(word: String, endpos: i64) -> i64 =
    if word == "ThreadPool" { make_tok(TK_THREADPOOL(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_ws_comments(s, pos);
    if p >= s.len() { make_tok(TK_EOF(), p) } else {
        let c = s.byte_at(p);
        if is_digit(c) { scan_number(s, p) } else if is_ident_start(c) {
            let ident_end = scan_ident_end(s, p + 1);
            keyword_or_ident(s, p, ident_end)
        } else if c == 34 {
            let str_end = scan_string_end(s, p + 1);
            make_tok(TK_STRING_LIT(), str_end)
        } else if c == 39 {
            // Char literal: 'x' or '\n' etc.
            let ch_end = scan_char_end(s, p + 1);
            make_tok(TK_CHAR_LIT(), ch_end)
        } else if c == 58 { if p + 1 < s.len() and s.byte_at(p + 1) == 58 { make_tok(TK_DCOLON(), p + 2) } else { make_tok(TK_COLON(), p + 1) } } else if c == 61 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_EQEQ(), p + 2) } else if p + 1 < s.len() and s.byte_at(p + 1) == 62 { make_tok(TK_FAT_ARROW(), p + 2) } else { make_tok(TK_EQ(), p + 1) } } else if c == 59 { make_tok(TK_SEMI(), p + 1) } else if c == 44 { make_tok(TK_COMMA(), p + 1) } else if c == 40 { make_tok(TK_LPAREN(), p + 1) } else if c == 41 { make_tok(TK_RPAREN(), p + 1) } else if c == 43 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_PLUSEQ(), p + 2) } else { make_tok(TK_PLUS(), p + 1) } } else if c == 45 { if p + 1 < s.len() and s.byte_at(p + 1) == 62 { make_tok(TK_ARROW(), p + 2) } else if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_MINUSEQ(), p + 2) } else { make_tok(TK_MINUS(), p + 1) } } else if c == 42 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_STAREQ(), p + 2) } else { make_tok(TK_STAR(), p + 1) } } else if c == 47 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_SLASHEQ(), p + 2) } else { make_tok(TK_SLASH(), p + 1) } } else if c == 37 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_PERCENTEQ(), p + 2) } else { make_tok(TK_PERCENT(), p + 1) } } else if c == 60 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_LTEQ(), p + 2) } else if p + 1 < s.len() and s.byte_at(p + 1) == 60 { if p + 2 < s.len() and s.byte_at(p + 2) == 61 { make_tok(TK_SHLEQ(), p + 3) } else { make_tok(TK_SHL(), p + 2) } } else { make_tok(TK_LT(), p + 1) } } else if c == 62 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_GTEQ(), p + 2) } else if p + 1 < s.len() and s.byte_at(p + 1) == 62 { if p + 2 < s.len() and s.byte_at(p + 2) == 61 { make_tok(TK_SHREQ(), p + 3) } else { make_tok(TK_SHR(), p + 2) } } else { make_tok(TK_GT(), p + 1) } } else if c == 33 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_NEQ(), p + 2) } else { make_tok(TK_EOF(), p) } } else if c == 46 { if p + 1 < s.len() and s.byte_at(p + 1) == 46 { if p + 2 < s.len() and s.byte_at(p + 2) == 61 { make_tok(TK_DOTDOTEQ(), p + 3) } else { make_tok(TK_DOTDOT(), p + 2) } } else { make_tok(TK_DOT(), p + 1) } } else if c == 91 { make_tok(TK_LBRACKET(), p + 1) } else if c == 93 { make_tok(TK_RBRACKET(), p + 1) } else if c == 123 { make_tok(TK_LBRACE(), p + 1) } else if c == 125 { make_tok(TK_RBRACE(), p + 1) } else if c == 38 { make_tok(TK_AMP(), p + 1) } else if c == 63 { make_tok(TK_QUESTION(), p + 1) } else if c == 124 { make_tok(TK_PIPE(), p + 1) } else { make_tok(TK_EOF(), p) }
    };

fn get_ident_text(s: String, pos: i64, tok: i64) -> String =
    let start = tok_end(tok) - (tok_val(tok) / 1000000);
    let p = skip_ws_comments(s, pos);
    let endp = scan_ident_end(s, p + 1);
    s.slice(p, endp);

fn get_int_text(s: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(s, pos);
    let endpos = tok_end(tok);
    s.slice(p, endpos);

fn get_string_text(s: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(s, pos);
    let endpos = tok_end(tok);
    s.slice(p + 1, endpos - 1);

// v0.91: Extract float literal text from source (e.g., "3.14")
fn get_float_text(s: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(s, pos);
    let endpos = tok_end(tok);
    s.slice(p, endpos);

// This prevents unbalanced parens in strings from breaking AST parsing
// Uses \L for (, \R for ), \B for \ to avoid actual parens in escaped content
fn escape_parens_for_ast(s: String) -> String =
    let sb = sb_new();
    let _p1 = escape_parens_sb(s, 0, sb);
    sb_build(sb);

fn escape_parens_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else {
        let c = s.byte_at(pos);
        // 92=\, 40=(, 41=), 76=L, 82=R, 66=B
        let _p2 = if c == 92 {
            let _p3 = sb_push(sb, chr(92));
            sb_push(sb, chr(66))
        } else if c == 40 {
            let _p4 = sb_push(sb, chr(92));
            sb_push(sb, chr(76))
        } else if c == 41 {
            let _p5 = sb_push(sb, chr(92));
            sb_push(sb, chr(82))
        } else {
            sb_push(sb, chr(c))
        };
        escape_parens_sb(s, pos + 1, sb)
    };

// \L -> (, \R -> ), \B -> \
fn unescape_parens_from_ast(s: String) -> String =
    let sb = sb_new();
    let _q1 = unescape_parens_sb(s, 0, sb);
    sb_build(sb);

fn unescape_parens_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else if s.byte_at(pos) == 92 and pos + 1 < s.len() {
        let next = s.byte_at(pos + 1);
        // 76=L -> 40=(, 82=R -> 41=), 66=B -> 92=\
        let _q2 = if next == 76 { sb_push(sb, chr(40)) }
                  else if next == 82 { sb_push(sb, chr(41)) }
                  else if next == 66 { sb_push(sb, chr(92)) }
                  else {
                      let _q3 = sb_push(sb, chr(92));
                      sb_push(sb, chr(next))
                  };
        unescape_parens_sb(s, pos + 2, sb)
    }
    else {
        let _q4 = sb_push(sb, chr(s.byte_at(pos)));
        unescape_parens_sb(s, pos + 1, sb)
    };

// ============================================================================
// SECTION 4: Parser Result Packing
// ============================================================================

fn pack_result(pos: i64, ast: String) -> String = int_to_string(pos) + ":" + ast;

fn unpack_pos(r: String) -> i64 = unpack_pos_acc(r, 0, 0);

fn unpack_pos_acc(r: String, pos: i64, acc: i64) -> i64 =
    if pos >= r.len() { acc } else {
        let c = r.byte_at(pos);
        if c == 58 { acc } else if is_digit(c) { unpack_pos_acc(r, pos + 1, acc * 10 + (c - 48)) } else { acc }
    };

fn unpack_ast(r: String) -> String =
    let cpos = find_colon(r, 0);
    if cpos >= r.len() { r } else { r.slice(cpos + 1, r.len()) };

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 58 { pos } else { find_colon(s, pos + 1) };

// ============================================================================
// SECTION 5: Expression Parser (recursive descent)
// ============================================================================

// Token constants use 2000000100-2000000999 range (offset 100-999 from base)
// So integers are < 2000000100 OR >= 2000001000
fn is_int_literal(kind: i64) -> bool = kind < 2000000000 + 100 or kind >= 2000000000 + 1000;

fn parse_int_lit(src: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(src, pos);
    let endpos = tok_end(tok);
    let text = src.slice(p, endpos);
    pack_result(endpos, "(int " + text + ")");

// v0.91: Parse float literal - extract text from source
fn parse_float_lit(src: String, pos: i64, tok: i64) -> String =
    let text = get_float_text(src, pos, tok);
    pack_result(tok_end(tok), "(float " + text + ")");

fn parse_bool_lit(tok: i64, kind: i64) -> String =
    if kind == TK_TRUE() { pack_result(tok_end(tok), "(bool true)") }
    else { pack_result(tok_end(tok), "(bool false)") };

fn parse_ident_or_call(src: String, pos: i64, tok: i64) -> String =
    let name = get_ident_text(src, pos, tok);
    let next = next_token_raw(src, tok_end(tok));
    if name == "assert" and tok_kind(next) == TK_LPAREN() {
        parse_assert_call(src, tok_end(next))
    } else if name == "todo" and tok_kind(next) == TK_LPAREN() {
        parse_panic_call(src, tok_end(next), "not yet implemented")
    } else if name == "unreachable" and tok_kind(next) == TK_LPAREN() {
        parse_panic_call(src, tok_end(next), "entered unreachable code")
    } else if name == "dbg" and tok_kind(next) == TK_LPAREN() {
        parse_dbg_call(src, tok_end(next), pos)
    } else if name == "dbg_str" and tok_kind(next) == TK_LPAREN() {
        parse_dbg_str_call(src, tok_end(next), pos)
    } else if name == "assert_eq" and tok_kind(next) == TK_LPAREN() {
        parse_assert_eq_call(src, tok_end(next), pos)
    } else if name == "assert_ne" and tok_kind(next) == TK_LPAREN() {
        parse_assert_ne_call(src, tok_end(next), pos)
    } else if name == "assert_gt" and tok_kind(next) == TK_LPAREN() {
        parse_assert_cmp_call(src, tok_end(next), pos, "<=", "assertion failed: left not greater than right")
    } else if name == "assert_lt" and tok_kind(next) == TK_LPAREN() {
        parse_assert_cmp_call(src, tok_end(next), pos, ">=", "assertion failed: left not less than right")
    } else if name == "assert_ge" and tok_kind(next) == TK_LPAREN() {
        parse_assert_cmp_call(src, tok_end(next), pos, "<", "assertion failed: left less than right")
    } else if name == "assert_le" and tok_kind(next) == TK_LPAREN() {
        parse_assert_cmp_call(src, tok_end(next), pos, ">", "assertion failed: left greater than right")
    } else if tok_kind(next) == TK_LPAREN() {
        let rargs = parse_args(src, tok_end(next), "");
        pack_result(unpack_pos(rargs), "(call <" + name + ">" + unpack_ast(rargs) + ")")
    } else if tok_kind(next) == TK_LBRACE() {
        // Two-token lookahead: if IDENT followed by ':', it's struct init
        let peek1 = next_token_raw(src, tok_end(next));
        let peek2 = next_token_raw(src, tok_end(peek1));
        if tok_kind(peek1) == TK_IDENT() and tok_kind(peek2) == TK_COLON() {
            parse_struct_init(src, tok_end(next), name)
        } else {
            pack_result(tok_end(tok), "(var <" + name + ">)")
        }
    } else if tok_kind(next) == TK_DCOLON() {
        let variant_tok = next_token_raw(src, tok_end(next));
        if tok_kind(variant_tok) == TK_IDENT() {
            let variant_name = get_ident_text(src, tok_end(next), variant_tok);
            pack_result(tok_end(variant_tok), "(enum_variant <" + name + "> <" + variant_name + ">)")
        } else {
            make_error_at("expected variant name after '::'", src, tok_end(next))
        }
    } else {
        pack_result(tok_end(tok), "(var <" + name + ">)")
    };

// assert(cond) or assert(cond, "msg") → (if (unary not cond) (call <bmb_panic> msg) (unit))
fn parse_assert_call(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(rc) { rc } else {
        let cond_ast = unpack_ast(rc);
        let t_next = next_token_raw(src, unpack_pos(rc));
        if tok_kind(t_next) == TK_COMMA() {
            // assert(cond, msg_expr)
            let rm = parse_expr(src, tok_end(t_next));
            if is_error(rm) { rm } else {
                let msg_ast = unpack_ast(rm);
                let t_close = next_token_raw(src, unpack_pos(rm));
                if tok_kind(t_close) != TK_RPAREN() { make_error_at("expected ')' after assert message", src, unpack_pos(rm)) }
                else {
                    let neg_cond = "(unary not " + cond_ast + ")";
                    let panic_call = "(call <bmb_panic> " + msg_ast + ")";
                    let assert_ast = "(if " + neg_cond + " " + panic_call + " (unit))";
                    pack_result(tok_end(t_close), assert_ast)
                }
            }
        } else if tok_kind(t_next) == TK_RPAREN() {
            // assert(cond) — default message
            let neg_cond = "(unary not " + cond_ast + ")";
            let panic_call = "(call <bmb_panic> (string assertion failed))";
            let assert_ast = "(if " + neg_cond + " " + panic_call + " (unit))";
            pack_result(tok_end(t_next), assert_ast)
        } else { make_error_at("expected ',' or ')' after assert condition", src, unpack_pos(rc)) }
    };

// dbg(expr) → (let <__dbg_N> expr (seq (call <eprintln> (var <__dbg_N>)) (var <__dbg_N>)))
fn parse_dbg_call(src: String, pos: i64, start_pos: i64) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re } else {
        let val_ast = unpack_ast(re);
        let t_close = next_token_raw(src, unpack_pos(re));
        if tok_kind(t_close) != TK_RPAREN() { make_error_at("expected ')' after dbg expression", src, unpack_pos(re)) }
        else {
            let dbg_var = "__dbg_" + int_to_string(start_pos);
            let dbg_ast = "(let <" + dbg_var + "> " + val_ast + " (seq (call <eprintln> (var <" + dbg_var + ">)) (var <" + dbg_var + ">)))";
            pack_result(tok_end(t_close), dbg_ast)
        }
    };

// dbg_str(expr) → prints string to stderr and returns it
fn parse_dbg_str_call(src: String, pos: i64, start_pos: i64) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re } else {
        let val_ast = unpack_ast(re);
        let t_close = next_token_raw(src, unpack_pos(re));
        if tok_kind(t_close) != TK_RPAREN() { make_error_at("expected ')' after dbg_str expression", src, unpack_pos(re)) }
        else {
            let dbg_var = "__dbgs_" + int_to_string(start_pos);
            let dbg_ast = "(let <" + dbg_var + "> " + val_ast + " (seq (call <eprintln_str> (var <" + dbg_var + ">)) (var <" + dbg_var + ">)))";
            pack_result(tok_end(t_close), dbg_ast)
        }
    };

// todo() or todo("msg"), unreachable() or unreachable("msg") → (call <bmb_panic> msg)
fn parse_panic_call(src: String, pos: i64, default_msg: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RPAREN() {
        // No argument — use default message
        pack_result(tok_end(t), "(call <bmb_panic> (string " + default_msg + "))")
    } else {
        // Custom message expression
        let rm = parse_expr(src, pos);
        if is_error(rm) { rm } else {
            let msg_ast = unpack_ast(rm);
            let t_close = next_token_raw(src, unpack_pos(rm));
            if tok_kind(t_close) != TK_RPAREN() { make_error_at("expected ')' after message", src, unpack_pos(rm)) }
            else { pack_result(tok_end(t_close), "(call <bmb_panic> " + msg_ast + ")") }
        }
    };

// assert_eq(a, b) → compare two values, panic if not equal
fn parse_assert_eq_call(src: String, pos: i64, start_pos: i64) -> String =
    parse_assert_cmp_call(src, pos, start_pos, "!=", "assertion failed: values not equal");

// assert_ne(a, b) → compare two values, panic if equal
fn parse_assert_ne_call(src: String, pos: i64, start_pos: i64) -> String =
    parse_assert_cmp_call(src, pos, start_pos, "==", "assertion failed: values unexpectedly equal");

// Shared helper for assert_eq/assert_ne
fn parse_assert_cmp_call(src: String, pos: i64, start_pos: i64, cmp_op: String, msg: String) -> String =
    let ra = parse_expr(src, pos);
    if is_error(ra) { ra } else {
        let a_ast = unpack_ast(ra);
        let t_comma = next_token_raw(src, unpack_pos(ra));
        if tok_kind(t_comma) != TK_COMMA() { make_error_at("expected ',' after first argument", src, unpack_pos(ra)) }
        else {
            let rb = parse_expr(src, tok_end(t_comma));
            if is_error(rb) { rb } else {
                let b_ast = unpack_ast(rb);
                let t_close = next_token_raw(src, unpack_pos(rb));
                if tok_kind(t_close) != TK_RPAREN() { make_error_at("expected ')' after second argument", src, unpack_pos(rb)) }
                else {
                    let lvar = "__aeq_l_" + int_to_string(start_pos);
                    let rvar = "__aeq_r_" + int_to_string(start_pos);
                    let cmp = "(binop " + cmp_op + " (var <" + lvar + ">) (var <" + rvar + ">))";
                    let panic_call = "(call <bmb_panic> (string " + msg + "))";
                    let if_ast = "(if " + cmp + " " + panic_call + " (unit))";
                    let ast = "(let <" + lvar + "> " + a_ast + " (let <" + rvar + "> " + b_ast + " " + if_ast + "))";
                    pack_result(tok_end(t_close), ast)
                }
            }
        }
    };

fn parse_unary(src: String, tok: i64, op: String) -> String =
    let re = parse_atom(src, tok_end(tok));
    pack_result(unpack_pos(re), "(unary " + op + " " + unpack_ast(re) + ")");

fn parse_paren_expr(src: String, tok: i64) -> String =
    let re = parse_expr(src, tok_end(tok));
    if is_error(re) { re } else {
        let next = next_token_raw(src, unpack_pos(re));
        if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), unpack_ast(re)) }
        else if tok_kind(next) == TK_COMMA() {
            parse_tuple_rest(src, tok_end(next), unpack_ast(re))
        }
        else { make_error_at("expected ')' or ',' after expression", src, unpack_pos(re)) }
    };

fn parse_tuple_rest(src: String, pos: i64, acc: String) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re } else {
        let new_acc = acc + " " + unpack_ast(re);
        let next = next_token_raw(src, unpack_pos(re));
        if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), "(tuple " + new_acc + ")") }
        else if tok_kind(next) == TK_COMMA() { parse_tuple_rest(src, tok_end(next), new_acc) }
        else { make_error_at("expected ')' or ',' in tuple", src, unpack_pos(re)) }
    };

// Get compound operator string from token kind, or "" for plain =
fn compound_op(kind: i64) -> String =
    if kind == TK_PLUSEQ() { "+" }
    else if kind == TK_MINUSEQ() { "-" }
    else if kind == TK_STAREQ() { "*" }
    else if kind == TK_SLASHEQ() { "/" }
    else if kind == TK_PERCENTEQ() { "%" }
    else if kind == TK_SHLEQ() { "<<" }
    else if kind == TK_SHREQ() { ">>" }
    else { "" };

fn is_assign_op(kind: i64) -> bool =
    kind == TK_EQ() or kind == TK_PLUSEQ() or kind == TK_MINUSEQ() or kind == TK_STAREQ() or kind == TK_SLASHEQ() or kind == TK_PERCENTEQ() or kind == TK_SHLEQ() or kind == TK_SHREQ();

// target can be: arr[i] or obj.field or var
// Supports: =, +=, -=, *=, /=
fn parse_set_expr(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { make_error_at("expected identifier after 'set'", src, pos) }
    else {
        let target_name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LBRACKET() {
            parse_set_index(src, tok_end(t2), target_name)
        } else if tok_kind(t2) == TK_DOT() {
            parse_set_field(src, tok_end(t2), target_name)
        } else if is_assign_op(tok_kind(t2)) {
            parse_set_var(src, tok_end(t2), target_name, compound_op(tok_kind(t2)))
        } else { make_error_at("expected '[', '.', '=', '+=', '-=', '*=', '/=', or '%=' after set target", src, tok_end(t1)) }
    };

// set x = val  or  set x += val
fn parse_set_var(src: String, pos: i64, name: String, op: String) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else if op == "" {
        pack_result(unpack_pos(rv), "(set_var <" + name + "> " + unpack_ast(rv) + ")")
    } else {
        let rhs = "(binop " + op + " (var <" + name + ">) " + unpack_ast(rv) + ")";
        pack_result(unpack_pos(rv), "(set_var <" + name + "> " + rhs + ")")
    };

// set arr[i] = val  or  set arr[i] += val
fn parse_set_index(src: String, pos: i64, target_name: String) -> String =
    let ri = parse_expr(src, pos);
    if is_error(ri) { ri } else {
        let t_close = next_token_raw(src, unpack_pos(ri));
        if tok_kind(t_close) != TK_RBRACKET() { make_error_at("expected ']' in set", src, unpack_pos(ri)) } else {
            let t_eq = next_token_raw(src, tok_end(t_close));
            if not is_assign_op(tok_kind(t_eq)) { make_error_at("expected '=', '+=', '-=', '*=', or '/=' in set", src, tok_end(t_close)) } else {
                let op = compound_op(tok_kind(t_eq));
                let rv = parse_expr(src, tok_end(t_eq));
                if is_error(rv) { rv } else {
                    let val_ast = if op == "" { unpack_ast(rv) }
                        else { "(binop " + op + " (index (var <" + target_name + ">) " + unpack_ast(ri) + ") " + unpack_ast(rv) + ")" };
                    pack_result(unpack_pos(rv), "(set_index (var <" + target_name + ">) " + unpack_ast(ri) + " " + val_ast + ")")
                }
            }
        }
    };

// set obj.field = val  or  set obj.field += val
fn parse_set_field(src: String, pos: i64, target_name: String) -> String =
    let t3 = next_token_raw(src, pos);
    let field_name = get_ident_text(src, pos, t3);
    let t_eq = next_token_raw(src, tok_end(t3));
    if not is_assign_op(tok_kind(t_eq)) { make_error_at("expected '=', '+=', '-=', '*=', or '/=' in set", src, tok_end(t3)) } else {
        let op = compound_op(tok_kind(t_eq));
        let rv = parse_expr(src, tok_end(t_eq));
        if is_error(rv) { rv } else {
            let val_ast = if op == "" { unpack_ast(rv) }
                else { "(binop " + op + " (field (var <" + target_name + ">) " + field_name + ") " + unpack_ast(rv) + ")" };
            pack_result(unpack_pos(rv), "(set_field (var <" + target_name + ">) " + field_name + " " + val_ast + ")")
        }
    };

// Block syntax: { stmt; stmt; ... final_expr }
// Where stmt is: let name = expr; or { lhs = rhs }; or expr;
fn parse_block_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RBRACE() {
        // Empty block: { } -> unit
        pack_result(tok_end(tok), "(unit)")
    } else {
        // Parse block contents
        let rb = parse_block_stmts(src, pos);
        if is_error(rb) { rb } else {
            let t2 = next_token_raw(src, unpack_pos(rb));
            if tok_kind(t2) != TK_RBRACE() {
                make_error_at("expected '}' to close block", src, unpack_pos(rb))
            } else {
                pack_result(tok_end(t2), "(block " + unpack_ast(rb) + ")")
            }
        }
    };

// Parse block statements: let binding or assignment or expression
fn parse_block_stmts(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() {
        pack_result(pos, "(unit)")
    } else if kind == TK_LET() {
        // Let binding: let name = val; body
        parse_block_let(src, tok_end(tok))
    } else if kind == TK_LBRACE() {
        // Assignment block: { lhs = rhs }; rest
        parse_block_assign(src, pos)
    } else if kind == TK_IDENT() {
        let peek = next_token_raw(src, tok_end(tok));
        if is_assign_op(tok_kind(peek)) {
            parse_bare_assign(src, pos)
        } else {
            // Expression or expression-statement
            parse_block_expr_stmt(src, pos)
        }
    } else {
        // Expression or expression-statement
        parse_block_expr_stmt(src, pos)
    };

// Parse let binding inside block: let name = val; rest
// v0.91: Support type annotations: let name: type = val; rest
fn parse_block_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_MUT() {
        // v0.91: let mut name ...
        parse_block_let_mut(src, tok_end(t1))
    } else if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_EQ() {
            parse_block_let_value(src, tok_end(t2), name, false)
        } else if tok_kind(t2) == TK_COLON() {
            // Skip type annotation until '='
            parse_block_let_skip_type(src, tok_end(t2), name, false)
        } else { make_error_at("expected '=' or ':' in let binding", src, tok_end(t1)) }
    } else { make_error_at("expected variable name after 'let'", src, pos) };

// v0.91: let mut name ...
fn parse_block_let_mut(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_EQ() {
            parse_block_let_value(src, tok_end(t2), name, true)
        } else if tok_kind(t2) == TK_COLON() {
            parse_block_let_skip_type(src, tok_end(t2), name, true)
        } else { make_error_at("expected '=' or ':' in let mut binding", src, tok_end(t1)) }
    } else { make_error_at("expected variable name after 'let mut'", src, pos) };

// v0.91: Skip type tokens until '=' in block let binding
fn parse_block_let_skip_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() {
        parse_block_let_value(src, tok_end(t), name, is_mut)
    } else if k == TK_IDENT() or k == TK_I64() or k == TK_I32() or k == TK_F64() or k == TK_BOOL() or k == TK_STRING_TYPE() or k == TK_STAR() or k == TK_AMP() or k == TK_MUT() or k == TK_QUESTION() {
        parse_block_let_skip_type(src, tok_end(t), name, is_mut)
    } else if k == TK_LBRACKET() {
        parse_block_let_skip_array_type(src, tok_end(t), name, is_mut)
    } else if k == TK_LPAREN() {
        parse_block_let_skip_tuple_type(src, tok_end(t), name, is_mut)
    } else { make_error_at("expected '=' after type in let binding", src, pos) };

fn parse_block_let_skip_tuple_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RPAREN() { parse_block_let_skip_type(src, tok_end(t), name, is_mut) }
    else { parse_block_let_skip_tuple_type(src, tok_end(t), name, is_mut) };

fn parse_block_let_skip_array_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_RBRACKET() {
        parse_block_let_skip_type(src, tok_end(t), name, is_mut)
    } else {
        parse_block_let_skip_array_type(src, tok_end(t), name, is_mut)
    };

// v0.91: Parse value and body for block let
fn parse_block_let_value(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv } else {
        let t3 = next_token_raw(src, unpack_pos(rv));
        if tok_kind(t3) == TK_SEMI() {
            let rb = parse_block_stmts(src, tok_end(t3));
            let tag = if is_mut { "let_mut" } else { "let" };
            pack_result(unpack_pos(rb), "(" + tag + " <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")")
        } else { make_error_at("expected ';' after let binding", src, unpack_pos(rv)) }
    };

// Parse assignment inside block: { lhs = rhs }; rest
fn parse_block_assign(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' for assignment", src, pos) } else {
        let peek1 = next_token_raw(src, tok_end(t1));
        let peek2 = if tok_kind(peek1) == TK_IDENT() { next_token_raw(src, tok_end(peek1)) } else { make_tok(TK_EOF(), 0) };
        if tok_kind(peek1) == TK_IDENT() and tok_kind(peek2) == TK_EQ() {
            // Looks like assignment - parse as { name = expr }
            parse_simple_assign_block(src, t1, peek1, peek2)
        } else {
            // Not an assignment - parse as block expression { stmts; ... final_expr }
            // Fall back to parsing as a block expression within an expr-stmt
            let rb = parse_block_stmts(src, tok_end(t1));
            if is_error(rb) { rb } else {
                let t_close = next_token_raw(src, unpack_pos(rb));
                if tok_kind(t_close) != TK_RBRACE() { make_error_at("expected '}' to close block", src, unpack_pos(rb)) } else {
                    let block_ast = "(block " + unpack_ast(rb) + ")";
                    let after_block = tok_end(t_close);
                    let t4 = next_token_raw(src, after_block);
                    if tok_kind(t4) == TK_SEMI() {
                        let rest = parse_block_stmts(src, tok_end(t4));
                        pack_result(unpack_pos(rest), "(seq " + block_ast + " " + unpack_ast(rest) + ")")
                    } else {
                        pack_result(after_block, block_ast)
                    }
                }
            }
        }
    };

fn parse_simple_assign_block(src: String, t1: i64, peek1: i64, peek2: i64) -> String =
    let name = get_ident_text(src, tok_end(t1), peek1);
    let rr = parse_expr(src, tok_end(peek2));
    if is_error(rr) { rr } else {
        let t3 = next_token_raw(src, unpack_pos(rr));
        if tok_kind(t3) == TK_RBRACE() {
            // Simple: { name = value }
            let assign_ast = "(assign (var <" + name + ">) " + unpack_ast(rr) + ")";
            let after_assign = tok_end(t3);
            let t4 = next_token_raw(src, after_assign);
            if tok_kind(t4) == TK_SEMI() {
                let rest = parse_block_stmts(src, tok_end(t4));
                pack_result(unpack_pos(rest), "(seq " + assign_ast + " " + unpack_ast(rest) + ")")
            } else {
                pack_result(after_assign, assign_ast)
            }
        } else if tok_kind(t3) == TK_SEMI() {
            // Multi-statement: { name = value; more_stmts... }
            let assign_ast = "(assign (var <" + name + ">) " + unpack_ast(rr) + ")";
            let rest = parse_block_stmts(src, tok_end(t3));
            if is_error(rest) { rest } else {
                let t_close = next_token_raw(src, unpack_pos(rest));
                if tok_kind(t_close) != TK_RBRACE() { make_error_at("expected '}' to close block", src, unpack_pos(rest)) } else {
                    let block_ast = "(block (seq " + assign_ast + " " + unpack_ast(rest) + "))";
                    let after_block = tok_end(t_close);
                    let t5 = next_token_raw(src, after_block);
                    if tok_kind(t5) == TK_SEMI() {
                        let rest2 = parse_block_stmts(src, tok_end(t5));
                        pack_result(unpack_pos(rest2), "(seq " + block_ast + " " + unpack_ast(rest2) + ")")
                    } else {
                        pack_result(after_block, block_ast)
                    }
                }
            }
        } else { make_error_at("expected '}' or ';' after assignment value", src, unpack_pos(rr)) }
    };

// Used for patterns like { result = result + 1 } without inner braces
fn parse_bare_assign(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let name = get_ident_text(src, pos, t1);
    let t2 = next_token_raw(src, tok_end(t1));
    let op = compound_op(tok_kind(t2));
    if not is_assign_op(tok_kind(t2)) { make_error_at("expected '=' or compound assignment", src, tok_end(t1)) } else {
        let rr = parse_expr(src, tok_end(t2));
        if is_error(rr) { rr } else {
            let val_ast = if op == "" { unpack_ast(rr) }
                else { "(binop " + op + " (var <" + name + ">) " + unpack_ast(rr) + ")" };
            let assign_ast = "(assign (var <" + name + ">) " + val_ast + ")";
            let t3 = next_token_raw(src, unpack_pos(rr));
            if tok_kind(t3) == TK_SEMI() {
                let rest = parse_block_stmts(src, tok_end(t3));
                pack_result(unpack_pos(rest), "(seq " + assign_ast + " " + unpack_ast(rest) + ")")
            } else {
                pack_result(unpack_pos(rr), assign_ast)
            }
        }
    };

// Parse expression statement: expr; rest or just expr at end
fn parse_block_expr_stmt(src: String, pos: i64) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re } else {
        let t1 = next_token_raw(src, unpack_pos(re));
        if tok_kind(t1) == TK_SEMI() {
            // Expression statement followed by more
            let rest = parse_block_stmts(src, tok_end(t1));
            pack_result(unpack_pos(rest), "(seq " + unpack_ast(re) + " " + unpack_ast(rest) + ")")
        } else {
            // Final expression (no semicolon)
            re
        }
    };

fn parse_atom(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if is_int_literal(kind) { parse_int_lit(src, pos, tok) }
    else if kind == TK_FLOAT_LIT() { parse_float_lit(src, pos, tok) }
    else if kind == TK_TRUE() or kind == TK_FALSE() { parse_bool_lit(tok, kind) }
    else if kind == TK_IDENT() { parse_ident_or_call(src, pos, tok) }
    else if kind == TK_STRING_LIT() { pack_result(tok_end(tok), "(string " + escape_parens_for_ast(get_string_text(src, pos, tok)) + ")") }
    else if kind == TK_CHAR_LIT() { pack_result(tok_end(tok), "(int " + int_to_string(get_char_value(src, pos)) + ")") }
    else if kind == TK_NOT() { parse_unary(src, tok, "not") }
    else if kind == TK_BNOT() { parse_unary(src, tok, "bnot") }  // v0.90.1
    else if kind == TK_MINUS() { parse_unary(src, tok, "-") }
    else if kind == TK_LPAREN() {
        let peek = next_token_raw(src, tok_end(tok));
        if tok_kind(peek) == TK_RPAREN() { pack_result(tok_end(peek), "(unit)") }
        else { parse_paren_expr(src, tok) }
    }
    else if kind == TK_LBRACE() { parse_block_expr(src, tok_end(tok)) }
    else if kind == TK_SET() { parse_set_expr(src, tok_end(tok)) }  // v0.90.2
    else if kind == TK_NULL() { pack_result(tok_end(tok), "(int 0)") }  // v0.90.2: null = 0
    else if kind == TK_LBRACKET() { parse_array_or_repeat(src, tok_end(tok)) }
    // &x just evaluates to x. Parse the inner atom and pass through.
    else if kind == TK_AMP() {
        let peek = next_token_raw(src, tok_end(tok));
        if tok_kind(peek) == TK_MUT() {
            // &mut x — skip mut, parse atom
            parse_atom(src, tok_end(peek))
        } else {
            parse_atom(src, tok_end(tok))
        }
    }
    // v0.95: fn |params| body — closure/lambda expression
    else if kind == TK_FN() {
        let peek = next_token_raw(src, tok_end(tok));
        if tok_kind(peek) == TK_PIPE() { parse_lambda_expr(src, tok_end(peek)) }
        else { make_error_at("expected '|' after 'fn' in expression", src, tok_end(tok)) }
    }
    else { make_error_at("unexpected token in expression", src, pos) };

// v0.95: Lambda/closure expression parsing
// Parses: fn |params...| body  or  fn |params...| { body }
// After opening '|' was consumed. Format: param1: Type, param2: Type| body
// AST result: (lambda (param <p1> T1) (param <p2> T2) BODY_AST)
fn parse_lambda_expr(src: String, pos: i64) -> String =
    let rp = parse_lambda_params(src, pos, "");
    if is_error(rp) { rp }
    else {
        let params_str = unpack_ast(rp);
        let after_params = unpack_pos(rp);
        // Check for optional -> ReturnType
        let t = next_token_raw(src, after_params);
        let body_pos = if tok_kind(t) == TK_ARROW() {
            let rt = parse_return_type(src, tok_end(t));
            unpack_pos(rt)
        } else { after_params };
        // Parse body expression
        let rb = parse_expr(src, body_pos);
        if is_error(rb) { rb }
        else { pack_result(unpack_pos(rb), "(lambda" + params_str + " " + unpack_ast(rb) + ")") }
    };

// Parse lambda parameters: name: Type, name: Type |
fn parse_lambda_params(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_PIPE() { pack_result(tok_end(tok), acc) }
    else if tok_kind(tok) == TK_IDENT() {
        let rp = parse_param(src, pos);
        if is_error(rp) { rp } else {
            let new_acc = acc + " " + unpack_ast(rp);
            let next = next_token_raw(src, unpack_pos(rp));
            if tok_kind(next) == TK_COMMA() { parse_lambda_params(src, tok_end(next), new_acc) }
            else if tok_kind(next) == TK_PIPE() { pack_result(tok_end(next), new_acc) }
            else { make_error_at("expected ',' or '|' in lambda parameters", src, unpack_pos(rp)) }
        }
    }
    else { make_error_at("expected parameter name or '|' in lambda", src, pos) };

// [val; count] → (array_repeat val count)
// [expr1, expr2, ...] → (array expr1 expr2 ...)
// [] → (array)
fn parse_array_or_repeat(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RBRACKET() {
        // Empty array []
        pack_result(tok_end(tok), "(array)")
    } else {
        let rv = parse_expr(src, pos);
        if is_error(rv) { rv }
        else {
            let val_ast = unpack_ast(rv);
            let next = next_token_raw(src, unpack_pos(rv));
            let nk = tok_kind(next);
            if nk == TK_SEMI() {
                // Array repeat: [val; count_expr]
                let count_rv = parse_expr(src, tok_end(next));
                if is_error(count_rv) { count_rv }
                else {
                    let count_ast = unpack_ast(count_rv);
                    let close = next_token_raw(src, unpack_pos(count_rv));
                    if tok_kind(close) != TK_RBRACKET() { make_error_at("expected ']' in array repeat", src, unpack_pos(count_rv)) }
                    else { pack_result(tok_end(close), "(array_repeat " + val_ast + " " + count_ast + ")") }
                }
            } else if nk == TK_COMMA() {
                // Array literal: [expr1, expr2, ...]
                parse_array_rest(src, tok_end(next), val_ast)
            } else if nk == TK_RBRACKET() {
                // Single-element array: [expr]
                pack_result(tok_end(next), "(array " + val_ast + ")")
            } else { make_error_at("expected ';', ',' or ']' in array", src, unpack_pos(rv)) }
        }
    };

// Parse remaining elements of array literal after first element and comma
fn parse_array_rest(src: String, pos: i64, acc: String) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else {
        let new_acc = acc + " " + unpack_ast(rv);
        let next = next_token_raw(src, unpack_pos(rv));
        if tok_kind(next) == TK_RBRACKET() {
            pack_result(tok_end(next), "(array " + new_acc + ")")
        } else if tok_kind(next) == TK_COMMA() {
            parse_array_rest(src, tok_end(next), new_acc)
        } else { make_error_at("expected ',' or ']' in array literal", src, unpack_pos(rv)) }
    };

fn parse_args(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), acc) } else {
        let re = parse_expr(src, pos);
        if is_error(re) { re } else {
            let new_acc = acc + " " + unpack_ast(re);
            let next = next_token_raw(src, unpack_pos(re));
            if tok_kind(next) == TK_COMMA() { parse_args(src, tok_end(next), new_acc) } else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) } else { make_error_at("expected ',' or ')' in arguments", src, unpack_pos(re)) }
        }
    };

fn parse_postfix(src: String, pos: i64) -> String =
    let rl = parse_atom(src, pos);
    if is_error(rl) { rl } else { parse_postfix_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_postfix_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_DOT() {
        let method_tok = next_token_raw(src, tok_end(tok));
        if tok_kind(method_tok) == TK_IDENT() {
            let method_name = get_ident_text(src, tok_end(tok), method_tok);
            let next = next_token_raw(src, tok_end(method_tok));
            if tok_kind(next) == TK_LPAREN() {
                // Method call with args: s.slice(0, 1)
                let rargs = parse_args(src, tok_end(next), "");
                let ast = "(method " + method_name + " " + left + unpack_ast(rargs) + ")";
                parse_postfix_rest(src, unpack_pos(rargs), ast)
            } else {
                let ast = "(field " + left + " " + method_name + ")";
                parse_postfix_rest(src, tok_end(method_tok), ast)
            }
        } else if is_int_literal(tok_kind(method_tok)) {
            let field_text = get_int_text(src, tok_end(tok), method_tok);
            let ast = "(field " + left + " " + field_text + ")";
            parse_postfix_rest(src, tok_end(method_tok), ast)
        } else { make_error_at("expected method name after '.'", src, tok_end(tok)) }
    } else if tok_kind(tok) == TK_LBRACKET() {
        let ri = parse_expr(src, tok_end(tok));
        if is_error(ri) { ri } else {
            let t_close = next_token_raw(src, unpack_pos(ri));
            if tok_kind(t_close) != TK_RBRACKET() { make_error_at("expected ']' after index", src, unpack_pos(ri)) }
            else {
                let ast = "(index " + left + " " + unpack_ast(ri) + ")";
                parse_postfix_rest(src, tok_end(t_close), ast)
            }
        }
    } else if tok_kind(tok) == TK_AS() {
        let type_tok = next_token_raw(src, tok_end(tok));
        if tok_kind(type_tok) == TK_STAR() {
            let t_type_start = tok_end(type_tok);
            let t_type = next_token_raw(src, t_type_start);
            let type_name = src.slice(t_type_start, tok_end(t_type));
            if type_name == "f64" {
                parse_postfix_rest(src, tok_end(t_type), "(cast_ptr_f64 " + left + ")")
            } else {
                parse_postfix_rest(src, tok_end(t_type), left)
            }
        } else if tok_kind(type_tok) == TK_I64() {
            // v0.95: also used for i32→i64 sext (identity at MIR level, codegen emits sext)
            parse_postfix_rest(src, tok_end(type_tok), "(cast_i64 " + left + ")")
        } else if tok_kind(type_tok) == TK_I32() {
            // v0.95: as i32 - emit trunc_i32 MIR instruction (i64→i32 narrowing)
            parse_postfix_rest(src, tok_end(type_tok), "(cast_i32 " + left + ")")
        } else if tok_kind(type_tok) == TK_F64() {
            parse_postfix_rest(src, tok_end(type_tok), "(cast_f64 " + left + ")")
        } else {
            // as bool, as String, etc. - no-op in bootstrap
            parse_postfix_rest(src, tok_end(type_tok), left)
        }
    } else { pack_result(pos, left) };

fn parse_mul(src: String, pos: i64) -> String =
    let rl = parse_postfix(src, pos);
    if is_error(rl) { rl } else { parse_mul_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_mul_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_STAR() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop * " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_SLASH() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop / " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_PERCENT() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop % " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_add(src: String, pos: i64) -> String =
    let rl = parse_mul(src, pos);
    if is_error(rl) { rl } else { parse_add_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_add_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PLUS() {
        let rr = parse_mul(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_add_rest(src, unpack_pos(rr), "(binop + " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_MINUS() {
        let rr = parse_mul(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_add_rest(src, unpack_pos(rr), "(binop - " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_shift(src: String, pos: i64) -> String =
    let rl = parse_add(src, pos);
    if is_error(rl) { rl } else { parse_shift_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_shift_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_SHL() {
        let rr = parse_add(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_shift_rest(src, unpack_pos(rr), "(binop << " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_SHR() {
        let rr = parse_add(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_shift_rest(src, unpack_pos(rr), "(binop >> " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_cmp(src: String, pos: i64) -> String =
    let rl = parse_bitor(src, pos);
    if is_error(rl) { rl } else { parse_cmp_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_cmp_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LT() {
        let rr = parse_bitor(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop < " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_GT() {
        let rr = parse_bitor(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop > " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_LTEQ() {
        let rr = parse_bitor(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop <= " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_GTEQ() {
        let rr = parse_bitor(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop >= " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_EQEQ() {
        let rr = parse_bitor(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop == " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_NEQ() {
        let rr = parse_bitor(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop != " + left + " " + unpack_ast(rr) + ")")
    } else { pack_result(pos, left) };

fn parse_bitand(src: String, pos: i64) -> String =
    let rl = parse_shift(src, pos);
    if is_error(rl) { rl } else { parse_bitand_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_bitand_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_BAND() {
        let rr = parse_shift(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_bitand_rest(src, unpack_pos(rr), "(binop band " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_bitxor(src: String, pos: i64) -> String =
    let rl = parse_bitand(src, pos);
    if is_error(rl) { rl } else { parse_bitxor_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_bitxor_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_BXOR() {
        let rr = parse_bitand(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_bitxor_rest(src, unpack_pos(rr), "(binop bxor " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_bitor(src: String, pos: i64) -> String =
    let rl = parse_bitxor(src, pos);
    if is_error(rl) { rl } else { parse_bitor_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_bitor_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_BOR() {
        let rr = parse_bitxor(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_bitor_rest(src, unpack_pos(rr), "(binop bor " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_and(src: String, pos: i64) -> String =
    let rl = parse_cmp(src, pos);
    if is_error(rl) { rl } else { parse_and_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_and_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_AND() {
        let rr = parse_cmp(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_and_rest(src, unpack_pos(rr), "(binop and " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_or(src: String, pos: i64) -> String =
    let rl = parse_and(src, pos);
    if is_error(rl) { rl } else { parse_or_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_or_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_OR() {
        let rr = parse_and(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_or_rest(src, unpack_pos(rr), "(binop or " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

// Split into helper functions to avoid exponential compilation time
// prefix = "(if c1 t1 (if c2 t2 ...", suffix = "))"
// Final AST = prefix + else_body + suffix

fn parse_if_chain_iter(src: String, pos: i64, prefix: String, suffix: String) -> String =
    // pos is right after 'if' keyword, parse: cond { then } else ...
    let rc = parse_or(src, pos);
    if is_error(rc) { rc }
    else { parse_if_chain_then(src, unpack_pos(rc), unpack_ast(rc), prefix, suffix) };

fn parse_if_chain_then(src: String, pos: i64, cond_ast: String, prefix: String, suffix: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' after if condition", src, pos) }
    else {
        let rt = parse_block_stmts(src, tok_end(t1));
        if is_error(rt) { rt }
        else { parse_if_chain_after_then(src, unpack_pos(rt), cond_ast, unpack_ast(rt), prefix, suffix) }
    };

fn parse_if_chain_after_then(src: String, pos: i64, cond_ast: String, then_ast: String, prefix: String, suffix: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after then branch", src, pos) }
    else {
        let new_prefix = prefix + "(if " + cond_ast + " " + then_ast + " ";
        let new_suffix = ")" + suffix;
        parse_if_chain_else(src, tok_end(t2), new_prefix, new_suffix)
    };

fn parse_if_chain_else(src: String, pos: i64, new_prefix: String, new_suffix: String) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) == TK_ELSE() {
        let t4 = next_token_raw(src, tok_end(t3));
        let k4 = tok_kind(t4);
        if k4 == TK_IF() { parse_if_chain_iter(src, tok_end(t4), new_prefix, new_suffix) }
        else if k4 == TK_LBRACE() { parse_if_chain_final_else(src, tok_end(t4), new_prefix, new_suffix) }
        else { make_error_at("expected 'if' or '{' after 'else'", src, tok_end(t3)) }
    } else {
        pack_result(pos, new_prefix + "(int 0)" + new_suffix)
    };

fn parse_if_chain_final_else(src: String, pos: i64, new_prefix: String, new_suffix: String) -> String =
    let re = parse_block_stmts(src, pos);
    if is_error(re) { re }
    else { parse_if_chain_finish(src, unpack_pos(re), unpack_ast(re), new_prefix, new_suffix) };

fn parse_if_chain_finish(src: String, pos: i64, else_ast: String, new_prefix: String, new_suffix: String) -> String =
    let t5 = next_token_raw(src, pos);
    if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after else branch", src, pos) }
    else {
        let middle = new_prefix + else_ast;
        let full = middle + new_suffix;
        pack_result(tok_end(t5), full)
    };


fn parse_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_IF() { parse_if_expr(src, tok_end(tok)) }
    else if kind == TK_LET() { parse_let_expr(src, tok_end(tok), pos) }
    else if kind == TK_WHILE() { parse_while_expr(src, tok_end(tok)) }  // v0.60.248
    else if kind == TK_LOOP() { parse_loop_expr(src, tok_end(tok)) }   // v0.90.31: loop
    else if kind == TK_FOR() { parse_for_expr(src, tok_end(tok)) }  // v0.95: for-loop
    else if kind == TK_BREAK() { pack_result(tok_end(tok), "(break)") }  // v0.90.8: break
    else if kind == TK_CONTINUE() { pack_result(tok_end(tok), "(continue)") }  // v0.90.31: continue
    else if kind == TK_RETURN() { parse_return_expr(src, tok_end(tok)) }       // v0.90.31: return
    else if kind == TK_MATCH() { parse_match_expr(src, tok_end(tok)) }       // v0.90.86: match
    else { parse_or(src, pos) };

fn parse_if_expr(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(rc) { rc }
    else { parse_if_after_cond(src, unpack_pos(rc), unpack_ast(rc)) };

fn parse_if_after_cond(src: String, pos: i64, cond_ast: String) -> String =
    let t1 = next_token_raw(src, pos);
    let k1 = tok_kind(t1);
    // v0.46: Support both 'then/else' (legacy) and '{ } else { }' (v0.32) syntax
    if k1 == TK_THEN() { parse_if_then_syntax(src, tok_end(t1), cond_ast) }
    else if k1 == TK_LBRACE() { parse_if_brace_syntax(src, tok_end(t1), cond_ast) }
    else { make_error_at("expected '{' or 'then' after if condition", src, pos) };

fn parse_if_then_syntax(src: String, pos: i64, cond_ast: String) -> String =
    let rt = parse_expr(src, pos);
    if is_error(rt) { rt }
    else { parse_if_then_else(src, unpack_pos(rt), cond_ast, unpack_ast(rt)) };

fn parse_if_then_else(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_ELSE() { make_error_at("expected 'else' after then expression", src, pos) }
    else {
        let re = parse_expr(src, tok_end(t2));
        make_if_ast(unpack_pos(re), cond_ast, then_ast, unpack_ast(re))
    };

fn parse_if_brace_syntax(src: String, pos: i64, cond_ast: String) -> String =
    let rt = parse_block_stmts(src, pos);
    if is_error(rt) { rt }
    else { parse_if_brace_then(src, unpack_pos(rt), cond_ast, unpack_ast(rt)) };

fn parse_if_brace_then(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after if body", src, pos) }
    else { parse_if_brace_else(src, tok_end(t2), cond_ast, then_ast) };

fn parse_if_brace_else(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) == TK_ELSE() { parse_if_brace_else_body(src, tok_end(t3), cond_ast, then_ast) }
    else {
        make_if_ast(pos, cond_ast, then_ast, "(int 0)")
    };

fn parse_if_brace_else_body(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t4 = next_token_raw(src, pos);
    let k4 = tok_kind(t4);
    if k4 == TK_LBRACE() { parse_if_brace_final(src, tok_end(t4), cond_ast, then_ast) }
    else if k4 == TK_IF() {
        let init_prefix = "(if " + cond_ast + " " + then_ast + " ";
        parse_if_chain_iter(src, tok_end(t4), init_prefix, ")")
    }
    else { make_error_at("expected '{' or 'if' after 'else'", src, pos) };

fn parse_if_brace_final(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let re = parse_block_stmts(src, pos);
    if is_error(re) { re }
    else { parse_if_brace_finish(src, unpack_pos(re), cond_ast, then_ast, unpack_ast(re)) };

fn parse_if_brace_finish(src: String, pos: i64, cond_ast: String, then_ast: String, else_ast: String) -> String =
    let t5 = next_token_raw(src, pos);
    if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after else body", src, pos) }
    else { make_if_ast(tok_end(t5), cond_ast, then_ast, else_ast) };

fn make_if_ast(pos: i64, cond_ast: String, then_ast: String, else_ast: String) -> String =
    let p1 = "(if " + cond_ast;
    let p2 = p1 + " " + then_ast;
    let p3 = p2 + " " + else_ast;
    pack_result(pos, p3 + ")");

fn parse_let_expr(src: String, pos: i64, start_pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let k1 = tok_kind(t1);
    if k1 == TK_MUT() {
        // let mut name = ...
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_IDENT() { make_error_at("expected variable name after 'mut'", src, tok_end(t1)) }
        else { parse_let_name_mut(src, tok_end(t1), t2) }
    } else if k1 == TK_IDENT() {
        // let name = ...
        parse_let_name(src, pos, t1)
    } else { make_error_at("expected variable name after 'let'", src, pos) };

fn parse_let_name(src: String, pos: i64, t1: i64) -> String =
    let name = get_ident_text(src, pos, t1);
    parse_let_after_name(src, tok_end(t1), name, false);

fn parse_let_name_mut(src: String, pos: i64, t2: i64) -> String =
    let name = get_ident_text(src, pos, t2);
    parse_let_after_name(src, tok_end(t2), name, true);

fn parse_let_after_name(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t2 = next_token_raw(src, pos);
    let k2 = tok_kind(t2);
    if k2 == TK_EQ() {
        // let name = value
        parse_let_value_mut(src, tok_end(t2), name, is_mut)
    } else if k2 == TK_COLON() {
        // let name: type = value - skip type annotation
        parse_let_skip_type(src, tok_end(t2), name, is_mut)
    } else { make_error_at("expected '=' or ':' after let binding name", src, pos) };

fn parse_let_skip_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    // Skip type token(s) until we find '='
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() {
        parse_let_value_mut(src, tok_end(t), name, is_mut)
    } else if k == TK_IDENT() or k == TK_I64() or k == TK_I32() or k == TK_F64() or k == TK_BOOL() or k == TK_STRING_TYPE() or k == TK_STAR() or k == TK_AMP() or k == TK_MUT() or k == TK_QUESTION() or k == TK_LT() or k == TK_GT() or k == TK_COMMA() or k == TK_PLUS() {
        // Skip the type tokens (including generic type args <T>, bounds T: A + B) and continue looking for '='
        parse_let_skip_type(src, tok_end(t), name, is_mut)
    } else if k == TK_LBRACKET() {
        parse_let_skip_array_type(src, tok_end(t), name, is_mut)
    } else if k == TK_LPAREN() {
        parse_let_skip_tuple_type(src, tok_end(t), name, is_mut)
    } else { make_error_at("expected '=' after type in let binding", src, pos) };

fn parse_let_skip_tuple_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RPAREN() { parse_let_skip_type(src, tok_end(t), name, is_mut) }
    else { parse_let_skip_tuple_type(src, tok_end(t), name, is_mut) };

fn parse_let_skip_array_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_RBRACKET() {
        parse_let_skip_type(src, tok_end(t), name, is_mut)
    } else {
        // Skip any token inside array type annotation (type name, semicolon, number)
        parse_let_skip_array_type(src, tok_end(t), name, is_mut)
    };

fn parse_let_value_mut(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else { parse_let_body_mut(src, unpack_pos(rv), name, unpack_ast(rv), is_mut) };

fn parse_let_body_mut(src: String, pos: i64, name: String, val_ast: String, is_mut: bool) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) != TK_SEMI() { make_error_at("expected ';' after let binding value", src, pos) }
    else {
        let rb = parse_expr(src, tok_end(t3));
        if is_mut {
            make_let_mut_ast(unpack_pos(rb), name, val_ast, unpack_ast(rb))
        } else {
            make_let_ast(unpack_pos(rb), name, val_ast, unpack_ast(rb))
        }
    };


fn make_let_ast(pos: i64, name: String, val_ast: String, body_ast: String) -> String =
    let p1 = "(let <" + name + "> ";
    let p2 = p1 + val_ast + " ";
    pack_result(pos, p2 + body_ast + ")");

fn make_let_mut_ast(pos: i64, name: String, val_ast: String, body_ast: String) -> String =
    let p1 = "(let_mut <" + name + "> ";
    let p2 = p1 + val_ast + " ";
    pack_result(pos, p2 + body_ast + ")");

// ============================================================================
// ============================================================================

// Parse while expression: while condition { body }
// AST format: (while condition body)
fn parse_while_expr(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(rc) { rc }
    else { parse_while_body(src, unpack_pos(rc), unpack_ast(rc)) };

fn parse_while_body(src: String, pos: i64, cond_ast: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' after while condition", src, pos) }
    else { parse_while_body_inner(src, tok_end(t1), cond_ast) };

// v0.91: While body uses parse_block_stmts for let/assign/expr support
fn parse_while_body_inner(src: String, pos: i64, cond_ast: String) -> String =
    let rb = parse_block_stmts(src, pos);
    if is_error(rb) { rb }
    else { parse_while_finish(src, unpack_pos(rb), cond_ast, unpack_ast(rb)) };

fn parse_while_finish(src: String, pos: i64, cond_ast: String, body_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after while body", src, pos) }
    else { pack_result(tok_end(t2), "(while " + cond_ast + " " + body_ast + ")") };

// AST format: (return) or (return expr)
// Bare return when next token is '}' or ';' or EOF
fn parse_return_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() or kind == TK_SEMI() or kind == TK_EOF() {
        pack_result(pos, "(return)")
    } else {
        let r = parse_expr(src, pos);
        if is_error(r) { r }
        else { pack_result(unpack_pos(r), "(return " + unpack_ast(r) + ")") }
    };

// AST format: (loop body)
fn parse_loop_expr(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' after loop", src, pos) }
    else { parse_loop_body(src, tok_end(t1)) };

fn parse_loop_body(src: String, pos: i64) -> String =
    let rb = parse_block_stmts(src, pos);
    if is_error(rb) { rb }
    else { parse_loop_finish(src, unpack_pos(rb), unpack_ast(rb)) };

fn parse_loop_finish(src: String, pos: i64, body_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after loop body", src, pos) }
    else { pack_result(tok_end(t2), "(loop " + body_ast + ")") };

// v0.95: for-loop parser
// Syntax: for <ident> in <start> .. <end> { <body> }
// Produces AST: (for <varname> start_ast end_ast body_ast)
fn parse_for_expr(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { make_error_at("expected variable name after 'for'", src, pos) }
    else {
        let varname = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_IN() { make_error_at("expected 'in' after for variable", src, tok_end(t1)) }
        else { parse_for_range(src, tok_end(t2), varname) }
    };

fn parse_for_range(src: String, pos: i64, varname: String) -> String =
    let rs = parse_or(src, pos);
    if is_error(rs) { rs }
    else {
        let expr_ast = unpack_ast(rs);
        let t3 = next_token_raw(src, unpack_pos(rs));
        if tok_kind(t3) == TK_DOTDOT() { parse_for_end(src, tok_end(t3), varname, expr_ast) }
        else if tok_kind(t3) == TK_DOTDOTEQ() { parse_for_end_inclusive(src, tok_end(t3), varname, expr_ast) }
        else if tok_kind(t3) == TK_LBRACE() {
            parse_for_in_body(src, tok_end(t3), varname, expr_ast, pos)
        }
        else { make_error_at("expected '..', '..=' or '{' after for expression", src, unpack_pos(rs)) }
    };

// for x in arr { body }
// → (block (let <__fia_N> arr (let <__fil_N> (method arr_len (var <__fia_N>))
//      (for <__fii_N> (int 0) (var <__fil_N>)
//          (let <x> (index (var <__fia_N>) (var <__fii_N>)) body)))))
// uid parameter ensures unique internal variable names for nested for-in loops
fn parse_for_in_body(src: String, pos: i64, varname: String, arr_ast: String, uid: i64) -> String =
    let rb = parse_block_stmts(src, pos);
    if is_error(rb) { rb }
    else {
        let body_ast = unpack_ast(rb);
        let t5 = next_token_raw(src, unpack_pos(rb));
        if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after for body", src, unpack_pos(rb)) }
        else {
            let suffix = i2s(uid);
            let arr_var = "__fia_" + suffix;
            let len_var = "__fil_" + suffix;
            let idx_var = "__fii_" + suffix;
            let desugared = "(block (let <" + arr_var + "> " + arr_ast +
                " (let <" + len_var + "> (method arr_len (var <" + arr_var + ">)) " +
                "(for <" + idx_var + "> (int 0) (var <" + len_var + ">) " +
                "(let <" + varname + "> (index (var <" + arr_var + ">) (var <" + idx_var + ">)) " +
                body_ast + ")))))";
            pack_result(tok_end(t5), desugared)
        }
    };

fn parse_for_end(src: String, pos: i64, varname: String, start_ast: String) -> String =
    let re = parse_or(src, pos);
    if is_error(re) { re }
    else {
        let end_ast = unpack_ast(re);
        let t4 = next_token_raw(src, unpack_pos(re));
        if tok_kind(t4) == TK_LBRACE() {
            parse_for_body(src, tok_end(t4), varname, start_ast, end_ast, "(int 1)")
        } else if tok_kind(t4) == TK_IDENT() and get_ident_text(src, unpack_pos(re), t4) == "step" {
            // for i in 0..N step EXPR { body }
            let step_r = parse_or(src, tok_end(t4));
            if is_error(step_r) { step_r } else {
                let step_ast = unpack_ast(step_r);
                let t5 = next_token_raw(src, unpack_pos(step_r));
                if tok_kind(t5) != TK_LBRACE() { make_error_at("expected '{' after step expression", src, unpack_pos(step_r)) }
                else { parse_for_body(src, tok_end(t5), varname, start_ast, end_ast, step_ast) }
            }
        } else { make_error_at("expected '{' or 'step' after for range", src, unpack_pos(re)) }
    };

fn parse_for_body(src: String, pos: i64, varname: String, start_ast: String, end_ast: String, step_ast: String) -> String =
    let rb = parse_block_stmts(src, pos);
    if is_error(rb) { rb }
    else {
        let body_ast = unpack_ast(rb);
        let t5 = next_token_raw(src, unpack_pos(rb));
        if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after for body", src, unpack_pos(rb)) }
        else if step_ast == "(int 1)" {
            pack_result(tok_end(t5), "(for <" + varname + "> " + start_ast + " " + end_ast + " " + body_ast + ")")
        } else {
            pack_result(tok_end(t5), "(for_step <" + varname + "> " + start_ast + " " + end_ast + " " + step_ast + " " + body_ast + ")")
        }
    };

fn parse_for_end_inclusive(src: String, pos: i64, varname: String, start_ast: String) -> String =
    let re = parse_or(src, pos);
    if is_error(re) { re }
    else {
        let end_ast = unpack_ast(re);
        let t4 = next_token_raw(src, unpack_pos(re));
        if tok_kind(t4) == TK_LBRACE() {
            parse_for_body_inclusive(src, tok_end(t4), varname, start_ast, end_ast, "(int 1)")
        } else if tok_kind(t4) == TK_IDENT() and get_ident_text(src, unpack_pos(re), t4) == "step" {
            let step_r = parse_or(src, tok_end(t4));
            if is_error(step_r) { step_r } else {
                let step_ast = unpack_ast(step_r);
                let t5 = next_token_raw(src, unpack_pos(step_r));
                if tok_kind(t5) != TK_LBRACE() { make_error_at("expected '{' after step expression", src, unpack_pos(step_r)) }
                else { parse_for_body_inclusive(src, tok_end(t5), varname, start_ast, end_ast, step_ast) }
            }
        } else { make_error_at("expected '{' or 'step' after for range", src, unpack_pos(re)) }
    };

fn parse_for_body_inclusive(src: String, pos: i64, varname: String, start_ast: String, end_ast: String, step_ast: String) -> String =
    let rb = parse_block_stmts(src, pos);
    if is_error(rb) { rb }
    else {
        let body_ast = unpack_ast(rb);
        let t5 = next_token_raw(src, unpack_pos(rb));
        if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after for body", src, unpack_pos(rb)) }
        else if step_ast == "(int 1)" {
            pack_result(tok_end(t5), "(for_incl <" + varname + "> " + start_ast + " " + end_ast + " " + body_ast + ")")
        } else {
            pack_result(tok_end(t5), "(for_step_incl <" + varname + "> " + start_ast + " " + end_ast + " " + step_ast + " " + body_ast + ")")
        }
    };

// match expr { pat1 => body1, pat2 => body2, _ => default }
// → (let <__match> expr (if (binop == (var <__match>) (int pat1)) body1 (if ... default)))

fn parse_match_expr(src: String, pos: i64) -> String =
    let rs = parse_expr(src, pos);
    if is_error(rs) { rs }
    else { parse_match_open(src, unpack_pos(rs), unpack_ast(rs)) };

fn parse_match_open(src: String, pos: i64, scrutinee: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) != TK_LBRACE() { make_error_at("expected '{' after match expression", src, pos) }
    else { parse_match_arms(src, tok_end(t), scrutinee, "", "") };

fn parse_match_arms(src: String, pos: i64, scrutinee: String, prefix: String, suffix: String) -> String =
    let t = next_token_raw(src, pos);
    let kind = tok_kind(t);
    if kind == TK_RBRACE() {
        let inner = prefix + "(int 0)" + suffix;
        let result = "(let <__match> " + scrutinee + " " + inner + ")";
        pack_result(tok_end(t), result)
    }
    else if kind == TK_IDENT() {
        let pat_text = get_ident_text(src, pos, t);
        if pat_text == "_" {
            parse_match_wildcard(src, tok_end(t), scrutinee, prefix, suffix)
        } else {
            let peek = next_token_raw(src, tok_end(t));
            if tok_kind(peek) == TK_DCOLON() {
                let var_tok = next_token_raw(src, tok_end(peek));
                let variant_name = get_ident_text(src, tok_end(peek), var_tok);
                let pat_expr = "(enum_variant <" + pat_text + "> <" + variant_name + ">)";
                parse_match_arm_arrow(src, tok_end(var_tok), scrutinee, pat_expr, prefix, suffix)
            } else {
                parse_match_var_bind(src, tok_end(t), scrutinee, pat_text, prefix, suffix)
            }
        }
    }
    else if is_int_literal(kind) {
        let int_text = get_int_text(src, pos, t);
        parse_match_arm_arrow(src, tok_end(t), scrutinee, "(int " + int_text + ")", prefix, suffix)
    }
    else if kind == TK_MINUS() {
        let t2 = next_token_raw(src, tok_end(t));
        if is_int_literal(tok_kind(t2)) {
            let int_text = "-" + get_int_text(src, tok_end(t), t2);
            parse_match_arm_arrow(src, tok_end(t2), scrutinee, "(int " + int_text + ")", prefix, suffix)
        } else { make_error_at("expected integer after '-' in match pattern", src, tok_end(t)) }
    }
    else if kind == TK_STRING_LIT() {
        let str_text = escape_parens_for_ast(get_string_text(src, pos, t));
        parse_match_arm_arrow(src, tok_end(t), scrutinee, "(string " + str_text + ")", prefix, suffix)
    }
    else if kind == TK_TRUE() {
        parse_match_arm_arrow(src, tok_end(t), scrutinee, "(bool true)", prefix, suffix)
    }
    else if kind == TK_FALSE() {
        parse_match_arm_arrow(src, tok_end(t), scrutinee, "(bool false)", prefix, suffix)
    }
    else if kind == TK_CHAR_LIT() {
        let cv = get_char_value(src, pos);
        parse_match_arm_arrow(src, tok_end(t), scrutinee, "(int " + int_to_string(cv) + ")", prefix, suffix)
    }
    else { make_error_at("expected pattern in match arm", src, pos) };

fn parse_match_arm_arrow(src: String, pos: i64, scrutinee: String, pat_expr: String, prefix: String, suffix: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_PIPE() {
        parse_match_or_pattern(src, tok_end(t), scrutinee, pat_expr, prefix, suffix)
    } else if tok_kind(t) == TK_DOTDOTEQ() {
        // Range pattern: lo..=hi => body
        parse_match_range_pattern(src, tok_end(t), scrutinee, pat_expr, prefix, suffix)
    } else if tok_kind(t) == TK_FAT_ARROW() {
        parse_match_arm_body(src, tok_end(t), scrutinee, pat_expr, prefix, suffix)
    } else { make_error_at("expected '=>', '|', or '..=' after match pattern", src, pos) };

// Range pattern: lo..=hi => body — generates (binop and (>= __match lo) (<= __match hi))
fn parse_match_range_pattern(src: String, pos: i64, scrutinee: String, lo_expr: String, prefix: String, suffix: String) -> String =
    let hi_result = parse_match_single_pattern(src, pos);
    if is_error(hi_result) { hi_result }
    else {
        let hi_expr = unpack_ast(hi_result);
        let range_cond = "(binop and (binop >= (var <__match>) " + lo_expr + ") (binop <= (var <__match>) " + hi_expr + "))";
        let t = next_token_raw(src, unpack_pos(hi_result));
        if tok_kind(t) == TK_FAT_ARROW() {
            parse_match_range_body(src, tok_end(t), scrutinee, range_cond, prefix, suffix)
        } else { make_error_at("expected '=>' after range pattern", src, unpack_pos(hi_result)) }
    };

fn parse_match_range_body(src: String, pos: i64, scrutinee: String, cond: String, prefix: String, suffix: String) -> String =
    let rb = parse_expr(src, pos);
    if is_error(rb) { rb }
    else {
        let body = unpack_ast(rb);
        let new_prefix = prefix + "(if " + cond + " " + body + " ";
        let new_suffix = ")" + suffix;
        parse_match_arm_sep(src, unpack_pos(rb), scrutinee, new_prefix, new_suffix)
    };

// OR pattern: `1 | 2 | 3 => body` collects alternatives and generates compound condition
fn parse_match_or_pattern(src: String, pos: i64, scrutinee: String, first_pat: String, prefix: String, suffix: String) -> String =
    let next_pat = parse_match_single_pattern(src, pos);
    if is_error(next_pat) { next_pat }
    else {
        let pat2 = unpack_ast(next_pat);
        let combined = "(binop or (binop == (var <__match>) " + first_pat + ") (binop == (var <__match>) " + pat2 + "))";
        parse_match_or_continue(src, unpack_pos(next_pat), scrutinee, combined, prefix, suffix)
    };

fn parse_match_or_continue(src: String, pos: i64, scrutinee: String, cond_so_far: String, prefix: String, suffix: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_PIPE() {
        let next_pat = parse_match_single_pattern(src, tok_end(t));
        if is_error(next_pat) { next_pat }
        else {
            let pat = unpack_ast(next_pat);
            let new_cond = "(binop or " + cond_so_far + " (binop == (var <__match>) " + pat + "))";
            parse_match_or_continue(src, unpack_pos(next_pat), scrutinee, new_cond, prefix, suffix)
        }
    } else if tok_kind(t) == TK_FAT_ARROW() {
        parse_match_or_body(src, tok_end(t), scrutinee, cond_so_far, prefix, suffix)
    } else { make_error_at("expected '=>' or '|' in OR pattern", src, pos) };

fn parse_match_or_body(src: String, pos: i64, scrutinee: String, cond: String, prefix: String, suffix: String) -> String =
    let rb = parse_expr(src, pos);
    if is_error(rb) { rb }
    else {
        let body = unpack_ast(rb);
        let new_prefix = prefix + "(if " + cond + " " + body + " ";
        let new_suffix = ")" + suffix;
        parse_match_arm_sep(src, unpack_pos(rb), scrutinee, new_prefix, new_suffix)
    };

// Parse a single pattern value (int, string, bool, enum variant) and return as pack_result
fn parse_match_single_pattern(src: String, pos: i64) -> String =
    let t = next_token_raw(src, pos);
    let kind = tok_kind(t);
    if is_int_literal(kind) {
        let int_text = get_int_text(src, pos, t);
        pack_result(tok_end(t), "(int " + int_text + ")")
    }
    else if kind == TK_MINUS() {
        let t2 = next_token_raw(src, tok_end(t));
        if is_int_literal(tok_kind(t2)) {
            let int_text = "-" + get_int_text(src, tok_end(t), t2);
            pack_result(tok_end(t2), "(int " + int_text + ")")
        } else { make_error_at("expected integer after '-'", src, tok_end(t)) }
    }
    else if kind == TK_STRING_LIT() {
        let str_text = escape_parens_for_ast(get_string_text(src, pos, t));
        pack_result(tok_end(t), "(string " + str_text + ")")
    }
    else if kind == TK_TRUE() { pack_result(tok_end(t), "(bool true)") }
    else if kind == TK_FALSE() { pack_result(tok_end(t), "(bool false)") }
    else if kind == TK_CHAR_LIT() {
        let cv = get_char_value(src, pos);
        pack_result(tok_end(t), "(int " + int_to_string(cv) + ")")
    }
    else if kind == TK_IDENT() {
        let name = get_ident_text(src, pos, t);
        let peek = next_token_raw(src, tok_end(t));
        if tok_kind(peek) == TK_DCOLON() {
            let var_tok = next_token_raw(src, tok_end(peek));
            let variant_name = get_ident_text(src, tok_end(peek), var_tok);
            pack_result(tok_end(var_tok), "(enum_variant <" + name + "> <" + variant_name + ">)")
        } else { make_error_at("expected '::' for enum variant in OR pattern", src, tok_end(t)) }
    }
    else { make_error_at("expected pattern value in OR pattern", src, pos) };

fn parse_match_arm_body(src: String, pos: i64, scrutinee: String, pat_expr: String, prefix: String, suffix: String) -> String =
    let rb = parse_expr(src, pos);
    if is_error(rb) { rb }
    else {
        let body = unpack_ast(rb);
        let cond = "(binop == (var <__match>) " + pat_expr + ")";
        let new_prefix = prefix + "(if " + cond + " " + body + " ";
        let new_suffix = ")" + suffix;
        parse_match_arm_sep(src, unpack_pos(rb), scrutinee, new_prefix, new_suffix)
    };

fn parse_match_arm_sep(src: String, pos: i64, scrutinee: String, prefix: String, suffix: String) -> String =
    let t = next_token_raw(src, pos);
    let kind = tok_kind(t);
    if kind == TK_COMMA() {
        parse_match_arms(src, tok_end(t), scrutinee, prefix, suffix)
    }
    else if kind == TK_RBRACE() {
        let inner = prefix + "(int 0)" + suffix;
        let result = "(let <__match> " + scrutinee + " " + inner + ")";
        pack_result(tok_end(t), result)
    }
    else { make_error_at("expected ',' or '}' after match arm body", src, pos) };

fn parse_match_wildcard(src: String, pos: i64, scrutinee: String, prefix: String, suffix: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) != TK_FAT_ARROW() { make_error_at("expected '=>' after '_'", src, pos) }
    else { parse_match_wildcard_body(src, tok_end(t), scrutinee, prefix, suffix) };

fn parse_match_wildcard_body(src: String, pos: i64, scrutinee: String, prefix: String, suffix: String) -> String =
    let rb = parse_expr(src, pos);
    if is_error(rb) { rb }
    else {
        let body = unpack_ast(rb);
        let inner = prefix + body + suffix;
        let result = "(let <__match> " + scrutinee + " " + inner + ")";
        parse_match_wildcard_end(src, unpack_pos(rb), result)
    };

fn parse_match_wildcard_end(src: String, pos: i64, result: String) -> String =
    let t = next_token_raw(src, pos);
    let kind = tok_kind(t);
    if kind == TK_COMMA() {
        let t2 = next_token_raw(src, tok_end(t));
        if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after wildcard arm", src, tok_end(t)) }
        else { pack_result(tok_end(t2), result) }
    }
    else if kind == TK_RBRACE() {
        pack_result(tok_end(t), result)
    }
    else { make_error_at("expected ',' or '}' after wildcard arm body", src, pos) };

// Variable binding pattern: `n => body_using_n` binds n to the match scrutinee
fn parse_match_var_bind(src: String, pos: i64, scrutinee: String, name: String, prefix: String, suffix: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_IF() {
        // Guard clause: x if cond => body
        parse_match_guard(src, tok_end(t), scrutinee, name, prefix, suffix)
    } else if tok_kind(t) == TK_FAT_ARROW() {
        parse_match_var_bind_body(src, tok_end(t), scrutinee, name, prefix, suffix)
    } else { make_error_at("expected '=>' or 'if' after variable pattern", src, pos) };

// Guard clause: x if cond => body
// Desugars to: (let <__match> scrutinee (let <x> (var <__match>) (if GUARD body SUFFIX)))
fn parse_match_guard(src: String, pos: i64, scrutinee: String, name: String, prefix: String, suffix: String) -> String =
    let cond_result = parse_expr(src, pos);
    if is_error(cond_result) { cond_result }
    else {
        let guard_ast = unpack_ast(cond_result);
        let t = next_token_raw(src, unpack_pos(cond_result));
        if tok_kind(t) != TK_FAT_ARROW() { make_error_at("expected '=>' after guard condition", src, unpack_pos(cond_result)) }
        else { parse_match_guard_body(src, tok_end(t), scrutinee, name, guard_ast, prefix, suffix) }
    };

fn parse_match_guard_body(src: String, pos: i64, scrutinee: String, name: String, guard: String, prefix: String, suffix: String) -> String =
    let rb = parse_expr(src, pos);
    if is_error(rb) { rb }
    else {
        let body = unpack_ast(rb);
        // (let <name> (var <__match>) (if GUARD body ELSE))
        // Two closing parens needed: one for (if, one for (let
        let guarded = "(if " + guard + " " + body + " ";
        let new_prefix = prefix + "(let <" + name + "> (var <__match>) " + guarded;
        let new_suffix = "))" + suffix;
        parse_match_arm_sep(src, unpack_pos(rb), scrutinee, new_prefix, new_suffix)
    };

fn parse_match_var_bind_body(src: String, pos: i64, scrutinee: String, name: String, prefix: String, suffix: String) -> String =
    let rb = parse_expr(src, pos);
    if is_error(rb) { rb }
    else {
        let body = unpack_ast(rb);
        let wrapped = "(let <" + name + "> (var <__match>) " + body + ")";
        let inner = prefix + wrapped + suffix;
        let result = "(let <__match> " + scrutinee + " " + inner + ")";
        parse_match_wildcard_end(src, unpack_pos(rb), result)
    };

// AST: (struct_init <Name> <field1> val1 <field2> val2)

fn parse_struct_init(src: String, pos: i64, name: String) -> String =
    parse_struct_fields(src, pos, "(struct_init <" + name + ">");

fn parse_struct_fields(src: String, pos: i64, acc: String) -> String =
    let t = next_token_raw(src, pos);
    let kind = tok_kind(t);
    if kind == TK_RBRACE() {
        pack_result(tok_end(t), acc + ")")
    }
    else if kind == TK_IDENT() {
        let field_name = get_ident_text(src, pos, t);
        parse_struct_field_colon(src, tok_end(t), acc, field_name)
    }
    else { make_error_at("expected field name or '}' in struct init", src, pos) };

fn parse_struct_field_colon(src: String, pos: i64, acc: String, field_name: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) != TK_COLON() { make_error_at("expected ':' after field name", src, pos) }
    else { parse_struct_field_value(src, tok_end(t), acc, field_name) };

fn parse_struct_field_value(src: String, pos: i64, acc: String, field_name: String) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else {
        let new_acc = acc + " <" + field_name + "> " + unpack_ast(rv);
        parse_struct_field_sep(src, unpack_pos(rv), new_acc)
    };

fn parse_struct_field_sep(src: String, pos: i64, acc: String) -> String =
    let t = next_token_raw(src, pos);
    let kind = tok_kind(t);
    if kind == TK_COMMA() {
        parse_struct_fields(src, tok_end(t), acc)
    }
    else if kind == TK_RBRACE() {
        pack_result(tok_end(t), acc + ")")
    }
    else { make_error_at("expected ',' or '}' after field value", src, pos) };

// ============================================================================
// SECTION 6: Function and Program Parser
// ============================================================================

fn parse_param(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_COLON() {
            let t3 = next_token_raw(src, tok_end(t2));
            let kind = tok_kind(t3);
            if kind == TK_I32() { pack_result(skip_nullable(src, tok_end(t3)), "(param <" + name + "> i32)") } else if kind == TK_I64() { pack_result(skip_nullable(src, tok_end(t3)), "(param <" + name + "> i64)") } else if kind == TK_F64() { pack_result(skip_nullable(src, tok_end(t3)), "(param <" + name + "> f64)") } else if kind == TK_BOOL() { pack_result(skip_nullable(src, tok_end(t3)), "(param <" + name + "> bool)") } else if kind == TK_STRING_TYPE() { pack_result(skip_nullable(src, tok_end(t3)), "(param <" + name + "> String)") } else if kind == TK_STAR() { let t4 = next_token_raw(src, tok_end(t3)); let struct_name = get_ident_text(src, tok_end(t3), t4); pack_result(skip_nullable(src, tok_end(t4)), "(param <" + name + "> *" + struct_name + ")") } else if kind == TK_LBRACKET() { parse_param_array_type(src, tok_end(t3), name) } else if kind == TK_AMP() { parse_param_ref_type(src, tok_end(t3), name) } else if kind == TK_IDENT() { let after_targs = skip_optional_type_args(src, tok_end(t3)); pack_result(skip_nullable(src, after_targs), "(param <" + name + "> i64)") } else { make_error_at("expected parameter type", src, tok_end(t2)) }
        } else { make_error_at("expected ':' after parameter name", src, tok_end(t1)) }
    } else { make_error_at("expected parameter name", src, pos) };

// Skip tokens until ']' and emit param as i64 (array is heap pointer)
fn parse_param_array_type(src: String, pos: i64, name: String) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_RBRACKET() {
        pack_result(skip_nullable(src, tok_end(t)), "(param <" + name + "> i64)")
    } else {
        parse_param_array_type(src, tok_end(t), name)
    };

// All reference types treated as i64 (pointer) at MIR/codegen level
fn parse_param_ref_type(src: String, pos: i64, name: String) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_MUT() {
        // &mut T — skip 'mut', then parse the base type as i64
        let t2 = next_token_raw(src, tok_end(t));
        let k2 = tok_kind(t2);
        if k2 == TK_LBRACKET() { parse_param_array_type(src, tok_end(t2), name) }
        else { pack_result(skip_nullable(src, tok_end(t2)), "(param <" + name + "> i64)") }
    } else if k == TK_LBRACKET() {
        // &[T; N] — delegate to array type parser (handles nullable)
        parse_param_array_type(src, tok_end(t), name)
    } else {
        // &T — just consume the type name and emit i64
        pack_result(skip_nullable(src, tok_end(t)), "(param <" + name + "> i64)")
    };

fn parse_params(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), acc) } else {
        let rp = parse_param(src, pos);
        if is_error(rp) { rp } else {
            let new_acc = acc + " " + unpack_ast(rp);
            let next = next_token_raw(src, unpack_pos(rp));
            if tok_kind(next) == TK_COMMA() { parse_params(src, tok_end(next), new_acc) } else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) } else { make_error_at("expected ',' or ')' in parameter list", src, unpack_pos(rp)) }
        }
    };

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        // v0.95: Skip generic type parameters <T>, <T: Bound> if present
        let after_generics = if tok_kind(t2) == TK_LT() { skip_generic_params(src, tok_end(t2)) } else { tok_end(t1) };
        let t2g = next_token_raw(src, after_generics);
        if tok_kind(t2g) == TK_LPAREN() {
            let rp = parse_params(src, tok_end(t2g), "");
            if is_error(rp) { rp } else {
                let t3 = next_token_raw(src, unpack_pos(rp));
                if tok_kind(t3) == TK_ARROW() {
                    let t4 = next_token_raw(src, tok_end(t3));
                    let ret_type_and_end = parse_return_type(src, tok_end(t3));
                    let ret_type = unpack_ast(ret_type_and_end);
                    let t5 = next_token_raw(src, unpack_pos(ret_type_and_end));
                    let eq_pos = skip_contracts(src, unpack_pos(ret_type_and_end));
                    let rb = parse_expr(src, eq_pos);
                    if is_error(rb) { rb } else {
                        let t6 = next_token_raw(src, unpack_pos(rb));
                        if tok_kind(t6) == TK_SEMI() { pack_result(tok_end(t6), "(fn <" + name + ">" + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") } else { pack_result(unpack_pos(rb), "(fn <" + name + ">" + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") }
                    }
                } else { make_error_at("expected '->' after parameters", src, unpack_pos(rp)) }
            }
        } else { make_error_at("expected '(' after function name", src, after_generics) }
    } else { make_error_at("expected function name after 'fn'", src, pos) };

// v0.95: Skip generic type parameters <T>, <T, U>, <T: Bound + Other> after fn/struct name
// Returns position after closing '>'
fn skip_generic_params(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_GT() { tok_end(t) }
    else if k == TK_EOF() { pos }
    else { skip_generic_params(src, tok_end(t)) };

// Skip generic type arguments <T>, <i64, String> after a type name
// Returns position after closing '>' or original pos if no '<'
fn skip_optional_type_args(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_LT() { skip_generic_params(src, tok_end(t)) }
    else { pos };

fn skip_array_type_tokens(src: String, pos: i64, type_str: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RBRACKET() { pack_result(skip_nullable(src, tok_end(t)), type_str) }
    else { skip_array_type_tokens(src, tok_end(t), type_str) };

// Returns position after the '=' token
fn skip_contracts(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() { tok_end(t) }
    else if k == TK_PRE() or k == TK_POST() {
        // Skip the contract expression (parse and discard)
        let re = parse_expr(src, tok_end(t));
        if is_error(re) { tok_end(t) }
        else { skip_contracts(src, unpack_pos(re)) }
    }
    else if k == TK_WHERE() {
        // v0.95: Skip where clause: where T: Bound + Bound, U: Bound = ...
        skip_where_clause(src, tok_end(t))
    }
    else { tok_end(t) };  // Unexpected token, try advancing

// v0.95: Skip where clause tokens until '=' is found
fn skip_where_clause(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() { tok_end(t) }
    else if k == TK_EOF() { pos }
    else if k == TK_LBRACE() { pos }  // Guard: don't skip past function body
    else { skip_where_clause(src, tok_end(t)) };

fn parse_return_type(src: String, pos: i64) -> String =
    let t4 = next_token_raw(src, pos);
    if tok_kind(t4) == TK_I32() { pack_result(skip_nullable(src, tok_end(t4)), "i32") }
    else if tok_kind(t4) == TK_I64() { pack_result(skip_nullable(src, tok_end(t4)), "i64") }
    else if tok_kind(t4) == TK_F64() { pack_result(skip_nullable(src, tok_end(t4)), "f64") }
    else if tok_kind(t4) == TK_BOOL() { pack_result(skip_nullable(src, tok_end(t4)), "bool") }
    else if tok_kind(t4) == TK_STRING_TYPE() { pack_result(skip_nullable(src, tok_end(t4)), "String") }
    else if tok_kind(t4) == TK_STAR() {
        let t5 = next_token_raw(src, tok_end(t4));
        let sname = get_ident_text(src, tok_end(t4), t5);
        pack_result(skip_nullable(src, tok_end(t5)), "*" + sname)
    }
    // nullable handled by skip_array_type_tokens
    else if tok_kind(t4) == TK_LBRACKET() {
        skip_array_type_tokens(src, tok_end(t4), "i64")
    }
    else if tok_kind(t4) == TK_AMP() {
        let t5 = next_token_raw(src, tok_end(t4));
        // nullable for &[T; N] handled by skip_array_type_tokens
        if tok_kind(t5) == TK_LBRACKET() { skip_array_type_tokens(src, tok_end(t5), "i64") }
        else if tok_kind(t5) == TK_MUT() {
            let t6 = next_token_raw(src, tok_end(t5));
            if tok_kind(t6) == TK_LBRACKET() { skip_array_type_tokens(src, tok_end(t6), "i64") }
            else { pack_result(skip_nullable(src, tok_end(t6)), "i64") }
        }
        else { pack_result(skip_nullable(src, tok_end(t5)), "i64") }
    }
    // nullable handled by skip_tuple_type_tokens
    else if tok_kind(t4) == TK_LPAREN() {
        skip_tuple_type_tokens(src, tok_end(t4), "i64")
    }
    else { let after_targs = skip_optional_type_args(src, tok_end(t4)); pack_result(skip_nullable(src, after_targs), "i64") };

fn skip_tuple_type_tokens(src: String, pos: i64, type_str: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RPAREN() { pack_result(skip_nullable(src, tok_end(t)), type_str) }
    else if tok_kind(t) == TK_EOF() { pack_result(pos, type_str) }
    else { skip_tuple_type_tokens(src, tok_end(t), type_str) };

// Returns position past '?' if present, or original position if not
fn skip_nullable(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_QUESTION() { tok_end(t) } else { pos };

// Emits (fn-pure <name> ...) or (fn-inline <name> ...) etc.
fn parse_fn_with_annotation(src: String, pos: i64, ann: String) -> String =
    let rf = parse_fn(src, pos);
    if is_error(rf) { rf } else {
        let ast = unpack_ast(rf);
        // Replace "(fn " prefix with "(fn-annotation "
        let new_ast = "(fn-" + ann + " " + ast.slice(4, ast.len());
        pack_result(unpack_pos(rf), new_ast)
    };

// Previously O(N²) due to fns + " " + unpack_ast(rf) pattern
// Handles @pure, @const, @inline at the source level (before tokenizer)
fn skip_annotation(src: String, pos: i64) -> String =
    let p = skip_ws_comments(src, pos);
    if p >= src.len() { "" }
    else if src.byte_at(p) == 64 {
        // @ found, scan annotation name
        let name_start = p + 1;
        let name_end = scan_ident_end(src, name_start);
        src.slice(name_start, name_end)
    } else { "" };

fn pos_after_annotation(src: String, pos: i64) -> i64 =
    let p = skip_ws_comments(src, pos);
    if p >= src.len() { p }
    else if src.byte_at(p) == 64 {
        let name_start = p + 1;
        scan_ident_end(src, name_start)
    } else { p };

fn parse_program_sb(src: String, pos: i64, sb: i64) -> String =
    let ann = skip_annotation(src, pos);
    if ann.len() > 0 {
        let after_ann = pos_after_annotation(src, pos);
        let tok2 = next_token_raw(src, after_ann);
        if tok_kind(tok2) == TK_FN() {
            let rf = parse_fn_with_annotation(src, tok_end(tok2), ann);
            if is_error(rf) { rf } else {
                let w1 = sb_push(sb, " ");
                let w2 = sb_push(sb, unpack_ast(rf));
                parse_program_sb(src, unpack_pos(rf), sb)
            }
        } else { make_error_at("expected 'fn' after @" + ann, src, after_ann) }
    } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() {
            let w1 = sb_push(sb, ")");
            sb_build(sb)
        } else if kind == TK_FN() {
            let rf = parse_fn(src, tok_end(tok));
            if is_error(rf) { rf } else {
                let w1 = sb_push(sb, " ");
                let w2 = sb_push(sb, unpack_ast(rf));
                parse_program_sb(src, unpack_pos(rf), sb)
            }
        } else if kind == TK_STRUCT() {
            let end_pos = skip_struct_decl(src, tok_end(tok));
            parse_program_sb(src, end_pos, sb)
        } else if kind == TK_EXTERN() {
            // Skip extern fn declarations (runtime functions are hardcoded)
            let end_pos = skip_extern_fn(src, tok_end(tok));
            parse_program_sb(src, end_pos, sb)
        } else if kind == TK_PUB() {
            // Skip pub and re-parse (next token should be fn/struct/enum/trait/type)
            parse_program_sb(src, tok_end(tok), sb)
        } else if kind == TK_TYPE() {
            // Skip type alias: type Name = ...;
            let end_pos = skip_to_semi(src, tok_end(tok));
            parse_program_sb(src, end_pos, sb)
        } else if kind == TK_ENUM() {
            // Skip enum definition: enum Name { ... }
            let end_pos = skip_struct_decl(src, tok_end(tok));
            parse_program_sb(src, end_pos, sb)
        } else if kind == TK_TRAIT() {
            // Skip trait definition: trait Name { ... }
            let end_pos = skip_brace_block(src, tok_end(tok));
            parse_program_sb(src, end_pos, sb)
        } else if kind == TK_IMPL() {
            // Skip impl block: impl [Trait for] Type { ... }
            let end_pos = skip_brace_block(src, tok_end(tok));
            parse_program_sb(src, end_pos, sb)
        } else if kind == TK_CONST() {
            // const NAME[: TYPE] = EXPR;  →  (fn-const <NAME> () BODY)
            let cr = parse_const_decl(src, tok_end(tok));
            if is_error(cr) { cr } else {
                let w1 = sb_push(sb, " ");
                let w2 = sb_push(sb, unpack_ast(cr));
                parse_program_sb(src, unpack_pos(cr), sb)
            }
        } else { make_error_at("expected 'fn' declaration", src, pos) }
    };

fn skip_extern_fn(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_SEMI() { tok_end(t) }
    else if k == TK_EOF() { pos }
    else { skip_extern_fn(src, tok_end(t)) };

// Parse const declaration: const NAME[: TYPE] = EXPR;
// Transforms to (fn-const <NAME> () BODY)
fn parse_const_decl(src: String, pos: i64) -> String =
    let name_tok = next_token_raw(src, pos);
    if tok_kind(name_tok) != TK_IDENT() { make_error_at("expected name after 'const'", src, pos) }
    else {
        let name = get_ident_text(src, pos, name_tok);
        let t2 = next_token_raw(src, tok_end(name_tok));
        // Optional : TYPE
        let eq_pos = if tok_kind(t2) == TK_COLON() {
            let type_tok = next_token_raw(src, tok_end(t2));
            let t3 = next_token_raw(src, tok_end(type_tok));
            tok_end(type_tok)
        } else { tok_end(name_tok) };
        let eq_tok = next_token_raw(src, eq_pos);
        if tok_kind(eq_tok) != TK_EQ() { make_error_at("expected '=' in const declaration", src, eq_pos) }
        else {
            let body_result = parse_expr(src, tok_end(eq_tok));
            if is_error(body_result) { body_result }
            else {
                let body = unpack_ast(body_result);
                let semi_tok = next_token_raw(src, unpack_pos(body_result));
                let end_pos = if tok_kind(semi_tok) == TK_SEMI() { tok_end(semi_tok) } else { unpack_pos(body_result) };
                pack_result(end_pos, "(fn-const <" + name + "> () " + body + ")")
            }
        }
    };

fn skip_struct_decl(src: String, pos: i64) -> i64 =
    // Skip name
    let t1 = next_token_raw(src, pos);
    // v0.95: Skip generic type params <T> after name if present
    let after_generics = skip_optional_type_args(src, tok_end(t1));
    // Skip to opening brace
    let t2 = next_token_raw(src, after_generics);
    if tok_kind(t2) == TK_LBRACE() {
        skip_to_rbrace(src, tok_end(t2))
    } else { tok_end(t2) };

fn skip_to_rbrace(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RBRACE() { tok_end(tok) }
    else if tok_kind(tok) == TK_EOF() { pos }
    else { skip_to_rbrace(src, tok_end(tok)) };

// Skip tokens until semicolon (for type aliases, extern decls)
fn skip_to_semi(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_SEMI() { tok_end(t) }
    else if k == TK_EOF() { pos }
    else { skip_to_semi(src, tok_end(t)) };

// Skip tokens until opening brace, then skip to matching closing brace
// Used for trait/impl blocks: trait Name { ... }, impl Trait for Type { ... }
fn skip_brace_block(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_LBRACE() { skip_nested_braces(src, tok_end(t), 1) }
    else if k == TK_EOF() { pos }
    else { skip_brace_block(src, tok_end(t)) };

// Skip nested braces with depth tracking
fn skip_nested_braces(src: String, pos: i64, depth: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EOF() { pos }
    else if k == TK_RBRACE() {
        if depth == 1 { tok_end(t) }
        else { skip_nested_braces(src, tok_end(t), depth - 1) }
    }
    else if k == TK_LBRACE() { skip_nested_braces(src, tok_end(t), depth + 1) }
    else { skip_nested_braces(src, tok_end(t), depth) };

// Pre-scans for struct declarations and builds registry:
// Format: "StructName:field0,field1,...;StructName2:field0,field1,...;"
fn build_struct_registry(src: String) -> String =
    let rsb = sb_new();
    let w = scan_structs(src, 0, rsb);
    sb_build(rsb);

fn scan_structs(src: String, pos: i64, rsb: i64) -> i64 =
    if pos >= src.len() { 0 } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() {
            // Unrecognized char (e.g. '@') returns TK_EOF before actual EOF
            // Skip it and continue scanning
            if tok_end(tok) < src.len() { scan_structs(src, tok_end(tok) + 1, rsb) }
            else { 0 }
        }
        else if kind == TK_STRUCT() {
            let end_pos = parse_struct_to_registry(src, tok_end(tok), rsb);
            scan_structs(src, end_pos, rsb)
        } else {
            scan_structs(src, tok_end(tok), rsb)
        }
    };

// Parse struct Name { field: Type, ... } and register fields
fn parse_struct_to_registry(src: String, pos: i64, rsb: i64) -> i64 =
    let t1 = next_token_raw(src, pos);
    let name = get_ident_text(src, pos, t1);
    // v0.95: Skip generic type parameters <T> after struct name
    let after_generics = skip_optional_type_args(src, tok_end(t1));
    let t2 = next_token_raw(src, after_generics);
    if tok_kind(t2) == TK_LBRACE() {
        let w1 = sb_push(rsb, name + ":");
        let end = parse_struct_fields_to_registry(src, tok_end(t2), rsb, 0);
        let w2 = sb_push(rsb, ";");
        end
    } else { tok_end(t2) };

fn parse_struct_fields_to_registry(src: String, pos: i64, rsb: i64, idx: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { tok_end(tok) }
    else if kind == TK_EOF() {
        // Handle unrecognized chars in struct body
        if tok_end(tok) < src.len() { parse_struct_fields_to_registry(src, tok_end(tok) + 1, rsb, idx) }
        else { pos }
    }
    else if kind == TK_IDENT() {
        let field_name = get_ident_text(src, pos, tok);
        // Check field type (after : token) for f64 or *StructName marker
        let type_info = check_field_type(src, tok_end(tok));
        let ptr_type = get_field_ptr_type(src, tok_end(tok));
        let type_suffix = if type_info == 1 { "~d" } else if ptr_type != "" { "~p-" + ptr_type } else { "" };
        let w1 = if idx > 0 { sb_push(rsb, ",") } else { 0 };
        let w2 = sb_push(rsb, field_name + type_suffix);
        let after_field = skip_field_type(src, tok_end(tok));
        parse_struct_fields_to_registry(src, after_field, rsb, idx + 1)
    } else {
        // Skip commas, colons, etc.
        parse_struct_fields_to_registry(src, tok_end(tok), rsb, idx)
    };

// Check if field type is f64 (returns 1 if f64, 0 otherwise)
fn check_field_type(src: String, pos: i64) -> i64 =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_COLON() {
        let t2 = next_token_raw(src, tok_end(t1));
        // f64 is tokenized as TK_F64, not TK_IDENT
        if tok_kind(t2) == TK_F64() { 1 } else { 0 }
    } else { 0 };

fn get_field_ptr_type(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_COLON() {
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_STAR() {
            let t3 = next_token_raw(src, tok_end(t2));
            if tok_kind(t3) == TK_IDENT() { get_ident_text(src, tok_end(t2), t3) }
            else { "" }
        } else { "" }
    } else { "" };

// Skip field type annotation (: Type) until , or }
fn skip_field_type(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_COMMA() { tok_end(tok) }
    else if kind == TK_RBRACE() { pos }
    else if kind == TK_EOF() { pos }
    else { skip_field_type(src, tok_end(tok)) };

// Look up field index from struct registry
// Registry format: "Node:left,right;Body:x,y,z;"

// Enum registry: scans for `enum Name { Var1, Var2, ... }` declarations
// Format: "Color:Red,Green,Blue;Direction:N,S,E,W;"
fn build_enum_registry(src: String) -> String =
    let rsb = sb_new();
    let w = scan_enums(src, 0, rsb);
    sb_build(rsb);

fn scan_enums(src: String, pos: i64, rsb: i64) -> i64 =
    if pos >= src.len() { 0 } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() {
            if tok_end(tok) < src.len() { scan_enums(src, tok_end(tok) + 1, rsb) }
            else { 0 }
        }
        else if kind == TK_ENUM() {
            let end_pos = parse_enum_to_registry(src, tok_end(tok), rsb);
            scan_enums(src, end_pos, rsb)
        } else {
            scan_enums(src, tok_end(tok), rsb)
        }
    };

fn parse_enum_to_registry(src: String, pos: i64, rsb: i64) -> i64 =
    let t1 = next_token_raw(src, pos);
    let name = get_ident_text(src, pos, t1);
    let t2 = next_token_raw(src, tok_end(t1));
    if tok_kind(t2) == TK_LBRACE() {
        let w1 = sb_push(rsb, name + ":");
        let end = parse_enum_variants_to_registry(src, tok_end(t2), rsb, 0);
        let w2 = sb_push(rsb, ";");
        end
    } else { tok_end(t2) };

fn parse_enum_variants_to_registry(src: String, pos: i64, rsb: i64, idx: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { tok_end(tok) }
    else if kind == TK_EOF() { pos }
    else if kind == TK_IDENT() {
        let variant_name = get_ident_text(src, pos, tok);
        let w1 = if idx > 0 { sb_push(rsb, ",") } else { 0 };
        let w2 = sb_push(rsb, variant_name);
        parse_enum_variants_to_registry(src, tok_end(tok), rsb, idx + 1)
    } else {
        // Skip commas, etc.
        parse_enum_variants_to_registry(src, tok_end(tok), rsb, idx)
    };

// Look up enum variant ordinal: enum_variant_ordinal("Color:Red,Green,Blue;", "Color", "Red") → 0
fn enum_variant_ordinal(reg: String, enum_name: String, variant: String) -> i64 =
    let prefix = enum_name + ":";
    let start = find_substr_pos(reg, prefix, 0);
    if start < 0 { -1 }
    else {
        let variants_start = start + prefix.len();
        let semi = find_char_pos(reg, 59, variants_start);
        let variants = reg.slice(variants_start, semi);
        count_variant_index(variants, variant, 0, 0)
    };

fn find_substr_pos(s: String, sub: String, pos: i64) -> i64 =
    if pos + sub.len() > s.len() { -1 }
    else if s.slice(pos, pos + sub.len()) == sub { pos }
    else { find_substr_pos(s, sub, pos + 1) };

fn find_char_pos(s: String, ch: i64, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == ch { pos }
    else { find_char_pos(s, ch, pos + 1) };

fn count_variant_index(variants: String, target: String, pos: i64, idx: i64) -> i64 =
    if pos >= variants.len() { -1 }
    else {
        let comma = find_char_pos(variants, 44, pos);
        let name = variants.slice(pos, comma);
        if name == target { idx }
        else { count_variant_index(variants, target, comma + 1, idx + 1) }
    };

// Resolve (enum_variant <Name> <Variant>) → (int N) in AST text
fn resolve_enum_variants_in_ast(ast: String, enum_reg: String) -> String =
    if enum_reg == "" { ast }
    else {
        let sb = sb_new();
        let w = resolve_ev_sb(ast, 0, enum_reg, sb);
        sb_build(sb)
    };

fn resolve_ev_sb(ast: String, pos: i64, enum_reg: String, sb: i64) -> i64 =
    if pos >= ast.len() { 0 }
    else {
        let marker = "(enum_variant ";
        let found = find_substr_pos(ast, marker, pos);
        if found < 0 {
            let w = sb_push_range(sb, ast, pos, ast.len());
            0
        } else {
            let w1 = sb_push_range(sb, ast, pos, found);
            let after_marker = found + marker.len();
            resolve_ev_one(ast, after_marker, enum_reg, sb)
        }
    };

fn resolve_ev_one(ast: String, pos: i64, enum_reg: String, sb: i64) -> i64 =
    // pos points to: <Name> <Variant>)
    let name_start = pos + 1;
    let name_end = find_char_pos(ast, 62, name_start);
    let enum_name = ast.slice(name_start, name_end);
    // After "> <", skip 3 chars to get variant name start
    let var_start = name_end + 3;
    let var_end = find_char_pos(ast, 62, var_start);
    let variant = ast.slice(var_start, var_end);
    let close = var_end + 2;
    let ordinal = enum_variant_ordinal(enum_reg, enum_name, variant);
    let replacement = if ordinal >= 0 { "(int " + int_to_string(ordinal) + ")" } else { "(int 0)" };
    let w = sb_push(sb, replacement);
    resolve_ev_sb(ast, close, enum_reg, sb);

fn parse_source(src: String) -> String =
    let sb = sb_new();
    let w1 = sb_push(sb, "(program");
    parse_program_sb(src, 0, sb);

// ============================================================================
// SECTION 7: S-Expression Utilities (for lowering)
// ============================================================================

fn low_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

fn low_skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_whitespace(s.byte_at(pos)) { low_skip_ws(s, pos + 1) } else { pos };

fn low_is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

fn low_is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
    c == 60 or c == 62 or c == 61 or c == 33;

fn low_find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_ident_char(s.byte_at(pos)) { low_find_ident_end(s, pos + 1) } else { pos };

fn low_find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_op_char(s.byte_at(pos)) { low_find_op_end(s, pos + 1) } else { pos };

fn low_starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() { false } else { match_bytes(s, prefix, pos, 0) };

fn low_find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() { pos } else {
        let c = s.byte_at(pos);
        if c == 40 { low_find_close_paren(s, pos + 1, depth + 1) } else if c == 41 { if depth == 1 { pos } else { low_find_close_paren(s, pos + 1, depth - 1) } } else { low_find_close_paren(s, pos + 1, depth) }
    };

fn extract_paren_content(s: String) -> String =
    if s.len() < 2 { "" } else if s.byte_at(0) == 40 {
        let end = low_find_close_paren(s, 0, 0);
        s.slice(1, end)
    } else { "" };

fn get_node_type(ast: String) -> String =
    if ast.len() == 0 { "" } else {
        let content = extract_paren_content(ast);
        let pos = low_skip_ws(content, 0);
        if pos >= content.len() { "" } else {
            let c = content.byte_at(pos);
            if low_is_ident_char(c) {
                let endp = low_find_ident_end(content, pos);
                content.slice(pos, endp)
            } else if low_is_op_char(c) {
                let endp = low_find_op_end(content, pos);
                content.slice(pos, endp)
            } else { "" }
        }
    };

// v0.92: Check if AST expression produces a float value
// Detects float literals and binops on float operands (recursive)
fn is_float_expr(ast: String) -> bool =
    let ntype = get_node_type(ast);
    if ntype == "float" { true }
    else if ntype == "unary" { is_float_expr(get_child(ast, 1)) }
    else if ntype == "binop" { is_float_expr(get_child(ast, 1)) }
    else { false };

fn get_child(ast: String, idx: i64) -> String =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let after_type = if end1 > pos { end1 } else { low_find_op_end(content, pos) };
    get_child_at(content, after_type, idx);

fn get_child_at(content: String, pos: i64, idx: i64) -> String =
    if idx < 0 { "" } else {
        let p = low_skip_ws(content, pos);
        if p >= content.len() { "" } else if idx == 0 { read_sexp_at(content, p) } else {
            let child = read_sexp_at(content, p);
            let next_pos = p + child.len();
            get_child_at(content, next_pos, idx - 1)
        }
    };

fn read_sexp_at(s: String, pos: i64) -> String =
    let p = low_skip_ws(s, pos);
    if p >= s.len() { "" } else {
        let c = s.byte_at(p);
        if c == 40 {
            let end = low_find_close_paren(s, p, 0);
            s.slice(p, end + 1)
        } else if c == 60 and p + 1 < s.len() and is_ident_start(s.byte_at(p + 1)) {
            // This fixes parsing of < operator in AST like (binop < ...)
            let end = find_angle_end(s, p);
            s.slice(p, end)
        } else if is_digit(c) or c == 45 {
            let end = find_number_end(s, p);
            s.slice(p, end)
        } else if low_is_ident_char(c) {
            let end = low_find_ident_end(s, p);
            s.slice(p, end)
        } else if low_is_op_char(c) {
            let end = low_find_op_end(s, p);
            s.slice(p, end)
        } else { "" }
    };

fn find_angle_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 62 { pos + 1 } else { find_angle_end(s, pos + 1) };

fn find_number_end(s: String, pos: i64) -> i64 =
    let p = if pos < s.len() and s.byte_at(pos) == 45 { pos + 1 } else { pos };
    let int_end = find_digits_end(s, p);
    // v0.91: Check for '.' followed by digit (float literal)
    if int_end + 1 < s.len() and s.byte_at(int_end) == 46 and is_digit(s.byte_at(int_end + 1)) {
        find_digits_end(s, int_end + 1)
    } else { int_end };

fn find_digits_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { find_digits_end(s, pos + 1) } else { pos };

fn extract_name(ast: String) -> String =
    let child = get_child(ast, 0);
    if child.len() >= 2 and child.byte_at(0) == 60 { child.slice(1, child.len() - 1) } else { child };

// Finds all "(var <oldname>)" patterns and replaces with "(var <newname>)"

fn rename_name_in_ast(ast: String, oldname: String, newname: String) -> String =
    rename_name_in_ast_at(ast, oldname, newname, 0, "");

fn rename_name_in_ast_at(ast: String, oldname: String, newname: String, pos: i64, acc: String) -> String =
    if pos >= ast.len() { acc } else {
        let lt_pos = find_char_at(ast, 60, pos);
        if lt_pos < 0 {
            acc + ast.slice(pos, ast.len())
        } else {
            let end_pos = lt_pos + 1 + oldname.len();
            if end_pos >= ast.len() {
                rename_name_in_ast_at(ast, oldname, newname, lt_pos + 1, acc + ast.slice(pos, lt_pos + 1))
            } else if ast.byte_at(end_pos) != 62 {
                rename_name_in_ast_at(ast, oldname, newname, lt_pos + 1, acc + ast.slice(pos, lt_pos + 1))
            } else {
                let candidate = ast.slice(lt_pos + 1, end_pos);
                if candidate == oldname {
                    let before = ast.slice(pos, lt_pos);
                    rename_name_in_ast_at(ast, oldname, newname, end_pos + 1, acc + before + "<" + newname + ">")
                } else {
                    rename_name_in_ast_at(ast, oldname, newname, lt_pos + 1, acc + ast.slice(pos, lt_pos + 1))
                }
            }
        }
    };

// Find character c starting from pos (returns -1 if not found)
fn find_char_at(ast: String, c: i64, pos: i64) -> i64 =
    if pos >= ast.len() { 0 - 1 }
    else if ast.byte_at(pos) == c { pos }
    else { find_char_at(ast, c, pos + 1) };

fn extract_int_value(ast: String) -> i64 =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let num_start = low_skip_ws(content, end1);
    parse_int_from(content, num_start, 0);

fn parse_hex_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if is_hex_digit(c) { parse_hex_from(s, pos + 1, acc * 16 + hex_digit_val(c)) }
        else if c == 95 { parse_hex_from(s, pos + 1, acc) }
        else { acc }
    };

fn parse_bin_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if c == 48 or c == 49 { parse_bin_from(s, pos + 1, acc * 2 + (c - 48)) }
        else if c == 95 { parse_bin_from(s, pos + 1, acc) }
        else { acc }
    };

// v0.95: Parse octal digits from string
fn parse_oct_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if c >= 48 and c <= 55 { parse_oct_from(s, pos + 1, acc * 8 + (c - 48)) }
        else if c == 95 { parse_oct_from(s, pos + 1, acc) }
        else { acc }
    };

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if c == 45 { 0 - parse_int_from(s, pos + 1, 0) }
        else if c == 48 and pos + 1 < s.len() and (s.byte_at(pos + 1) == 120 or s.byte_at(pos + 1) == 88) {
            parse_hex_from(s, pos + 2, 0)
        } else if c == 48 and pos + 1 < s.len() and (s.byte_at(pos + 1) == 98 or s.byte_at(pos + 1) == 66) {
            parse_bin_from(s, pos + 2, 0)
        } else if c == 48 and pos + 1 < s.len() and (s.byte_at(pos + 1) == 111 or s.byte_at(pos + 1) == 79) {
            parse_oct_from(s, pos + 2, 0)
        } else if is_digit(c) { parse_int_from(s, pos + 1, acc * 10 + (c - 48)) }
        else if c == 95 { parse_int_from(s, pos + 1, acc) }
        else { acc }
    };

// v0.91: Extract float value text from AST node "(float 3.14)" → "3.14"
fn extract_float_value_text(ast: String) -> String =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let val_start = low_skip_ws(content, end1);
    content.slice(val_start, content.len());

fn is_fn_node(ast: String) -> bool =
    let nt = get_node_type(ast);
    nt == "fn" or nt == "fn-pure" or nt == "fn-const" or nt == "fn-inline";

// ============================================================================
// SECTION 8: MIR Result Packing
// ============================================================================

fn pack_ids(temp_id: i64, block_id: i64) -> i64 = temp_id * 1000000 + block_id;
fn unpack_temp(packed: i64) -> i64 = packed / 1000000;
fn unpack_block(packed: i64) -> i64 = packed % 1000000;

// Returns 1 for non-trivial ifs/whiles/loops, 0 for simple nodes
// Under-counts for complex nested cases, but sufficient for seq offset computation
fn shallow_blocks(ast: String) -> i64 =
    let ntype = get_node_type(ast);
    if ntype == "if" {
        let then_b = get_child(ast, 1);
        let else_b = get_child(ast, 2);
        if is_pure_expr(then_b) and is_pure_expr(else_b) { 0 }
        else { 1 }
    } else if ntype == "while" or ntype == "loop" or ntype == "for" or ntype == "for_incl" or ntype == "for_step" or ntype == "for_step_incl" { 1 }
    else if ntype == "break" or ntype == "continue" or ntype == "return" { 1 }
    else { 0 };

fn get_exit_label(ast: String, entry_label: String, block_id: i64) -> String =
    let ntype = get_node_type(ast);
    if ntype == "if" {
        let then_b = get_child(ast, 1);
        let else_b = get_child(ast, 2);
        if is_pure_expr(then_b) and is_pure_expr(else_b) { entry_label }
        else { "merge_" + int_to_string(block_id) }
    } else if ntype == "while" {
        "exit_" + int_to_string(block_id)
    } else if ntype == "loop" {
        "exit_" + int_to_string(block_id)
    } else if ntype == "for" or ntype == "for_incl" or ntype == "for_step" or ntype == "for_step_incl" {
        "for_end_" + int_to_string(block_id)
    } else if ntype == "break" {
        "after_break_" + int_to_string(block_id)
    } else if ntype == "continue" {
        "after_continue_" + int_to_string(block_id)
    } else if ntype == "return" {
        "after_return_" + int_to_string(block_id)
    } else if ntype == "block" {
        let inner = block_inner(ast);
        get_exit_label(inner, entry_label, block_id)
    } else if ntype == "seq" {
        // Recurse into last first; if it returns entry_label (no blocks),
        // fall back to first. Uses shallow_blocks for block_id offset.
        let first = seq_first(ast);
        let last = seq_second(ast);
        let first_blocks = shallow_blocks(first);
        let last_exit = get_exit_label(last, entry_label, block_id + first_blocks);
        if last_exit != entry_label { last_exit }
        else { get_exit_label(first, entry_label, block_id) }
    } else if ntype == "let_mut" {
        let body = get_child(ast, 2);
        get_exit_label(body, entry_label, block_id)
    } else if ntype == "let" {
        let body = get_child(ast, 2);
        get_exit_label(body, entry_label, block_id)
    } else if ntype == "tuple" or ntype == "array" or ntype == "call" or ntype == "method" or ntype == "struct_init" {
        scan_exit_children(ast, 0, count_children(ast), entry_label, block_id)
    } else if ntype == "binop" {
        // Left then right operand
        let left_exit = get_exit_label(get_child(ast, 1), entry_label, block_id);
        if left_exit == entry_label { get_exit_label(get_child(ast, 2), entry_label, block_id) }
        else { left_exit }
    } else if ntype == "unary" {
        get_exit_label(get_child(ast, 1), entry_label, block_id)
    } else if ntype == "assign" {
        get_exit_label(get_child(ast, 1), entry_label, block_id)
    } else {
        entry_label
    };

fn scan_exit_children(ast: String, idx: i64, count: i64, entry_label: String, block_id: i64) -> String =
    if idx >= count { entry_label }
    else {
        let child = get_child(ast, idx);
        let child_exit = get_exit_label(child, entry_label, block_id);
        if child_exit == entry_label { scan_exit_children(ast, idx + 1, count, entry_label, block_id) }
        else { child_exit }
    };

fn sb_push_mir(sb: i64, text: String) -> i64 =
    if text.len() > 0 {
        let len = sb_len(sb);
        let w0 = if len > 0 { sb_push(sb, "|") } else { 0 };
        sb_push(sb, text)
    } else { 0 };

// ============================================================================
// SECTION 8a: Iterative Expression Lowering (v0.60.300)
// ============================================================================
// Trampolining approach to avoid stack overflow on deeply nested expressions.
// Uses string-encoded work stack and result stack.
// Work items use TILDE (~) as field separator, TAB (chr(9)) as item separator.
// This allows the trampoline to be tail-recursive, which LLVM optimizes to a loop.

// Work item types:
// EX~ast~temp_id~block_id - Evaluate expression
// IN~ast~temp_id~block_id - Evaluate int literal
// BO~ast~temp_id~block_id - Evaluate bool literal
// ST~ast~temp_id~block_id - Evaluate string literal
// VA~ast~temp_id~block_id - Evaluate variable
// BI~op~temp_id~block_id~left_ast~right_ast - Start binop
// BM~op~left_id~temp_id~block_id~right_ast - Binop: left done, do right
// BF~op~left_id~right_id~temp_id~block_id - Binop: finalize
// UN~op~temp_id~block_id~operand_ast - Start unary
// UF~op~operand_id~temp_id~block_id - Unary: finalize
// IF~ast~temp_id~block_id - Start if
// IC~my_bid~cond_id~cond_temp~then_ast~else_ast - If: cond done, do then
// IT~my_bid~cond_id~then_label~else_label~merge_label~then_id~then_exit~then_temp~then_block~else_ast - If: then done
// IX~my_bid~then_id~then_exit~else_id~else_exit~else_temp~else_block - If: finalize
// LE~name~temp_id~block_id~value_ast~body_ast - Start let
// LB~name~val_id~val_temp~val_block~body_ast - Let: value done, do body
// CA~name~temp_id~block_id~idx~args_acc~ast - Call: start/continue
// CF~name~temp_id~block_id~args_acc - Call: finalize
// ME~fn_name~temp_id~block_id~recv_ast~idx~ast - Method: start
// MA~fn_name~recv_id~temp_id~block_id~idx~args_acc~ast - Method: continue
// MF~fn_name~temp_id~block_id~args_acc - Method: finalize

fn work_sep() -> String = chr(9);
// This eliminates escape_field/unescape_field overhead (50K+ SB creations)


fn pop_work_item(stack: String) -> String =
    if stack == "" { "" } else {
        let sep_pos = find_work_sep(stack, 0);
        if sep_pos >= stack.len() { stack } else { stack.slice(0, sep_pos) }
    };

fn pop_work_rest(stack: String) -> String =
    if stack == "" { "" } else {
        let sep_pos = find_work_sep(stack, 0);
        if sep_pos >= stack.len() { "" } else { stack.slice(sep_pos + 1, stack.len()) }
    };

fn find_work_sep(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 9 { pos }
    else { find_work_sep(s, pos + 1) };

fn get_field(item: String, idx: i64) -> String =
    get_field_at(item, 0, idx);

fn get_field_at(item: String, pos: i64, idx: i64) -> String =
    if pos >= item.len() { "" }
    else if idx == 0 {
        let end = find_field_sep(item, pos);
        item.slice(pos, end)
    } else {
        let sep = find_field_sep(item, pos);
        if sep >= item.len() { "" } else { get_field_at(item, sep + 1, idx - 1) }
    };

fn find_field_sep(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 1 { pos }
    else { find_field_sep(s, pos + 1) };

// ~ (126) -> \^ (92, 94), \ (92) -> \\ (92, 92)

fn make_work(t: String, f1: String, f2: String, f3: String, f4: String, f5: String) -> String =
    t + chr(1) + f1 + chr(1) + f2 + chr(1) + f3 + chr(1) + f4 + chr(1) + f5;

fn make_work3(t: String, f1: String, f2: String, f3: String) -> String =
    t + chr(1) + f1 + chr(1) + f2 + chr(1) + f3;

fn work3_get1(item: String) -> String = get_field(item, 1);

fn make_work4(t: String, f1: String, f2: String, f3: String, f4: String) -> String =
    t + chr(1) + f1 + chr(1) + f2 + chr(1) + f3 + chr(1) + f4;


fn make_work7(t: String, f1: String, f2: String, f3: String, f4: String, f5: String, f6: String, f7: String) -> String =
    t + chr(1) + f1 + chr(1) + f2 + chr(1) + f3 + chr(1) + f4 + chr(1) + f5 + chr(1) + f6 + chr(1) + f7;


fn i2s(n: i64) -> String = int_to_string(n);
fn s2i(s: String) -> i64 = parse_int_simple(s, 0, 0);

fn parse_int_simple(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc }
    else {
        let c = s.byte_at(pos);
        if c >= 48 and c <= 57 { parse_int_simple(s, pos + 1, acc * 10 + (c - 48)) }
        else { acc }
    };

// Main iterative lowering entry point
// Uses a result-threaded trampoline: each step receives and returns (temp_id, block_id, exit_label)
fn lower_expr_iter(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let init_work = make_work3("EX", ast, i2s(temp_id), i2s(block_id));
    let exit_sb = sb_new();
    let work_sb = sb_new();
    let result = trampoline_v3(init_work, temp_id, block_id, "", sb, exit_sb, work_sb);
    let _ef = sb_free(exit_sb);
    let _wf = sb_free(work_sb);
    result;

// Trampoline v3: Optimized with reusable SBs and leaf step fast path
// Key optimizations over v2:
// 1. exit_sb and work_sb are reused across steps (clear instead of alloc/free)
// 2. Leaf steps (no new work, unchanged exit/block) use fast path
// 3. Single-pass pipe parsing for step results
fn trampoline_v3(work_stack: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64, exit_sb: i64, work_sb: i64) -> i64 =
    if work_stack == "" { pack_ids(cur_temp, cur_block) }
    else {
        let _save = bmb_arena_save();
        let item = pop_work_item(work_stack);
        let rest = pop_work_rest(work_stack);
        // Process item with current result (MIR pushed to sb which is malloc-based)
        let step = do_step(item, cur_temp, cur_block, cur_exit_label, sb);
        // Check for leaf step: no pipes = leaf (just temp integer)
        let p1 = find_single_pipe(step, 0);
        if p1 >= step.len() {
            // LEAF FAST PATH: step = just new_temp as string
            // No new work, block and exit_label unchanged
            let new_temp = s2i(step);
            // Only need to preserve rest of work stack
            let _wc = sb_clear(work_sb);
            let _wp = if rest.len() > 0 { sb_push(work_sb, rest) } else { 0 };
            let _restore = bmb_arena_restore();
            let combined = if sb_len(work_sb) == 0 { "" } else { sb_build(work_sb) };
            trampoline_v3(combined, new_temp, cur_block, cur_exit_label, sb, exit_sb, work_sb)
        } else {
            // FULL PATH: parse step result "temp|block|exit_label|work"
            let new_temp = s2i(step.slice(0, p1));
            let p2 = find_single_pipe(step, p1 + 1);
            let new_block = s2i(step.slice(p1 + 1, p2));
            let p3 = find_single_pipe(step, p2 + 1);
            // Copy exit_label to reusable SB (survives restore)
            let _ec = sb_clear(exit_sb);
            let _ep = sb_push(exit_sb, step.slice(p2 + 1, p3));
            // Build combined work stack in reusable SB (survives restore)
            let _wc = sb_clear(work_sb);
            let new_work = if p3 >= step.len() { "" } else { step.slice(p3 + 1, step.len()) };
            let _wp = if new_work == "" and rest == "" { 0 }
                      else if new_work == "" { sb_push(work_sb, rest) }
                      else if rest == "" { sb_push(work_sb, new_work) }
                      else { let _a = sb_push(work_sb, new_work); let _b = sb_push(work_sb, work_sep()); sb_push(work_sb, rest) };
            let _restore = bmb_arena_restore();
            // Rebuild strings from SBs in fresh arena
            let new_exit_label = sb_build(exit_sb);
            let combined = if sb_len(work_sb) == 0 { "" } else { sb_build(work_sb) };
            trampoline_v3(combined, new_temp, new_block, new_exit_label, sb, exit_sb, work_sb)
        }
    };

// Step result: encodes new work items and result
// Format: "new_temp|new_block|exit_label|new_work"
fn make_step(temp: i64, block: i64, exit_label: String, work: String) -> String =
    i2s(temp) + "|" + i2s(block) + "|" + exit_label + "|" + work;

// Used by steps that: (1) have no new work, (2) don't change block_id, (3) don't change exit_label
fn make_step_leaf(temp: i64) -> String = i2s(temp);


fn find_single_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 124 { pos }
    else { find_single_pipe(s, pos + 1) };

// Process a single work item with current result
// Uses first two bytes of work item directly for O(1) dispatch via nested if/else on bytes
fn do_step(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let b0 = item.byte_at(0);
    // Group by first byte for faster average dispatch
    if b0 == 69 { // 'E'
        step_expr(item, cur_temp, cur_block, cur_exit_label, sb) // EX
    }
    else if b0 == 66 { // 'B' — BI, BR, BF, BO, BK
        let b1 = item.byte_at(1);
        if b1 == 73 { step_binop_start(item, cur_temp, cur_block, cur_exit_label, sb) }       // BI
        else if b1 == 82 { step_binop_right(item, cur_temp, cur_block, cur_exit_label, sb) }   // BR
        else if b1 == 70 { step_binop_final(item, cur_temp, cur_block, cur_exit_label, sb) }   // BF
        else if b1 == 79 { step_bool(item, cur_temp, cur_block, cur_exit_label, sb) }          // BO
        else if b1 == 75 { step_break(item, cur_temp, cur_block, cur_exit_label, sb) }         // BK
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 73 { // 'I' — IN, IS, IT, IE, IX, IZ
        let b1 = item.byte_at(1);
        if b1 == 78 { step_int(item, cur_temp, cur_block, cur_exit_label, sb) }            // IN
        else if b1 == 83 { step_if_start(item, cur_temp, cur_block, cur_exit_label, sb) }  // IS
        else if b1 == 84 { step_if_then(item, cur_temp, cur_block, cur_exit_label, sb) }   // IT
        else if b1 == 69 { step_if_else(item, cur_temp, cur_block, cur_exit_label, sb) }   // IE
        else if b1 == 88 { step_if_final(item, cur_temp, cur_block, cur_exit_label, sb) }  // IX
        else if b1 == 90 { step_if_select(item, cur_temp, cur_block, cur_exit_label, sb) } // IZ v0.93.2
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 83 { // 'S' — ST, SQ, S2, SI, S3, S4, S5, SF, SV, SW
        let b1 = item.byte_at(1);
        if b1 == 84 { step_string(item, cur_temp, cur_block, cur_exit_label, sb) }             // ST
        else if b1 == 81 { step_seq_start(item, cur_temp, cur_block, cur_exit_label, sb) }     // SQ
        else if b1 == 50 { step_seq_second(item, cur_temp, cur_block, cur_exit_label, sb) }    // S2
        else if b1 == 73 { step_set_index_start(item, cur_temp, cur_block, cur_exit_label, sb) }  // SI
        else if b1 == 51 { step_set_index_idx(item, cur_temp, cur_block, cur_exit_label, sb) }    // S3
        else if b1 == 52 { step_set_index_val(item, cur_temp, cur_block, cur_exit_label, sb) }    // S4
        else if b1 == 53 { step_set_index_final(item, cur_temp, cur_block, cur_exit_label, sb) }  // S5
        else if b1 == 70 { step_set_field_start(item, cur_temp, cur_block, cur_exit_label, sb) }  // SF
        else if b1 == 86 { step_set_var_start(item, cur_temp, cur_block, cur_exit_label, sb) }    // SV
        else if b1 == 87 { step_set_var_final(item, cur_temp, cur_block, cur_exit_label, sb) }    // SW
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 67 { // 'C' — CS, CA, CF, CN, C6
        let b1 = item.byte_at(1);
        if b1 == 83 { step_call_start(item, cur_temp, cur_block, cur_exit_label, sb) }     // CS
        else if b1 == 65 { step_call_arg(item, cur_temp, cur_block, cur_exit_label, sb) }  // CA
        else if b1 == 70 { step_call_final(item, cur_temp, cur_block, cur_exit_label, sb) }// CF
        else if b1 == 78 { step_continue(item, cur_temp, cur_block, cur_exit_label, sb) }  // CN
        else if b1 == 54 { step_cast_to_i64(item, cur_temp, cur_block, cur_exit_label, sb) }// C6 v0.93.6
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 76 { // 'L' — LS, LB
        let b1 = item.byte_at(1);
        if b1 == 83 { step_let_start(item, cur_temp, cur_block, cur_exit_label, sb) }  // LS
        else if b1 == 66 { step_let_body(item, cur_temp, cur_block, cur_exit_label, sb) } // LB
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 65 { // 'A' — AS, AF, AI, A2, A3, AL, AR
        let b1 = item.byte_at(1);
        if b1 == 83 { step_assign_start(item, cur_temp, cur_block, cur_exit_label, sb) }          // AS
        else if b1 == 70 { step_assign_final(item, cur_temp, cur_block, cur_exit_label, sb) }     // AF
        else if b1 == 73 { step_array_index_start(item, cur_temp, cur_block, cur_exit_label, sb) }// AI
        else if b1 == 50 { step_array_index_idx(item, cur_temp, cur_block, cur_exit_label, sb) }  // A2
        else if b1 == 51 { step_array_index_final(item, cur_temp, cur_block, cur_exit_label, sb) }// A3
        else if b1 == 76 { step_array_literal(item, cur_temp, cur_block, cur_exit_label, sb) }    // AL
        else if b1 == 82 { step_array_repeat(item, cur_temp, cur_block, cur_exit_label, sb) }     // AR
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 77 { // 'M' — MS, MA, MF
        let b1 = item.byte_at(1);
        if b1 == 83 { step_method_start(item, cur_temp, cur_block, cur_exit_label, sb) }  // MS
        else if b1 == 65 { step_method_arg(item, cur_temp, cur_block, cur_exit_label, sb) }// MA
        else if b1 == 70 { step_method_final(item, cur_temp, cur_block, cur_exit_label, sb) } // MF
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 78 { // 'N' — NR, NO (nullable methods)
        let b1 = item.byte_at(1);
        if b1 == 82 { step_nullable_result(item, cur_temp, cur_block, cur_exit_label, sb) }  // NR
        else if b1 == 79 { step_nullable_or(item, cur_temp, cur_block, cur_exit_label, sb) } // NO
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 86 { // 'V' — VA, VM, VB
        let b1 = item.byte_at(1);
        if b1 == 65 { step_var(item, cur_temp, cur_block, cur_exit_label, sb) }            // VA
        else if b1 == 77 { step_mut_start(item, cur_temp, cur_block, cur_exit_label, sb) } // VM
        else if b1 == 66 { step_mut_body(item, cur_temp, cur_block, cur_exit_label, sb) }  // VB
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 85 { // 'U' — UN, UF, UT
        let b1 = item.byte_at(1);
        if b1 == 78 { step_unary_start(item, cur_temp, cur_block, cur_exit_label, sb) }    // UN
        else if b1 == 70 { step_unary_final(item, cur_temp, cur_block, cur_exit_label, sb) }// UF
        else if b1 == 84 { step_unit(item, cur_temp, cur_block, cur_exit_label, sb) }       // UT
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 70 { // 'F' — FL, FA, F2, FP, FQ
        let b1 = item.byte_at(1);
        if b1 == 76 { step_float(item, cur_temp, cur_block, cur_exit_label, sb) }              // FL
        else if b1 == 65 { step_field_access_start(item, cur_temp, cur_block, cur_exit_label, sb) } // FA
        else if b1 == 50 { step_field_access_final(item, cur_temp, cur_block, cur_exit_label, sb) } // F2
        else if b1 == 80 { step_cast_ptr_f64_start(item, cur_temp, cur_block, cur_exit_label, sb) } // FP
        else if b1 == 81 { step_cast_ptr_f64_finish(item, cur_temp, cur_block, cur_exit_label, sb) }// FQ
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 82 { // 'R' — RT, RV
        let b1 = item.byte_at(1);
        if b1 == 84 { step_return(item, cur_temp, cur_block, cur_exit_label, sb) }         // RT
        else if b1 == 86 { step_return_value(item, cur_temp, cur_block, cur_exit_label, sb) }// RV
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 71 { // 'G' — G2, G3
        let b1 = item.byte_at(1);
        if b1 == 50 { step_set_field_val(item, cur_temp, cur_block, cur_exit_label, sb) }    // G2
        else if b1 == 51 { step_set_field_final(item, cur_temp, cur_block, cur_exit_label, sb) } // G3
        else { make_step_leaf(cur_temp) }
    }
    else if b0 == 84 { // 'T' — TU
        step_tuple(item, cur_temp, cur_block, cur_exit_label, sb) // TU
    }
    else if b0 == 87 { // 'W' — W3 (cast to i32) v0.95
        step_cast_to_i32(item, cur_temp, cur_block, cur_exit_label, sb) // W3
    }
    else if b0 == 88 { // 'X' — XF (cast to f64) v0.93.6
        step_cast_to_f64(item, cur_temp, cur_block, cur_exit_label, sb) // XF
    }
    else { make_step_leaf(cur_temp) };

// EX: Dispatch based on node type - expand to specific handler
fn step_expr(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let ntype = get_node_type(ast);
    // INLINE LEAF: int literal
    if ntype == "int" {
        let val = extract_int_value(ast);
        let tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + tmp + " = const " + i2s(val));
        make_step_leaf(cur_temp + 1)
    }
    // INLINE LEAF: float literal
    else if ntype == "float" {
        let text = extract_float_value_text(ast);
        let tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + tmp + " = const F:" + text);
        make_step_leaf(cur_temp + 1)
    }
    // INLINE LEAF: boolean literal
    else if ntype == "bool" {
        let child = get_child(ast, 0);
        let val = if child == "true" { 1 } else { 0 };
        let tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + tmp + " = const " + i2s(val));
        make_step_leaf(cur_temp + 1)
    }
    // INLINE LEAF: string literal
    else if ntype == "string" {
        let str_content = extract_string_content(ast);
        let tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + tmp + " = string " + chr(34) + str_content + chr(34));
        make_step_leaf(cur_temp + 1)
    }
    // INLINE LEAF: variable reference
    else if ntype == "var" {
        let name = extract_name(ast);
        let tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + tmp + " = copy %" + name);
        make_step_leaf(cur_temp + 1)
    }
    else if ntype == "binop" {
        let op = get_child(ast, 0);
        let left = get_child(ast, 1);
        let right = get_child(ast, 2);
        // v0.92: Float-aware binop - prefix op with "f" for float operands
        let mir_op = if is_float_expr(left) { "f" + op } else { op };
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("BI", mir_op, left, right, ""))
    }
    else if ntype == "unary" {
        let op = get_child(ast, 0);
        let operand = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("UN", op, operand, ""))
    }
    else if ntype == "if" {
        let cond = get_child(ast, 0);
        let then_br = get_child(ast, 1);
        let else_br = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("IS", cond, then_br, else_br, ""))
    }
    else if ntype == "let" {
        let name = extract_name(ast);
        let value = get_child(ast, 1);
        let body = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("LS", name, value, body, ""))
    }
    // v0.92: let_mut uses alloca/store/load for correct loop behavior
    else if ntype == "let_mut" {
        let name = extract_name(ast);
        let value = get_child(ast, 1);
        let body = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("VM", name, value, body, ""))
    }
    else if ntype == "call" {
        let name = extract_name(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("CS", name, ast, "1", ""))
    }
    else if ntype == "method" {
        let method_name = get_child(ast, 0);
        let receiver = get_child(ast, 1);
        if is_nullable_method(method_name) {
            make_step(cur_temp, cur_block, cur_exit_label,
                make_work3("EX", receiver, "", "") + work_sep() +
                make_work4("NR", method_name, ast, "", ""))
        } else {
            let fn_name = method_to_runtime_fn(method_name);
            make_step(cur_temp, cur_block, cur_exit_label, make_work("MS", fn_name, receiver, ast, "2", ""))
        }
    }
    else if ntype == "block" {
        let inner = block_inner(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("EX", inner, "", ""))
    }
    // INLINE LEAF: unit value
    else if ntype == "unit" {
        let tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + tmp + " = const 0");
        make_step_leaf(cur_temp + 1)
    }
    else if ntype == "seq" {
        let e1 = seq_first(ast);
        let e2 = seq_second(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("SQ", e1, e2, ""))
    }
    else if ntype == "assign" {
        let lhs = assign_lhs_expr(ast);
        let rhs = assign_rhs_expr(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AS", lhs, rhs, ""))
    }
    else if ntype == "while" {
        let while_exit = "exit_" + i2s(cur_block);
        let result = lower_while_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, while_exit, "")
    }
    else if ntype == "loop" {
        let loop_exit = "exit_" + i2s(cur_block);
        let result = lower_loop_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, loop_exit, "")
    }
    // v0.95: For-loop support - use recursive lowering
    else if ntype == "for" {
        let for_exit = "for_end_" + i2s(cur_block);
        let result = lower_for_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, for_exit, "")
    }
    else if ntype == "for_incl" {
        let for_exit = "for_end_" + i2s(cur_block);
        let result = lower_for_incl_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, for_exit, "")
    }
    else if ntype == "for_step" {
        let for_exit = "for_end_" + i2s(cur_block);
        let result = lower_for_step_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, for_exit, "")
    }
    else if ntype == "for_step_incl" {
        let for_exit = "for_end_" + i2s(cur_block);
        let result = lower_for_step_incl_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, for_exit, "")
    }
    else if ntype == "index" {
        let base = get_child(ast, 0);
        let idx = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AI", base, idx, ""))
    }
    else if ntype == "ptr_index" {
        let base = get_child(ast, 0);
        let idx = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AI", base, idx, "P"))
    }
    else if ntype == "set_index" {
        let base = get_child(ast, 0);
        let idx = get_child(ast, 1);
        let val = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("SI", base, idx, val, ""))
    }
    else if ntype == "set_ptr_index" {
        let base = get_child(ast, 0);
        let idx = get_child(ast, 1);
        let val = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("SI", base, idx, val, "P"))
    }
    else if ntype == "set_field" {
        let obj = get_child(ast, 0);
        let field = get_child(ast, 1);
        let val = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("SF", obj, field, val, ""))
    }
    else if ntype == "set_var" {
        let name = extract_name(ast);
        let val = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("SV", name, val, "", ""))
    }
    else if ntype == "field" {
        let base_expr = get_child(ast, 0);
        let field_name = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("FA", base_expr, field_name, ""))
    }
    else if ntype == "break" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("BK", "", "", ""))
    }
    else if ntype == "continue" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("CN", "", "", ""))
    }
    else if ntype == "return" {
        let has_value = if ast.len() > 8 { get_child(ast, 0) } else { "" };
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("RT", has_value, "", ""))
    }
    else if ntype == "cast_i64" {
        let inner = get_child(ast, 0);
        let cont = make_work3("C6", "", "", "");
        let do_expr = make_work3("EX", inner, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_expr + work_sep() + cont)
    }
    else if ntype == "cast_f64" {
        let inner = get_child(ast, 0);
        let cont = make_work3("XF", "", "", "");
        let do_expr = make_work3("EX", inner, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_expr + work_sep() + cont)
    }
    // v0.95: as i32 cast - lower inner, emit trunc_i32
    else if ntype == "cast_i32" {
        let inner = get_child(ast, 0);
        let cont = make_work3("W3", "", "", "");
        let do_expr = make_work3("EX", inner, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_expr + work_sep() + cont)
    }
    else if ntype == "cast_ptr_f64" {
        let inner = get_child(ast, 0);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("FP", inner, "", ""))
    }
    else if ntype == "array_repeat" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AR", ast, "", ""))
    }
    else if ntype == "array" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AL", ast, "", ""))
    }
    else if ntype == "tuple" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("TU", ast, "", ""))
    }
    else if ntype == "struct_init" {
        let result = lower_struct_init_sb(ast, cur_temp, cur_block, sb, "");
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, cur_exit_label, "")
    }
    // v0.95: Lambda/closure - delegate to recursive lowering
    else if ntype == "lambda" {
        let result = lower_lambda_sb(ast, cur_temp, cur_block, sb, cur_exit_label);
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, cur_exit_label, "")
    }
    else { make_step_leaf(cur_temp) };

// IN: Integer literal - emit MIR, advance temp
fn step_int(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let val = extract_int_value(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + i2s(val));
    make_step_leaf(cur_temp + 1);

// FL: Float literal - emit MIR const F:value, advance temp
fn step_float(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let text = extract_float_value_text(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const F:" + text);
    make_step_leaf(cur_temp + 1);

// BO: Boolean literal
fn step_bool(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + i2s(val));
    make_step_leaf(cur_temp + 1);

// ST: String literal
fn step_string(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let str_content = extract_string_content(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = string " + chr(34) + str_content + chr(34));
    make_step_leaf(cur_temp + 1);

// VA: Variable reference
fn step_var(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let name = extract_name(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = copy %" + name);
    make_step_leaf(cur_temp + 1);

// BI: Start binop - push left expr, then BR continuation
fn step_binop_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let left = get_field(item, 2);
    let right = get_field(item, 3);
    // After left, cur_temp will have advanced. BR needs to know where left result is.
    let cont = make_work("BR", op, right, i2s(cur_temp), "", "");
    let do_left = make_work3("EX", left, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_left + work_sep() + cont);

// BR: Binop right - left done, do right. cur_temp-1 is left result.
fn step_binop_right(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let right = get_field(item, 2);
    let left_start = s2i(get_field(item, 3));
    let left_id = cur_temp - 1;
    // Push right, then BF finalize
    let cont = make_work4("BF", op, i2s(left_id), i2s(cur_temp), "");
    let do_right = make_work3("EX", right, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_right + work_sep() + cont);

// BF: Binop final - both done, emit binop MIR
fn step_binop_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let left_id = s2i(get_field(item, 2));
    let right_start = s2i(get_field(item, 3));
    let right_id = cur_temp - 1;
    let result_tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + op + " %_t" + i2s(left_id) + ", %_t" + i2s(right_id));
    make_step_leaf(cur_temp + 1);

// UN: Start unary - push operand, then UF
fn step_unary_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let operand = get_field(item, 2);
    let cont = make_work3("UF", op, i2s(cur_temp), "");
    let do_op = make_work3("EX", operand, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_op + work_sep() + cont);

// UF: Unary final - emit unary MIR
fn step_unary_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let operand_id = cur_temp - 1;
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let result_tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + i2s(operand_id));
    make_step_leaf(cur_temp + 1);

// IS: Start if - push cond, then IT
fn step_if_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let cond = get_field(item, 1);
    let then_br = get_field(item, 2);
    let else_br = get_field(item, 3);
    if is_pure_expr(then_br) and is_pure_expr(else_br) {
        let cont = make_work3("IZ", then_br, else_br, "");
        let do_cond = make_work3("EX", cond, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_cond + work_sep() + cont)
    } else {
        // After cond, we'll have cond_id and need to emit branch then do branches
        let cont = make_work("IT", then_br, else_br, i2s(cur_temp), i2s(cur_block), "");
        let do_cond = make_work3("EX", cond, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_cond + work_sep() + cont)
    };

// IZ: If-select - cond done, emit both pure values and select
fn step_if_select(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let then_br = get_field(item, 1);
    let else_br = get_field(item, 2);
    let cond_id = cur_temp - 1;
    let then_result = lower_expr_sb(then_br, cur_temp, cur_block, sb, cur_exit_label);
    let then_temp = unpack_temp(then_result);
    let then_id = then_temp - 1;
    let else_result = lower_expr_sb(else_br, then_temp, cur_block, sb, cur_exit_label);
    let else_temp = unpack_temp(else_result);
    let else_id = else_temp - 1;
    let select_tmp = "%_t" + i2s(else_temp);
    let w = sb_push_mir(sb, "  " + select_tmp + " = select %_t" + i2s(cond_id) + ", %_t" + i2s(then_id) + ", %_t" + i2s(else_id));
    make_step_leaf(else_temp + 1);

// IT: If then - cond done, emit branch, do then branch
// Sets exit_label to then_label for the then branch execution
fn step_if_then(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let then_br = get_field(item, 1);
    let else_br = get_field(item, 2);
    let orig_temp = s2i(get_field(item, 3));
    let orig_block = s2i(get_field(item, 4));
    let cond_id = cur_temp - 1;
    let my_block = cur_block;
    let then_label = "then_" + i2s(my_block);
    let else_label = "else_" + i2s(my_block);
    let merge_label = "merge_" + i2s(my_block);
    let branch_text = "  branch %_t" + i2s(cond_id) + ", " + then_label + ", " + else_label;
    let w1 = sb_push_mir(sb, branch_text);
    let then_label_text = then_label + ":";
    let w2 = sb_push_mir(sb, then_label_text);
    // Continue with then, then IE
    // Pass merge_label as the expected exit for then branch (will be updated by nested ifs)
    let cont = make_work7("IE", else_br, i2s(my_block), then_label, else_label, merge_label, i2s(cur_temp), then_br);
    let do_then = make_work3("EX", then_br, "", "");
    // Set exit_label to then_label - the then branch will update this if it contains nested ifs
    make_step(cur_temp, my_block + 1, then_label, do_then + work_sep() + cont);

// IE: If else - then done, emit goto, do else
// Uses cur_exit_label as the actual then_exit (propagated through trampoline)
fn step_if_else(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let else_br = get_field(item, 1);
    let my_block = s2i(get_field(item, 2));
    let then_label = get_field(item, 3);
    let else_label = get_field(item, 4);
    let merge_label = get_field(item, 5);
    let then_start = s2i(get_field(item, 6));
    let then_ast = get_field(item, 7);
    let then_id = cur_temp - 1;
    // Use the propagated exit_label from trampoline - this is the actual exit point of the then branch
    let then_exit = if cur_exit_label == "" { then_label } else { cur_exit_label };
    let goto_text = "  goto " + merge_label;
    let w1 = sb_push_mir(sb, goto_text);
    let else_text = else_label + ":";
    let w2 = sb_push_mir(sb, else_text);
    // Continue with else, then IX final
    let cont = make_work7("IX", i2s(my_block), merge_label, i2s(then_id), then_exit, i2s(cur_temp), i2s(cur_block), else_br);
    let do_else = make_work3("EX", else_br, "", "");
    // Set exit_label to else_label - the else branch will update this if it contains nested ifs
    make_step(cur_temp, cur_block, else_label, do_else + work_sep() + cont);

// IX: If final - else done, emit goto and phi
// Uses cur_exit_label as the actual else_exit (propagated through trampoline)
fn step_if_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let my_block = s2i(get_field(item, 1));
    let merge_label = get_field(item, 2);
    let then_id = s2i(get_field(item, 3));
    let then_exit = get_field(item, 4);
    let else_start = s2i(get_field(item, 5));
    let else_entry_block = s2i(get_field(item, 6));
    let else_ast = get_field(item, 7);
    let else_id = cur_temp - 1;
    // Use the propagated exit_label from trampoline - this is the actual exit point of the else branch
    let else_exit = if cur_exit_label == "" { "else_" + i2s(my_block) } else { cur_exit_label };
    let goto_text = "  goto " + merge_label;
    let w1 = sb_push_mir(sb, goto_text);
    let merge_text = merge_label + ":";
    let w2 = sb_push_mir(sb, merge_text);
    let phi_tmp = "%_t" + i2s(cur_temp);
    let phi_text = "  " + phi_tmp + " = phi [%_t" + i2s(then_id) + ", " + then_exit + "], [%_t" + i2s(else_id) + ", " + else_exit + "]";
    let w3 = sb_push_mir(sb, phi_text);
    // After if completes, exit_label is merge_label
    make_step(cur_temp + 1, cur_block, merge_label, "");

// LS: Start let - push value, then LB
fn step_let_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let value = get_field(item, 2);
    let body = get_field(item, 3);
    // fixing variable shadowing (let x = 1; let x = x + 10;)
    let unique_name = name + "_v" + i2s(cur_temp);
    let body_renamed = rename_name_in_ast(body, name, unique_name);
    let cont = make_work4("LB", unique_name, body_renamed, i2s(cur_temp), "");
    let do_val = make_work3("EX", value, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_val + work_sep() + cont);

// LB: Let body - value done, emit alloca+store, do body
fn step_let_body(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let unique_name = get_field(item, 1);
    let body = get_field(item, 2);
    let val_id = cur_temp - 1;
    let w1 = sb_push_mir(sb, "  alloca %" + unique_name);
    let w2 = sb_push_mir(sb, "  store %" + unique_name + ", %_t" + i2s(val_id));
    let do_body = make_work3("EX", body, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_body);

// VM: Start mutable variable - push value, then VB
// v0.92: Mutable variables use alloca/store/load for correct loop behavior
fn step_mut_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let value = get_field(item, 2);
    let body = get_field(item, 3);
    let unique_name = name + "_" + i2s(cur_temp);
    let body_renamed = rename_name_in_ast(body, name, unique_name);
    let cont = make_work4("VB", unique_name, body_renamed, i2s(cur_temp), "");
    let do_val = make_work3("EX", value, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_val + work_sep() + cont);

// VB: Mutable variable body - value done, emit alloca + store, do body
// v0.92: Uses alloca/store/load pattern instead of copy for correct SSA in loops
fn step_mut_body(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let body = get_field(item, 2);
    let val_id = cur_temp - 1;
    // Emit alloca for the mutable variable
    let w1 = sb_push_mir(sb, "  alloca %" + name);
    // Emit store initial value
    let w2 = sb_push_mir(sb, "  store %" + name + ", %_t" + i2s(val_id));
    let do_body = make_work3("EX", body, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_body);

// CS: Start call - begin processing args
fn step_call_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let arg = get_child(ast, idx);
    if arg == "" {
        // No args, emit call
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "()");
        make_step_leaf(cur_temp + 1)
    } else {
        // Has args, start processing
        // Field 4: collected arg temps (starts empty)
        let cont = make_work("CA", name, ast, i2s(idx + 1), "", "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// CA: Call arg - process next arg or finalize
fn step_call_arg(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let collected = get_field(item, 4);
    // Append the result of the just-evaluated arg (cur_temp - 1)
    let this_arg = "%_t" + i2s(cur_temp - 1);
    let new_collected = if collected == "" { this_arg } else { collected + ", " + this_arg };
    let arg = get_child(ast, idx);
    if arg == "" {
        // Done with args, emit call
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "(" + new_collected + ")");
        make_step_leaf(cur_temp + 1)
    } else {
        // More args
        let cont = make_work("CA", name, ast, i2s(idx + 1), new_collected, "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// CF: Call final (unused in new design, kept for compatibility)
fn step_call_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    make_step_leaf(cur_temp);

// MS: Start method - do receiver
fn step_method_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let fn_name = get_field(item, 1);
    let receiver = get_field(item, 2);
    let ast = get_field(item, 3);
    let idx = s2i(get_field(item, 4));
    // Field 4: collected arg temps (starts empty, receiver added after eval)
    let cont = make_work("MA", fn_name, ast, i2s(idx), "", "");
    let do_recv = make_work3("EX", receiver, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_recv + work_sep() + cont);

// MA: Method arg - process next arg or finalize
fn step_method_arg(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let fn_name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let collected = get_field(item, 4);
    // Append the result of the just-evaluated arg/receiver (cur_temp - 1)
    let this_arg = "%_t" + i2s(cur_temp - 1);
    let new_collected = if collected == "" { this_arg } else { collected + ", " + this_arg };
    let arg = get_child(ast, idx);
    if arg == "" {
        // Done with args
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + fn_name + "(" + new_collected + ")");
        make_step_leaf(cur_temp + 1)
    } else {
        // More args
        let cont = make_work("MA", fn_name, ast, i2s(idx + 1), new_collected, "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// MF: Method final (unused)
fn step_method_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    make_step_leaf(cur_temp);

// T? is represented as i64 where 0 = null/none, non-zero = some value
// is_some() → value != 0, is_none() → value == 0
// unwrap()/expect() → identity (pass-through)
// unwrap_or(default) → select(value != 0, value, default)

fn is_nullable_method(name: String) -> bool =
    if name == "is_some" { true } else if name == "is_none" { true }
    else if name == "unwrap" { true } else if name == "unwrap_or" { true }
    else if name == "expect" { true } else { false };

// NR: Nullable result - receiver evaluated, emit comparison or dispatch unwrap_or
fn step_nullable_result(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let method = get_field(item, 1);
    let ast = get_field(item, 2);
    let recv_id = cur_temp - 1;
    if method == "is_some" {
        let result = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result + " = != %_t" + i2s(recv_id) + ", 0");
        make_step_leaf(cur_temp + 1)
    } else if method == "is_none" {
        let result = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result + " = == %_t" + i2s(recv_id) + ", 0");
        make_step_leaf(cur_temp + 1)
    } else if method == "unwrap" or method == "expect" {
        // Identity - result is the receiver itself
        make_step_leaf(cur_temp)
    } else if method == "unwrap_or" {
        // Evaluate default argument, then emit nullable_select
        let default_arg = get_child(ast, 2);
        let cont = make_work3("NO", i2s(recv_id), "", "");
        let do_default = make_work3("EX", default_arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_default + work_sep() + cont)
    } else { make_step_leaf(cur_temp) };

// NO: Nullable or final - default evaluated, emit nullable_select
fn step_nullable_or(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let recv_id = s2i(get_field(item, 1));
    let default_id = cur_temp - 1;
    let result = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + result + " = nullable_select %_t" + i2s(recv_id) + ", %_t" + i2s(default_id));
    make_step_leaf(cur_temp + 1);

fn step_unit(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const 0");
    make_step_leaf(cur_temp + 1);

fn step_seq_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let e1 = get_field(item, 1);
    let e2 = get_field(item, 2);
    // First lower e1, then continue with e2
    let cont = make_work3("S2", e2, "", "");
    let eval = make_work3("EX", e1, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_seq_second(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let e2 = get_field(item, 1);
    make_step(cur_temp, cur_block, cur_exit_label, make_work3("EX", e2, "", ""));

fn step_assign_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let lhs = get_field(item, 1);
    let rhs = get_field(item, 2);
    // Lower RHS, then do assignment
    let cont = make_work3("AF", lhs, "", "");
    let eval = make_work3("EX", rhs, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.92: Use store instead of copy for mutable variable assignments
fn step_assign_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let lhs = get_field(item, 1);
    // RHS value is in %_t(cur_temp-1)
    let rhs_temp = cur_temp - 1;
    let name = extract_var_from_assign(lhs);
    let w1 = sb_push_mir(sb, "  store %" + name + ", %_t" + i2s(rhs_temp));
    // Assignment returns unit
    let tmp = "%_t" + i2s(cur_temp);
    let w2 = sb_push_mir(sb, "  " + tmp + " = const 0");
    make_step_leaf(cur_temp + 1);

fn step_array_index_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base = get_field(item, 1);
    let idx = get_field(item, 2);
    let flag = get_field(item, 3);
    let cont = make_work3("A2", idx, flag, "");
    let eval = make_work3("EX", base, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_array_index_idx(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let idx = get_field(item, 1);
    let flag = get_field(item, 2);
    let base_temp = cur_temp - 1;
    let cont = make_work3("A3", i2s(base_temp), flag, "");
    let eval = make_work3("EX", idx, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_array_index_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base_t = get_field(item, 1);
    let flag = get_field(item, 2);
    let idx_temp = cur_temp - 1;
    if flag == "P" {
        // Direct GEP for raw pointer (no +2 header offset)
        let gep = "%_t" + i2s(cur_temp);
        let load_tmp = "%_t" + i2s(cur_temp + 1);
        let w1 = sb_push_mir(sb, "  " + gep + " = gep %_t" + base_t + ", %_t" + i2s(idx_temp));
        let w2 = sb_push_mir(sb, "  " + load_tmp + " = load_ptr " + gep);
        make_step_leaf(cur_temp + 2)
    } else {
        // Add 2 to index to skip array header
        let hdr_const = "%_t" + i2s(cur_temp);
        let w0a = sb_push_mir(sb, "  " + hdr_const + " = const 2");
        let offset_tmp = "%_t" + i2s(cur_temp + 1);
        let w0b = sb_push_mir(sb, "  " + offset_tmp + " = + %_t" + i2s(idx_temp) + ", " + hdr_const);
        let gep = "%_t" + i2s(cur_temp + 2);
        let load_tmp = "%_t" + i2s(cur_temp + 3);
        let w1 = sb_push_mir(sb, "  " + gep + " = gep %_t" + base_t + ", " + offset_tmp);
        let w2 = sb_push_mir(sb, "  " + load_tmp + " = load_ptr " + gep);
        make_step_leaf(cur_temp + 4)
    };

fn step_set_index_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base = get_field(item, 1);
    let idx = get_field(item, 2);
    let val = get_field(item, 3);
    let flag = get_field(item, 4);
    let cont = make_work4("S3", idx, val, flag, "");
    let eval = make_work3("EX", base, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_set_index_idx(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let idx = get_field(item, 1);
    let val = get_field(item, 2);
    let flag = get_field(item, 3);
    let base_temp = cur_temp - 1;
    let cont = make_work4("S4", i2s(base_temp), val, flag, "");
    let eval = make_work3("EX", idx, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_set_index_val(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base_t = get_field(item, 1);
    let val = get_field(item, 2);
    let flag = get_field(item, 3);
    let idx_temp = cur_temp - 1;
    let cont = make_work4("S5", base_t, i2s(idx_temp), flag, "");
    let eval = make_work3("EX", val, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_set_index_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base_t = get_field(item, 1);
    let idx_t = get_field(item, 2);
    let flag = get_field(item, 3);
    let val_temp = cur_temp - 1;
    if flag == "P" {
        // Direct GEP for raw pointer (no +2 header offset)
        let gep = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + gep + " = gep %_t" + base_t + ", %_t" + idx_t);
        let w2 = sb_push_mir(sb, "  store_ptr " + gep + ", %_t" + i2s(val_temp));
        let result = "%_t" + i2s(cur_temp + 1);
        let w3 = sb_push_mir(sb, "  " + result + " = const 0");
        make_step_leaf(cur_temp + 2)
    } else {
        // Add 2 to index to skip array header
        let hdr_const = "%_t" + i2s(cur_temp);
        let w0a = sb_push_mir(sb, "  " + hdr_const + " = const 2");
        let offset_tmp = "%_t" + i2s(cur_temp + 1);
        let w0b = sb_push_mir(sb, "  " + offset_tmp + " = + %_t" + idx_t + ", " + hdr_const);
        let gep = "%_t" + i2s(cur_temp + 2);
        let w1 = sb_push_mir(sb, "  " + gep + " = gep %_t" + base_t + ", " + offset_tmp);
        let w2 = sb_push_mir(sb, "  store_ptr " + gep + ", %_t" + i2s(val_temp));
        let result = "%_t" + i2s(cur_temp + 3);
        let w3 = sb_push_mir(sb, "  " + result + " = const 0");
        make_step_leaf(cur_temp + 4)
    };

fn step_field_access_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let base_expr = get_field(item, 1);
    let field_name = get_field(item, 2);
    let cont = make_work3("F2", field_name, "", "");
    let eval = make_work3("EX", base_expr, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_field_access_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let field_name = get_field(item, 1);
    let base_temp = cur_temp - 1;
    let dest = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + dest + " = field-access %_t" + i2s(base_temp) + "." + field_name);
    make_step_leaf(cur_temp + 1);

fn step_set_field_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let obj = get_field(item, 1);
    let field = get_field(item, 2);
    let val = get_field(item, 3);
    let cont = make_work4("G2", field, val, "", "");
    let eval = make_work3("EX", obj, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_set_field_val(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let field = get_field(item, 1);
    let val = get_field(item, 2);
    let obj_temp = cur_temp - 1;
    let cont = make_work4("G3", i2s(obj_temp), field, "", "");
    let eval = make_work3("EX", val, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_set_field_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let obj_t = get_field(item, 1);
    let field = get_field(item, 2);
    let val_temp = cur_temp - 1;
    let w1 = sb_push_mir(sb, "  field-store %_t" + obj_t + "." + field + ", %_t" + i2s(val_temp));
    // set returns 0 (unit)
    let result = "%_t" + i2s(cur_temp);
    let w2 = sb_push_mir(sb, "  " + result + " = const 0");
    make_step_leaf(cur_temp + 1);

fn step_set_var_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let val = get_field(item, 2);
    let cont = make_work3("SW", name, "", "");
    let do_val = make_work3("EX", val, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_val + work_sep() + cont);

fn step_set_var_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let val_id = cur_temp - 1;
    let w1 = sb_push_mir(sb, "  store %" + name + ", %_t" + i2s(val_id));
    // set returns 0 (unit)
    let result = "%_t" + i2s(cur_temp);
    let w2 = sb_push_mir(sb, "  " + result + " = const 0");
    make_step_leaf(cur_temp + 1);

// cur_exit_label should contain the while/for exit label
fn step_break(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let goto_text = "  goto " + cur_exit_label;
    let w1 = sb_push_mir(sb, goto_text);
    let after_label = "after_break_" + i2s(cur_block);
    let label_text = after_label + ":";
    let w2 = sb_push_mir(sb, label_text);
    let tmp = "%_t" + i2s(cur_temp);
    let const_text = "  " + tmp + " = const 0";
    let w3 = sb_push_mir(sb, const_text);
    make_step(cur_temp + 1, cur_block, after_label, "");

// Derive loop header from exit label:
//   "exit_N" → "loop_N" (while/loop)
//   "for_end_N" → "for_start_N" (for)
fn derive_loop_start(exit_label: String) -> String =
    if exit_label.len() >= 8 and exit_label.slice(0, 8) == "for_end_" {
        // For loops: continue should jump to increment, not condition check
        "for_inc_" + exit_label.slice(8, exit_label.len())
    } else {
        "loop_" + exit_label.slice(5, exit_label.len())
    };

fn step_continue(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let loop_label = derive_loop_start(cur_exit_label);
    let goto_text = "  goto " + loop_label;
    let w1 = sb_push_mir(sb, goto_text);
    let after_label = "after_continue_" + i2s(cur_block);
    let label_text = after_label + ":";
    let w2 = sb_push_mir(sb, label_text);
    let tmp = "%_t" + i2s(cur_temp);
    let const_text = "  " + tmp + " = const 0";
    let w3 = sb_push_mir(sb, const_text);
    make_step(cur_temp + 1, cur_block, after_label, "");

// Work item: RT~value_ast~~~
fn step_return(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let value_ast = work3_get1(item);
    if value_ast.len() == 0 {
        // Bare return
        let w1 = sb_push_mir(sb, "  return");
        let after_label = "after_return_" + i2s(cur_block);
        let label_text = after_label + ":";
        let w2 = sb_push_mir(sb, label_text);
        let tmp = "%_t" + i2s(cur_temp);
        let const_text = "  " + tmp + " = const 0";
        let w3 = sb_push_mir(sb, const_text);
        make_step(cur_temp + 1, cur_block, after_label, "")
    } else {
        // Return with value - lower the value first (EX), then emit return (RV)
        let cont = make_work3("RV", "", "", "");
        let do_expr = make_work3("EX", value_ast, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_expr + work_sep() + cont)
    };

fn step_return_value(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let result_id = cur_temp - 1;
    let ret_text = "  return %_t" + i2s(result_id);
    let w1 = sb_push_mir(sb, ret_text);
    let after_label = "after_return_" + i2s(cur_block);
    let label_text = after_label + ":";
    let w2 = sb_push_mir(sb, label_text);
    let tmp = "%_t" + i2s(cur_temp);
    let const_text = "  " + tmp + " = const 0";
    let w3 = sb_push_mir(sb, const_text);
    make_step(cur_temp + 1, cur_block, after_label, "");

// Inner expr already evaluated at cur_temp-1, emit fptosi MIR instruction
fn step_cast_to_i64(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let result_id = cur_temp - 1;
    let src = "%_t" + i2s(result_id);
    let dst = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + dst + " = fptosi " + src);
    make_step_leaf(cur_temp + 1);

// Inner expr already evaluated at cur_temp-1, emit sitofp MIR instruction
fn step_cast_to_f64(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let result_id = cur_temp - 1;
    let src = "%_t" + i2s(result_id);
    let dst = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + dst + " = sitofp " + src);
    make_step_leaf(cur_temp + 1);

// v0.95: Cast i64→i32 (trunc_i32) - work-list continuation handler
// Inner expr already evaluated at cur_temp-1, emit trunc_i32 MIR instruction
fn step_cast_to_i32(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let result_id = cur_temp - 1;
    let src = "%_t" + i2s(result_id);
    let dst = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + dst + " = trunc_i32 " + src);
    make_step_leaf(cur_temp + 1);

fn lower_cast_ptr_f64_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let inner = get_child(ast, 0);
    let result = lower_expr_sb(inner, temp_id, block_id, sb, loop_exit);
    let inner_temp = unpack_temp(result);
    let inner_block = unpack_block(result);
    let result_id = inner_temp - 1;
    let w1 = sb_push_mir(sb, "  mark_f64_ptr %_t" + int_to_string(result_id));
    pack_ids(inner_temp, inner_block);

fn lower_cast_i64_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let inner = get_child(ast, 0);
    let result = lower_expr_sb(inner, temp_id, block_id, sb, loop_exit);
    let inner_temp = unpack_temp(result);
    let inner_block = unpack_block(result);
    let result_id = inner_temp - 1;
    let dst = "%_t" + int_to_string(inner_temp);
    let w1 = sb_push_mir(sb, "  " + dst + " = fptosi %_t" + int_to_string(result_id));
    pack_ids(inner_temp + 1, inner_block);

fn lower_cast_f64_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let inner = get_child(ast, 0);
    let result = lower_expr_sb(inner, temp_id, block_id, sb, loop_exit);
    let inner_temp = unpack_temp(result);
    let inner_block = unpack_block(result);
    let result_id = inner_temp - 1;
    let dst = "%_t" + int_to_string(inner_temp);
    let w1 = sb_push_mir(sb, "  " + dst + " = sitofp %_t" + int_to_string(result_id));
    pack_ids(inner_temp + 1, inner_block);

// v0.95: Recursive: cast_i32 - evaluate inner and emit trunc_i32 (i64→i32)
fn lower_cast_i32_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let inner = get_child(ast, 0);
    let result = lower_expr_sb(inner, temp_id, block_id, sb, loop_exit);
    let inner_temp = unpack_temp(result);
    let inner_block = unpack_block(result);
    let result_id = inner_temp - 1;
    let dst = "%_t" + int_to_string(inner_temp);
    let w1 = sb_push_mir(sb, "  " + dst + " = trunc_i32 %_t" + int_to_string(result_id));
    pack_ids(inner_temp + 1, inner_block);

// v0.95: Lambda/closure lowering
// AST: (lambda (param <x> i64) (param <y> i64) BODY_AST)
// Strategy: Extract lambda as a top-level function, return fn_ref
fn lower_lambda_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let lambda_name = "__lambda_" + int_to_string(temp_id);
    let params = collect_lambda_params(ast, 0, "");
    let body_ast = get_lambda_body(ast, 0);
    let lambda_sb = sb_new();
    let lambda_result = lower_expr_sb(body_ast, 0, 0, lambda_sb, "");
    let lambda_temp = unpack_temp(lambda_result);
    let result_id = lambda_temp - 1;
    let w1 = sb_push_mir(lambda_sb, "  return %_t" + int_to_string(result_id));
    let lambda_body = sb_build(lambda_sb);
    // v0.95: Uniform closure convention — ALL lambdas get __closure: i64 first param
    let free_vars = find_free_vars_in_mir(lambda_body, params);
    let tmp = "%_t" + int_to_string(temp_id);
    let all_params = if params == "" { "__closure: i64" } else { "__closure: i64, " + params };
    if free_vars == "" {
        // No captures: closure struct with count=0
        let w2 = sb_push_mir(sb, "  " + tmp + " = closure_new @" + lambda_name + ", 0");
        let lambda_fn = "fn " + lambda_name + "(" + all_params + ") -> i64 {|entry:|" + lambda_body + "|}";
        let w3 = sb_push(sb, chr(1) + lambda_fn + chr(1));
        pack_ids(temp_id + 1, block_id)
    } else {
        // Closure with captures: load captures from __closure in function prologue
        let cap_count = count_csv_items(free_vars);
        let cap_loads = build_capture_load_mir(free_vars, 0);
        let new_body = replace_all_free_vars(lambda_body, free_vars, 0);
        let body_with_loads = cap_loads + "|" + new_body;
        let cap_args = format_free_var_refs(free_vars, 0, "");
        let w2 = sb_push_mir(sb, "  " + tmp + " = closure_new @" + lambda_name + ", " + int_to_string(cap_count) + ", " + cap_args);
        let lambda_fn = "fn " + lambda_name + "(" + all_params + ") -> i64 {|entry:|" + body_with_loads + "|}";
        let w3 = sb_push(sb, chr(1) + lambda_fn + chr(1));
        pack_ids(temp_id + 1, block_id)
    };

// Collect lambda parameters: scan children until we find a non-param node
fn collect_lambda_params(ast: String, idx: i64, acc: String) -> String =
    let child = get_child(ast, idx);
    if child == "" or get_node_type(child) != "param" { acc } else {
        let param_name = get_child(child, 0);
        let name = if param_name.len() >= 2 and param_name.byte_at(0) == 60 { param_name.slice(1, param_name.len() - 1) } else { param_name };
        let param_type = get_child(child, 1);
        let entry = name + ": " + param_type;
        let new_acc = if acc == "" { entry } else { acc + ", " + entry };
        collect_lambda_params(ast, idx + 1, new_acc)
    };

// Find lambda body: the first non-param child
fn get_lambda_body(ast: String, idx: i64) -> String =
    let child = get_child(ast, idx);
    if child == "" { "(int 0)" } else if get_node_type(child) != "param" { child } else { get_lambda_body(ast, idx + 1) };

// v0.95: Free variable detection for closure capture
// Scans lambda body MIR for %name references not matching temps, blocks, params, or locals
fn find_free_vars_in_mir(body: String, params: String) -> String =
    let locals = collect_local_alloca_names(body, 0, "");
    let all_refs = scan_mir_for_free_vars(body, 0, "", params);
    filter_out_locals(all_refs, locals);

// Collect names of alloca'd variables from pipe-separated MIR lines
fn collect_local_alloca_names(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc }
    else {
        let p = low_skip_ws(mir, pos);
        let pipe = find_char(mir, p, 124);
        let line_end = if pipe < mir.len() { pipe } else { mir.len() };
        let trimmed = trim(mir.slice(p, line_end));
        let new_acc = if starts_with_alloca_pct(trimmed) {
            let pct_pos = find_char(trimmed, 0, 37);
            let name_start = pct_pos + 1;
            let name_end = find_var_end(trimmed, name_start);
            let name = trimmed.slice(name_start, name_end);
            if var_in_list(name, acc) { acc }
            else if acc == "" { name }
            else { acc + "," + name }
        } else { acc };
        if pipe >= mir.len() { new_acc }
        else { collect_local_alloca_names(mir, pipe + 1, new_acc) }
    };

fn starts_with_alloca_pct(s: String) -> bool =
    s.len() >= 8
    and s.byte_at(0) == 97 and s.byte_at(1) == 108
    and s.byte_at(2) == 108 and s.byte_at(3) == 111
    and s.byte_at(4) == 99 and s.byte_at(5) == 97
    and s.byte_at(6) == 32 and s.byte_at(7) == 37;

// Filter out locally-defined variables from the free vars list
fn filter_out_locals(free_vars: String, locals: String) -> String =
    if free_vars == "" { "" }
    else {
        let comma = find_comma_or_end(free_vars, 0);
        let name = free_vars.slice(0, comma);
        let rest = if comma >= free_vars.len() { "" } else { free_vars.slice(comma + 1, free_vars.len()) };
        let filtered_rest = filter_out_locals(rest, locals);
        if var_in_list(name, locals) { filtered_rest }
        else if filtered_rest == "" { name }
        else { name + "," + filtered_rest }
    };

fn scan_mir_for_free_vars(mir: String, pos: i64, found: String, params: String) -> String =
    if pos >= mir.len() { found }
    else {
        let next_pct = find_char(mir, pos, 37);
        if next_pct >= mir.len() { found }
        else {
            let name_end = find_var_end(mir, next_pct + 1);
            let name = mir.slice(next_pct + 1, name_end);
            let new_found = if name.len() == 0 { found }
                else if is_temp_name(name) { found }
                else if is_block_name(name) { found }
                else if is_lambda_param_name(name, params) { found }
                else if var_in_list(name, found) { found }
                else if found == "" { name }
                else { found + "," + name };
            scan_mir_for_free_vars(mir, name_end, new_found, params)
        }
    };

fn find_var_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else {
        let ch = s.byte_at(pos);
        if (ch >= 65 and ch <= 90) or (ch >= 97 and ch <= 122) or (ch >= 48 and ch <= 57) or ch == 95 {
            find_var_end(s, pos + 1)
        } else { pos }
    };

fn is_temp_name(name: String) -> bool =
    name.len() >= 2 and name.byte_at(0) == 95 and name.byte_at(1) == 116;

fn is_block_name(name: String) -> bool =
    name.len() >= 2 and name.byte_at(0) == 95 and name.byte_at(1) == 98;

fn is_lambda_param_name(name: String, params: String) -> bool =
    if params == "" { false } else { check_param_name_match(name, params, 0) };

fn check_param_name_match(name: String, params: String, pos: i64) -> bool =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { false }
    else {
        let colon = find_char(params, p, 58);
        let param_name = trim(params.slice(p, colon));
        if param_name == name { true }
        else {
            let comma = find_comma_or_end(params, colon);
            if comma >= params.len() { false }
            else { check_param_name_match(name, params, comma + 1) }
        }
    };

fn var_in_list(name: String, list: String) -> bool =
    if list == "" { false } else { check_var_list(name, list, 0) };

fn check_var_list(name: String, list: String, pos: i64) -> bool =
    let p = low_skip_ws(list, pos);
    if p >= list.len() { false }
    else {
        let comma = find_comma_or_end(list, p);
        let item = list.slice(p, comma);
        if item == name { true }
        else if comma >= list.len() { false }
        else { check_var_list(name, list, comma + 1) }
    };

fn count_csv_items(list: String) -> i64 =
    if list == "" { 0 } else { count_csv_rec(list, 0) };

fn count_csv_rec(list: String, pos: i64) -> i64 =
    let p = low_skip_ws(list, pos);
    if p >= list.len() { 0 }
    else {
        let comma = find_comma_or_end(list, p);
        if comma >= list.len() { 1 }
        else { 1 + count_csv_rec(list, comma + 1) }
    };

// Replace all free variables in MIR with capture parameter names (__cap0, __cap1, ...)
fn replace_all_free_vars(mir: String, free_vars: String, cap_idx: i64) -> String =
    if free_vars == "" { mir }
    else {
        let comma = find_comma_or_end(free_vars, 0);
        let var_name = free_vars.slice(0, comma);
        let cap_name = "__cap" + int_to_string(cap_idx);
        let new_mir = replace_free_var(mir, var_name, cap_name);
        let rest = if comma >= free_vars.len() { "" } else { free_vars.slice(comma + 1, free_vars.len()) };
        replace_all_free_vars(new_mir, rest, cap_idx + 1)
    };

fn replace_free_var(mir: String, old_name: String, new_name: String) -> String =
    let rsb = sb_new();
    let w = replace_var_rec(mir, 0, old_name, new_name, rsb);
    sb_build(rsb);

fn replace_var_rec(mir: String, pos: i64, old_name: String, new_name: String, rsb: i64) -> i64 =
    if pos >= mir.len() { 0 }
    else {
        let next_pct = find_char(mir, pos, 37);
        if next_pct >= mir.len() {
            sb_push(rsb, mir.slice(pos, mir.len()))
        } else {
            let w1 = if next_pct > pos { sb_push(rsb, mir.slice(pos, next_pct)) } else { 0 };
            let name_end = find_var_end(mir, next_pct + 1);
            let name = mir.slice(next_pct + 1, name_end);
            if name == old_name {
                let w2 = sb_push(rsb, "%");
                let w3 = sb_push(rsb, new_name);
                replace_var_rec(mir, name_end, old_name, new_name, rsb)
            } else {
                let w2 = sb_push(rsb, mir.slice(next_pct, name_end));
                replace_var_rec(mir, name_end, old_name, new_name, rsb)
            }
        }
    };

// Build MIR lines to load captures from __closure struct in lambda prologue
fn build_capture_load_mir(free_vars: String, idx: i64) -> String =
    if free_vars == "" { "" }
    else {
        let comma = find_comma_or_end(free_vars, 0);
        let cap_name = "__cap" + int_to_string(idx);
        let mir_line = "  %" + cap_name + " = closure_load %__closure, " + int_to_string(idx);
        let rest = if comma >= free_vars.len() { "" } else { free_vars.slice(comma + 1, free_vars.len()) };
        let rest_mir = build_capture_load_mir(rest, idx + 1);
        if rest_mir == "" { mir_line } else { mir_line + "|" + rest_mir }
    };

// Format free variable references with % prefix for closure_new MIR instruction
fn format_free_var_refs(free_vars: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(free_vars, pos);
    if p >= free_vars.len() { acc }
    else {
        let comma = find_comma_or_end(free_vars, p);
        let name = free_vars.slice(p, comma);
        let entry = "%" + name;
        let new_acc = if acc == "" { entry } else { acc + ", " + entry };
        if comma >= free_vars.len() { new_acc } else { format_free_var_refs(free_vars, comma + 1, new_acc) }
    };

fn lower_array_repeat_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let val_ast = get_child(ast, 0);
    let count_ast = get_child(ast, 1);
    let count_type = get_node_type(count_ast);
    if count_type == "int" {
        // Literal integer count: use optimized path with compile-time alloc size
        let count_val = extract_int_value(count_ast);
        let val_type = get_node_type(val_ast);
        if val_type == "int" {
            // Both count and val are literals: fully optimized path
            let val_str = int_to_string(extract_int_value(val_ast));
            lower_array_repeat_lit_sb(val_str, int_to_string(count_val), temp_id, block_id, sb)
        } else {
            let ids = lower_expr_sb(val_ast, temp_id, block_id, sb, loop_exit);
            let new_temp = unpack_temp(ids);
            let new_block = unpack_block(ids);
            let val_temp = "%_t" + int_to_string(new_temp - 1);
            let arr_ids = lower_array_repeat_lit_with_val_sb(val_temp, count_val, new_temp, new_block, sb);
            let w_mark = if val_type == "string" { sb_push_mir(sb, "  mark_str_ptr %_t" + int_to_string(unpack_temp(arr_ids) - 1)) } else { 0 };
            arr_ids
        }
    } else {
        // Expression count: lower the expression first, then use result temp
        let ids = lower_expr_sb(count_ast, temp_id, block_id, sb, loop_exit);
        let count_temp = "%_t" + int_to_string(temp_id);
        let new_temp = unpack_temp(ids);
        let new_block = unpack_block(ids);
        lower_array_repeat_expr_sb(count_temp, new_temp, new_block, sb)
    };

// Stores val_tmp at arr[idx+2], arr[idx+3], ..., arr[count+1]
fn emit_fill_stores(arr_ptr: String, val_tmp: String, idx: i64, count: i64, temp_id: i64, sb: i64) -> i64 =
    if idx >= count { temp_id }
    else {
        let actual_idx = idx + 2;
        let idx_tmp = "%_t" + int_to_string(temp_id);
        let w1 = sb_push_mir(sb, "  " + idx_tmp + " = const " + int_to_string(actual_idx));
        let gep_tmp = "%_t" + int_to_string(temp_id + 1);
        let w2 = sb_push_mir(sb, "  " + gep_tmp + " = gep " + arr_ptr + ", " + idx_tmp);
        let w3 = sb_push_mir(sb, "  store_ptr " + gep_tmp + ", " + val_tmp);
        emit_fill_stores(arr_ptr, val_tmp, idx + 1, count, temp_id + 2, sb)
    };

fn emit_fill_stores_step(arr_ptr: String, val_tmp: String, idx: i64, count: i64, temp_id: i64, sb: i64) -> i64 =
    if idx >= count { temp_id }
    else {
        let actual_idx = idx + 2;
        let idx_tmp = "%_t" + i2s(temp_id);
        let w1 = sb_push_mir(sb, "  " + idx_tmp + " = const " + i2s(actual_idx));
        let gep_tmp = "%_t" + i2s(temp_id + 1);
        let w2 = sb_push_mir(sb, "  " + gep_tmp + " = gep " + arr_ptr + ", " + idx_tmp);
        let w3 = sb_push_mir(sb, "  store_ptr " + gep_tmp + ", " + val_tmp);
        emit_fill_stores_step(arr_ptr, val_tmp, idx + 1, count, temp_id + 2, sb)
    };

// val_str: initial value as string ("0", "1", etc.)
// IMPORTANT: The copy (result) MUST be the last temp before pack_ids,
// because lower_let_sb uses (val_temp - 1) as the result temp.
fn lower_array_repeat_lit_sb(val_str: String, count_str: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let count_val = parse_int_simple(count_str, 0, 0);
    let alloc_size = int_to_string(count_val + 2);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = call @calloc(" + alloc_size + ", 8)");
    // Store capacity at index 0
    let cap_val = "%_t" + int_to_string(temp_id + 1);
    let w2a = sb_push_mir(sb, "  " + cap_val + " = const " + count_str);
    let cap_idx = "%_t" + int_to_string(temp_id + 2);
    let w2b = sb_push_mir(sb, "  " + cap_idx + " = const 0");
    let cap_gep = "%_t" + int_to_string(temp_id + 3);
    let w2c = sb_push_mir(sb, "  " + cap_gep + " = gep " + tmp + ", " + cap_idx);
    let w2d = sb_push_mir(sb, "  store_ptr " + cap_gep + ", " + cap_val);
    // Store length at index 1
    let len_idx = "%_t" + int_to_string(temp_id + 4);
    let w2e = sb_push_mir(sb, "  " + len_idx + " = const 1");
    let len_gep = "%_t" + int_to_string(temp_id + 5);
    let w2f = sb_push_mir(sb, "  " + len_gep + " = gep " + tmp + ", " + len_idx);
    let w2g = sb_push_mir(sb, "  store_ptr " + len_gep + ", " + cap_val);
    if val_str == "0" {
        let result = "%_t" + int_to_string(temp_id + 6);
        let w3 = sb_push_mir(sb, "  " + result + " = copy " + tmp);
        pack_ids(temp_id + 7, block_id)
    } else {
        let val_tmp = "%_t" + int_to_string(temp_id + 6);
        let wv = sb_push_mir(sb, "  " + val_tmp + " = const " + val_str);
        let end_temp = emit_fill_stores(tmp, val_tmp, 0, count_val, temp_id + 7, sb);
        // Copy MUST be last — lower_let_sb uses (next_temp - 1) as result
        let result = "%_t" + int_to_string(end_temp);
        let w3 = sb_push_mir(sb, "  " + result + " = copy " + tmp);
        pack_ids(end_temp + 1, block_id)
    };

// val_temp: already-lowered temp holding the fill value
// count_val: compile-time known array size
fn lower_array_repeat_lit_with_val_sb(val_temp: String, count_val: i64, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let count_str = int_to_string(count_val);
    let alloc_size = int_to_string(count_val + 2);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = call @calloc(" + alloc_size + ", 8)");
    // Store capacity at index 0
    let cap_val = "%_t" + int_to_string(temp_id + 1);
    let w2a = sb_push_mir(sb, "  " + cap_val + " = const " + count_str);
    let cap_idx = "%_t" + int_to_string(temp_id + 2);
    let w2b = sb_push_mir(sb, "  " + cap_idx + " = const 0");
    let cap_gep = "%_t" + int_to_string(temp_id + 3);
    let w2c = sb_push_mir(sb, "  " + cap_gep + " = gep " + tmp + ", " + cap_idx);
    let w2d = sb_push_mir(sb, "  store_ptr " + cap_gep + ", " + cap_val);
    // Store length at index 1
    let len_idx = "%_t" + int_to_string(temp_id + 4);
    let w2e = sb_push_mir(sb, "  " + len_idx + " = const 1");
    let len_gep = "%_t" + int_to_string(temp_id + 5);
    let w2f = sb_push_mir(sb, "  " + len_gep + " = gep " + tmp + ", " + len_idx);
    let w2g = sb_push_mir(sb, "  store_ptr " + len_gep + ", " + cap_val);
    // Fill data positions with val_temp (already lowered expression result)
    let end_temp = emit_fill_stores(tmp, val_temp, 0, count_val, temp_id + 6, sb);
    // Copy MUST be last — lower_let_sb uses (next_temp - 1) as result
    let result = "%_t" + int_to_string(end_temp);
    let w3 = sb_push_mir(sb, "  " + result + " = copy " + tmp);
    pack_ids(end_temp + 1, block_id);

fn lower_array_repeat_expr_sb(count_temp: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    // Compute alloc_size = count + 2 at runtime
    let two_tmp = "%_t" + int_to_string(temp_id);
    let w0b = sb_push_mir(sb, "  " + two_tmp + " = const 2");
    let alloc_tmp = "%_t" + int_to_string(temp_id + 1);
    let w0c = sb_push_mir(sb, "  " + alloc_tmp + " = + " + count_temp + ", " + two_tmp);
    // Allocate: calloc(alloc_size, 8)
    let arr_tmp = "%_t" + int_to_string(temp_id + 2);
    let w1 = sb_push_mir(sb, "  " + arr_tmp + " = call @calloc(" + alloc_tmp + ", 8)");
    // Store capacity at index 0
    let cap_idx = "%_t" + int_to_string(temp_id + 3);
    let w2b = sb_push_mir(sb, "  " + cap_idx + " = const 0");
    let cap_gep = "%_t" + int_to_string(temp_id + 4);
    let w2c = sb_push_mir(sb, "  " + cap_gep + " = gep " + arr_tmp + ", " + cap_idx);
    let w2d = sb_push_mir(sb, "  store_ptr " + cap_gep + ", " + count_temp);
    // Store length at index 1
    let len_idx = "%_t" + int_to_string(temp_id + 5);
    let w2e = sb_push_mir(sb, "  " + len_idx + " = const 1");
    let len_gep = "%_t" + int_to_string(temp_id + 6);
    let w2f = sb_push_mir(sb, "  " + len_gep + " = gep " + arr_tmp + ", " + len_idx);
    let w2g = sb_push_mir(sb, "  store_ptr " + len_gep + ", " + count_temp);
    // Copy array base pointer as result
    let result = "%_t" + int_to_string(temp_id + 7);
    let w3 = sb_push_mir(sb, "  " + result + " = copy " + arr_tmp);
    pack_ids(temp_id + 8, block_id);

fn lower_array_literal_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let count = count_children(ast);
    let arr_tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + arr_tmp + " = call @calloc(" + int_to_string(count + 2) + ", 8)");
    // Store capacity at index 0
    let cap_val = "%_t" + int_to_string(temp_id + 1);
    let w2a = sb_push_mir(sb, "  " + cap_val + " = const " + int_to_string(count));
    let cap_idx = "%_t" + int_to_string(temp_id + 2);
    let w2b = sb_push_mir(sb, "  " + cap_idx + " = const 0");
    let cap_gep = "%_t" + int_to_string(temp_id + 3);
    let w2c = sb_push_mir(sb, "  " + cap_gep + " = gep " + arr_tmp + ", " + cap_idx);
    let w2d = sb_push_mir(sb, "  store_ptr " + cap_gep + ", " + cap_val);
    // Store length at index 1
    let len_idx = "%_t" + int_to_string(temp_id + 4);
    let w2e = sb_push_mir(sb, "  " + len_idx + " = const 1");
    let len_gep = "%_t" + int_to_string(temp_id + 5);
    let w2f = sb_push_mir(sb, "  " + len_gep + " = gep " + arr_tmp + ", " + len_idx);
    let w2g = sb_push_mir(sb, "  store_ptr " + len_gep + ", " + cap_val);
    // Store elements starting at index 2
    let ids = lower_array_elements_sb(ast, 0, count, arr_tmp, temp_id + 6, block_id, sb, loop_exit);
    // Emit copy of array base as result so callers get the pointer
    let result_temp = unpack_temp(ids);
    let result_tmp = "%_t" + int_to_string(result_temp);
    let w3 = sb_push_mir(sb, "  " + result_tmp + " = copy " + arr_tmp);
    pack_ids(result_temp + 1, unpack_block(ids));

// Store each element of array/tuple literal
fn lower_array_elements_sb(ast: String, idx: i64, count: i64, arr_tmp: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    lower_elements_with_offset_sb(ast, idx, count, arr_tmp, temp_id, block_id, sb, loop_exit, 2);

fn lower_tuple_elements_sb(ast: String, idx: i64, count: i64, arr_tmp: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    lower_elements_with_offset_sb(ast, idx, count, arr_tmp, temp_id, block_id, sb, loop_exit, 0);

fn lower_elements_with_offset_sb(ast: String, idx: i64, count: i64, arr_tmp: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String, base_offset: i64) -> i64 =
    if idx >= count { pack_ids(temp_id, block_id) }
    else {
        let elem = get_child(ast, idx);
        let ids = lower_expr_sb(elem, temp_id, block_id, sb, loop_exit);
        let new_temp = unpack_temp(ids);
        let new_block = unpack_block(ids);
        let elem_tmp = "%_t" + int_to_string(new_temp - 1);
        // Emit const for index+offset, gep for pointer, store_ptr for value
        let idx_tmp = "%_t" + int_to_string(new_temp);
        let w1 = sb_push_mir(sb, "  " + idx_tmp + " = const " + int_to_string(idx + base_offset));
        let gep_tmp = "%_t" + int_to_string(new_temp + 1);
        let w2 = sb_push_mir(sb, "  " + gep_tmp + " = gep " + arr_tmp + ", " + idx_tmp);
        let w3 = sb_push_mir(sb, "  store_ptr " + gep_tmp + ", " + elem_tmp);
        lower_elements_with_offset_sb(ast, idx + 1, count, arr_tmp, new_temp + 2, new_block, sb, loop_exit, base_offset)
    };

// Same structure as array literal but semantically a tuple
fn lower_tuple_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let count = count_children(ast);
    let tup_tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tup_tmp + " = call @calloc(" + int_to_string(count) + ", 8)");
    let ids = lower_tuple_elements_sb(ast, 0, count, tup_tmp, temp_id + 1, block_id, sb, loop_exit);
    let result_temp = unpack_temp(ids);
    let result_tmp = "%_t" + int_to_string(result_temp);
    let w2 = sb_push_mir(sb, "  " + result_tmp + " = copy " + tup_tmp);
    pack_ids(result_temp + 1, unpack_block(ids));

// AST: (struct_init <Name> <field1> val1 <field2> val2)
// MIR: calloc(field_count, 8) + field-store for each field
fn lower_struct_init_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let total_children = count_children(ast);
    let field_count = (total_children - 1) / 2;
    let base_tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + base_tmp + " = call @calloc(" + int_to_string(field_count) + ", 8)");
    let ids = lower_struct_fields_sb(ast, 1, total_children, base_tmp, temp_id + 1, block_id, sb, loop_exit);
    let result_temp = unpack_temp(ids);
    let result_tmp = "%_t" + int_to_string(result_temp);
    let w2 = sb_push_mir(sb, "  " + result_tmp + " = copy " + base_tmp);
    pack_ids(result_temp + 1, unpack_block(ids));

fn lower_struct_fields_sb(ast: String, idx: i64, total: i64, base_tmp: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    if idx >= total { pack_ids(temp_id, block_id) }
    else {
        let field_name_raw = get_child(ast, idx);
        let field_name = if field_name_raw.len() >= 2 and field_name_raw.byte_at(0) == 60 { field_name_raw.slice(1, field_name_raw.len() - 1) } else { field_name_raw };
        let val_expr = get_child(ast, idx + 1);
        let ids = lower_expr_sb(val_expr, temp_id, block_id, sb, loop_exit);
        let val_temp = unpack_temp(ids);
        let val_block = unpack_block(ids);
        let val_id = val_temp - 1;
        // Copy base to unique temp to avoid LLVM name collisions in field-store codegen
        let fs_base = "%_t" + int_to_string(val_temp);
        let w0 = sb_push_mir(sb, "  " + fs_base + " = copy " + base_tmp);
        let fs_text = "  field-store " + fs_base + "." + field_name + ", %_t" + int_to_string(val_id);
        let w1 = sb_push_mir(sb, fs_text);
        lower_struct_fields_sb(ast, idx + 2, total, base_tmp, val_temp + 1, val_block, sb, loop_exit)
    };

// Count children in AST node (array, call, etc.)
fn count_children(ast: String) -> i64 =
    count_children_at(ast, 0, 0);

fn count_children_at(ast: String, idx: i64, count: i64) -> i64 =
    let child = get_child(ast, idx);
    if child == "" or child.len() == 0 { count }
    else { count_children_at(ast, idx + 1, count + 1) };

fn step_cast_ptr_f64_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let inner = get_field(item, 1);
    let cont = make_work3("FQ", "", "", "");
    let eval = make_work3("EX", inner, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

fn step_cast_ptr_f64_finish(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let result_id = cur_temp - 1;
    let result = "%_t" + i2s(result_id);
    let w1 = sb_push_mir(sb, "  mark_f64_ptr " + result);
    make_step_leaf(cur_temp);

fn step_array_literal(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let ids = lower_array_literal_sb(ast, cur_temp, cur_block, sb, cur_exit_label);
    let new_block = unpack_block(ids);
    let new_exit = if new_block > cur_block { get_exit_label(ast, cur_exit_label, cur_block) } else { cur_exit_label };
    make_step(unpack_temp(ids), new_block, new_exit, "");

fn step_tuple(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let ids = lower_tuple_sb(ast, cur_temp, cur_block, sb, cur_exit_label);
    let new_block = unpack_block(ids);
    let new_exit = if new_block > cur_block { get_exit_label(ast, cur_exit_label, cur_block) } else { cur_exit_label };
    make_step(unpack_temp(ids), new_block, new_exit, "");

fn step_array_repeat(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    // AST: (array_repeat val_expr count_expr)
    let val_ast = get_child(ast, 0);
    let count_ast = get_child(ast, 1);
    let count_type = get_node_type(count_ast);
    if count_type == "int" {
        let count_val = extract_int_value(count_ast);
        let val_type = get_node_type(val_ast);
        if val_type == "int" {
            let val_str = int_to_string(extract_int_value(val_ast));
            step_array_repeat_lit(val_str, int_to_string(count_val), cur_temp, sb)
        } else {
            let ids = lower_expr_sb(val_ast, cur_temp, cur_block, sb, cur_exit_label);
            let new_temp = unpack_temp(ids);
            let val_temp = "%_t" + i2s(new_temp - 1);
            let arr_leaf = step_array_repeat_lit_with_val(val_temp, count_val, new_temp, sb);
            let result_temp = new_temp + 6 + count_val * 2 + 1;
            let w_mark = if val_type == "string" { sb_push_mir(sb, "  mark_str_ptr %_t" + i2s(result_temp - 1)) } else { 0 };
            arr_leaf
        }
    } else {
        // Lower count expression, then use result for array allocation
        let ids = lower_expr_sb(count_ast, cur_temp, cur_block, sb, cur_exit_label);
        let count_temp = "%_t" + i2s(cur_temp);
        let new_temp = unpack_temp(ids);
        step_array_repeat_expr(count_temp, new_temp, sb)
    };

// val_str: initial value as string ("0", "1", etc.)
// IMPORTANT: The copy (result) MUST be the last temp before make_step_leaf
fn step_array_repeat_lit(val_str: String, count_str: String, cur_temp: i64, sb: i64) -> String =
    let tmp = "%_t" + i2s(cur_temp);
    let count_val = parse_int_simple(count_str, 0, 0);
    let alloc_size = int_to_string(count_val + 2);
    let w1 = sb_push_mir(sb, "  " + tmp + " = call @calloc(" + alloc_size + ", 8)");
    // Store capacity at index 0
    let cap_val = "%_t" + i2s(cur_temp + 1);
    let w2a = sb_push_mir(sb, "  " + cap_val + " = const " + count_str);
    let cap_idx = "%_t" + i2s(cur_temp + 2);
    let w2b = sb_push_mir(sb, "  " + cap_idx + " = const 0");
    let cap_gep = "%_t" + i2s(cur_temp + 3);
    let w2c = sb_push_mir(sb, "  " + cap_gep + " = gep " + tmp + ", " + cap_idx);
    let w2d = sb_push_mir(sb, "  store_ptr " + cap_gep + ", " + cap_val);
    // Store length at index 1
    let len_idx = "%_t" + i2s(cur_temp + 4);
    let w2e = sb_push_mir(sb, "  " + len_idx + " = const 1");
    let len_gep = "%_t" + i2s(cur_temp + 5);
    let w2f = sb_push_mir(sb, "  " + len_gep + " = gep " + tmp + ", " + len_idx);
    let w2g = sb_push_mir(sb, "  store_ptr " + len_gep + ", " + cap_val);
    if val_str == "0" {
        let result = "%_t" + i2s(cur_temp + 6);
        let w3 = sb_push_mir(sb, "  " + result + " = copy " + tmp);
        make_step_leaf(cur_temp + 7)
    } else {
        let val_tmp = "%_t" + i2s(cur_temp + 6);
        let wv = sb_push_mir(sb, "  " + val_tmp + " = const " + val_str);
        let end_temp = emit_fill_stores_step(tmp, val_tmp, 0, count_val, cur_temp + 7, sb);
        // Copy MUST be last — result convention uses (next_temp - 1)
        let result = "%_t" + i2s(end_temp);
        let w3 = sb_push_mir(sb, "  " + result + " = copy " + tmp);
        make_step_leaf(end_temp + 1)
    };

fn step_array_repeat_lit_with_val(val_temp: String, count_val: i64, cur_temp: i64, sb: i64) -> String =
    let count_str = int_to_string(count_val);
    let alloc_size = int_to_string(count_val + 2);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = call @calloc(" + alloc_size + ", 8)");
    // Store capacity at index 0
    let cap_val = "%_t" + i2s(cur_temp + 1);
    let w2a = sb_push_mir(sb, "  " + cap_val + " = const " + count_str);
    let cap_idx = "%_t" + i2s(cur_temp + 2);
    let w2b = sb_push_mir(sb, "  " + cap_idx + " = const 0");
    let cap_gep = "%_t" + i2s(cur_temp + 3);
    let w2c = sb_push_mir(sb, "  " + cap_gep + " = gep " + tmp + ", " + cap_idx);
    let w2d = sb_push_mir(sb, "  store_ptr " + cap_gep + ", " + cap_val);
    // Store length at index 1
    let len_idx = "%_t" + i2s(cur_temp + 4);
    let w2e = sb_push_mir(sb, "  " + len_idx + " = const 1");
    let len_gep = "%_t" + i2s(cur_temp + 5);
    let w2f = sb_push_mir(sb, "  " + len_gep + " = gep " + tmp + ", " + len_idx);
    let w2g = sb_push_mir(sb, "  store_ptr " + len_gep + ", " + cap_val);
    // Fill data positions with val_temp
    let end_temp = emit_fill_stores_step(tmp, val_temp, 0, count_val, cur_temp + 6, sb);
    // Copy MUST be last
    let result = "%_t" + i2s(end_temp);
    let w3 = sb_push_mir(sb, "  " + result + " = copy " + tmp);
    make_step_leaf(end_temp + 1);

fn step_array_repeat_expr(count_temp: String, cur_temp: i64, sb: i64) -> String =
    // Compute alloc_size = count + 2 at runtime
    let two_tmp = "%_t" + i2s(cur_temp);
    let w0b = sb_push_mir(sb, "  " + two_tmp + " = const 2");
    let alloc_tmp = "%_t" + i2s(cur_temp + 1);
    let w0c = sb_push_mir(sb, "  " + alloc_tmp + " = + " + count_temp + ", " + two_tmp);
    // Allocate: calloc(alloc_size, 8)
    let arr_tmp = "%_t" + i2s(cur_temp + 2);
    let w1 = sb_push_mir(sb, "  " + arr_tmp + " = call @calloc(" + alloc_tmp + ", 8)");
    // Store capacity at index 0
    let cap_idx = "%_t" + i2s(cur_temp + 3);
    let w2b = sb_push_mir(sb, "  " + cap_idx + " = const 0");
    let cap_gep = "%_t" + i2s(cur_temp + 4);
    let w2c = sb_push_mir(sb, "  " + cap_gep + " = gep " + arr_tmp + ", " + cap_idx);
    let w2d = sb_push_mir(sb, "  store_ptr " + cap_gep + ", " + count_temp);
    // Store length at index 1
    let len_idx = "%_t" + i2s(cur_temp + 5);
    let w2e = sb_push_mir(sb, "  " + len_idx + " = const 1");
    let len_gep = "%_t" + i2s(cur_temp + 6);
    let w2f = sb_push_mir(sb, "  " + len_gep + " = gep " + arr_tmp + ", " + len_idx);
    let w2g = sb_push_mir(sb, "  store_ptr " + len_gep + ", " + count_temp);
    // Copy array base pointer as result
    let result = "%_t" + i2s(cur_temp + 7);
    let w3 = sb_push_mir(sb, "  " + result + " = copy " + arr_tmp);
    make_step_leaf(cur_temp + 8);

// Build argument string from temp range [start, end)

fn lower_expr_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let ntype = get_node_type(ast);
    if ntype == "int" { lower_int_sb(ast, temp_id, block_id, sb) } else if ntype == "float" { lower_float_sb(ast, temp_id, block_id, sb) } else if ntype == "bool" { lower_bool_sb(ast, temp_id, block_id, sb) } else if ntype == "string" { lower_string_sb(ast, temp_id, block_id, sb) } else if ntype == "var" { lower_var_sb(ast, temp_id, block_id, sb) } else if ntype == "binop" { lower_binop_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "unary" { lower_unary_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "if" { lower_if_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "let" { lower_let_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "let_mut" { lower_let_mut_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "call" { lower_call_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "method" { lower_method_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "block" { lower_block_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "unit" { lower_unit_sb(ast, temp_id, block_id, sb) } else if ntype == "seq" { lower_seq_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "assign" { lower_assign_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "while" { lower_while_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "loop" { lower_loop_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "for" { lower_for_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "for_incl" { lower_for_incl_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "for_step" { lower_for_step_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "for_step_incl" { lower_for_step_incl_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "field" { lower_field_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "set_field" { lower_set_field_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "index" { lower_index_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "ptr_index" { lower_ptr_index_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "set_index" { lower_set_index_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "set_ptr_index" { lower_ptr_set_index_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "break" { lower_break_sb(loop_exit, temp_id, block_id, sb) } else if ntype == "continue" { lower_continue_sb(loop_exit, temp_id, block_id, sb) } else if ntype == "return" { lower_return_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "cast_ptr_f64" { lower_cast_ptr_f64_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "cast_i64" { lower_cast_i64_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "cast_f64" { lower_cast_f64_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "cast_i32" { lower_cast_i32_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "array_repeat" { lower_array_repeat_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "array" { lower_array_literal_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "tuple" { lower_tuple_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "struct_init" { lower_struct_init_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "set_var" { lower_set_var_sb(ast, temp_id, block_id, sb, loop_exit) } else if ntype == "lambda" { lower_lambda_sb(ast, temp_id, block_id, sb, loop_exit) } else { pack_ids(temp_id, block_id) };

fn lower_int_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let val = extract_int_value(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + int_to_string(val));
    pack_ids(temp_id + 1, block_id);

// v0.91: Lower float literal to MIR: (float 3.14) → %_t0 = const F:3.14
fn lower_float_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let text = extract_float_value_text(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const F:" + text);
    pack_ids(temp_id + 1, block_id);

fn lower_bool_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + int_to_string(val));
    pack_ids(temp_id + 1, block_id);

fn lower_string_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let str_content = extract_string_content(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = string " + chr(34) + str_content + chr(34));
    pack_ids(temp_id + 1, block_id);

fn extract_string_content(ast: String) -> String =
    let start = 8;
    let end = ast.len() - 1;
    if end > start { unescape_parens_from_ast(ast.slice(start, end)) } else { "" };

fn lower_var_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let name = extract_name(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = copy %" + name);
    pack_ids(temp_id + 1, block_id);

// v0.92: Float-aware binop lowering - detect float operands and use f+/f-/f*/f/ MIR operators
fn lower_binop_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let op = get_child(ast, 0);
    let left_ast = get_child(ast, 1);
    let right_ast = get_child(ast, 2);
    let left_result = lower_expr_sb(left_ast, temp_id, block_id, sb, loop_exit);
    let left_temp = unpack_temp(left_result);
    let left_block = unpack_block(left_result);
    let left_id = left_temp - 1;
    let right_result = lower_expr_sb(right_ast, left_temp, left_block, sb, loop_exit);
    let right_temp = unpack_temp(right_result);
    let right_block = unpack_block(right_result);
    let right_id = right_temp - 1;
    let result_tmp = "%_t" + int_to_string(right_temp);
    // v0.92: Use float MIR operator (f+, f-, etc) when operands are float
    let mir_op = if is_float_expr(left_ast) { "f" + op } else { op };
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(left_id) + ", %_t" + int_to_string(right_id));
    pack_ids(right_temp + 1, right_block);

fn lower_unary_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let op = get_child(ast, 0);
    let operand = get_child(ast, 1);
    let operand_result = lower_expr_sb(operand, temp_id, block_id, sb, loop_exit);
    let operand_temp = unpack_temp(operand_result);
    let operand_block = unpack_block(operand_result);
    let operand_id = operand_temp - 1;
    let result_tmp = "%_t" + int_to_string(operand_temp);
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(operand_id));
    pack_ids(operand_temp + 1, operand_block);

// v0.95: Pure expression check for select optimization
// Select evaluates BOTH branches, so only pure (side-effect-free, non-trapping) expressions are safe.
// String literals are excluded: bmb_string_new_from_cstr allocates memory (leak if not selected).
// Division and modulo are excluded: they trap on zero (UB when divisor is 0).
fn is_pure_expr(ast: String) -> bool =
    let nt = get_node_type(ast);
    if nt == "int" or nt == "bool" or nt == "var" or nt == "float" or nt == "unit" { true }
    else if nt == "binop" {
        let op = get_child(ast, 0);
        if op == "/" or op == "%" { false }
        else { is_pure_expr(get_child(ast, 1)) and is_pure_expr(get_child(ast, 2)) }
    }
    else if nt == "unary" { is_pure_expr(get_child(ast, 1)) }
    else if nt == "cast_i64" or nt == "cast_f64" or nt == "cast_i32" { is_pure_expr(get_child(ast, 0)) }
    else { false };

fn lower_if_select_sb(cond: String, then_b: String, else_b: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let cond_result = lower_expr_sb(cond, temp_id, block_id, sb, loop_exit);
    let cond_temp = unpack_temp(cond_result);
    let cond_blk = unpack_block(cond_result);
    let cond_id = cond_temp - 1;
    let then_result = lower_expr_sb(then_b, cond_temp, cond_blk, sb, loop_exit);
    let then_temp = unpack_temp(then_result);
    let then_id = then_temp - 1;
    let else_result = lower_expr_sb(else_b, then_temp, cond_blk, sb, loop_exit);
    let else_temp = unpack_temp(else_result);
    let else_id = else_temp - 1;
    let select_tmp = "%_t" + int_to_string(else_temp);
    let w = sb_push_mir(sb, "  " + select_tmp + " = select %_t" + int_to_string(cond_id) + ", %_t" + int_to_string(then_id) + ", %_t" + int_to_string(else_id));
    pack_ids(else_temp + 1, cond_blk);

fn lower_if_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let cond = get_child(ast, 0);
    let then_branch = get_child(ast, 1);
    let else_branch = get_child(ast, 2);
    if is_pure_expr(then_branch) and is_pure_expr(else_branch) {
        lower_if_select_sb(cond, then_branch, else_branch, temp_id, block_id, sb, loop_exit)
    } else {
        lower_if_branch_sb(cond, then_branch, else_branch, temp_id, block_id, sb, loop_exit)
    };

fn lower_if_branch_sb(cond: String, then_branch: String, else_branch: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let cond_result = lower_expr_sb(cond, temp_id, block_id, sb, loop_exit);
    let cond_temp = unpack_temp(cond_result);
    let my_block_id = unpack_block(cond_result);
    let cond_id = cond_temp - 1;
    let then_label = "then_" + int_to_string(my_block_id);
    let else_label = "else_" + int_to_string(my_block_id);
    let merge_label = "merge_" + int_to_string(my_block_id);
    let branch_text = "  branch %_t" + int_to_string(cond_id) + ", " + then_label + ", " + else_label;
    let w1 = sb_push_mir(sb, branch_text);
    let then_label_text = then_label + ":";
    let w2 = sb_push_mir(sb, then_label_text);
    let then_result = lower_expr_sb(then_branch, cond_temp, my_block_id + 1, sb, loop_exit);
    let then_temp = unpack_temp(then_result);
    let then_block = unpack_block(then_result);
    let then_id = then_temp - 1;
    let then_exit = get_exit_label(then_branch, then_label, my_block_id + 1);
    let goto_merge1 = "  goto " + merge_label;
    let w3 = sb_push_mir(sb, goto_merge1);
    let else_label_text = else_label + ":";
    let w4 = sb_push_mir(sb, else_label_text);
    let else_result = lower_expr_sb(else_branch, then_temp, then_block, sb, loop_exit);
    let else_temp = unpack_temp(else_result);
    let else_block = unpack_block(else_result);
    let else_id = else_temp - 1;
    let else_exit = get_exit_label(else_branch, else_label, then_block);
    let goto_merge2 = "  goto " + merge_label;
    let w5 = sb_push_mir(sb, goto_merge2);
    let merge_label_text = merge_label + ":";
    let w6 = sb_push_mir(sb, merge_label_text);
    let phi_tmp = "%_t" + int_to_string(else_temp);
    let phi_text = "  " + phi_tmp + " = phi [%_t" + int_to_string(then_id) + ", " + then_exit + "], [%_t" + int_to_string(else_id) + ", " + else_exit + "]";
    let w7 = sb_push_mir(sb, phi_text);
    pack_ids(else_temp + 1, else_block);

// This fixes 21 golden test opt-fail errors where `let x = 0; set x = val;`
// generated store to non-existent alloca. LLVM mem2reg promotes unused allocas.
fn lower_let_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let name = extract_name(ast);
    // let binding names, fixing variable shadowing (let x = 1; let x = x + 10;)
    let unique_name = name + "_" + int_to_string(temp_id);
    let value_ast = get_child(ast, 1);
    let body_raw = get_child(ast, 2);
    let body_ast = rename_name_in_ast(body_raw, name, unique_name);
    let val_result = lower_expr_sb(value_ast, temp_id, block_id, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let w1 = sb_push_mir(sb, "  alloca %" + unique_name);
    let w2 = sb_push_mir(sb, "  store %" + unique_name + ", %_t" + int_to_string(val_id));
    lower_expr_sb(body_ast, val_temp, val_block, sb, loop_exit);

// v0.92: Mutable let - emit alloca + store instead of copy
fn lower_let_mut_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let name = extract_name(ast);
    let unique_name = name + "_" + int_to_string(temp_id);
    let value_ast = get_child(ast, 1);
    let body_raw = get_child(ast, 2);
    let body_ast = rename_name_in_ast(body_raw, name, unique_name);
    let val_result = lower_expr_sb(value_ast, temp_id, block_id, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let w1 = sb_push_mir(sb, "  alloca %" + unique_name);
    let w2 = sb_push_mir(sb, "  store %" + unique_name + ", %_t" + int_to_string(val_id));
    lower_expr_sb(body_ast, val_temp, val_block, sb, loop_exit);

fn lower_call_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let name = extract_name(ast);
    lower_call_args_sb(ast, name, temp_id, block_id, 1, "", sb, loop_exit);

fn lower_call_args_sb(ast: String, name: String, temp_id: i64, block_id: i64, idx: i64, args_acc: String, sb: i64, loop_exit: String) -> i64 =
    let arg = get_child(ast, idx);
    if arg == "" {
        let result_tmp = "%_t" + int_to_string(temp_id);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "(" + args_acc + ")");
        pack_ids(temp_id + 1, block_id)
    } else {
        let arg_result = lower_expr_sb(arg, temp_id, block_id, sb, loop_exit);
        let arg_temp = unpack_temp(arg_result);
        let arg_block = unpack_block(arg_result);
        let arg_id = arg_temp - 1;
        let new_args = if args_acc == "" { "%_t" + int_to_string(arg_id) } else { args_acc + ", %_t" + int_to_string(arg_id) };
        lower_call_args_sb(ast, name, arg_temp, arg_block, idx + 1, new_args, sb, loop_exit)
    };

// Method AST: (method name receiver arg1 arg2 ...)
// String methods map to bmb_string_* functions
fn lower_method_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let method_name = get_child(ast, 0);
    if is_nullable_method(method_name) {
        lower_nullable_method_sb(ast, method_name, temp_id, block_id, sb, loop_exit)
    } else {
        let receiver = get_child(ast, 1);
        let runtime_fn = method_to_runtime_fn(method_name);
        lower_method_args_sb(ast, runtime_fn, receiver, temp_id, block_id, 2, sb, loop_exit)
    };

fn lower_nullable_method_sb(ast: String, method: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let receiver = get_child(ast, 1);
    let recv_result = lower_expr_sb(receiver, temp_id, block_id, sb, loop_exit);
    let recv_temp = unpack_temp(recv_result);
    let recv_block = unpack_block(recv_result);
    let recv_id = recv_temp - 1;
    if method == "is_some" {
        let result = "%_t" + int_to_string(recv_temp);
        let w1 = sb_push_mir(sb, "  " + result + " = != %_t" + int_to_string(recv_id) + ", 0");
        pack_ids(recv_temp + 1, recv_block)
    } else if method == "is_none" {
        let result = "%_t" + int_to_string(recv_temp);
        let w1 = sb_push_mir(sb, "  " + result + " = == %_t" + int_to_string(recv_id) + ", 0");
        pack_ids(recv_temp + 1, recv_block)
    } else if method == "unwrap" or method == "expect" {
        // Identity - result is the receiver
        pack_ids(recv_temp, recv_block)
    } else if method == "unwrap_or" {
        let default_arg = get_child(ast, 2);
        let def_result = lower_expr_sb(default_arg, recv_temp, recv_block, sb, loop_exit);
        let def_temp = unpack_temp(def_result);
        let def_block = unpack_block(def_result);
        let def_id = def_temp - 1;
        let result = "%_t" + int_to_string(def_temp);
        let w1 = sb_push_mir(sb, "  " + result + " = nullable_select %_t" + int_to_string(recv_id) + ", %_t" + int_to_string(def_id));
        pack_ids(def_temp + 1, def_block)
    } else { pack_ids(recv_temp, recv_block) };

fn method_to_runtime_fn(method: String) -> String =
    if method == "len" { "bmb_string_len" }
    else if method == "byte_at" { "bmb_string_char_at" }
    else if method == "slice" { "bmb_string_slice" }
    else if method == "concat" { "bmb_string_concat" }
    else if method == "starts_with" { "bmb_string_starts_with" }
    else if method == "ends_with" { "bmb_string_ends_with" }
    else if method == "contains" { "bmb_string_contains" }
    else if method == "index_of" { "bmb_string_index_of" }
    else if method == "trim" { "bmb_string_trim" }
    else if method == "replace" { "bmb_string_replace" }
    else if method == "to_upper" { "bmb_string_to_upper" }
    else if method == "to_lower" { "bmb_string_to_lower" }
    else if method == "repeat" { "bmb_string_repeat" }
    else if method == "is_empty" { "bmb_string_is_empty" }
    else if method == "push" { "bmb_array_push" }
    else if method == "pop" { "bmb_array_pop" }
    else if method == "arr_len" { "bmb_array_len" }
    else if method == "arr_concat" { "bmb_array_concat" }
    else if method == "arr_slice" { "bmb_array_slice" }
    else if method == "clamp" { "bmb_clamp" }
    else if method == "pow" { "bmb_pow" }
    else if method == "floor" { "bmb_f64_floor" }
    else if method == "ceil" { "bmb_f64_ceil" }
    else if method == "round" { "bmb_f64_round" }
    else if method == "sqrt" { "bmb_f64_sqrt" }
    else if method == "is_nan" { "bmb_f64_is_nan" }
    else if method == "to_int" { "f64_to_i64" }
    else if method == "to_float" { "i64_to_f64" }
    else { "bmb_" + method };

fn lower_method_args_sb(ast: String, fn_name: String, receiver: String, temp_id: i64, block_id: i64, idx: i64, sb: i64, loop_exit: String) -> i64 =
    let recv_result = lower_expr_sb(receiver, temp_id, block_id, sb, loop_exit);
    let recv_temp = unpack_temp(recv_result);
    let recv_block = unpack_block(recv_result);
    let recv_id = recv_temp - 1;
    let args_acc = "%_t" + int_to_string(recv_id);
    lower_method_extra_args_sb(ast, fn_name, recv_temp, recv_block, idx, args_acc, sb, loop_exit);

fn lower_method_extra_args_sb(ast: String, fn_name: String, temp_id: i64, block_id: i64, idx: i64, args_acc: String, sb: i64, loop_exit: String) -> i64 =
    let arg = get_child(ast, idx);
    if arg == "" {
        let result_tmp = "%_t" + int_to_string(temp_id);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + fn_name + "(" + args_acc + ")");
        pack_ids(temp_id + 1, block_id)
    } else {
        let arg_result = lower_expr_sb(arg, temp_id, block_id, sb, loop_exit);
        let arg_temp = unpack_temp(arg_result);
        let arg_block = unpack_block(arg_result);
        let arg_id = arg_temp - 1;
        let new_args = args_acc + ", %_t" + int_to_string(arg_id);
        lower_method_extra_args_sb(ast, fn_name, arg_temp, arg_block, idx + 1, new_args, sb, loop_exit)
    };

// Block format: (block inner_expr)
fn lower_block_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let inner = block_inner(ast);
    lower_expr_sb(inner, temp_id, block_id, sb, loop_exit);

// Extract inner expression from (block inner)
fn block_inner(ast: String) -> String =
    let len = ast.len();
    if len < 9 { "" } else { ast.slice(7, len - 1) };

fn lower_unit_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const 0");
    pack_ids(temp_id + 1, block_id);

// Seq format: (seq expr1 expr2)
fn lower_seq_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let e1 = seq_first(ast);
    let e2 = seq_second(ast);
    let r1 = lower_expr_sb(e1, temp_id, block_id, sb, loop_exit);
    let t1 = unpack_temp(r1);
    let b1 = unpack_block(r1);
    lower_expr_sb(e2, t1, b1, sb, loop_exit);

// Extract first expression from (seq e1 e2)
fn seq_first(ast: String) -> String =
    let len = ast.len();
    if len < 10 { "" } else {
        let content = ast.slice(5, len - 1);
        find_first_balanced(content, 0, 0, "")
    };

// Extract second expression from (seq e1 e2)
fn seq_second(ast: String) -> String =
    let len = ast.len();
    if len < 10 { "" } else {
        let content = ast.slice(5, len - 1);
        find_rest_balanced(content, 0, 0)
    };

// Find first balanced expression (stop at top-level space)
fn find_first_balanced(s: String, idx: i64, depth: i64, acc: String) -> String =
    if idx >= s.len() { acc } else {
        let c = s.byte_at(idx);
        if c == 40 { find_first_balanced(s, idx + 1, depth + 1, acc + chr(c)) }
        else if c == 41 { find_first_balanced(s, idx + 1, depth - 1, acc + chr(c)) }
        else if c == 32 and depth == 0 { acc }
        else { find_first_balanced(s, idx + 1, depth, acc + chr(c)) }
    };

// Find rest after first balanced expression
fn find_rest_balanced(s: String, idx: i64, depth: i64) -> String =
    if idx >= s.len() { "" } else {
        let c = s.byte_at(idx);
        if c == 40 { find_rest_balanced(s, idx + 1, depth + 1) }
        else if c == 41 { find_rest_balanced(s, idx + 1, depth - 1) }
        else if c == 32 and depth == 0 { s.slice(idx + 1, s.len()) }
        else { find_rest_balanced(s, idx + 1, depth) }
    };

// Assign format: (assign lhs rhs)
// v0.92: Use store instead of copy for mutable variable assignments
fn lower_assign_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let lhs = assign_lhs_expr(ast);
    let rhs = assign_rhs_expr(ast);
    let rr = lower_expr_sb(rhs, temp_id, block_id, sb, loop_exit);
    let tr = unpack_temp(rr);
    let br = unpack_block(rr);
    let rhs_id = tr - 1;
    // Extract target name from lhs (var <name>)
    let name = extract_var_from_assign(lhs);
    let w1 = sb_push_mir(sb, "  store %" + name + ", %_t" + int_to_string(rhs_id));
    // Assignment returns unit
    let tmp = "%_t" + int_to_string(tr);
    let w2 = sb_push_mir(sb, "  " + tmp + " = const 0");
    pack_ids(tr + 1, br);

// ============================================================================
// ============================================================================
// MIR format:
//   goto loop_N
//   loop_N:
//     <cond code>
//     branch %cond, body_N, exit_N
//   body_N:
//     <body code>
//     goto loop_N
//   exit_N:
//     %result = const 0   ; while returns unit

fn lower_while_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let cond_ast = get_child(ast, 0);
    let body_ast = get_child(ast, 1);
    let loop_label = "loop_" + int_to_string(block_id);
    let body_label = "body_" + int_to_string(block_id);
    let exit_label = "exit_" + int_to_string(block_id);
    // Jump to loop header
    let goto_loop = "  goto " + loop_label;
    let w1 = sb_push_mir(sb, goto_loop);
    let loop_label_text = loop_label + ":";
    let w2 = sb_push_mir(sb, loop_label_text);
    // Lower condition (condition doesn't need break)
    let cond_result = lower_expr_sb(cond_ast, temp_id, block_id + 1, sb, "");
    let cond_temp = unpack_temp(cond_result);
    let cond_block = unpack_block(cond_result);
    let cond_id = cond_temp - 1;
    // Branch on condition
    let branch_text = "  branch %_t" + int_to_string(cond_id) + ", " + body_label + ", " + exit_label;
    let w3 = sb_push_mir(sb, branch_text);
    let body_label_text = body_label + ":";
    let w4 = sb_push_mir(sb, body_label_text);
    // Lower body - pass THIS while's exit_label so break can jump to it
    let body_result = lower_expr_sb(body_ast, cond_temp, cond_block, sb, exit_label);
    let body_temp = unpack_temp(body_result);
    let body_block = unpack_block(body_result);
    // Jump back to loop header
    let goto_loop2 = "  goto " + loop_label;
    let w5 = sb_push_mir(sb, goto_loop2);
    let exit_label_text = exit_label + ":";
    let w6 = sb_push_mir(sb, exit_label_text);
    // While returns unit
    let result_tmp = "%_t" + int_to_string(body_temp);
    let result_text = "  " + result_tmp + " = const 0";
    let w7 = sb_push_mir(sb, result_text);
    pack_ids(body_temp + 1, body_block);

// AST: (loop body) → MIR:
//   goto loop_N
//   loop_N:
//     <body code>
//     goto loop_N
//   exit_N:
//     %result = const 0   ; loop returns unit
fn lower_loop_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let body_ast = get_child(ast, 0);
    let loop_label = "loop_" + int_to_string(block_id);
    let exit_label = "exit_" + int_to_string(block_id);
    // Jump to loop header
    let goto_loop = "  goto " + loop_label;
    let w1 = sb_push_mir(sb, goto_loop);
    let loop_label_text = loop_label + ":";
    let w2 = sb_push_mir(sb, loop_label_text);
    // Lower body - pass exit_label so break can jump to it
    let body_result = lower_expr_sb(body_ast, temp_id, block_id + 1, sb, exit_label);
    let body_temp = unpack_temp(body_result);
    let body_block = unpack_block(body_result);
    // Jump back to loop header (unconditional)
    let goto_loop2 = "  goto " + loop_label;
    let w3 = sb_push_mir(sb, goto_loop2);
    let exit_label_text = exit_label + ":";
    let w4 = sb_push_mir(sb, exit_label_text);
    // Loop returns unit
    let result_tmp = "%_t" + int_to_string(body_temp);
    let result_text = "  " + result_tmp + " = const 0";
    let w5 = sb_push_mir(sb, result_text);
    pack_ids(body_temp + 1, body_block);

// AST: (break) → MIR: goto <exit_label> + unreachable block
fn lower_break_sb(loop_exit: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let goto_text = "  goto " + loop_exit;
    let w1 = sb_push_mir(sb, goto_text);
    // Start unreachable block for code after break (required for LLVM IR validity)
    let after_label = "after_break_" + int_to_string(block_id);
    let label_text = after_label + ":";
    let w2 = sb_push_mir(sb, label_text);
    // Return unit value in unreachable block
    let tmp = "%_t" + int_to_string(temp_id);
    let const_text = "  " + tmp + " = const 0";
    let w3 = sb_push_mir(sb, const_text);
    pack_ids(temp_id + 1, block_id);

// Derive loop header from exit label using derive_loop_start
// AST: (continue) → MIR: goto <loop_label> + unreachable block
fn lower_continue_sb(loop_exit: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let loop_label = derive_loop_start(loop_exit);
    let goto_text = "  goto " + loop_label;
    let w1 = sb_push_mir(sb, goto_text);
    // Start unreachable block for code after continue
    let after_label = "after_continue_" + int_to_string(block_id);
    let label_text = after_label + ":";
    let w2 = sb_push_mir(sb, label_text);
    // Return unit value in unreachable block
    let tmp = "%_t" + int_to_string(temp_id);
    let const_text = "  " + tmp + " = const 0";
    let w3 = sb_push_mir(sb, const_text);
    pack_ids(temp_id + 1, block_id);

// AST: (return) or (return expr) → MIR: return or return %val + unreachable block
fn lower_return_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    if ast.len() == 8 {
        // Bare return: (return)
        let w1 = sb_push_mir(sb, "  return");
        let after_label = "after_return_" + int_to_string(block_id);
        let label_text = after_label + ":";
        let w2 = sb_push_mir(sb, label_text);
        let tmp = "%_t" + int_to_string(temp_id);
        let const_text = "  " + tmp + " = const 0";
        let w3 = sb_push_mir(sb, const_text);
        pack_ids(temp_id + 1, block_id)
    } else {
        // Return with value: (return expr)
        let inner = get_child(ast, 0);
        let result = lower_expr_sb(inner, temp_id, block_id, sb, loop_exit);
        let val_temp = unpack_temp(result);
        let val_block = unpack_block(result);
        let val_id = val_temp - 1;
        let ret_text = "  return %_t" + int_to_string(val_id);
        let w1 = sb_push_mir(sb, ret_text);
        let after_label = "after_return_" + int_to_string(val_block);
        let label_text = after_label + ":";
        let w2 = sb_push_mir(sb, label_text);
        let tmp = "%_t" + int_to_string(val_temp);
        let const_text = "  " + tmp + " = const 0";
        let w3 = sb_push_mir(sb, const_text);
        pack_ids(val_temp + 1, val_block)
    };

// AST: (field base_expr field_name) → MIR: %dest = field-access %base.field_name
fn lower_field_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let field_name = get_child(ast, 1);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let dest = "%_t" + int_to_string(base_temp);
    let w1 = sb_push_mir(sb, "  " + dest + " = field-access %_t" + int_to_string(base_id) + "." + field_name);
    pack_ids(base_temp + 1, base_block);

fn lower_set_field_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let field_name = get_child(ast, 1);
    let val_expr = get_child(ast, 2);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let val_result = lower_expr_sb(val_expr, base_temp, base_block, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let w1 = sb_push_mir(sb, "  field-store %_t" + int_to_string(base_id) + "." + field_name + ", %_t" + int_to_string(val_id));
    let dest = "%_t" + int_to_string(val_temp);
    let w2 = sb_push_mir(sb, "  " + dest + " = const 0");
    pack_ids(val_temp + 1, val_block);

fn lower_set_var_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let name = extract_name(ast);
    let val_expr = get_child(ast, 1);
    let val_result = lower_expr_sb(val_expr, temp_id, block_id, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let w1 = sb_push_mir(sb, "  store %" + name + ", %_t" + int_to_string(val_id));
    let dest = "%_t" + int_to_string(val_temp);
    let w2 = sb_push_mir(sb, "  " + dest + " = const 0");
    pack_ids(val_temp + 1, val_block);

fn lower_index_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let idx_expr = get_child(ast, 1);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let idx_result = lower_expr_sb(idx_expr, base_temp, base_block, sb, loop_exit);
    let idx_temp = unpack_temp(idx_result);
    let idx_block = unpack_block(idx_result);
    let idx_id = idx_temp - 1;
    // Add 2 to index to skip array header
    let hdr_const = "%_t" + int_to_string(idx_temp);
    let w0a = sb_push_mir(sb, "  " + hdr_const + " = const 2");
    let offset_tmp = "%_t" + int_to_string(idx_temp + 1);
    let w0b = sb_push_mir(sb, "  " + offset_tmp + " = + %_t" + int_to_string(idx_id) + ", " + hdr_const);
    let gep_dest = "%_t" + int_to_string(idx_temp + 2);
    let load_dest = "%_t" + int_to_string(idx_temp + 3);
    let w1 = sb_push_mir(sb, "  " + gep_dest + " = gep %_t" + int_to_string(base_id) + ", " + offset_tmp);
    let w2 = sb_push_mir(sb, "  " + load_dest + " = load_ptr " + gep_dest);
    pack_ids(idx_temp + 4, idx_block);

fn lower_set_index_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let idx_expr = get_child(ast, 1);
    let val_expr = get_child(ast, 2);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let idx_result = lower_expr_sb(idx_expr, base_temp, base_block, sb, loop_exit);
    let idx_temp = unpack_temp(idx_result);
    let idx_block = unpack_block(idx_result);
    let idx_id = idx_temp - 1;
    let val_result = lower_expr_sb(val_expr, idx_temp, idx_block, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    // Add 2 to index to skip array header
    let hdr_const = "%_t" + int_to_string(val_temp);
    let w0a = sb_push_mir(sb, "  " + hdr_const + " = const 2");
    let offset_tmp = "%_t" + int_to_string(val_temp + 1);
    let w0b = sb_push_mir(sb, "  " + offset_tmp + " = + %_t" + int_to_string(idx_id) + ", " + hdr_const);
    let gep_dest = "%_t" + int_to_string(val_temp + 2);
    let w1 = sb_push_mir(sb, "  " + gep_dest + " = gep %_t" + int_to_string(base_id) + ", " + offset_tmp);
    let w2 = sb_push_mir(sb, "  store_ptr " + gep_dest + ", %_t" + int_to_string(val_id));
    let result_dest = "%_t" + int_to_string(val_temp + 3);
    let w3 = sb_push_mir(sb, "  " + result_dest + " = const 0");
    pack_ids(val_temp + 4, val_block);

// Raw pointer index: direct GEP without +2 array header offset
fn lower_ptr_index_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let idx_expr = get_child(ast, 1);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let idx_result = lower_expr_sb(idx_expr, base_temp, base_block, sb, loop_exit);
    let idx_temp = unpack_temp(idx_result);
    let idx_block = unpack_block(idx_result);
    let idx_id = idx_temp - 1;
    let gep_dest = "%_t" + int_to_string(idx_temp);
    let load_dest = "%_t" + int_to_string(idx_temp + 1);
    let w1 = sb_push_mir(sb, "  " + gep_dest + " = gep %_t" + int_to_string(base_id) + ", %_t" + int_to_string(idx_id));
    let w2 = sb_push_mir(sb, "  " + load_dest + " = load_ptr " + gep_dest);
    pack_ids(idx_temp + 2, idx_block);

// Raw pointer set_index: direct GEP without +2 array header offset
fn lower_ptr_set_index_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    let base_expr = get_child(ast, 0);
    let idx_expr = get_child(ast, 1);
    let val_expr = get_child(ast, 2);
    let base_result = lower_expr_sb(base_expr, temp_id, block_id, sb, loop_exit);
    let base_temp = unpack_temp(base_result);
    let base_block = unpack_block(base_result);
    let base_id = base_temp - 1;
    let idx_result = lower_expr_sb(idx_expr, base_temp, base_block, sb, loop_exit);
    let idx_temp = unpack_temp(idx_result);
    let idx_block = unpack_block(idx_result);
    let idx_id = idx_temp - 1;
    let val_result = lower_expr_sb(val_expr, idx_temp, idx_block, sb, loop_exit);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let gep_dest = "%_t" + int_to_string(val_temp);
    let w1 = sb_push_mir(sb, "  " + gep_dest + " = gep %_t" + int_to_string(base_id) + ", %_t" + int_to_string(idx_id));
    let w2 = sb_push_mir(sb, "  store_ptr " + gep_dest + ", %_t" + int_to_string(val_id));
    let result_dest = "%_t" + int_to_string(val_temp + 1);
    let w3 = sb_push_mir(sb, "  " + result_dest + " = const 0");
    pack_ids(val_temp + 2, val_block);

// ============================================================================
// v0.95: For-Loop Range Lowering
// ============================================================================
// AST: (for <varname> start_ast end_ast body_ast)
// MIR:
//   alloca %varname
//   <start code> → %_tS
//   store %varname, %_tS
//   <end code> → %_tE
//   goto for_start_N
// for_start_N:
//   %_tL = load %varname → resolves via alloca/load in codegen
//   %_tC = < %_tL, %_tE
//   branch %_tC, for_body_N, for_end_N
// for_body_N:
//   <body code>
//   %_tI = load %varname
//   %_tI+1 = const 1
//   %_tI+2 = + %_tI, %_tI+1
//   store %varname, %_tI+2
//   goto for_start_N
// for_end_N:
//   %_tR = const 0  ; for returns unit

fn extract_for_varname_from_ast(ast: String) -> String =
    let raw = get_child(ast, 0);
    if raw.len() < 3 { "" } else if raw.byte_at(0) != 60 { raw } else { raw.slice(1, raw.len() - 1) };

// cmp_op: "< " for exclusive (..), "<= " for inclusive (..=)
fn lower_for_range_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String, cmp_op: String) -> i64 =
    let varname = extract_for_varname_from_ast(ast);
    let unique_var = varname + "_" + int_to_string(temp_id);
    let start_ast = get_child(ast, 1);
    let end_ast = get_child(ast, 2);
    let body_raw = get_child(ast, 3);
    // Rename all <varname> references in body to <unique_var>
    let body_ast = rename_name_in_ast(body_raw, varname, unique_var);

    let for_start_lbl = "for_start_" + int_to_string(block_id);
    let for_body_lbl = "for_body_" + int_to_string(block_id);
    let for_end_lbl = "for_end_" + int_to_string(block_id);

    let w0 = sb_push_mir(sb, "  alloca %" + unique_var);

    let start_result = lower_expr_sb(start_ast, temp_id, block_id + 1, sb, "");
    let start_temp = unpack_temp(start_result);
    let start_block = unpack_block(start_result);
    let start_id = start_temp - 1;
    let w1 = sb_push_mir(sb, "  store %" + unique_var + ", %_t" + int_to_string(start_id));

    let end_result = lower_expr_sb(end_ast, start_temp, start_block, sb, "");
    let end_temp = unpack_temp(end_result);
    let end_block = unpack_block(end_result);
    let end_id = end_temp - 1;

    let goto_start = "  goto " + for_start_lbl;
    let w2 = sb_push_mir(sb, goto_start);
    let start_label_text = for_start_lbl + ":";
    let w3 = sb_push_mir(sb, start_label_text);

    let load_tmp = "%_t" + int_to_string(end_temp);
    let load_text = "  " + load_tmp + " = copy %" + unique_var;
    let w4 = sb_push_mir(sb, load_text);
    let cmp_tmp = "%_t" + int_to_string(end_temp + 1);
    let cmp_text = "  " + cmp_tmp + " = " + cmp_op + load_tmp + ", %_t" + int_to_string(end_id);
    let w5 = sb_push_mir(sb, cmp_text);
    let branch_text = "  branch " + cmp_tmp + ", " + for_body_lbl + ", " + for_end_lbl;
    let w6 = sb_push_mir(sb, branch_text);

    let body_label_text = for_body_lbl + ":";
    let w7 = sb_push_mir(sb, body_label_text);

    // Lower body - pass THIS for's end label so break can jump to it
    let body_result = lower_expr_sb(body_ast, end_temp + 2, end_block, sb, for_end_lbl);
    let body_temp = unpack_temp(body_result);
    let body_block = unpack_block(body_result);

    // for_inc_N label: continue jumps here (before increment, not for_start)
    // Need goto before label to satisfy LLVM basic block terminator requirement
    let for_inc_lbl = "for_inc_" + int_to_string(block_id);
    let goto_inc = "  goto " + for_inc_lbl;
    let w7b = sb_push_mir(sb, goto_inc);
    let inc_label_text = for_inc_lbl + ":";
    let w7c = sb_push_mir(sb, inc_label_text);

    let inc_load_tmp = "%_t" + int_to_string(body_temp);
    let inc_load_text = "  " + inc_load_tmp + " = copy %" + unique_var;
    let w8 = sb_push_mir(sb, inc_load_text);
    let one_tmp = "%_t" + int_to_string(body_temp + 1);
    let one_text = "  " + one_tmp + " = const 1";
    let w9 = sb_push_mir(sb, one_text);
    let inc_tmp = "%_t" + int_to_string(body_temp + 2);
    let inc_text = "  " + inc_tmp + " = + " + inc_load_tmp + ", " + one_tmp;
    let w10 = sb_push_mir(sb, inc_text);
    let store_text = "  store %" + unique_var + ", " + inc_tmp;
    let w11 = sb_push_mir(sb, store_text);

    let goto_start2 = "  goto " + for_start_lbl;
    let w12 = sb_push_mir(sb, goto_start2);

    let end_label_text = for_end_lbl + ":";
    let w13 = sb_push_mir(sb, end_label_text);
    let result_tmp = "%_t" + int_to_string(body_temp + 3);
    let result_text = "  " + result_tmp + " = const 0";
    let w14 = sb_push_mir(sb, result_text);
    pack_ids(body_temp + 4, body_block);

fn lower_for_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    lower_for_range_sb(ast, temp_id, block_id, sb, loop_exit, "< ");

fn lower_for_incl_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    lower_for_range_sb(ast, temp_id, block_id, sb, loop_exit, "<= ");

// for_step: (for_step <var> start end step body) — children: 1=start, 2=end, 3=step, 4=body
fn lower_for_step_range_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String, cmp_op: String) -> i64 =
    let varname = extract_for_varname_from_ast(ast);
    let unique_var = varname + "_" + int_to_string(temp_id);
    let start_ast = get_child(ast, 1);
    let end_ast = get_child(ast, 2);
    let step_ast = get_child(ast, 3);
    let body_raw = get_child(ast, 4);
    let body_ast = rename_name_in_ast(body_raw, varname, unique_var);

    let for_start_lbl = "for_start_" + int_to_string(block_id);
    let for_body_lbl = "for_body_" + int_to_string(block_id);
    let for_end_lbl = "for_end_" + int_to_string(block_id);

    let w0 = sb_push_mir(sb, "  alloca %" + unique_var);

    let start_result = lower_expr_sb(start_ast, temp_id, block_id + 1, sb, "");
    let start_temp = unpack_temp(start_result);
    let start_block = unpack_block(start_result);
    let start_id = start_temp - 1;
    let w1 = sb_push_mir(sb, "  store %" + unique_var + ", %_t" + int_to_string(start_id));

    let end_result = lower_expr_sb(end_ast, start_temp, start_block, sb, "");
    let end_temp = unpack_temp(end_result);
    let end_block = unpack_block(end_result);
    let end_id = end_temp - 1;

    // Lower step expression
    let step_result = lower_expr_sb(step_ast, end_temp, end_block, sb, "");
    let step_temp = unpack_temp(step_result);
    let step_block = unpack_block(step_result);
    let step_id = step_temp - 1;

    let goto_start = "  goto " + for_start_lbl;
    let w2 = sb_push_mir(sb, goto_start);
    let start_label_text = for_start_lbl + ":";
    let w3 = sb_push_mir(sb, start_label_text);

    let load_tmp = "%_t" + int_to_string(step_temp);
    let load_text = "  " + load_tmp + " = copy %" + unique_var;
    let w4 = sb_push_mir(sb, load_text);
    let cmp_tmp = "%_t" + int_to_string(step_temp + 1);
    let cmp_text = "  " + cmp_tmp + " = " + cmp_op + load_tmp + ", %_t" + int_to_string(end_id);
    let w5 = sb_push_mir(sb, cmp_text);
    let branch_text = "  branch " + cmp_tmp + ", " + for_body_lbl + ", " + for_end_lbl;
    let w6 = sb_push_mir(sb, branch_text);

    let body_label_text = for_body_lbl + ":";
    let w7 = sb_push_mir(sb, body_label_text);

    let body_result = lower_expr_sb(body_ast, step_temp + 2, step_block, sb, for_end_lbl);
    let body_temp = unpack_temp(body_result);
    let body_block = unpack_block(body_result);

    let for_inc_lbl = "for_inc_" + int_to_string(block_id);
    let goto_inc = "  goto " + for_inc_lbl;
    let w7b = sb_push_mir(sb, goto_inc);
    let inc_label_text = for_inc_lbl + ":";
    let w7c = sb_push_mir(sb, inc_label_text);

    let inc_load_tmp = "%_t" + int_to_string(body_temp);
    let inc_load_text = "  " + inc_load_tmp + " = copy %" + unique_var;
    let w8 = sb_push_mir(sb, inc_load_text);
    // Use step expression result instead of const 1
    let inc_tmp = "%_t" + int_to_string(body_temp + 1);
    let inc_text = "  " + inc_tmp + " = + " + inc_load_tmp + ", %_t" + int_to_string(step_id);
    let w10 = sb_push_mir(sb, inc_text);
    let store_text = "  store %" + unique_var + ", " + inc_tmp;
    let w11 = sb_push_mir(sb, store_text);

    let goto_start2 = "  goto " + for_start_lbl;
    let w12 = sb_push_mir(sb, goto_start2);

    let end_label_text = for_end_lbl + ":";
    let w13 = sb_push_mir(sb, end_label_text);
    let result_tmp = "%_t" + int_to_string(body_temp + 2);
    let result_text = "  " + result_tmp + " = const 0";
    let w14 = sb_push_mir(sb, result_text);
    pack_ids(body_temp + 3, body_block);

fn lower_for_step_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    lower_for_step_range_sb(ast, temp_id, block_id, sb, loop_exit, "< ");

fn lower_for_step_incl_sb(ast: String, temp_id: i64, block_id: i64, sb: i64, loop_exit: String) -> i64 =
    lower_for_step_range_sb(ast, temp_id, block_id, sb, loop_exit, "<= ");

// Extract lhs from (assign lhs rhs)
fn assign_lhs_expr(ast: String) -> String =
    let len = ast.len();
    if len < 15 { "" } else {
        let content = ast.slice(8, len - 1);
        find_first_balanced(content, 0, 0, "")
    };

// Extract rhs from (assign lhs rhs)
fn assign_rhs_expr(ast: String) -> String =
    let len = ast.len();
    if len < 15 { "" } else {
        let content = ast.slice(8, len - 1);
        find_rest_balanced(content, 0, 0)
    };

// Extract variable name from (var <name>)
// v0.92: Fixed guard from < 10 to < 9 to handle single-char variable names
fn extract_var_from_assign(ast: String) -> String =
    let len = ast.len();
    if len < 9 { "" } else {
        // (var <name>) -> skip "(var <" = 6, remove ">)" = 2
        ast.slice(6, len - 2)
    };

fn get_fn_annotation(ast: String) -> String =
    let nt = get_node_type(ast);
    if nt == "fn-pure" { "pure" }
    else if nt == "fn-const" { "const" }
    else if nt == "fn-inline" { "inline" }
    else { "" };

// Rewrite (index (var <name>)) to (ptr_index (var <name>)) for raw pointer params
// This ensures raw pointer indexing skips the +2 array header offset
fn rewrite_ptr_index(body: String, ast: String, idx: i64) -> String =
    let child = get_child(ast, idx);
    if child == "" or get_node_type(child) != "param" { body } else {
        let param_name_raw = get_child(child, 0);
        let name = if param_name_raw.len() >= 2 and param_name_raw.byte_at(0) == 60 { param_name_raw.slice(1, param_name_raw.len() - 1) } else { param_name_raw };
        let param_type_raw = get_child(child, 1);
        let is_ptr = param_type_raw == "*";
        let new_body = if is_ptr {
            let b2 = body.replace("(index (var <" + name + ">)", "(ptr_index (var <" + name + ">)");
            b2.replace("(set_index (var <" + name + ">)", "(set_ptr_index (var <" + name + ">)")
        } else { body };
        rewrite_ptr_index(new_body, ast, idx + 1)
    };

fn lower_function_sb(ast: String) -> String =
    let name = extract_name(ast);
    let params = collect_params(ast, 1, "");
    let ret_type = get_fn_return_type(ast);
    let ann = get_fn_annotation(ast);
    let body_ast_raw = get_fn_body(ast);
    // Rewrite index/set_index to ptr_index/set_ptr_index for raw pointer params
    let body_ast = rewrite_ptr_index(body_ast_raw, ast, 1);
    let sb = sb_new();
    let final_result = lower_expr_iter(body_ast, 0, 0, sb);
    let final_temp = unpack_temp(final_result);
    let result_id = final_temp - 1;
    let w1 = sb_push_mir(sb, "  return %_t" + int_to_string(result_id));
    let body_mir_raw = sb_build(sb);
    let ann_suffix = if ann == "" { "" } else { " @" + ann };
    // v0.95: Extract lambda functions delimited by chr(1) markers
    let lambda_fns = extract_lambda_fns(body_mir_raw, 0, "");
    let body_mir = remove_lambda_markers(body_mir_raw, 0, sb_new());
    let main_fn = "fn " + name + "(" + params + ") -> " + ret_type + ann_suffix + " {|entry:|" + body_mir + "|}";
    if lambda_fns == "" { main_fn } else { main_fn + "||" + lambda_fns };

// v0.95: Extract lambda function MIR from chr(1)-delimited markers
// Scans body_mir for chr(1)...chr(1) pairs and collects the content
fn extract_lambda_fns(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc }
    else if s.byte_at(pos) == 1 {
        // Found start marker, find end marker
        let end = find_char(s, pos + 1, 1);
        let lambda_fn = s.slice(pos + 1, end);
        let new_acc = if acc == "" { lambda_fn } else { acc + "||" + lambda_fn };
        if end + 1 >= s.len() { new_acc } else { extract_lambda_fns(s, end + 1, new_acc) }
    }
    else { extract_lambda_fns(s, pos + 1, acc) };

// v0.95: Remove chr(1)-delimited lambda markers from body MIR
// Returns the body with all chr(1)...chr(1) sections removed
fn remove_lambda_markers(s: String, pos: i64, out_sb: i64) -> String =
    if pos >= s.len() { sb_build(out_sb) }
    else if s.byte_at(pos) == 1 {
        // Skip chr(1)...chr(1) section
        let end = find_char(s, pos + 1, 1);
        if end + 1 >= s.len() { sb_build(out_sb) }
        else { remove_lambda_markers(s, end + 1, out_sb) }
    }
    else {
        let w = sb_push_char(out_sb, s.byte_at(pos));
        remove_lambda_markers(s, pos + 1, out_sb)
    };

fn lower_program_sb(ast: String) -> String =
    let sb = sb_new();
    let w1 = lower_program_inner_sb(ast, 0, sb);
    sb_build(sb);

fn lower_program_inner_sb(ast: String, idx: i64, sb: i64) -> i64 =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" { 0 } else if not is_fn_node(fn_ast) { 0 } else {
        let _save = bmb_arena_save();
        let fn_mir = lower_function_sb(fn_ast);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_mir);
        let _restore = bmb_arena_restore();
        lower_program_inner_sb(ast, idx + 1, sb)
    };

// ============================================================================
// SECTION 9: Expression Lowering
// ============================================================================

fn collect_params(ast: String, idx: i64, acc: String) -> String =
    let child = get_child(ast, idx);
    if child == "" or get_node_type(child) != "param" { acc } else {
        let param_name = get_child(child, 0);
        let name = if param_name.len() >= 2 and param_name.byte_at(0) == 60 { param_name.slice(1, param_name.len() - 1) } else { param_name };
        let param_type_raw = get_child(child, 1);
        let param_type = if param_type_raw == "*" { let sname = get_child(child, 2); "*" + sname } else { param_type_raw };
        let entry = name + ": " + param_type;
        let new_acc = if acc == "" { entry } else { acc + ", " + entry };
        collect_params(ast, idx + 1, new_acc)
    };

fn get_fn_return_type(ast: String) -> String =
    let content = extract_paren_content(ast);
    get_fn_return_scan(content, 0);

// v0.46: Added String return type support
fn get_fn_return_scan(content: String, pos: i64) -> String =
    let p = low_skip_ws(content, pos);
    if p >= content.len() { "i64" } else {
        if content.byte_at(p) == 42 {
            // Read the struct name after *
            let name_start = p + 1;
            let name_end = low_find_ident_end(content, name_start);
            if name_end > name_start { "*" + content.slice(name_start, name_end) }
            else { "i64" }
        } else {
            let child = read_sexp_at(content, p);
            if child == "" { "i64" } else if child == "i32" or child == "i64" or child == "f64" or child == "bool" or child == "String" or child == "ptr" { child } else if child.byte_at(0) == 40 { get_fn_return_scan(content, p + child.len()) } else if child.byte_at(0) == 60 { get_fn_return_scan(content, p + child.len()) } else { get_fn_return_scan(content, p + child.len()) }
        }
    };

fn get_fn_body(ast: String) -> String =
    let content = extract_paren_content(ast);
    get_fn_body_scan(content, 0, "");

fn get_fn_body_scan(content: String, pos: i64, last_expr: String) -> String =
    let p = low_skip_ws(content, pos);
    if p >= content.len() { last_expr } else {
        let child = read_sexp_at(content, p);
        if child == "" { last_expr } else if child.len() > 0 and child.byte_at(0) == 40 {
            let ntype = get_node_type(child);
            if ntype == "param" { get_fn_body_scan(content, p + child.len(), last_expr) } else { get_fn_body_scan(content, p + child.len(), child) }
        } else {
            get_fn_body_scan(content, p + child.len(), last_expr)
        }
    };


fn find_pipe_skip_quotes(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 124 { pos }
    else if s.byte_at(pos) == 34 { find_pipe_skip_quotes(s, skip_quoted_string(s, pos + 1)) }
    else { find_pipe_skip_quotes(s, pos + 1) };

fn skip_quoted_string(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 34 { pos + 1 }
    else if s.byte_at(pos) == 92 { skip_quoted_string(s, pos + 2) }
    else { skip_quoted_string(s, pos + 1) };

// v0.46: Extract return type from MIR function signature
// MIR format: fn name(params) -> RetType {|...|}
fn extract_mir_return_type(mir: String) -> String =
    let arrow_pos = find_arrow(mir, 0);
    let brace_pos = find_char(mir, arrow_pos, 123);
    if arrow_pos >= mir.len() or brace_pos <= arrow_pos + 2 { "i64" }
    else {
        let raw = trim(mir.slice(arrow_pos + 2, brace_pos));
        let ann = find_mir_annotation(raw);
        if ann == "" { raw } else { strip_annotation(raw) }
    };

fn find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 61 { pos } else { find_eq(s, pos + 1) };

fn llvm_gen_binop(op: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let op_with_nsw = if op == "add" { "add nsw" } else if op == "sub" { "sub nsw" } else if op == "mul" { "mul nsw" } else { op };
    "  " + dest + " = " + op_with_nsw + " i64 " + trim_end(left) + ", " + trim_end(right);

fn llvm_gen_cmp(pred: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    "  " + dest + "_cmp = icmp " + pred + " i64 " + trim_end(left) + ", " + trim_end(right) + "|  " + dest + " = zext i1 " + dest + "_cmp to i64";

fn llvm_gen_not(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = xor i64 " + trim_end(operand) + ", 1";

fn llvm_gen_bnot(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = xor i64 " + trim_end(operand) + ", -1";

// MIR: gep %base, %idx → LLVM: getelementptr i64, ptr %base, i64 %idx
fn llvm_gen_gep(line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let base = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let idx = trim_end(line.slice(p2, line.len()));
    let conv = "  " + dest + "_gp = inttoptr i64 " + base + " to ptr";
    let gep = "  " + dest + " = getelementptr i64, ptr " + dest + "_gp, i64 " + idx;
    conv + "|" + gep;

fn llvm_gen_store_ptr_sb(line: String, pos: i64, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let ptr = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let val = trim_end(line.slice(p2, line.len()));
    let val_is_double = is_double_var_sb(val, str_sb);
    let ptr_is_f64 = is_f64_ptr_sb(trim_end(ptr), str_sb);
    if val_is_double or ptr_is_f64 {
        same_mapping("  store double " + val + ", ptr " + trim_end(ptr))
    } else {
        same_mapping("  store i64 " + val + ", ptr " + trim_end(ptr))
    };

fn llvm_gen_load_ptr_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p = low_skip_ws(line, pos);
    let ptr = trim_end(line.slice(p, line.len()));
    let ptr_is_f64 = is_f64_ptr_sb(ptr, str_sb);
    let ptr_is_str = is_str_ptr_sb(ptr, str_sb);
    if ptr_is_f64 {
        let w = push_double_marker(str_sb, dest);
        same_mapping("  " + dest + " = load double, ptr " + ptr)
    } else if ptr_is_str {
        let w = push_string_marker(str_sb, dest);
        same_mapping("  " + dest + " = load i64, ptr " + ptr)
    } else {
        same_mapping("  " + dest + " = load i64, ptr " + ptr)
    };

fn llvm_gen_gep_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let base = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let idx = trim_end(line.slice(p2, line.len()));
    let base_is_f64 = is_f64_ptr_sb(base, str_sb);
    let base_is_str = is_str_ptr_sb(base, str_sb);
    // Propagate *f64 or *string marker to GEP result
    let w = if base_is_f64 { push_f64_ptr_marker(str_sb, dest) } else if base_is_str { push_str_ptr_marker(str_sb, dest) } else { 0 };
    // Both i64 and f64 are 8 bytes, GEP scaling is the same
    same_mapping(llvm_gen_gep(line, pos, dest));

fn llvm_gen_phi(line: String, pos: i64, dest: String) -> String =
    llvm_gen_phi_typed(line, pos, dest, "i64");

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn extract_phi_val(content: String) -> String =
    let comma_pos = find_char(content, 0, 44);
    content.slice(0, comma_pos);

fn llvm_gen_phi_typed(line: String, pos: i64, dest: String, ret_type: String) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    let first_fixed = fix_phi_label(first_content);
    let second_fixed = fix_phi_label(second_content);
    let llvm_type = if ret_type == "String" { "ptr" } else if ret_type == "f64" { "double" } else { "i64" };
    "  " + dest + " = phi " + llvm_type + " [ " + first_fixed + " ], [ " + second_fixed + " ]";

fn fix_phi_label(content: String) -> String =
    let comma_pos = find_char(content, 0, 44);
    let val = content.slice(0, comma_pos);
    let label = content.slice(comma_pos + 2, content.len());
    val + ", %" + label;

// v0.46: Determine LLVM return type from function name
fn get_call_return_type(fn_name: String) -> String =
    // Void functions (no return value assignment)
    if fn_name == "@println" or fn_name == "@print_str" or fn_name == "@println_str" or fn_name == "@eprint" or fn_name == "@eprintln" or fn_name == "@eprint_str" or fn_name == "@eprintln_str" or fn_name == "@eprint_f64" or fn_name == "@eprintln_f64" or fn_name == "@bmb_panic" { "void" }
    else if fn_name == "@free" or fn_name == "@print_f64" or fn_name == "@println_f64" or fn_name == "@bmb_print_i64" or fn_name == "@puts_cstr" { "void" }
    else if fn_name == "@store_u8" or fn_name == "@store_i64" { "void" }
    else if fn_name == "@hashmap_insert" or fn_name == "@hashmap_free" { "void" }
    else if fn_name == "@str_hashmap_free" or fn_name == "@strmap_free" { "void" }
    else if fn_name == "@vec_set" or fn_name == "@vec_free" or fn_name == "@vec_reverse" or fn_name == "@vec_swap" or fn_name == "@vec_sort" or fn_name == "@vec_clear" or fn_name == "@vec_extend" or fn_name == "@vec_insert" or fn_name == "@vec_dedup" or fn_name == "@vec_fill" { "void" }
    else if fn_name == "@bmb_exit" or fn_name == "@bmb_sleep_ms" or fn_name == "@bmb_random_seed" { "void" }
    else if fn_name == "@bmb_mutex_unlock" or fn_name == "@bmb_mutex_free" { "void" }
    else if fn_name == "@bmb_channel_send" or fn_name == "@bmb_channel_close" { "void" }
    else if fn_name == "@bmb_arc_drop" { "void" }
    else if fn_name == "@bmb_rwlock_read_unlock" or fn_name == "@bmb_rwlock_write_unlock" or fn_name == "@bmb_rwlock_free" { "void" }
    else if fn_name == "@bmb_barrier_free" or fn_name == "@bmb_condvar_notify_one" or fn_name == "@bmb_condvar_notify_all" or fn_name == "@bmb_condvar_free" { "void" }
    else if fn_name == "@bmb_async_file_write" or fn_name == "@bmb_async_file_close" { "void" }
    else if fn_name == "@bmb_async_socket_write" or fn_name == "@bmb_async_socket_close" { "void" }
    else if fn_name == "@bmb_thread_pool_execute" or fn_name == "@bmb_thread_pool_join" or fn_name == "@bmb_thread_pool_shutdown" { "void" }
    else if fn_name == "@bmb_scope_spawn" or fn_name == "@bmb_scope_wait" { "void" }
    // Pointer-returning functions (String type)
    else if fn_name == "@get_arg" or fn_name == "@bmb_read_file" or fn_name == "@bmb_getenv" or fn_name == "@bmb_system_capture" { "ptr" }
    else if fn_name == "@bmb_string_new" or fn_name == "@bmb_string_from_cstr" or fn_name == "@bmb_string_slice" { "ptr" }
    else if fn_name == "@bmb_string_concat" or fn_name == "@bmb_chr" or fn_name == "@bmb_int_to_string" { "ptr" }
    else if fn_name == "@bmb_string_concat3" or fn_name == "@bmb_string_concat5" or fn_name == "@bmb_string_concat7" { "ptr" }
    else if fn_name == "@bmb_sb_build" or fn_name == "@bmb_read_file" or fn_name == "@bmb_getenv" or fn_name == "@get_arg" { "ptr" }
    else if fn_name == "@malloc" or fn_name == "@calloc" { "ptr" }
    else if fn_name == "@hashmap_new" or fn_name == "@vec_new" or fn_name == "@vec_with_capacity" or fn_name == "@str_hashmap_new" or fn_name == "@reg_cached_lookup" { "ptr" }
    else if fn_name == "@bmb_string_trim" or fn_name == "@bmb_string_replace" or fn_name == "@bmb_f64_to_string" or fn_name == "@bmb_string_reverse" or fn_name == "@bmb_string_pad_left" or fn_name == "@bmb_string_pad_right" or fn_name == "@bmb_to_hex" or fn_name == "@bmb_to_binary" or fn_name == "@bmb_to_octal" or fn_name == "@bmb_getcwd" or fn_name == "@bmb_exec_output" or fn_name == "@bmb_string_join" { "ptr" }
    else if fn_name == "@bmb_string_to_upper" or fn_name == "@bmb_string_to_lower" or fn_name == "@bmb_string_repeat" { "ptr" }
    else if fn_name == "@bmb_array_push" or fn_name == "@bmb_array_pop" { "ptr" }
    else if fn_name == "@bmb_array_concat" or fn_name == "@bmb_array_slice" { "ptr" }
    else if fn_name == "@sqrt" or fn_name == "@i64_to_f64" or fn_name == "@sin" or fn_name == "@cos" or fn_name == "@tan" or fn_name == "@atan" or fn_name == "@atan2" or fn_name == "@log" or fn_name == "@log2" or fn_name == "@log10" or fn_name == "@exp" or fn_name == "@fmod" or fn_name == "@pow_f64" { "double" }
    else if fn_name == "@bmb_f64_floor" or fn_name == "@bmb_f64_ceil" or fn_name == "@bmb_f64_round" { "double" }
    else if fn_name == "@bmb_f64_sqrt" or fn_name == "@bmb_f64_abs" { "double" }
    else if fn_name == "@bmb_f64_min" or fn_name == "@bmb_f64_max" or fn_name == "@bmb_parse_f64" { "double" }
    // All other functions return i64
    else { "i64" };

fn map_runtime_fn(fn_name: String) -> String =
    if fn_name.len() < 2 { fn_name }
    else {
        let c = fn_name.byte_at(1);
        // Fast reject: chars that can never be runtime functions
        if c < 97 or c > 119 { fn_name }           // outside a-w
        else if c >= 100 and c <= 101 { fn_name }   // d, e
        else if c == 104 { fn_name }                   // h
        else if c >= 106 and c <= 108 { fn_name }   // j, k, l
        else if c == 110 { fn_name }                 // n
        else if c == 113 { fn_name }                 // q
        else if c >= 117 and c <= 118 { fn_name }    // u, v
        else { map_runtime_fn_full(fn_name) }
    };

fn map_runtime_fn_full(fn_name: String) -> String =
    if fn_name == "@main" { "@bmb_user_main" }
    else if fn_name == "@chr" { "@bmb_chr" }
    else if fn_name == "@ord" { "@bmb_ord" }
    else if fn_name == "@println" { "@println" }
    else if fn_name == "@print" { "@bmb_print_i64" }  // v0.90.8: Map print to runtime
    else if fn_name == "@print_str" { "@print_str" }
    else if fn_name == "@println_str" { "@println_str" }
    else if fn_name == "@eprint" { "@eprint" }
    else if fn_name == "@eprintln" { "@eprintln" }
    else if fn_name == "@eprint_str" { "@eprint_str" }
    else if fn_name == "@eprintln_str" { "@eprintln_str" }
    else if fn_name == "@eprint_f64" { "@eprint_f64" }
    else if fn_name == "@eprintln_f64" { "@eprintln_f64" }
    else if fn_name == "@read_file" { "@bmb_read_file" }
    else if fn_name == "@write_file" { "@bmb_write_file" }
    else if fn_name == "@write_file_newlines" { "@write_file_newlines" }
    else if fn_name == "@file_exists" { "@bmb_file_exists" }
    else if fn_name == "@sb_new" { "@bmb_sb_new" }
    else if fn_name == "@sb_push" { "@bmb_sb_push" }
    else if fn_name == "@sb_push_range" { "@sb_push_range" }
    else if fn_name == "@sb_push_int" { "@bmb_sb_push_int" }
    else if fn_name == "@sb_push_char" { "@bmb_sb_push_char" }
    else if fn_name == "@sb_push_escaped" { "@bmb_sb_push_escaped" }
    else if fn_name == "@sb_len" { "@bmb_sb_len" }
    else if fn_name == "@sb_build" { "@bmb_sb_build" }
    else if fn_name == "@sb_clear" { "@bmb_sb_clear" }
    else if fn_name == "@sb_contains" { "@bmb_sb_contains" }
    else if fn_name == "@arg_count" { "@arg_count" }
    else if fn_name == "@get_arg" { "@get_arg" }
    else if fn_name == "@getenv" { "@bmb_getenv" }
    else if fn_name == "@system" { "@bmb_system" }
    else if fn_name == "@system_capture" { "@bmb_system_capture" }
    else if fn_name == "@free_string" { "@bmb_string_free" }
    else if fn_name == "@sb_free" { "@bmb_sb_free" }
    else if fn_name == "@arena_mode" { "@bmb_arena_mode" }
    // free function calls produce @abs/@min/@max and need explicit mapping)
    else if fn_name == "@abs" { "@bmb_abs" }
    else if fn_name == "@min" { "@bmb_min" }
    else if fn_name == "@max" { "@bmb_max" }
    else if fn_name == "@clamp" { "@bmb_clamp" }
    else if fn_name == "@pow" { "@bmb_pow" }
    else if fn_name == "@concat3" { "@bmb_string_concat3" }
    else if fn_name == "@concat5" { "@bmb_string_concat5" }
    else if fn_name == "@concat7" { "@bmb_string_concat7" }
    else if fn_name == "@arena_reset" { "@bmb_arena_reset" }
    else if fn_name == "@arena_save" { "@bmb_arena_save" }
    else if fn_name == "@arena_restore" { "@bmb_arena_restore" }
    else if fn_name == "@arena_usage" { "@bmb_arena_usage" }
    else if fn_name == "@thread_spawn" { "@bmb_thread_spawn" }
    else if fn_name == "@thread_join" { "@bmb_thread_join" }
    else if fn_name == "@mutex_new" { "@bmb_mutex_new" }
    else if fn_name == "@mutex_lock" { "@bmb_mutex_lock" }
    else if fn_name == "@mutex_unlock" { "@bmb_mutex_unlock" }
    else if fn_name == "@mutex_try_lock" { "@bmb_mutex_try_lock" }
    else if fn_name == "@mutex_free" { "@bmb_mutex_free" }
    else if fn_name == "@channel_new" { "@bmb_channel_new" }
    else if fn_name == "@channel_send" { "@bmb_channel_send" }
    else if fn_name == "@channel_recv" { "@bmb_channel_recv" }
    else if fn_name == "@channel_try_send" { "@bmb_channel_try_send" }
    else if fn_name == "@channel_try_recv" { "@bmb_channel_try_recv" }
    else if fn_name == "@channel_recv_timeout" { "@bmb_channel_recv_timeout" }
    else if fn_name == "@channel_send_timeout" { "@bmb_channel_send_timeout" }
    else if fn_name == "@channel_close" { "@bmb_channel_close" }
    else if fn_name == "@channel_is_closed" { "@bmb_channel_is_closed" }
    else if fn_name == "@channel_recv_opt" { "@bmb_channel_recv_opt" }
    else if fn_name == "@sender_clone" { "@bmb_sender_clone" }
    else if fn_name == "@arc_new" { "@bmb_arc_new" }
    else if fn_name == "@arc_clone" { "@bmb_arc_clone" }
    else if fn_name == "@arc_get" { "@bmb_arc_get" }
    else if fn_name == "@arc_drop" { "@bmb_arc_drop" }
    else if fn_name == "@arc_strong_count" { "@bmb_arc_strong_count" }
    else if fn_name == "@rwlock_new" { "@bmb_rwlock_new" }
    else if fn_name == "@rwlock_read" { "@bmb_rwlock_read" }
    else if fn_name == "@rwlock_read_unlock" { "@bmb_rwlock_read_unlock" }
    else if fn_name == "@rwlock_write" { "@bmb_rwlock_write" }
    else if fn_name == "@rwlock_write_unlock" { "@bmb_rwlock_write_unlock" }
    else if fn_name == "@rwlock_free" { "@bmb_rwlock_free" }
    else if fn_name == "@barrier_new" { "@bmb_barrier_new" }
    else if fn_name == "@barrier_wait" { "@bmb_barrier_wait" }
    else if fn_name == "@barrier_free" { "@bmb_barrier_free" }
    else if fn_name == "@condvar_new" { "@bmb_condvar_new" }
    else if fn_name == "@condvar_wait" { "@bmb_condvar_wait" }
    else if fn_name == "@condvar_notify_one" { "@bmb_condvar_notify_one" }
    else if fn_name == "@condvar_notify_all" { "@bmb_condvar_notify_all" }
    else if fn_name == "@condvar_free" { "@bmb_condvar_free" }
    else if fn_name == "@async_file_open" { "@bmb_async_file_open" }
    else if fn_name == "@async_file_read" { "@bmb_async_file_read" }
    else if fn_name == "@async_file_write" { "@bmb_async_file_write" }
    else if fn_name == "@async_file_close" { "@bmb_async_file_close" }
    else if fn_name == "@async_socket_connect" { "@bmb_async_socket_connect" }
    else if fn_name == "@async_socket_read" { "@bmb_async_socket_read" }
    else if fn_name == "@async_socket_write" { "@bmb_async_socket_write" }
    else if fn_name == "@async_socket_close" { "@bmb_async_socket_close" }
    else if fn_name == "@thread_pool_new" { "@bmb_thread_pool_new" }
    else if fn_name == "@thread_pool_execute" { "@bmb_thread_pool_execute" }
    else if fn_name == "@thread_pool_join" { "@bmb_thread_pool_join" }
    else if fn_name == "@thread_pool_shutdown" { "@bmb_thread_pool_shutdown" }
    else if fn_name == "@scope_new" { "@bmb_scope_new" }
    else if fn_name == "@scope_spawn" { "@bmb_scope_spawn" }
    else if fn_name == "@scope_wait" { "@bmb_scope_wait" }
    else if fn_name == "@block_on" { "@bmb_block_on" }
    else if fn_name == "@int_to_string" { "@bmb_int_to_string" }
    else if fn_name == "@string_len" { "@bmb_string_len" }
    else if fn_name == "@f64_to_string" { "@bmb_f64_to_string" }
    else if fn_name == "@parse_int" { "@bmb_parse_int" }
    else if fn_name == "@parse_f64" { "@bmb_parse_f64" }
    else if fn_name == "@exit_process" { "@bmb_exit" }
    else if fn_name == "@time_ms" { "@bmb_time_ms" }
    else if fn_name == "@sleep_ms" { "@bmb_sleep_ms" }
    else if fn_name == "@fabs" { "@bmb_f64_abs" }
    else if fn_name == "@floor" { "@bmb_f64_floor" }
    else if fn_name == "@ceil" { "@bmb_f64_ceil" }
    else if fn_name == "@round" { "@bmb_f64_round" }
    else if fn_name == "@f64_is_nan" { "@bmb_f64_is_nan" }
    else if fn_name == "@random_i64" { "@bmb_random_i64" }
    else if fn_name == "@random_seed" { "@bmb_random_seed" }
    else if fn_name == "@string_count" { "@bmb_string_count" }
    else if fn_name == "@string_reverse" { "@bmb_string_reverse" }
    else if fn_name == "@string_pad_left" { "@bmb_string_pad_left" }
    else if fn_name == "@string_pad_right" { "@bmb_string_pad_right" }
    else if fn_name == "@string_last_index_of" { "@bmb_string_last_index_of" }
    else if fn_name == "@file_delete" { "@bmb_delete_file" }
    else if fn_name == "@getcwd" { "@bmb_getcwd" }
    else if fn_name == "@to_hex" { "@bmb_to_hex" }
    else if fn_name == "@to_binary" { "@bmb_to_binary" }
    else if fn_name == "@to_octal" { "@bmb_to_octal" }
    else if fn_name == "@time_ns" { "@bmb_time_ns" }
    else if fn_name == "@run_command" { "@bmb_exec_output" }
    else if fn_name == "@string_split" { "@bmb_string_split" }
    else if fn_name == "@string_join" { "@bmb_string_join" }
    else if fn_name == "@sb_push_f64" { "@bmb_sb_push_f64" }
    else if fn_name == "@sb_push_hex" { "@bmb_sb_push_hex" }
    else if fn_name == "@sb_push_bool" { "@bmb_sb_push_bool" }
    else if fn_name == "@popcount" { "@bmb_popcount" }
    else if fn_name == "@clz" { "@bmb_clz" }
    else if fn_name == "@ctz" { "@bmb_ctz" }
    else if fn_name == "@bit_reverse" { "@bmb_bit_reverse" }
    else if fn_name == "@map_keys" { "@hashmap_keys" }
    else if fn_name == "@map_values" { "@hashmap_values" }
    else if fn_name == "@string_eq" { "@bmb_string_eq" }
    else if fn_name == "@string_cmp" { "@bmb_string_cmp" }
    else if fn_name == "@string_hash" { "@bmb_string_hash" }
    else if fn_name == "@read_int" { "@bmb_read_int" }
    else { fn_name };

// v0.46: Handle different return types (i64, ptr, void)
fn llvm_gen_call(line: String, pos: i64, dest: String) -> String =
    let at_pos = find_char(line, pos, 64);
    let paren_pos = find_char(line, at_pos, 40);
    let close_pos = find_char(line, paren_pos, 41);
    let fn_name = line.slice(at_pos, paren_pos);
    if fn_name == "@store_u8" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let addr = trim_end(args.slice(0, comma));
        let value = trim(args.slice(comma + 1, args.len()));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + "_v = trunc i64 " + value + " to i8|  store i8 " + dest + "_v, ptr " + dest + "_p, align 1|  " + dest + " = add nsw i64 0, 0"
    } else if fn_name == "@load_u8" {
        let addr = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + "_b = load i8, ptr " + dest + "_p, align 1|  " + dest + " = zext i8 " + dest + "_b to i64"
    } else if fn_name == "@store_i64" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let addr = trim_end(args.slice(0, comma));
        let value = trim(args.slice(comma + 1, args.len()));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  store i64 " + value + ", ptr " + dest + "_p, align 8|  " + dest + " = add nsw i64 0, 0"
    } else if fn_name == "@load_i64" {
        let addr = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + " = load i64, ptr " + dest + "_p, align 8"
    } else if fn_name == "@ord" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = add nsw i64 0, " + arg
    } else if fn_name == "@i64_to_f64" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = sitofp i64 " + arg + " to double"
    } else if fn_name == "@f64_to_i64" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = fptosi double " + arg + " to i64"
    } else if fn_name == "@bmb_string_char_at" {
        // String struct: {ptr data, i64 len, i64 cap}, byte_at(s, idx) -> s.data[idx] as i64
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let str_arg = trim_end(args.slice(0, comma));
        let idx_arg = trim(args.slice(comma + 1, args.len()));
        // v0.95: !invariant.load on string struct loads — BMB strings are immutable
        "  " + dest + "_str = inttoptr i64 " + str_arg + " to ptr|  " + dest + "_dpp = getelementptr {ptr, i64, i64}, ptr " + dest + "_str, i32 0, i32 0|  " + dest + "_dp = load ptr, ptr " + dest + "_dpp, !invariant.load !0|  " + dest + "_bp = getelementptr i8, ptr " + dest + "_dp, i64 " + idx_arg + "|  " + dest + "_b = load i8, ptr " + dest + "_bp|  " + dest + " = zext i8 " + dest + "_b to i64"
    } else if fn_name == "@bmb_string_len" {
        let str_arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_str = inttoptr i64 " + str_arg + " to ptr|  " + dest + "_lp = getelementptr {ptr, i64, i64}, ptr " + dest + "_str, i32 0, i32 1|  " + dest + " = load i64, ptr " + dest + "_lp, !invariant.load !0"
    } else {
    let emitted_fn = map_runtime_fn(fn_name);
    let args = line.slice(paren_pos + 1, close_pos);
    let arg_types = get_call_arg_types(emitted_fn);
    let formatted = format_call_args_typed(args, arg_types, 0, 0, "", "");
    let conversions = call_arg_conversions(formatted);
    let formatted_args = call_arg_formatted(formatted);
    let ret_type = get_call_return_type(emitted_fn);
    if ret_type == "void" {
        conversions + "  call void " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = add nsw i64 0, 0"
    } else if ret_type == "ptr" {
        // ptr-returning functions need ptrtoint conversion to i64
        conversions + "  " + dest + "_ptr = call ptr " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = ptrtoint ptr " + dest + "_ptr to i64"
    } else {
        conversions + "  " + dest + " = call " + ret_type + " " + emitted_fn + "(" + formatted_args + ")"
    }
    }; // v0.90.9: close i64_to_f64/f64_to_i64 else

fn llvm_gen_call_reg(line: String, pos: i64, dest: String, registry: String) -> String =
    let at_pos = find_char(line, pos, 64);
    let paren_pos = find_char(line, at_pos, 40);
    let close_pos = find_char(line, paren_pos, 41);
    let fn_name = line.slice(at_pos, paren_pos);
    if fn_name == "@store_u8" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let addr = trim_end(args.slice(0, comma));
        let value = trim(args.slice(comma + 1, args.len()));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + "_v = trunc i64 " + value + " to i8|  store i8 " + dest + "_v, ptr " + dest + "_p, align 1|  " + dest + " = add nsw i64 0, 0"
    } else if fn_name == "@load_u8" {
        let addr = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + "_b = load i8, ptr " + dest + "_p, align 1|  " + dest + " = zext i8 " + dest + "_b to i64"
    } else if fn_name == "@store_i64" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let addr = trim_end(args.slice(0, comma));
        let value = trim(args.slice(comma + 1, args.len()));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  store i64 " + value + ", ptr " + dest + "_p, align 8|  " + dest + " = add nsw i64 0, 0"
    } else if fn_name == "@load_i64" {
        let addr = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_p = inttoptr i64 " + addr + " to ptr|  " + dest + " = load i64, ptr " + dest + "_p, align 8"
    } else if fn_name == "@ord" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = add nsw i64 0, " + arg
    } else if fn_name == "@i64_to_f64" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = sitofp i64 " + arg + " to double"
    } else if fn_name == "@f64_to_i64" {
        let arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + " = fptosi double " + arg + " to i64"
    } else if fn_name == "@bmb_string_char_at" {
        let args = line.slice(paren_pos + 1, close_pos);
        let comma = find_char(args, 0, 44);
        let str_arg = trim_end(args.slice(0, comma));
        let idx_arg = trim(args.slice(comma + 1, args.len()));
        // v0.95: !invariant.load on string struct loads — BMB strings are immutable
        "  " + dest + "_str = inttoptr i64 " + str_arg + " to ptr|  " + dest + "_dpp = getelementptr {ptr, i64, i64}, ptr " + dest + "_str, i32 0, i32 0|  " + dest + "_dp = load ptr, ptr " + dest + "_dpp, !invariant.load !0|  " + dest + "_bp = getelementptr i8, ptr " + dest + "_dp, i64 " + idx_arg + "|  " + dest + "_b = load i8, ptr " + dest + "_bp|  " + dest + " = zext i8 " + dest + "_b to i64"
    } else if fn_name == "@bmb_string_len" {
        let str_arg = trim_end(line.slice(paren_pos + 1, close_pos));
        "  " + dest + "_str = inttoptr i64 " + str_arg + " to ptr|  " + dest + "_lp = getelementptr {ptr, i64, i64}, ptr " + dest + "_str, i32 0, i32 1|  " + dest + " = load i64, ptr " + dest + "_lp, !invariant.load !0"
    } else {
    let args = line.slice(paren_pos + 1, close_pos);
    // v0.95: Check registry for user-defined function BEFORE runtime mapping
    // This prevents name collision when user defines e.g. parse_int which would
    // otherwise be remapped to @bmb_parse_int (runtime built-in)
    let user_info = lookup_fn_both(registry, fn_name);
    let emitted_fn = if user_info != "" { fn_name } else { map_runtime_fn(fn_name) };
    let reg_info = if user_info != "" { user_info } else { lookup_fn_both(registry, emitted_fn) };
    let reg_ret = if reg_info == "" { "" } else { let c2 = find_char(reg_info, 0, 58); reg_info.slice(0, c2) };
    let reg_params = if reg_info == "" { "" } else { let c2 = find_char(reg_info, 0, 58); reg_info.slice(c2 + 1, reg_info.len()) };
    if reg_ret != "" {
        // Use registry types
        let arg_types = if reg_params != "" { reg_params } else { get_call_arg_types(emitted_fn) };
        let formatted = format_call_args_typed(args, arg_types, 0, 0, "", "");
        let conversions = call_arg_conversions(formatted);
        let formatted_args = call_arg_formatted(formatted);
        if reg_ret == "void" {
            conversions + "  call void " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = add nsw i64 0, 0"
        } else if reg_ret == "ptr" {
            conversions + "  " + dest + "_ptr = call ptr " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = ptrtoint ptr " + dest + "_ptr to i64"
        } else if reg_ret == "double" {
            conversions + "  " + dest + " = call double " + emitted_fn + "(" + formatted_args + ")"
        } else if reg_ret == "i32" {
            // v0.95: i32 return → call i32, sext to i64
            conversions + "  " + dest + "_i32c = call i32 " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = sext i32 " + dest + "_i32c to i64"
        } else {
            conversions + "  " + dest + " = call " + reg_ret + " " + emitted_fn + "(" + formatted_args + ")"
        }
    } else {
        // Fall back to existing logic
        llvm_gen_call(line, pos, dest)
    }
    }; // v0.90.9: close i64_to_f64/f64_to_i64 else

fn get_call_arg_types(fn_name: String) -> String =
    // String functions with ptr first arg
    if fn_name == "@bmb_string_slice" { "pii" }
    else if fn_name == "@bmb_string_concat" { "pp" }
    else if fn_name == "@bmb_string_concat3" { "ppp" }
    else if fn_name == "@bmb_string_concat5" { "ppppp" }
    else if fn_name == "@bmb_string_concat7" { "ppppppp" }
    else if fn_name == "@bmb_string_new" { "pi" }
    else if fn_name == "@bmb_string_from_cstr" { "p" }
    else if fn_name == "@bmb_string_eq" { "pp" }
    else if fn_name == "@bmb_string_cmp" { "pp" }
    else if fn_name == "@bmb_string_hash" { "p" }
    else if fn_name == "@bmb_ord" { "p" }
    else if fn_name == "@bmb_sb_contains" { "ip" }
    else if fn_name == "@bmb_string_len" { "p" }
    else if fn_name == "@bmb_string_char_at" { "pi" }
    else if fn_name == "@bmb_read_file" { "p" }
    else if fn_name == "@bmb_write_file" { "pp" }
    else if fn_name == "@write_file_newlines" { "pp" }
    else if fn_name == "@bmb_append_file" { "pp" }
    else if fn_name == "@bmb_file_exists" { "p" }
    else if fn_name == "@bmb_file_size" { "p" }
    else if fn_name == "@bmb_getenv" { "p" }
    else if fn_name == "@bmb_system" { "p" }
    else if fn_name == "@bmb_system_capture" { "p" }
    else if fn_name == "@bmb_string_free" { "p" }
    else if fn_name == "@bmb_sb_free" { "i" }
    else if fn_name == "@bmb_arena_mode" { "i" }
    else if fn_name == "@bmb_sb_push" { "ip" }
    else if fn_name == "@sb_push_range" { "ipii" }
    else if fn_name == "@bmb_sb_push_escaped" { "ip" }
    else if fn_name == "@print_str" { "p" }
    else if fn_name == "@println_str" { "p" }
    else if fn_name == "@eprint" { "i" }
    else if fn_name == "@eprintln" { "i" }
    else if fn_name == "@eprint_str" { "p" }
    else if fn_name == "@eprintln_str" { "p" }
    else if fn_name == "@eprint_f64" { "d" }
    else if fn_name == "@eprintln_f64" { "d" }
    else if fn_name == "@bmb_panic" { "p" }
    else if fn_name == "@bmb_string_starts_with" { "pp" }
    else if fn_name == "@bmb_string_ends_with" { "pp" }
    else if fn_name == "@bmb_string_contains" { "pp" }
    else if fn_name == "@bmb_string_index_of" { "pp" }
    else if fn_name == "@bmb_string_trim" { "p" }
    else if fn_name == "@bmb_string_replace" { "ppp" }
    else if fn_name == "@bmb_string_to_upper" { "p" }
    else if fn_name == "@bmb_string_to_lower" { "p" }
    else if fn_name == "@bmb_string_repeat" { "pi" }
    else if fn_name == "@bmb_string_is_empty" { "p" }
    else if fn_name == "@bmb_string_count" { "pp" }
    else if fn_name == "@bmb_string_reverse" { "p" }
    else if fn_name == "@bmb_string_pad_left" { "pii" }
    else if fn_name == "@bmb_string_pad_right" { "pii" }
    else if fn_name == "@bmb_string_last_index_of" { "pp" }
    else if fn_name == "@bmb_array_push" { "pi" }
    else if fn_name == "@bmb_array_pop" { "p" }
    else if fn_name == "@bmb_array_concat" { "pp" }
    else if fn_name == "@bmb_array_slice" { "pii" }
    else if fn_name == "@bmb_array_len" { "p" }
    else if fn_name == "@malloc" { "i" }
    else if fn_name == "@calloc" { "ii" }
    else if fn_name == "@free" { "p" }
    else if fn_name == "@sqrt" or fn_name == "@sin" or fn_name == "@cos" or fn_name == "@tan" or fn_name == "@atan" or fn_name == "@log" or fn_name == "@log2" or fn_name == "@log10" or fn_name == "@exp" { "d" }
    else if fn_name == "@atan2" or fn_name == "@fmod" or fn_name == "@pow_f64" { "dd" }
    else if fn_name == "@bmb_f64_floor" { "d" }
    else if fn_name == "@bmb_f64_ceil" { "d" }
    else if fn_name == "@bmb_f64_round" { "d" }
    else if fn_name == "@bmb_f64_sqrt" { "d" }
    else if fn_name == "@bmb_f64_abs" { "d" }
    else if fn_name == "@bmb_f64_is_nan" { "d" }
    else if fn_name == "@bmb_f64_min" { "dd" }
    else if fn_name == "@bmb_f64_max" { "dd" }
    else if fn_name == "@bmb_f64_to_int" { "d" }
    else if fn_name == "@bmb_f64_to_string" { "d" }
    else if fn_name == "@bmb_parse_int" { "p" }
    else if fn_name == "@bmb_parse_f64" { "p" }
    else if fn_name == "@bmb_exit" { "i" }
    else if fn_name == "@bmb_sleep_ms" { "i" }
    else if fn_name == "@bmb_random_seed" { "i" }
    else if fn_name == "@bmb_to_hex" or fn_name == "@bmb_to_binary" or fn_name == "@bmb_to_octal" { "i" }
    else if fn_name == "@print_f64" { "d" }
    else if fn_name == "@println_f64" { "d" }
    else if fn_name == "@bmb_print_i64" { "i" }  // v0.90.8: mapped from print
    else if fn_name == "@puts_cstr" { "p" }
    else if fn_name == "@store_u8" { "pii" }
    else if fn_name == "@load_u8" { "pi" }
    else if fn_name == "@store_i64" { "pii" }
    else if fn_name == "@load_i64" { "pi" }
    else if fn_name == "@char_at" { "pi" }
    else if fn_name == "@hashmap_insert" { "ppi" }
    else if fn_name == "@hashmap_get" { "pp" }
    else if fn_name == "@hashmap_free" { "p" }
    else if fn_name == "@hashmap_remove" { "pp" }
    else if fn_name == "@hashmap_contains" { "pp" }
    else if fn_name == "@hashmap_len" { "p" }
    else if fn_name == "@str_hashmap_insert" { "ppi" }
    else if fn_name == "@str_hashmap_get" { "pp" }
    else if fn_name == "@str_hashmap_free" { "p" }
    else if fn_name == "@str_hashmap_contains" { "pp" }
    else if fn_name == "@str_hashmap_len" { "p" }
    else if fn_name == "@str_hashmap_remove" { "pp" }
    else if fn_name == "@str_hashmap_keys" { "p" }
    else if fn_name == "@str_hashmap_values" { "p" }
    else if fn_name == "@reg_cached_lookup" { "ppi" }
    else if fn_name == "@vec_push" { "pi" }
    else if fn_name == "@vec_get" { "pi" }
    else if fn_name == "@vec_set" { "pii" }
    else if fn_name == "@vec_len" { "p" }
    else if fn_name == "@vec_free" { "p" }
    else if fn_name == "@vec_reverse" { "p" }
    else if fn_name == "@vec_contains" { "pi" }
    else if fn_name == "@vec_index_of" { "pi" }
    else if fn_name == "@vec_swap" { "pii" }
    else if fn_name == "@vec_sort" { "p" }
    else if fn_name == "@vec_with_capacity" { "i" }
    else if fn_name == "@vec_clear" { "p" }
    else if fn_name == "@sb_println" { "i" }
    else if fn_name == "@sb_with_capacity" { "i" }
    else if fn_name == "@bmb_delete_file" { "p" }
    else if fn_name == "@vec_pop" { "p" }
    else if fn_name == "@vec_cap" { "p" }
    else if fn_name == "@vec_slice" { "pii" }
    else if fn_name == "@vec_extend" { "pp" }
    else if fn_name == "@vec_remove" { "pi" }
    else if fn_name == "@vec_insert" { "pii" }
    else if fn_name == "@bmb_exec_output" { "pp" }
    else if fn_name == "@bmb_string_split" { "pp" }
    else if fn_name == "@bmb_string_join" { "ip" }
    else if fn_name == "@bmb_sb_push_f64" { "id" }
    else if fn_name == "@hashmap_keys" { "p" }
    else if fn_name == "@hashmap_values" { "p" }
    else if fn_name == "@vec_dedup" { "p" }
    else if fn_name == "@vec_fill" { "pi" }
    else if fn_name == "@vec_copy" { "p" }
    else if fn_name == "@vec_sum" { "p" }
    else if fn_name == "@strmap_free" or fn_name == "@strmap_size" or fn_name == "@strmap_keys" or fn_name == "@strmap_values" { "i" }
    else if fn_name == "@strmap_get" or fn_name == "@strmap_contains" or fn_name == "@strmap_remove" { "ip" }
    else if fn_name == "@strmap_insert" { "ipi" }
    else if fn_name == "@bmb_string_cmp" { "pp" }
    else if fn_name == "@bmb_string_hash" { "p" }
    else if fn_name == "@vec_min" or fn_name == "@vec_max" or fn_name == "@vec_product" { "p" }
    // Default: all i64
    else { "" };

// Returns pair: (conversions_string, formatted_args_string)
// Uses separator "###" to split conversions from args
fn format_call_args_typed(args: String, types: String, pos: i64, idx: i64, conv_acc: String, arg_acc: String) -> String =
    let p = low_skip_ws(args, pos);
    if p >= args.len() { conv_acc + "###" + arg_acc } else {
        let comma = find_comma_or_end(args, p);
        let arg = trim_end(args.slice(p, comma));
        let typ = if idx < types.len() { types.byte_at(idx) } else { 105 };
        let pair = if typ == 112 {
            // 'p' = ptr: need inttoptr conversion
            let ptr_name = arg + "_p" + int_to_string(idx);
            let conv = "  " + ptr_name + " = inttoptr i64 " + arg + " to ptr|";
            let typed_arg = "ptr " + ptr_name;
            pack_conv_arg(conv, typed_arg)
        } else if typ == 100 {
            // 'd' = double: no conversion, just use double type
            pack_conv_arg("", "double " + arg)
        } else if typ == 115 {
            // v0.95: 's' = i32: trunc i64 to i32 before passing
            let i32_name = arg + "_s" + int_to_string(idx);
            let conv = "  " + i32_name + " = trunc i64 " + arg + " to i32|";
            let typed_arg = "i32 " + i32_name;
            pack_conv_arg(conv, typed_arg)
        } else {
            // 'i' or default = i64: no conversion needed
            pack_conv_arg("", "i64 " + arg)
        };
        let new_conv = conv_acc + unpack_conv(pair);
        let typed_arg = unpack_arg(pair);
        let new_arg = if arg_acc == "" { typed_arg } else { arg_acc + ", " + typed_arg };
        if comma >= args.len() { new_conv + "###" + new_arg } else { format_call_args_typed(args, types, comma + 1, idx + 1, new_conv, new_arg) }
    };

// Helper to pack conversion and arg into a pair string
fn pack_conv_arg(conv: String, arg: String) -> String = conv + "###" + arg;

// Helper to unpack conversion from pair
fn unpack_conv(pair: String) -> String =
    let sep = find_separator(pair, 0);
    pair.slice(0, sep);

// Helper to unpack arg from pair
fn unpack_arg(pair: String) -> String =
    let sep = find_separator(pair, 0);
    pair.slice(sep + 3, pair.len());

// Find "###" separator
fn find_separator(s: String, pos: i64) -> i64 =
    if pos + 2 >= s.len() { s.len() }
    else if s.byte_at(pos) == 35 and s.byte_at(pos + 1) == 35 and s.byte_at(pos + 2) == 35 { pos }
    else { find_separator(s, pos + 1) };

fn call_arg_conversions(formatted: String) -> String =
    let sep = find_separator(formatted, 0);
    formatted.slice(0, sep);

fn call_arg_formatted(formatted: String) -> String =
    let sep = find_separator(formatted, 0);
    formatted.slice(sep + 3, formatted.len());

fn find_comma(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { pos } else { find_comma(s, pos + 1) };

fn find_comma_or_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { pos } else { find_comma_or_end(s, pos + 1) };

fn find_char(s: String, pos: i64, ch: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == ch { pos } else { find_char(s, pos + 1, ch) };

fn trim_end(s: String) -> String =
    trim_end_at(s, s.len() - 1);

fn trim_end_at(s: String, pos: i64) -> String =
    if pos < 0 { "" } else if low_is_whitespace(s.byte_at(pos)) { trim_end_at(s, pos - 1) } else { s.slice(0, pos + 1) };

// v0.46: Trim both leading and trailing whitespace
fn trim(s: String) -> String =
    let start = low_skip_ws(s, 0);
    if start >= s.len() { "" } else { trim_end(s.slice(start, s.len())) };

fn llvm_gen_return_typed(line: String, pos: i64, ret_type: String) -> String =
    let val_start = low_skip_ws(line, pos + 6);
    let val = trim_end(line.slice(val_start, line.len()));
    if ret_type == "f64" {
        "  ret double " + val
    } else if ret_type == "i32" {
        // v0.95: trunc i64 to i32 before returning
        "  " + val + "_i32r = trunc i64 " + val + " to i32|  ret i32 " + val + "_i32r"
    } else {
        "  ret i64 " + val
    };

fn llvm_gen_branch(line: String, pos: i64) -> String =
    let after = low_skip_ws(line, pos + 6);
    let comma1 = find_comma(line, after);
    let cond = trim_end(line.slice(after, comma1));
    let after1 = low_skip_ws(line, comma1 + 1);
    let comma2 = find_comma(line, after1);
    let then_label = line.slice(after1, comma2);
    let after2 = low_skip_ws(line, comma2 + 1);
    let else_label = trim_end(line.slice(after2, line.len()));
    "  " + cond + "_i1 = trunc i64 " + cond + " to i1|  br i1 " + cond + "_i1, label %" + trim_end(then_label) + ", label %" + else_label;

fn llvm_gen_goto(line: String, pos: i64) -> String =
    let label_start = low_skip_ws(line, pos + 4);
    let label = line.slice(label_start, line.len());
    "  br label %" + trim_end(label);

// v0.92: Float binary operation
// MIR: f+ %a, %b → LLVM: fadd double %a, %b
fn llvm_gen_float_binop(op: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    "  " + dest + " = " + op + " double " + trim_end(left) + ", " + trim_end(right);

// v0.92: Float comparison operation
// MIR: f< %a, %b → LLVM: fcmp olt double %a, %b + zext i1 to i64
fn llvm_gen_float_cmp(pred: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    "  " + dest + "_cmp = fcmp " + pred + " double " + trim_end(left) + ", " + trim_end(right) + "|  " + dest + " = zext i1 " + dest + "_cmp to i64";

// v0.92: Alloca for mutable variables - emit LLVM alloca and mark in mapping
// MIR: alloca %name → LLVM: %name = alloca i64 + mapping[%name] = ALLOCA
fn llvm_gen_alloca(line: String, pos: i64, mapping: String) -> String =
    let name_start = low_skip_ws(line, pos + 6);
    let name = trim_end(line.slice(name_start, line.len()));
    let new_mapping = add_mapping(mapping, name, "ALLOCA");
    changed_mapping(new_mapping, "  " + name + " = alloca i64");

// v0.92: Store for mutable variables
// MIR: store %name, %_tN → LLVM: store i64 %resolved_src, ptr %name
fn llvm_gen_store_sb(line: String, pos: i64, mapping: String, str_sb: i64) -> String =
    let after_store = low_skip_ws(line, pos + 5);
    let comma_pos = find_comma(line, after_store);
    let dest_name = trim_end(line.slice(after_store, comma_pos));
    let src_start = low_skip_ws(line, comma_pos + 1);
    let src = trim_end(line.slice(src_start, line.len()));
    let resolved_src = resolve_variable(src, mapping);
    let src_is_double = is_double_var_sb(src, str_sb);
    let src_is_string = is_string_var_sb(src, str_sb);
    let src_is_f64_ptr = is_f64_ptr_sb(src, str_sb);
    let src_is_str_ptr = is_str_ptr_sb(src, str_sb);
    let src_is_i32 = is_i32_var_sb(src, str_sb);
    // v0.95: Propagate closure marker from source to dest
    let src_is_closure = is_closure_var_sb(src, str_sb);
    let w_cl = if src_is_closure {
        let cap_count = get_closure_cap_count_sb(src, str_sb);
        push_closure_marker(str_sb, dest_name, cap_count)
    } else { 0 };
    let w1 = if src_is_string { push_string_marker(str_sb, dest_name) }
        else if src_is_f64_ptr { push_f64_ptr_marker(str_sb, dest_name) }
        else if src_is_str_ptr { push_str_ptr_marker(str_sb, dest_name) }
        else if src_is_i32 { push_i32_marker(str_sb, dest_name) }
        else { 0 };
    if src_is_double {
        let w = push_double_marker(str_sb, dest_name);
        same_mapping("  store double " + resolved_src + ", ptr " + dest_name)
    } else {
        same_mapping("  store i64 " + resolved_src + ", ptr " + dest_name)
    };

fn eliminate_identity_copies_ir(ir: String) -> String = {
    let aliases = build_ir_copy_aliases(ir, 0, "");
    if aliases.len() == 0 { ir }
    else {
        let sb = sb_new();
        let w = rebuild_ir_no_copies(ir, 0, sb, aliases);
        sb_build(sb)
    }
};

// Pass 1: Scan LLVM IR lines for identity copy patterns, build alias table
// Alias table format: ",dest=src,dest2=src2" (comma-prefixed for safe lookup)
fn build_ir_copy_aliases(ir: String, pos: i64, aliases: String) -> String =
    if pos >= ir.len() { aliases }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let ws_start = low_skip_ws(ir, pos);
        let new_aliases = if ws_start < pipe_pos and ir.byte_at(ws_start) == 37 {
            let line = ir.slice(pos, pipe_pos);
            try_add_ir_copy_alias(line, aliases)
        } else { aliases };
        if pipe_pos >= ir.len() { new_aliases }
        else { build_ir_copy_aliases(ir, pipe_pos + 1, new_aliases) }
    };

// Check if line is an identity copy, add alias if so
fn try_add_ir_copy_alias(line: String, aliases: String) -> String = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { aliases }
    else if line.byte_at(p) != 37 { aliases }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { aliases }
        else {
            let dest = trim(line.slice(p, eq_pos));
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if rhs == "add nsw i64 0, 0" {
                aliases + "," + dest + "=0"
            } else if starts_with(rhs, "add nsw i64 0, ", 0) {
                let src = rhs.slice(15, rhs.len());
                let resolved = resolve_ir_alias_d(aliases, src, 0);
                aliases + "," + dest + "=" + resolved
            } else if starts_with(rhs, "fadd nsz double 0.0, ", 0) {
                let src = rhs.slice(21, rhs.len());
                let resolved = resolve_ir_alias_d(aliases, src, 0);
                aliases + "," + dest + "=" + resolved
            } else { aliases }
        }
    }
};

// Searches for ",name=" in aliases string, returns position of value (after '=')
// or -1 if not found. Avoids creating "," + name + "=" key string.
fn find_alias_entry_noa(aliases: String, name: String, pos: i64) -> i64 =
    if pos >= aliases.len() { 0 - 1 }
    else {
        let comma = find_char(aliases, pos, 44);
        if comma >= aliases.len() { 0 - 1 }
        else {
            let entry_start = comma + 1;
            let eq_after = entry_start + name.len();
            if eq_after < aliases.len()
               and match_bytes(aliases, name, entry_start, 0)
               and aliases.byte_at(eq_after) == 61 {
                eq_after + 1
            } else {
                find_alias_entry_noa(aliases, name, comma + 1)
            }
        }
    };

// Resolve alias transitively with depth limit
fn resolve_ir_alias_d(aliases: String, name: String, depth: i64) -> String =
    if depth > 20 { name }
    else {
        let val_start = find_alias_entry_noa(aliases, name, 0);
        if val_start < 0 { name }
        else {
            let comma_pos = find_char(aliases, val_start, 44);
            let target = if comma_pos >= aliases.len() { aliases.slice(val_start, aliases.len()) }
                         else { aliases.slice(val_start, comma_pos) };
            resolve_ir_alias_d(aliases, target, depth + 1)
        }
    };

// Check if LLVM IR line is an identity copy
fn is_identity_copy_ir(line: String) -> bool = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { false }
    else if line.byte_at(p) != 37 { false }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { false }
        else {
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            rhs == "add nsw i64 0, 0" or starts_with(rhs, "add nsw i64 0, ", 0) or starts_with(rhs, "fadd nsz double 0.0, ", 0)
        }
    }
};

// Pass 2: Rebuild IR without identity copies, substituting aliases
fn rebuild_ir_no_copies(ir: String, pos: i64, sb: i64, aliases: String) -> i64 =
    if pos >= ir.len() { 0 }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let line = ir.slice(pos, pipe_pos);
        let w = if is_identity_copy_ir(line) {
            0
        } else {
            let len = sb_len(sb);
            let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
            subst_ir_aliases_to_sb(line, aliases, sb)
        };
        if pipe_pos >= ir.len() { 0 }
        else { rebuild_ir_no_copies(ir, pipe_pos + 1, sb, aliases) }
    };

// Substitute aliased %names in a single LLVM IR line
fn subst_ir_aliases_to_sb(line: String, aliases: String, outer_sb: i64) -> i64 =
    subst_ir_scan(line, 0, aliases, outer_sb);

// Scan line for % tokens and substitute aliases
fn subst_ir_scan(line: String, pos: i64, aliases: String, sb: i64) -> i64 =
    if pos >= line.len() { 0 }
    else if line.byte_at(pos) == 37 {
        let name_end = scan_ident_end(line, pos + 1);
        let name = line.slice(pos, name_end);
        let resolved = resolve_ir_alias_d(aliases, name, 0);
        let w1 = sb_push(sb, resolved);
        subst_ir_scan(line, name_end, aliases, sb)
    } else {
        let next_pct = find_char(line, pos + 1, 37);
        let chunk_end = if next_pct >= line.len() { line.len() } else { next_pct };
        let w1 = sb_push_range(sb, line, pos, chunk_end);
        if chunk_end >= line.len() { 0 }
        else { subst_ir_scan(line, chunk_end, aliases, sb) }
    };

// ============================================================================
// Pattern: %X = zext i1 %cmp to i64 ... %Y = trunc i64 %X to i1
// Since %Y == %cmp, replace %Y with %cmp and remove the trunc line
// The zext line stays (may have other uses); LLVM DCEs if unused
// ============================================================================

// Entry point: eliminate redundant trunc(zext(i1)) roundtrips
fn eliminate_zext_trunc_ir(ir: String) -> String = {
    let zext_map = build_zext_map(ir, 0, "");
    if zext_map.len() == 0 { ir }
    else {
        let aliases = build_trunc_aliases(ir, 0, zext_map, "");
        if aliases.len() == 0 { ir }
        else {
            let sb = sb_new();
            let w = rebuild_ir_no_truncs(ir, 0, sb, aliases);
            sb_build(sb)
        }
    }
};

// Pass A: Build zext map — records which %vars are zext of i1 values
// Format: ",dest=i1_src,dest2=i1_src2"
fn build_zext_map(ir: String, pos: i64, zmap: String) -> String =
    if pos >= ir.len() { zmap }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let ws_start = low_skip_ws(ir, pos);
        let new_zmap = if ws_start < pipe_pos and ir.byte_at(ws_start) == 37 {
            let line = ir.slice(pos, pipe_pos);
            try_add_zext(line, zmap)
        } else { zmap };
        if pipe_pos >= ir.len() { new_zmap }
        else { build_zext_map(ir, pipe_pos + 1, new_zmap) }
    };

// Check if line is "zext i1 %X to i64", record dest → X in zext map
fn try_add_zext(line: String, zmap: String) -> String = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { zmap }
    else if line.byte_at(p) != 37 { zmap }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { zmap }
        else {
            let dest = trim(line.slice(p, eq_pos));
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if starts_with(rhs, "zext i1 ", 0) {
                let to_pos = find_pattern_at_slow(rhs, " to ", 8);
                if to_pos < 0 { zmap }
                else {
                    let src = trim(rhs.slice(8, to_pos));
                    zmap + "," + dest + "=" + src
                }
            } else { zmap }
        }
    }
};

// Pass B: Find truncs whose source is in zext map, build alias table
fn build_trunc_aliases(ir: String, pos: i64, zmap: String, aliases: String) -> String =
    if pos >= ir.len() { aliases }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let ws_start = low_skip_ws(ir, pos);
        let new_aliases = if ws_start < pipe_pos and ir.byte_at(ws_start) == 37 {
            let line = ir.slice(pos, pipe_pos);
            try_add_trunc_alias(line, zmap, aliases)
        } else { aliases };
        if pipe_pos >= ir.len() { new_aliases }
        else { build_trunc_aliases(ir, pipe_pos + 1, zmap, new_aliases) }
    };

// Check if line is "trunc i64 %X to i1" where %X is a zext, add alias
fn try_add_trunc_alias(line: String, zmap: String, aliases: String) -> String = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { aliases }
    else if line.byte_at(p) != 37 { aliases }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { aliases }
        else {
            let dest = trim(line.slice(p, eq_pos));
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if starts_with(rhs, "trunc i64 ", 0) {
                let to_pos = find_pattern_at_slow(rhs, " to ", 10);
                if to_pos < 0 { aliases }
                else {
                    let src = trim(rhs.slice(10, to_pos));
                    let zext_src = lookup_zext_src(zmap, src);
                    if zext_src == "" { aliases }
                    else { aliases + "," + dest + "=" + zext_src }
                }
            } else { aliases }
        }
    }
};

// Lookup i1 source for a zext result
fn lookup_zext_src(zmap: String, name: String) -> String = {
    let val_start = find_alias_entry_noa(zmap, name, 0);
    if val_start < 0 { "" }
    else {
        let comma_pos = find_char(zmap, val_start, 44);
        if comma_pos >= zmap.len() { zmap.slice(val_start, zmap.len()) }
        else { zmap.slice(val_start, comma_pos) }
    }
};

// Check if line is a trunc that was aliased
fn is_aliased_trunc_ir(line: String, aliases: String) -> bool = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { false }
    else if line.byte_at(p) != 37 { false }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { false }
        else {
            let dest = trim(line.slice(p, eq_pos));
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if starts_with(rhs, "trunc i64 ", 0) {
                find_alias_entry_noa(aliases, dest, 0) >= 0
            } else { false }
        }
    }
};

// Pass C: Rebuild IR without aliased truncs, substitute aliases
fn rebuild_ir_no_truncs(ir: String, pos: i64, sb: i64, aliases: String) -> i64 =
    if pos >= ir.len() { 0 }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let line = ir.slice(pos, pipe_pos);
        let w = if is_aliased_trunc_ir(line, aliases) {
            0
        } else {
            let len = sb_len(sb);
            let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
            subst_ir_aliases_to_sb(line, aliases, sb)
        };
        if pipe_pos >= ir.len() { 0 }
        else { rebuild_ir_no_truncs(ir, pipe_pos + 1, sb, aliases) }
    };

fn eliminate_dead_zexts_ir(ir: String) -> String = {
    let dead = build_dead_zext_set(ir, 0, "");
    if dead.len() == 0 { ir }
    else {
        let sb = sb_new();
        let w = rebuild_ir_no_dead_zexts(ir, 0, sb, dead);
        sb_build(sb)
    }
};

// Scan IR for zext i1 lines, check if their results are unused
fn build_dead_zext_set(ir: String, pos: i64, dead: String) -> String =
    if pos >= ir.len() { dead }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let ws_start = low_skip_ws(ir, pos);
        let new_dead = if ws_start < pipe_pos and ir.byte_at(ws_start) == 37 {
            let line = ir.slice(pos, pipe_pos);
            try_mark_dead_zext(ir, line, dead)
        } else { dead };
        if pipe_pos >= ir.len() { new_dead }
        else { build_dead_zext_set(ir, pipe_pos + 1, new_dead) }
    };

// If line is a zext i1 and its dest is unused, add to dead set
fn try_mark_dead_zext(ir: String, line: String, dead: String) -> String = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { dead }
    else if line.byte_at(p) != 37 { dead }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { dead }
        else {
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if starts_with(rhs, "zext i1 ", 0) {
                let dest = trim(line.slice(p, eq_pos));
                if is_var_unused_in_ir(ir, dest) {
                    dead + "|" + dest + "|"
                } else { dead }
            } else { dead }
        }
    }
};

// Check if a variable has only one occurrence (its definition) in the IR
fn is_var_unused_in_ir(ir: String, name: String) -> bool = {
    let first = find_var_use_wb(ir, name, 0);
    if first < 0 { true }
    else {
        let second = find_var_use_wb(ir, name, first + name.len());
        second < 0
    }
};

// Find next occurrence of name with word boundary check
fn find_var_use_wb(ir: String, name: String, start: i64) -> i64 = {
    let pos = find_pattern_at_slow(ir, name, start);
    if pos < 0 { -1 }
    else {
        let end_pos = pos + name.len();
        if end_pos >= ir.len() { pos }
        else {
            let ch = ir.byte_at(end_pos);
            if is_alnum_or_underscore(ch) {
                find_var_use_wb(ir, name, pos + 1)
            } else { pos }
        }
    }
};

// Check if a line is a dead zext (in the dead set)
fn is_dead_zext_range(ir: String, start: i64, end: i64, dead: String) -> bool = {
    let p = low_skip_ws(ir, start);
    if p >= end { false }
    else if ir.byte_at(p) != 37 { false }
    else {
        let eq_pos = find_char_in_range(ir, p, end, 61);
        if eq_pos >= end { false }
        else {
            let rhs_start = low_skip_ws(ir, eq_pos + 1);
            if rhs_start + 8 <= end and match_bytes(ir, "zext i1 ", rhs_start, 0) {
                let dest_end = trim_end_pos(ir, p, eq_pos);
                let dest = ir.slice(p, dest_end);
                let key = "|" + dest + "|";
                find_pattern_noa(dead, key, 0) >= 0
            } else { false }
        }
    }
};

fn find_char_in_range(s: String, start: i64, end: i64, ch: i64) -> i64 =
    if start >= end { end }
    else if s.byte_at(start) == ch { start }
    else { find_char_in_range(s, start + 1, end, ch) };

fn trim_end_pos(s: String, start: i64, end: i64) -> i64 =
    if end <= start { start }
    else if s.byte_at(end - 1) == 32 or s.byte_at(end - 1) == 9 { trim_end_pos(s, start, end - 1) }
    else { end };

// Rebuild IR excluding dead zext lines
// v0.95.7: Uses sb_push_range to avoid line slice allocation for non-dead lines
fn rebuild_ir_no_dead_zexts(ir: String, pos: i64, sb: i64, dead: String) -> i64 =
    if pos >= ir.len() { 0 }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let w = if is_dead_zext_range(ir, pos, pipe_pos, dead) {
            0
        } else {
            let len = sb_len(sb);
            let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
            sb_push_range(sb, ir, pos, pipe_pos)
        };
        if pipe_pos >= ir.len() { 0 }
        else { rebuild_ir_no_dead_zexts(ir, pipe_pos + 1, sb, dead) }
    };

// Pattern: %a = ptrtoint ptr %P to i64 ... %b = inttoptr i64 %a to ptr → %b aliases %P
fn eliminate_inttoptr_roundtrips_ir(ir: String) -> String = {
    let pmap = build_ptrtoint_map(ir, 0, "");
    if pmap.len() == 0 { ir }
    else {
        let aliases = build_inttoptr_aliases(ir, 0, pmap, "");
        if aliases.len() == 0 { ir }
        else {
            let sb = sb_new();
            let w = rebuild_ir_no_inttoptrs(ir, 0, sb, aliases);
            sb_build(sb)
        }
    }
};

// Pass 1: Build ptrtoint map — records which i64 vars came from ptrtoint
// Format: ",i64_dest=ptr_src,..."
fn build_ptrtoint_map(ir: String, pos: i64, pmap: String) -> String =
    if pos >= ir.len() { pmap }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let ws_start = low_skip_ws(ir, pos);
        let new_pmap = if ws_start < pipe_pos and ir.byte_at(ws_start) == 37 {
            let line = ir.slice(pos, pipe_pos);
            try_add_ptrtoint(line, pmap)
        } else { pmap };
        if pipe_pos >= ir.len() { new_pmap }
        else { build_ptrtoint_map(ir, pipe_pos + 1, new_pmap) }
    };

// Check if line is "%X = ptrtoint ptr %P to i64", add to map
fn try_add_ptrtoint(line: String, pmap: String) -> String = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { pmap }
    else if line.byte_at(p) != 37 { pmap }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { pmap }
        else {
            let dest = trim(line.slice(p, eq_pos));
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if starts_with(rhs, "ptrtoint ptr ", 0) {
                let to_pos = find_pattern_at_slow(rhs, " to ", 13);
                if to_pos < 0 { pmap }
                else {
                    let src = trim(rhs.slice(13, to_pos));
                    pmap + "," + dest + "=" + src
                }
            } else { pmap }
        }
    }
};

// Pass 2: Find inttoptr whose i64 source is in ptrtoint map
fn build_inttoptr_aliases(ir: String, pos: i64, pmap: String, aliases: String) -> String =
    if pos >= ir.len() { aliases }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let ws_start = low_skip_ws(ir, pos);
        let new_aliases = if ws_start < pipe_pos and ir.byte_at(ws_start) == 37 {
            let line = ir.slice(pos, pipe_pos);
            try_add_inttoptr_alias(line, pmap, aliases)
        } else { aliases };
        if pipe_pos >= ir.len() { new_aliases }
        else { build_inttoptr_aliases(ir, pipe_pos + 1, pmap, new_aliases) }
    };

// Check if line is "%Y = inttoptr i64 %X to ptr" where %X is in ptrtoint map
fn try_add_inttoptr_alias(line: String, pmap: String, aliases: String) -> String = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { aliases }
    else if line.byte_at(p) != 37 { aliases }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { aliases }
        else {
            let dest = trim(line.slice(p, eq_pos));
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if starts_with(rhs, "inttoptr i64 ", 0) {
                let to_pos = find_pattern_at_slow(rhs, " to ", 13);
                if to_pos < 0 { aliases }
                else {
                    let src = trim(rhs.slice(13, to_pos));
                    let ptr_src = lookup_ptr_src(pmap, src);
                    if ptr_src == "" { aliases }
                    else { aliases + "," + dest + "=" + ptr_src }
                }
            } else { aliases }
        }
    }
};

// Lookup original ptr source for a ptrtoint result
fn lookup_ptr_src(pmap: String, name: String) -> String = {
    let val_start = find_alias_entry_noa(pmap, name, 0);
    if val_start < 0 { "" }
    else {
        let comma_pos = find_char(pmap, val_start, 44);
        if comma_pos >= pmap.len() { pmap.slice(val_start, pmap.len()) }
        else { pmap.slice(val_start, comma_pos) }
    }
};

// Check if line is an inttoptr that was aliased
fn is_aliased_inttoptr(line: String, aliases: String) -> bool = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { false }
    else if line.byte_at(p) != 37 { false }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { false }
        else {
            let dest = trim(line.slice(p, eq_pos));
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if starts_with(rhs, "inttoptr i64 ", 0) {
                find_alias_entry_noa(aliases, dest, 0) >= 0
            } else { false }
        }
    }
};

// Pass 3: Rebuild IR without aliased inttoptrs, substitute aliases
fn rebuild_ir_no_inttoptrs(ir: String, pos: i64, sb: i64, aliases: String) -> i64 =
    if pos >= ir.len() { 0 }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let line = ir.slice(pos, pipe_pos);
        let w = if is_aliased_inttoptr(line, aliases) {
            0
        } else {
            let len = sb_len(sb);
            let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
            subst_ir_aliases_to_sb(line, aliases, sb)
        };
        if pipe_pos >= ir.len() { 0 }
        else { rebuild_ir_no_inttoptrs(ir, pipe_pos + 1, sb, aliases) }
    };

fn eliminate_dead_ptrtoints_ir(ir: String) -> String = {
    let dead = build_dead_ptrtoint_set(ir, 0, "");
    if dead.len() == 0 { ir }
    else {
        let sb = sb_new();
        let w = rebuild_ir_no_dead_ptrtoints(ir, 0, sb, dead);
        sb_build(sb)
    }
};

// ============================================================================
// IR Memory Attribute Pass
// For pure functions (no calls, no loads, no stores, no pointer ops),
// add memory(none) to the function header to enable LLVM optimizations.
// ============================================================================

// v0.93.4: Check if a call target is a known memory(none) function
fn mn_is_pure_call(line: String) -> bool =
    let at_pos = find_byte_in_range(line, 64, 0, line.len());
    if at_pos < 0 { false }
    else {
        let paren_pos = find_char(line, at_pos, 40);
        if paren_pos <= at_pos { false }
        else {
            let fn_name = line.slice(at_pos + 1, paren_pos);
            // Runtime math functions
            fn_name == "bmb_abs" or fn_name == "bmb_min" or fn_name == "bmb_max"
            or fn_name == "bmb_clamp" or fn_name == "bmb_pow"
            or fn_name == "bmb_popcount" or fn_name == "bmb_clz" or fn_name == "bmb_ctz" or fn_name == "bmb_bit_reverse"
            // Math intrinsics
            or fn_name == "sqrt" or fn_name == "sin" or fn_name == "cos" or fn_name == "tan"
            or fn_name == "atan" or fn_name == "atan2" or fn_name == "log" or fn_name == "log2"
            or fn_name == "log10" or fn_name == "exp" or fn_name == "fmod" or fn_name == "pow_f64"
            // Float operations
            or fn_name == "bmb_f64_floor" or fn_name == "bmb_f64_ceil" or fn_name == "bmb_f64_round"
            or fn_name == "bmb_f64_sqrt" or fn_name == "bmb_f64_abs" or fn_name == "bmb_f64_is_nan"
            or fn_name == "bmb_f64_min" or fn_name == "bmb_f64_max" or fn_name == "bmb_f64_to_int"
        }
    };

fn mn_has_memory_op(ir: String, pos: i64) -> bool =
    if pos >= ir.len() { false }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let line = ir.slice(pos, pipe_pos);
        // Check for non-call memory operations first
        let has_mem = find_pattern_at(line, "store ", 0) >= 0
            or find_pattern_at(line, "load ", 0) >= 0
            or find_pattern_at(line, "inttoptr", 0) >= 0
            or find_pattern_at(line, "ptrtoint", 0) >= 0
            or find_pattern_at(line, "getelementptr", 0) >= 0;
        if has_mem { true }
        else {
            // v0.93.4: For calls, check if target is a known pure function
            let has_call = find_pattern_at(line, "call ", 0) >= 0;
            let has_impure_call = has_call and not mn_is_pure_call(line);
            if has_impure_call { true }
            else if pipe_pos >= ir.len() { false }
            else { mn_has_memory_op(ir, pipe_pos + 1) }
        }
    };

// Check if a call target is a known read-only function (reads memory but does not write)
fn mn_is_readonly_call(line: String) -> bool =
    if mn_is_pure_call(line) { true }
    else {
        let at_pos = find_byte_in_range(line, 64, 0, line.len());
        if at_pos < 0 { false }
        else {
            let paren_pos = find_char(line, at_pos, 40);
            if paren_pos <= at_pos { false }
            else {
                let fn_name = line.slice(at_pos + 1, paren_pos);
                fn_name == "bmb_array_len" or fn_name == "bmb_string_len"
                or fn_name == "bmb_string_char_at" or fn_name == "bmb_string_eq"
                or fn_name == "bmb_string_cmp" or fn_name == "bmb_string_hash"
                or fn_name == "bmb_string_starts_with" or fn_name == "bmb_string_ends_with"
                or fn_name == "bmb_string_contains" or fn_name == "bmb_string_index_of"
                or fn_name == "bmb_string_is_empty" or fn_name == "bmb_string_count"
                or fn_name == "bmb_string_last_index_of" or fn_name == "bmb_ord"
                or fn_name == "bmb_f64_is_nan"
            }
        }
    };

// Check if a function body has write operations (stores or write-capable calls)
fn mn_has_write_op(ir: String, pos: i64) -> bool =
    if pos >= ir.len() { false }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let line = ir.slice(pos, pipe_pos);
        let has_write = find_pattern_at(line, "store ", 0) >= 0
            or find_pattern_at(line, "inttoptr", 0) >= 0;
        if has_write { true }
        else {
            let has_call = find_pattern_at(line, "call ", 0) >= 0;
            let has_write_call = has_call and not mn_is_readonly_call(line);
            if has_write_call { true }
            else if pipe_pos >= ir.len() { false }
            else { mn_has_write_op(ir, pipe_pos + 1) }
        }
    };

fn annotate_memory_none_ir(ir: String) -> String =
    // Only annotate functions that have nosync and don't already have memory(
    let pipe = find_pipe_skip_quotes(ir, 0);
    let header = ir.slice(0, pipe);
    if find_pattern_at(header, "nosync", 0) < 0 { ir }
    else if find_pattern_at(header, "memory(", 0) >= 0 { ir }
    else if mn_has_memory_op(ir, pipe + 1) { ir }
    else {
        // Add memory(none) before the opening brace
        let brace = find_char(header, 0, 123);
        if brace >= header.len() { ir }
        else {
            let before_brace = header.slice(0, brace);
            let rest = if pipe >= ir.len() { "" } else { ir.slice(pipe, ir.len()) };
            before_brace + "memory(none) {" + rest
        }
    };

// Annotate read-only functions with memory(read): has loads/GEPs but no stores/write-calls
fn annotate_memory_read_ir(ir: String) -> String =
    let pipe = find_pipe_skip_quotes(ir, 0);
    let header = ir.slice(0, pipe);
    // Skip if already annotated or not a normal function
    if find_pattern_at(header, "memory(", 0) >= 0 { ir }
    else if find_pattern_at(header, "nosync", 0) < 0 { ir }
    else if mn_has_write_op(ir, pipe + 1) { ir }
    else {
        // Has reads but no writes → memory(read)
        let brace = find_char(header, 0, 123);
        if brace >= header.len() { ir }
        else {
            let before_brace = header.slice(0, brace);
            let rest = if pipe >= ir.len() { "" } else { ir.slice(pipe, ir.len()) };
            before_brace + "memory(read) {" + rest
        }
    };

fn build_dead_ptrtoint_set(ir: String, pos: i64, dead: String) -> String =
    if pos >= ir.len() { dead }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let ws_start = low_skip_ws(ir, pos);
        let new_dead = if ws_start < pipe_pos and ir.byte_at(ws_start) == 37 {
            let line = ir.slice(pos, pipe_pos);
            try_mark_dead_ptrtoint(ir, line, dead)
        } else { dead };
        if pipe_pos >= ir.len() { new_dead }
        else { build_dead_ptrtoint_set(ir, pipe_pos + 1, new_dead) }
    };

fn try_mark_dead_ptrtoint(ir: String, line: String, dead: String) -> String = {
    let p = low_skip_ws(line, 0);
    if p >= line.len() { dead }
    else if line.byte_at(p) != 37 { dead }
    else {
        let eq_pos = find_eq(line, p);
        if eq_pos >= line.len() { dead }
        else {
            let rhs = trim(line.slice(eq_pos + 1, line.len()));
            if starts_with(rhs, "ptrtoint ptr ", 0) {
                let dest = trim(line.slice(p, eq_pos));
                if is_var_unused_in_ir(ir, dest) {
                    dead + "|" + dest + "|"
                } else { dead }
            } else { dead }
        }
    }
};

fn is_dead_ptrtoint_range(ir: String, start: i64, end: i64, dead: String) -> bool = {
    let p = low_skip_ws(ir, start);
    if p >= end { false }
    else if ir.byte_at(p) != 37 { false }
    else {
        let eq_pos = find_char_in_range(ir, p, end, 61);
        if eq_pos >= end { false }
        else {
            let rhs_start = low_skip_ws(ir, eq_pos + 1);
            if rhs_start + 13 <= end and match_bytes(ir, "ptrtoint ptr ", rhs_start, 0) {
                let dest_end = trim_end_pos(ir, p, eq_pos);
                let dest = ir.slice(p, dest_end);
                let key = "|" + dest + "|";
                find_pattern_noa(dead, key, 0) >= 0
            } else { false }
        }
    }
};

// v0.95.7: Uses sb_push_range + range-based check
fn rebuild_ir_no_dead_ptrtoints(ir: String, pos: i64, sb: i64, dead: String) -> i64 =
    if pos >= ir.len() { 0 }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let w = if is_dead_ptrtoint_range(ir, pos, pipe_pos, dead) {
            0
        } else {
            let len = sb_len(sb);
            let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
            sb_push_range(sb, ir, pos, pipe_pos)
        };
        if pipe_pos >= ir.len() { 0 }
        else { rebuild_ir_no_dead_ptrtoints(ir, pipe_pos + 1, sb, dead) }
    };

// ============================================================================
// IR Store-Load Forwarding Pass
// When "store i64 %val, ptr %x" is followed by "%t = load i64, ptr %x"
// in the same basic block with no intervening store to %x or call,
// replace the load with "%t = add nsw i64 0, %val" (identity copy).
// ============================================================================

// Check if IR line is a store: "  store i64 %val, ptr %x"
fn slf_is_store(line: String) -> bool =
    let s = low_skip_ws(line, 0);
    find_pattern_at(line, "store i64 ", s) == s or find_pattern_at(line, "store double ", s) == s;

// Extract ptr name from "  store i64 %val, ptr %x" → "%x"
fn slf_store_ptr(line: String) -> String =
    let ptr_pos = find_pattern_at(line, ", ptr ", 0);
    if ptr_pos < 0 { "" }
    else { trim_end(line.slice(ptr_pos + 6, line.len())) };

// Extract stored value from "  store i64 %val, ptr %x" → "%val"
fn slf_store_val(line: String) -> String =
    let s = low_skip_ws(line, 0);
    let after_type = if find_pattern_at(line, "store i64 ", s) == s { s + 10 }
        else if find_pattern_at(line, "store double ", s) == s { s + 13 }
        else { 0 - 1 };
    if after_type < 0 { "" }
    else {
        let comma = find_pattern_at(line, ", ptr ", after_type);
        if comma < 0 { "" }
        else { trim_end(line.slice(after_type, comma)) }
    };

// Check if IR line is a load: "  %t = load i64, ptr %x"
fn slf_is_i64_load(line: String) -> bool =
    find_pattern_at(line, " = load i64, ptr ", 0) >= 0;

// Extract ptr from "  %t = load i64, ptr %x" → "%x"
fn slf_load_ptr(line: String) -> String =
    let load_pos = find_pattern_at(line, " = load i64, ptr ", 0);
    if load_pos < 0 { "" }
    else { trim_end(line.slice(load_pos + 17, line.len())) };

// Extract dest from "  %t = load i64, ptr %x" → "%t"
fn slf_load_dest(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = load i64, ptr ", 0);
    if eq_pos < 0 { "" }
    else { trim(line.slice(0, eq_pos)) };

// Check if line is a basic block boundary (label or terminator)
fn slf_is_bb_boundary(line: String) -> bool =
    let s = low_skip_ws(line, 0);
    if s >= line.len() { false }
    else {
        let trimmed = trim(line);
        // Labels end with ':'
        (trimmed.len() > 0 and trimmed.byte_at(trimmed.len() - 1) == 58) or
        // Branches
        find_pattern_at(line, "br ", s) == s or
        find_pattern_at(line, "ret ", s) == s or
        find_pattern_at(line, "unreachable", s) == s
    };

// Check if line is a call (may clobber memory)
fn slf_is_call(line: String) -> bool =
    find_pattern_at(line, "call ", 0) >= 0;

// Get the LAST value for key in the table (most recent store wins)
fn slf_table_get_last(table: String, key: String, pos: i64, found: String) -> String =
    if pos >= table.len() { found } else {
        let semi = find_char(table, pos, 59);
        let entry = table.slice(pos, semi);
        let eq = find_char(entry, 0, 61);
        if eq >= entry.len() { slf_table_get_last(table, key, semi + 1, found) } else {
            let entry_key = entry.slice(0, eq);
            let new_found = if entry_key == key { entry.slice(eq + 1, entry.len()) } else { found };
            slf_table_get_last(table, key, semi + 1, new_found)
        }
    };

fn slf_table_get(table: String, key: String) -> String =
    slf_table_get_last(table, key, 0, "");

// Process IR lines: forward stores to loads within the same basic block
fn slf_process(ir: String, pos: i64, sb: i64, table: String) -> i64 =
    if pos >= ir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let line = ir.slice(pos, pipe_pos);
        // Clear table on BB boundary or call
        let cur_table = if slf_is_bb_boundary(line) or slf_is_call(line) { "" } else { table };
        // Track stores
        let new_table = if slf_is_store(line) {
            let ptr = slf_store_ptr(line);
            let val = slf_store_val(line);
            if ptr != "" and val != "" { cp_table_set(cur_table, ptr, val) }
            else { cur_table }
        } else { cur_table };
        // Forward loads
        let new_line = if slf_is_i64_load(line) {
            let ptr = slf_load_ptr(line);
            let fwd = slf_table_get(new_table, ptr);
            if fwd != "" {
                let dest = slf_load_dest(line);
                "  " + dest + " = add nsw i64 0, " + fwd
            } else { line }
        } else { line };
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, new_line);
        if pipe_pos >= ir.len() { 0 }
        else { slf_process(ir, pipe_pos + 1, sb, new_table) }
    };

fn eliminate_store_load_ir(ir: String) -> String = {
    let sb = sb_new();
    let w = slf_process(ir, 0, sb, "");
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result
};

// ============================================================================
// IR Dead Store/Alloca Elimination Pass
// After store-load forwarding, many alloca+store pairs become dead (value
// never loaded). This pass removes them to reduce IR size.
// Two-pass: (1) identify dead allocas, (2) rebuild without dead lines.
// ============================================================================

// Pass 1: Scan IR lines to find alloca vars that are never loaded
// Returns comma-delimited dead set: ",name1,name2,"
fn dsa_find_dead(ir: String, pos: i64, allocas: String, loaded: String) -> String =
    if pos >= ir.len() {
        // Return allocas that are not in loaded set
        dsa_filter_dead(allocas, loaded, 0, "")
    } else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let line = ir.slice(pos, pipe_pos);
        let trimmed = trim(line);
        // Track allocas: "%name = alloca i64"
        let new_allocas = if find_pattern_at(trimmed, "= alloca i64", 0) > 0 {
            let eq_pos = find_pattern_at(trimmed, " = ", 0);
            if eq_pos > 0 {
                let name = trimmed.slice(0, eq_pos);
                allocas + "," + name
            } else { allocas }
        } else { allocas };
        // Track loads: "= load i64, ptr %name" or "= load double, ptr %name"
        let new_loaded = if find_pattern_at(trimmed, "= load ", 0) > 0 {
            let ptr_pos = find_pattern_at(trimmed, ", ptr ", 0);
            if ptr_pos >= 0 {
                let name = trim_end(trimmed.slice(ptr_pos + 6, trimmed.len()));
                // Strip trailing metadata like ", !invariant.load !0"
                let comma = find_char(name, 0, 44);
                let clean_name = if comma < name.len() { name.slice(0, comma) } else { name };
                loaded + "," + clean_name
            } else { loaded }
        } else { new_loaded_from_other(trimmed, loaded) };
        if pipe_pos >= ir.len() { dsa_filter_dead(new_allocas, new_loaded, 0, "") }
        else { dsa_find_dead(ir, pipe_pos + 1, new_allocas, new_loaded) }
    };

// Also track uses via "store ... ptr %name" where %name appears as a call argument, GEP base, etc.
fn new_loaded_from_other(line: String, loaded: String) -> String =
    // Check if line uses a ptr var for anything other than store dest
    // For now, just check if a ptr is used in GEP, call, or inttoptr context
    loaded;

// Filter: keep only alloca names not in loaded set
fn dsa_filter_dead(allocas: String, loaded: String, pos: i64, dead: String) -> String =
    if pos >= allocas.len() { dead }
    else {
        let next_comma = find_char(allocas, pos + 1, 44);
        let name = if next_comma > allocas.len() { allocas.slice(pos + 1, allocas.len()) }
            else { allocas.slice(pos + 1, next_comma) };
        if name.len() == 0 { dsa_filter_dead(allocas, loaded, next_comma, dead) }
        else {
            let is_loaded = find_pattern_at(loaded, "," + name, 0) >= 0;
            let new_dead = if is_loaded { dead } else { dead + "," + name + "," };
            if next_comma > allocas.len() { new_dead }
            else { dsa_filter_dead(allocas, loaded, next_comma, new_dead) }
        }
    };

// Check if a line should be removed (dead alloca or store to dead alloca)
fn dsa_is_dead_line(line: String, dead: String) -> bool =
    if dead.len() == 0 { false }
    else {
        let trimmed = trim(line);
        // Dead alloca: "%name = alloca i64" where name is in dead set
        if find_pattern_at(trimmed, "= alloca i64", 0) > 0 {
            let eq_pos = find_pattern_at(trimmed, " = ", 0);
            if eq_pos > 0 {
                let name = trimmed.slice(0, eq_pos);
                find_pattern_at(dead, "," + name + ",", 0) >= 0
            } else { false }
        }
        // Dead store: "store i64 %val, ptr %name" where name is in dead set
        else if find_pattern_at(trimmed, "store i64 ", 0) == 0 or find_pattern_at(trimmed, "store double ", 0) == 0 {
            let ptr_pos = find_pattern_at(trimmed, ", ptr ", 0);
            if ptr_pos >= 0 {
                let name = trim_end(trimmed.slice(ptr_pos + 6, trimmed.len()));
                find_pattern_at(dead, "," + name + ",", 0) >= 0
            } else { false }
        }
        else { false }
    };

// Pass 2: Rebuild IR without dead lines
fn dsa_rebuild(ir: String, pos: i64, sb: i64, dead: String) -> i64 =
    if pos >= ir.len() { 0 }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        let line = ir.slice(pos, pipe_pos);
        let w = if dsa_is_dead_line(line, dead) { 0 }
            else {
                let len = sb_len(sb);
                let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
                sb_push(sb, line)
            };
        if pipe_pos >= ir.len() { 0 }
        else { dsa_rebuild(ir, pipe_pos + 1, sb, dead) }
    };

fn eliminate_dead_stores_ir(ir: String) -> String = {
    let dead = dsa_find_dead(ir, 0, "", "");
    if dead.len() == 0 { ir }
    else {
        let sb = sb_new();
        let w = dsa_rebuild(ir, 0, sb, dead);
        let result = sb_build(sb);
        let _f = sb_free(sb);
        result
    }
};

// Module-level pass: scan for @name references, remove define blocks
// for functions never referenced. Uses line-by-line scanning with string builders
// for O(n) memory usage on large IR.
// Zero-allocation substring search (arena-safe replacement for find_pattern_at_slow)
fn find_pattern_noa(s: String, pat: String, pos: i64) -> i64 =
    if pos + pat.len() > s.len() { 0 - 1 }
    else if match_bytes(s, pat, pos, 0) { pos }
    else { find_pattern_noa(s, pat, pos + 1) };

fn match_bytes(s: String, pat: String, s_pos: i64, p_pos: i64) -> bool =
    if p_pos >= pat.len() { true }
    else if s.byte_at(s_pos + p_pos) != pat.byte_at(p_pos) { false }
    else { match_bytes(s, pat, s_pos, p_pos + 1) };

// Dead function elimination: remove unreferenced function definitions from module IR
fn eliminate_dead_functions_ir(ir: String) -> String = {
    // Phase 1: collect @name refs from non-define lines (line-by-line for TCO safety)
    let set_sb = sb_new();
    let w1 = sb_push(set_sb, ",main,bmb_user_main,");
    let w2 = collect_refs_by_lines(ir, 0, set_sb, 0);
    let called = sb_build(set_sb);
    // Phase 2: rebuild IR keeping only referenced function sections
    let out_sb = sb_new();
    let w3 = rebuild_ir_no_dead_fns(ir, 0, out_sb, called);
    sb_build(out_sb)
};

// Scan IR line-by-line for @name references, skip define header lines
// is_def_line: 1 if current line is a define header (first line after ||)
fn collect_refs_by_lines(ir: String, pos: i64, set_sb: i64, is_def_line: i64) -> i64 =
    if pos >= ir.len() { 0 }
    else {
        let pipe_pos = find_pipe_skip_quotes(ir, pos);
        // Check if this is || (function separator — next line is define header)
        let is_dbl = pipe_pos + 1 < ir.len() and ir.byte_at(pipe_pos + 1) == 124;
        // Skip @names in define header lines
        let w = if is_def_line == 1 { 0 }
                else { collect_refs_in_range(ir, pos, pipe_pos, set_sb) };
        if pipe_pos >= ir.len() { 0 }
        else if is_dbl { collect_refs_by_lines(ir, pipe_pos + 2, set_sb, 1) }
        else { collect_refs_by_lines(ir, pipe_pos + 1, set_sb, 0) }
    };

// Find @name references in IR range [start, end) and add to set_sb
fn collect_refs_in_range(ir: String, start: i64, end: i64, set_sb: i64) -> i64 =
    if start >= end { 0 }
    else {
        let at_pos = find_byte_in_range(ir, 64, start, end);
        if at_pos < 0 { 0 }
        else {
            let name_end = find_at_name_end_in(ir, at_pos + 1, end);
            let w = if name_end > at_pos + 1 {
                let name = ir.slice(at_pos + 1, name_end);
                let w1 = sb_push(set_sb, name);
                sb_push(set_sb, ",")
            } else { 0 };
            collect_refs_in_range(ir, name_end, end, set_sb)
        }
    };

fn find_at_name_end_in(s: String, pos: i64, end: i64) -> i64 =
    if pos >= end { pos }
    else {
        let ch = s.byte_at(pos);
        if is_alnum_or_underscore(ch) or ch == 46 { find_at_name_end_in(s, pos + 1, end) }
        else { pos }
    };

// Rebuild IR skipping dead function blocks (separated by ||)
fn rebuild_ir_no_dead_fns(ir: String, pos: i64, sb: i64, called: String) -> i64 =
    if pos >= ir.len() { 0 }
    else {
        let fn_end = find_double_pipe(ir, pos);
        let fn_name = extract_define_name_fast(ir, pos, fn_end);
        let keep = if fn_name.len() == 0 { true }
                   else {
                       let key = "," + fn_name + ",";
                       find_pattern_noa(called, key, 0) >= 0
                   };
        let w = if keep {
            let len = sb_len(sb);
            let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
            sb_push_range(sb, ir, pos, fn_end)
        } else { 0 };
        if fn_end + 2 >= ir.len() { 0 }
        else { rebuild_ir_no_dead_fns(ir, fn_end + 2, sb, called) }
    };

// Extract function name from define header by searching directly in IR range
fn extract_define_name_fast(ir: String, start: i64, end: i64) -> String = {
    let def_pos = find_pattern_noa_range(ir, "define ", start, end);
    if def_pos < 0 { "" }
    else {
        let at_pos = find_byte_in_range(ir, 64, def_pos + 7, end);
        if at_pos < 0 { "" }
        else {
            let name_end = find_at_name_end_in(ir, at_pos + 1, end);
            if name_end > at_pos + 1 { ir.slice(at_pos + 1, name_end) } else { "" }
        }
    }
};

// Zero-allocation pattern search within range [pos, end)
fn find_pattern_noa_range(s: String, pat: String, pos: i64, end: i64) -> i64 =
    if pos + pat.len() > end { 0 - 1 }
    else if match_bytes(s, pat, pos, 0) { pos }
    else { find_pattern_noa_range(s, pat, pos + 1, end) };

fn find_byte_in_range(s: String, byte: i64, pos: i64, end: i64) -> i64 =
    if pos >= end { -1 }
    else if s.byte_at(pos) == byte { pos }
    else { find_byte_in_range(s, byte, pos + 1, end) };

fn build_all_registries(mir: String, fn_rsb: i64, ptr_rsb: i64) -> i64 =
    build_all_registries_acc(mir, 0, fn_rsb, ptr_rsb);

fn build_all_registries_acc(mir: String, pos: i64, fn_rsb: i64, ptr_rsb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let w1 = register_fn_type(fn_mir, fn_rsb);
        let w2 = register_ptr_return(fn_mir, ptr_rsb);
        if fn_end + 2 >= mir.len() { 0 } else { build_all_registries_acc(mir, fn_end + 2, fn_rsb, ptr_rsb) }
    };

fn register_fn_type(fn_mir: String, rsb: i64) -> i64 =
    let first_pipe = find_char(fn_mir, 0, 124);
    let header = fn_mir.slice(0, first_pipe);
    if header.len() < 4 { 0 }
    else if low_starts_with_at(header, 0, "fn ") {
        let name_start = 3;
        let paren_pos = find_char(header, name_start, 40);
        let fn_name = header.slice(name_start, paren_pos);
        let close_pos = find_char(header, paren_pos, 41);
        let arrow_pos = find_arrow(header, close_pos);
        let brace_pos = find_char(header, arrow_pos, 123);
        let raw_ret = trim(header.slice(arrow_pos + 2, brace_pos));
        let ann = find_mir_annotation(raw_ret);
        let ret_type = if ann == "" { raw_ret } else { strip_annotation(raw_ret) };
        // v0.95: i32 return type support
        let llvm_ret = if ret_type == "f64" { "double" } else if ret_type == "ptr" { "ptr" } else if ret_type == "i32" { "i32" } else { "i64" };
        let params = header.slice(paren_pos + 1, close_pos);
        let param_sig = build_param_sig(params, 0, "");
        let w1 = sb_push(rsb, "@" + fn_name + ":" + llvm_ret + ":" + param_sig + ",");
        0
    } else { 0 };

// ============================================================================
// Scans MIR for functions with @const annotation, 0 params, returning a constant.
// Replaces all call @name() with const <value> in the MIR.
// ============================================================================

// Main entry point: optimize MIR by inlining const functions
fn optimize_const_inlining(mir: String) -> String =
    let const_map = build_const_map(mir);
    if const_map == "" { mir }
    else { apply_const_map_to_mir(mir, const_map, 0) };

// Build map of const function name -> value from MIR
// Format: "@name=value,@name2=value2,"
fn build_const_map(mir: String) -> String =
    let sb = sb_new();
    let w1 = build_const_map_acc(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

fn build_const_map_acc(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let w1 = try_register_const_fn(fn_mir, sb);
        if fn_end + 2 >= mir.len() { 0 } else { build_const_map_acc(mir, fn_end + 2, sb) }
    };

// Check if a function MIR is a 0-arg @const returning a constant
// Must have ONLY: entry: | %_tN = const <value> | return %_tN | }
// Reject functions with calls, arithmetic, etc.
fn try_register_const_fn(fn_mir: String, sb: i64) -> i64 =
    let first_pipe = find_char(fn_mir, 0, 124);
    let header = if first_pipe >= fn_mir.len() { fn_mir } else { fn_mir.slice(0, first_pipe) };
    let has_const = find_pattern_at(header, "@const", 0);
    if has_const < 0 { 0 }
    else {
        let paren_pos = find_char(header, 3, 40);
        let fn_name = header.slice(3, paren_pos);
        let close_pos = find_char(header, paren_pos, 41);
        let params = trim(header.slice(paren_pos + 1, close_pos));
        if params.len() > 0 { 0 }
        else {
            // Verify body has no calls or complex instructions
            let has_call = find_pattern_at(fn_mir, "= call ", first_pipe);
            if has_call >= 0 { 0 }
            else {
                let const_pos = find_pattern_at(fn_mir, "= const ", first_pipe);
                if const_pos < 0 { 0 }
                else {
                    let value_start = const_pos + 8;
                    let line_end = find_char(fn_mir, value_start, 124);
                    let value = trim(fn_mir.slice(value_start, line_end));
                    if value.len() == 0 { 0 }
                    else {
                        let first_ch = value.byte_at(0);
                        // Support both integer (123) and float (F:3.14) constants
                        let is_num = if first_ch >= 48 and first_ch <= 57 { true }
                            else if first_ch == 45 and value.len() > 1 and value.byte_at(1) >= 48 and value.byte_at(1) <= 57 { true }
                            else if first_ch == 70 and value.len() > 2 and value.byte_at(1) == 58 { true }
                            else { false };
                        if is_num {
                            let w1 = sb_push(sb, "@");
                            let w2 = sb_push(sb, fn_name);
                            let w3 = sb_push(sb, "=");
                            let w4 = sb_push(sb, value);
                            let w5 = sb_push(sb, ",");
                            0
                        } else { 0 }
                    }
                }
            }
        }
    };

// Apply all const map entries to MIR
fn apply_const_map_to_mir(mir: String, const_map: String, pos: i64) -> String =
    if pos >= const_map.len() { mir }
    else {
        let at_pos = find_char(const_map, pos, 64);
        if at_pos >= const_map.len() { mir }
        else {
            let eq_pos = find_char(const_map, at_pos, 61);
            let comma_pos = find_char(const_map, eq_pos, 44);
            let fn_name = const_map.slice(at_pos + 1, eq_pos);
            let value = const_map.slice(eq_pos + 1, comma_pos);
            let pattern = "call @" + fn_name + "()";
            let replacement = "const " + value;
            let new_mir = replace_all_in_mir(mir, pattern, replacement);
            apply_const_map_to_mir(new_mir, const_map, comma_pos + 1)
        }
    };

// Replace all occurrences of pattern in string with replacement
fn replace_all_in_mir(s: String, pattern: String, replacement: String) -> String =
    let first = find_pattern_at(s, pattern, 0);
    if first < 0 { s }
    else {
        let sb = sb_new();
        let w1 = replace_all_in_mir_acc(s, 0, pattern, replacement, sb);
        let result = sb_build(sb);
        let _f = sb_free(sb);
        result
    };

fn replace_all_in_mir_acc(s: String, pos: i64, pattern: String, replacement: String, sb: i64) -> i64 =
    let found = find_pattern_at(s, pattern, pos);
    if found < 0 {
        sb_push(sb, s.slice(pos, s.len()))
    } else {
        let w1 = sb_push(sb, s.slice(pos, found));
        let w2 = sb_push(sb, replacement);
        replace_all_in_mir_acc(s, found + pattern.len(), pattern, replacement, sb)
    };

// ============================================================================
// MIR Constant Folding Pass
// Folds binary arithmetic (+,-,*,/,%) on known integer constants.
// Propagates constants through copy instructions.
// ============================================================================

// Constant table: "key1:val1;key2:val2" — ';' (59) entry sep, ':' (58) key-val sep
fn cf_table_set(table: String, key: String, val: i64) -> String =
    if table == "" { key + ":" + i2s(val) } else { table + ";" + key + ":" + i2s(val) };

fn cf_table_get_at(table: String, key: String, pos: i64) -> i64 =
    if pos >= table.len() { 0 - 99999999 } else {
        let semi = find_char(table, pos, 59);
        let entry = table.slice(pos, semi);
        let colon = find_char(entry, 0, 58);
        if colon >= entry.len() { cf_table_get_at(table, key, semi + 1) } else {
            let entry_key = entry.slice(0, colon);
            if entry_key == key { parse_int_from(entry, colon + 1, 0) }
            else { cf_table_get_at(table, key, semi + 1) }
        }
    };

fn cf_table_get(table: String, key: String) -> i64 = cf_table_get_at(table, key, 0);
fn cf_table_has(table: String, key: String) -> bool = cf_table_get(table, key) != 0 - 99999999;

// Check if line is integer constant: %dest = const <digits|minus>
// Must match the ASSIGNMENT's `= const`, not ` = const ` inside string content.
fn cf_is_int_const(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        let after_eq = eq_pos + 3;
        if after_eq + 6 > line.len() { false }
        else if starts_with(line.slice(after_eq, line.len()), "const ", 0) {
            let vs = after_eq + 6;
            if vs >= line.len() { false } else {
                let ch = line.byte_at(vs);
                (ch >= 48 and ch <= 57) or ch == 45
            }
        } else { false }
    };

// Extract integer value from: %dest = const 42
// Must use the ASSIGNMENT's `= const`, not one inside string content.
fn cf_extract_int_val(line: String) -> i64 =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { 0 } else {
        let after_eq = eq_pos + 3;
        if starts_with(line.slice(after_eq, line.len()), "const ", 0) {
            parse_int_from(line, after_eq + 6, 0)
        } else { 0 }
    };

// Extract dest from: %dest = ...
fn cf_extract_dest(line: String) -> String =
    let start = low_skip_ws(line, 0);
    if start >= line.len() { "" }
    else if line.byte_at(start) != 37 { "" }
    else {
        let eq_pos = find_pattern_at(line, " = ", start);
        if eq_pos < 0 { "" } else { line.slice(start, eq_pos) }
    };

// Check/extract copy: %dest = copy %src
// Must use first ` = ` to avoid matching inside string content.
fn cf_is_copy(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        starts_with(line.slice(eq_pos + 3, line.len()), "copy %", 0)
    };
fn cf_copy_src(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { "" } else {
        if starts_with(line.slice(eq_pos + 3, line.len()), "copy %", 0) {
            line.slice(eq_pos + 8, line.len())
        } else { "" }
    };

// Check if line is binary arithmetic: %dest = OP %a, %b
fn cf_is_arith(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        let rest = line.slice(eq_pos + 3, line.len());
        starts_with(rest, "+ ", 0) or starts_with(rest, "- ", 0) or
        starts_with(rest, "* ", 0) or starts_with(rest, "/ ", 0) or
        starts_with(rest, "% ", 0)
    };

// Check if line is non-trapping arithmetic (excludes div/mod which trap on zero)
// Used by IfElseToSelect to ensure select operands cannot cause UB
fn cf_is_non_trapping_arith(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        let rest = line.slice(eq_pos + 3, line.len());
        starts_with(rest, "+ ", 0) or starts_with(rest, "- ", 0) or
        starts_with(rest, "* ", 0)
    };

// Extract operator from binary arithmetic
fn cf_arith_op(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { "" } else {
        let rest = line.slice(eq_pos + 3, line.len());
        if starts_with(rest, "+ ", 0) { "+" }
        else if starts_with(rest, "- ", 0) { "-" }
        else if starts_with(rest, "* ", 0) { "*" }
        else if starts_with(rest, "/ ", 0) { "/" }
        else if starts_with(rest, "% ", 0) { "%" }
        else { "" }
    };

// Extract left operand: %dest = OP %left, %right -> %left
fn cf_arith_left(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { "" } else {
        let rest = line.slice(eq_pos + 3, line.len());
        let pct = find_char(rest, 0, 37);
        if pct >= rest.len() { "" } else {
            let comma = find_char(rest, pct, 44);
            if comma >= rest.len() { "" } else { rest.slice(pct, comma) }
        }
    };

// Extract right operand: ..., %right -> %right
fn cf_arith_right(line: String) -> String =
    let comma = find_char(line, 0, 44);
    if comma >= line.len() { "" } else {
        let rest = line.slice(comma + 1, line.len());
        let after_ws = low_skip_ws(rest, 0);
        if after_ws >= rest.len() { "" }
        else if rest.byte_at(after_ws) == 37 { rest.slice(after_ws, rest.len()) }
        else { "" }
    };

// Binary arithmetic on constants (5 branches — bootstrap limit)
fn cf_compute(op: String, a: i64, b: i64) -> i64 =
    if op == "+" { a + b } else if op == "-" { a - b } else if op == "*" { a * b } else if op == "/" { if b == 0 { 0 } else { a / b } } else if op == "%" { if b == 0 { 0 } else { a - (a / b) * b } } else { 0 };

// Check if line is comparison: %dest = OP %a, %b where OP is ==,!=,<,>,<=,>=
fn cf_is_cmp(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        let rest = line.slice(eq_pos + 3, line.len());
        starts_with(rest, "== ", 0) or starts_with(rest, "!= ", 0) or
        starts_with(rest, "<= ", 0) or starts_with(rest, ">= ", 0) or
        starts_with(rest, "< ", 0) or starts_with(rest, "> ", 0)
    };

// Extract comparison operator
fn cf_cmp_op(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { "" } else {
        let rest = line.slice(eq_pos + 3, line.len());
        if starts_with(rest, "== ", 0) { "==" }
        else if starts_with(rest, "!= ", 0) { "!=" }
        else if starts_with(rest, "<= ", 0) { "<=" }
        else if starts_with(rest, ">= ", 0) { ">=" }
        else if starts_with(rest, "< ", 0) { "<" }
        else if starts_with(rest, "> ", 0) { ">" }
        else { "" }
    };

// Evaluate comparison (separate from cf_compute to avoid 5-branch limit)
fn cf_eval_cmp(op: String, a: i64, b: i64) -> i64 =
    if op == "==" { if a == b { 1 } else { 0 } }
    else if op == "!=" { if a != b { 1 } else { 0 } }
    else if op == "<" { if a < b { 1 } else { 0 } }
    else if op == ">" { if a > b { 1 } else { 0 } }
    else if op == "<=" { if a <= b { 1 } else { 0 } }
    else { if a >= b { 1 } else { 0 } };

// Check if line is shift: %dest = << %a, %b or >> %a, %b
fn cf_is_shift(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        let rest = line.slice(eq_pos + 3, line.len());
        starts_with(rest, "<< ", 0) or starts_with(rest, ">> ", 0)
    };

// Extract shift operator
fn cf_shift_op(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { "" } else {
        let rest = line.slice(eq_pos + 3, line.len());
        if starts_with(rest, "<< ", 0) { "<<" }
        else if starts_with(rest, ">> ", 0) { ">>" }
        else { "" }
    };

// Evaluate shift (separate function to avoid branch limits)
fn cf_eval_shift(op: String, a: i64, b: i64) -> i64 =
    if op == "<<" { a * cf_pow2(b) } else { a / cf_pow2(b) };

// 2^n helper for shift evaluation
fn cf_pow2(n: i64) -> i64 =
    if n <= 0 { 1 } else { 2 * cf_pow2(n - 1) };

// Check if line is bitwise: %dest = band/bor/bxor %a, %b
fn cf_is_bitwise(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        let rest = line.slice(eq_pos + 3, line.len());
        starts_with(rest, "band ", 0) or starts_with(rest, "bor ", 0) or
        starts_with(rest, "bxor ", 0)
    };

// Extract bitwise operator
fn cf_bitwise_op(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { "" } else {
        let rest = line.slice(eq_pos + 3, line.len());
        if starts_with(rest, "band ", 0) { "band" }
        else if starts_with(rest, "bor ", 0) { "bor" }
        else if starts_with(rest, "bxor ", 0) { "bxor" }
        else { "" }
    };

// Evaluate bitwise (separate function)
fn cf_eval_bitwise(op: String, a: i64, b: i64) -> i64 =
    if op == "band" { a band b } else if op == "bor" { a bor b } else { a bxor b };

// Check if line is unary neg: %dest = neg %src
// Must use first ` = ` to avoid matching inside string content.
fn cf_is_neg(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        starts_with(line.slice(eq_pos + 3, line.len()), "neg %", 0)
    };
// Check if line is unary not: %dest = not %src
fn cf_is_not(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        starts_with(line.slice(eq_pos + 3, line.len()), "not %", 0)
    };
// Extract source from unary: %dest = neg %src -> %src
fn cf_unary_src(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { "" } else {
        let rest = line.slice(eq_pos + 3, line.len());
        if starts_with(rest, "neg %", 0) { line.slice(eq_pos + 7, line.len()) }
        else if starts_with(rest, "not %", 0) { line.slice(eq_pos + 7, line.len()) }
        else { "" }
    };

// Power-of-2 check: n > 1 and (n & (n-1)) == 0
fn cf_is_pow2(n: i64) -> bool =
    n > 1 and (n band (n - 1)) == 0;

// Log2 for power-of-2 values
fn cf_log2(n: i64) -> i64 =
    if n <= 1 { 0 } else { 1 + cf_log2(n / 2) };

// Check if algebraic simplification applies (one operand known: x+0, x*1, x*0, x-x, etc.)
fn cf_can_simplify(line: String, table: String) -> bool =
    if cf_is_arith(line) {
        let op = cf_arith_op(line);
        let left = cf_arith_left(line);
        let right = cf_arith_right(line);
        let lk = cf_table_has(table, left);
        let rk = cf_table_has(table, right);
        // x - x → 0
        if op == "-" and left == right { true }
        // x + 0, x - 0 → x
        else if (op == "+" or op == "-") and rk and cf_table_get(table, right) == 0 { true }
        // 0 + x → x
        else if op == "+" and lk and cf_table_get(table, left) == 0 { true }
        // x * 0, 0 * x → 0
        else if op == "*" and rk and cf_table_get(table, right) == 0 { true }
        else if op == "*" and lk and cf_table_get(table, left) == 0 { true }
        // x * 1, 1 * x → x
        else if op == "*" and rk and cf_table_get(table, right) == 1 { true }
        else if op == "*" and lk and cf_table_get(table, left) == 1 { true }
        // x / 1 → x
        else if op == "/" and rk and cf_table_get(table, right) == 1 { true }
        // x % 1 → 0
        else if op == "%" and rk and cf_table_get(table, right) == 1 { true }
        // x * 2^n → x << n (strength reduction)
        else if op == "*" and rk and cf_is_pow2(cf_table_get(table, right)) { true }
        else if op == "*" and lk and cf_is_pow2(cf_table_get(table, left)) { true }
        else { false }
    } else if cf_is_shift(line) {
        let left = cf_arith_left(line);
        let right = cf_arith_right(line);
        let rk = cf_table_has(table, right);
        // x << 0, x >> 0 → x
        rk and cf_table_get(table, right) == 0
    } else if cf_is_bitwise(line) {
        let op = cf_bitwise_op(line);
        let left = cf_arith_left(line);
        let right = cf_arith_right(line);
        let lk = cf_table_has(table, left);
        let rk = cf_table_has(table, right);
        // x ^ x, x - x pattern → 0 (already handled for arith)
        if (op == "bxor") and left == right { true }
        // x & x → x, x | x → x
        else if (op == "band" or op == "bor") and left == right { true }
        // x & 0, 0 & x → 0
        else if op == "band" and rk and cf_table_get(table, right) == 0 { true }
        else if op == "band" and lk and cf_table_get(table, left) == 0 { true }
        // x | 0, 0 | x → x
        else if op == "bor" and rk and cf_table_get(table, right) == 0 { true }
        else if op == "bor" and lk and cf_table_get(table, left) == 0 { true }
        // x ^ 0, 0 ^ x → x
        else if op == "bxor" and rk and cf_table_get(table, right) == 0 { true }
        else if op == "bxor" and lk and cf_table_get(table, left) == 0 { true }
        else { false }
    } else { false };

// Generate algebraically simplified line
fn cf_simplified(line: String, table: String) -> String =
    let dest = cf_extract_dest(line);
    if cf_is_arith(line) { cf_simplified_arith(dest, line, table) }
    else if cf_is_shift(line) { cf_simplified_shift(dest, line, table) }
    else if cf_is_bitwise(line) { cf_simplified_bitwise(dest, line, table) }
    else { line };

fn cf_simplified_arith(dest: String, line: String, table: String) -> String =
    let op = cf_arith_op(line);
    let left = cf_arith_left(line);
    let right = cf_arith_right(line);
    let lk = cf_table_has(table, left);
    let rk = cf_table_has(table, right);
    // x - x → 0
    if op == "-" and left == right { "  " + dest + " = const 0" }
    // x * 0, 0 * x → 0
    else if op == "*" and rk and cf_table_get(table, right) == 0 { "  " + dest + " = const 0" }
    else if op == "*" and lk and cf_table_get(table, left) == 0 { "  " + dest + " = const 0" }
    // x + 0, x - 0 → copy x
    else if (op == "+" or op == "-") and rk and cf_table_get(table, right) == 0 { "  " + dest + " = copy " + left }
    // 0 + x → copy x
    else if op == "+" and lk and cf_table_get(table, left) == 0 { "  " + dest + " = copy " + right }
    // x * 1 → copy x
    else if op == "*" and rk and cf_table_get(table, right) == 1 { "  " + dest + " = copy " + left }
    // 1 * x → copy x
    else if op == "*" and lk and cf_table_get(table, left) == 1 { "  " + dest + " = copy " + right }
    // x / 1 → copy x
    else if op == "/" and rk and cf_table_get(table, right) == 1 { "  " + dest + " = copy " + left }
    // x % 1 → 0
    else if op == "%" and rk and cf_table_get(table, right) == 1 { "  " + dest + " = const 0" }
    // x * 2^n → x << n (strength reduction, emits 2-line replacement)
    else if op == "*" and rk and cf_is_pow2(cf_table_get(table, right)) {
        let shift_amt = cf_log2(cf_table_get(table, right));
        "  " + dest + "_sr = const " + i2s(shift_amt) + "|  " + dest + " = << " + left + ", " + dest + "_sr"
    }
    // 2^n * x → x << n (commutative)
    else if op == "*" and lk and cf_is_pow2(cf_table_get(table, left)) {
        let shift_amt = cf_log2(cf_table_get(table, left));
        "  " + dest + "_sr = const " + i2s(shift_amt) + "|  " + dest + " = << " + right + ", " + dest + "_sr"
    }
    else { line };

fn cf_simplified_shift(dest: String, line: String, table: String) -> String =
    let left = cf_arith_left(line);
    let right = cf_arith_right(line);
    let rk = cf_table_has(table, right);
    // x << 0, x >> 0 → copy x
    if rk and cf_table_get(table, right) == 0 { "  " + dest + " = copy " + left }
    else { line };

fn cf_simplified_bitwise(dest: String, line: String, table: String) -> String =
    let op = cf_bitwise_op(line);
    let left = cf_arith_left(line);
    let right = cf_arith_right(line);
    let lk = cf_table_has(table, left);
    let rk = cf_table_has(table, right);
    // x ^ x → 0
    if op == "bxor" and left == right { "  " + dest + " = const 0" }
    // x & x → copy x, x | x → copy x
    else if (op == "band" or op == "bor") and left == right { "  " + dest + " = copy " + left }
    // x & 0, 0 & x → 0
    else if op == "band" and rk and cf_table_get(table, right) == 0 { "  " + dest + " = const 0" }
    else if op == "band" and lk and cf_table_get(table, left) == 0 { "  " + dest + " = const 0" }
    // x | 0, 0 | x → copy x
    else if op == "bor" and rk and cf_table_get(table, right) == 0 { "  " + dest + " = copy " + left }
    else if op == "bor" and lk and cf_table_get(table, left) == 0 { "  " + dest + " = copy " + right }
    // x ^ 0 → copy x
    else if op == "bxor" and rk and cf_table_get(table, right) == 0 { "  " + dest + " = copy " + left }
    // 0 ^ x → copy x
    else if op == "bxor" and lk and cf_table_get(table, left) == 0 { "  " + dest + " = copy " + right }
    else { line };

// Check if line can be constant-folded (arithmetic, comparison, or unary)
fn cf_can_fold(line: String, table: String) -> bool =
    if cf_is_arith(line) or cf_is_cmp(line) or cf_is_shift(line) or cf_is_bitwise(line) {
        let left = cf_arith_left(line);
        let right = cf_arith_right(line);
        cf_table_has(table, left) and cf_table_has(table, right)
    } else if cf_is_neg(line) or cf_is_not(line) {
        let src = cf_unary_src(line);
        cf_table_has(table, src)
    } else { false };

// Generate folded replacement line
fn cf_folded(line: String, table: String) -> String =
    let dest = cf_extract_dest(line);
    if cf_is_neg(line) {
        let src = cf_unary_src(line);
        let val = cf_table_get(table, src);
        "  " + dest + " = const " + i2s(0 - val)
    } else if cf_is_not(line) {
        let src = cf_unary_src(line);
        let val = cf_table_get(table, src);
        let result = if val == 0 { 1 } else { 0 };
        "  " + dest + " = const " + i2s(result)
    } else {
        let left = cf_arith_left(line);
        let right = cf_arith_right(line);
        let lv = cf_table_get(table, left);
        let rv = cf_table_get(table, right);
        if cf_is_arith(line) {
            let op = cf_arith_op(line);
            "  " + dest + " = const " + i2s(cf_compute(op, lv, rv))
        } else if cf_is_cmp(line) {
            let op = cf_cmp_op(line);
            "  " + dest + " = const " + i2s(cf_eval_cmp(op, lv, rv))
        } else if cf_is_shift(line) {
            let op = cf_shift_op(line);
            "  " + dest + " = const " + i2s(cf_eval_shift(op, lv, rv))
        } else {
            let op = cf_bitwise_op(line);
            "  " + dest + " = const " + i2s(cf_eval_bitwise(op, lv, rv))
        }
    };

// Update const table after processing a line
fn cf_update_table(line: String, table: String) -> String =
    if cf_is_int_const(line) {
        let dest = cf_extract_dest(line);
        let val = cf_extract_int_val(line);
        cf_table_set(table, dest, val)
    } else if ube_is_phi(line) {
        // Phi constant propagation: if both incoming values are the same constant,
        // the phi result is that constant
        let dest = cf_extract_dest(line);
        let eq_pos = find_pattern_at(line, " = ", 0);
        let rhs = line.slice(eq_pos + 3, line.len());
        let phi_args = rhs.slice(4, rhs.len());
        let b1_start = find_char(phi_args, 0, 91);
        let b1_end = find_char(phi_args, b1_start, 93);
        let bracket1 = phi_args.slice(b1_start, b1_end + 1);
        let val1_var = ube_phi_val(bracket1);
        let b2_start = find_char(phi_args, b1_end + 1, 91);
        let b2_end = find_char(phi_args, b2_start, 93);
        let bracket2 = phi_args.slice(b2_start, b2_end + 1);
        let val2_var = ube_phi_val(bracket2);
        if cf_table_has(table, val1_var) and cf_table_has(table, val2_var) {
            let v1 = cf_table_get(table, val1_var);
            let v2 = cf_table_get(table, val2_var);
            if v1 == v2 { cf_table_set(table, dest, v1) } else { table }
        } else { table }
    } else if cf_is_copy(line) {
        let dest = cf_extract_dest(line);
        let src = cf_copy_src(line);
        if cf_table_has(table, src) {
            let val = cf_table_get(table, src);
            cf_table_set(table, dest, val)
        } else { table }
    } else { table };

// Process one function's MIR lines for constant folding
// Branch simplification: detect "branch %cond, then, else" with known cond
fn cf_is_branch(line: String) -> bool =
    let s = low_skip_ws(line, 0);
    find_pattern_at(line, "branch ", s) == s;

fn cf_branch_cond(line: String) -> String =
    let s = low_skip_ws(line, 0);
    let after = s + 7;
    let comma = find_char(line, after, 44);
    trim_end(line.slice(after, comma));

fn cf_branch_then(line: String) -> String =
    let s = low_skip_ws(line, 0);
    let after = s + 7;
    let comma1 = find_char(line, after, 44);
    let start = low_skip_ws(line, comma1 + 1);
    let comma2 = find_char(line, start, 44);
    trim_end(line.slice(start, comma2));

fn cf_branch_else(line: String) -> String =
    let s = low_skip_ws(line, 0);
    let after = s + 7;
    let comma1 = find_char(line, after, 44);
    let start1 = low_skip_ws(line, comma1 + 1);
    let comma2 = find_char(line, start1, 44);
    let start2 = low_skip_ws(line, comma2 + 1);
    trim_end(line.slice(start2, line.len()));

fn cf_can_simplify_branch(line: String, table: String) -> bool =
    if cf_is_branch(line) {
        let cond = cf_branch_cond(line);
        // Known condition value
        if cf_table_has(table, cond) { true }
        // Both targets are the same (branch %c, L, L → goto L)
        else { cf_branch_then(line) == cf_branch_else(line) }
    } else { false };

fn cf_simplified_branch(line: String, table: String) -> String =
    let then_label = cf_branch_then(line);
    let else_label = cf_branch_else(line);
    // Both targets the same — unconditional goto
    if then_label == else_label { "  goto " + then_label }
    else {
        let cond = cf_branch_cond(line);
        let val = cf_table_get(table, cond);
        if val != 0 { "  goto " + then_label }
        else { "  goto " + else_label }
    };

// Check if phi can be folded (both incoming values are the same known constant)
fn cf_can_fold_phi(line: String, table: String) -> bool =
    if ube_is_phi(line) {
        let eq_pos = find_pattern_at(line, " = ", 0);
        let rhs = line.slice(eq_pos + 3, line.len());
        let phi_args = rhs.slice(4, rhs.len());
        let b1_start = find_char(phi_args, 0, 91);
        let b1_end = find_char(phi_args, b1_start, 93);
        let bracket1 = phi_args.slice(b1_start, b1_end + 1);
        let val1_var = ube_phi_val(bracket1);
        let b2_start = find_char(phi_args, b1_end + 1, 91);
        let b2_end = find_char(phi_args, b2_start, 93);
        let bracket2 = phi_args.slice(b2_start, b2_end + 1);
        let val2_var = ube_phi_val(bracket2);
        if cf_table_has(table, val1_var) and cf_table_has(table, val2_var) {
            cf_table_get(table, val1_var) == cf_table_get(table, val2_var)
        } else { false }
    } else { false };

// Fold phi to constant when both incoming values are the same known constant
fn cf_folded_phi(line: String, table: String) -> String =
    let dest = cf_extract_dest(line);
    let eq_pos = find_pattern_at(line, " = ", 0);
    let rhs = line.slice(eq_pos + 3, line.len());
    let phi_args = rhs.slice(4, rhs.len());
    let b1_start = find_char(phi_args, 0, 91);
    let b1_end = find_char(phi_args, b1_start, 93);
    let bracket1 = phi_args.slice(b1_start, b1_end + 1);
    let val1_var = ube_phi_val(bracket1);
    let val = cf_table_get(table, val1_var);
    "  " + dest + " = const " + i2s(val);

// Check if line is a select instruction
fn cf_is_select(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false }
    else { starts_with(line.slice(eq_pos + 3, line.len()), "select ", 0) };

// Parse select parts: returns "cond,val1,val2"
fn cf_select_parts(line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    let rhs = line.slice(eq_pos + 3, line.len());
    let after_sel = rhs.slice(7, rhs.len());
    let c1 = find_char(after_sel, 0, 44);
    let cond = trim_end(after_sel.slice(0, c1));
    let p2 = low_skip_ws(after_sel, c1 + 1);
    let c2 = find_char(after_sel, p2, 44);
    let val1 = trim_end(after_sel.slice(p2, c2));
    let p3 = low_skip_ws(after_sel, c2 + 1);
    let val2 = trim_end(after_sel.slice(p3, after_sel.len()));
    cond + "," + val1 + "," + val2;

// Check if select can be simplified (same values or known condition)
fn cf_can_simplify_select(line: String, table: String) -> bool =
    if cf_is_select(line) {
        let parts = cf_select_parts(line);
        let c1 = find_char(parts, 0, 44);
        let cond = parts.slice(0, c1);
        let c2 = find_char(parts, c1 + 1, 44);
        let val1 = parts.slice(c1 + 1, c2);
        let val2 = parts.slice(c2 + 1, parts.len());
        if val1 == val2 { true }
        else { cf_table_has(table, cond) }
    } else { false };

// Simplify select to copy
fn cf_simplified_select(line: String, table: String) -> String =
    let dest = cf_extract_dest(line);
    let parts = cf_select_parts(line);
    let c1 = find_char(parts, 0, 44);
    let cond = parts.slice(0, c1);
    let c2 = find_char(parts, c1 + 1, 44);
    let val1 = parts.slice(c1 + 1, c2);
    let val2 = parts.slice(c2 + 1, parts.len());
    if val1 == val2 { "  " + dest + " = copy " + val1 }
    else if cf_table_get(table, cond) != 0 { "  " + dest + " = copy " + val1 }
    else { "  " + dest + " = copy " + val2 };

// Dispatch: try fold, simplify, branch, phi, select
fn cf_try_simplify(line: String, table: String) -> String =
    if cf_can_fold(line, table) { cf_folded(line, table) }
    else if cf_can_simplify(line, table) { cf_simplified(line, table) }
    else if cf_can_simplify_branch(line, table) { cf_simplified_branch(line, table) }
    else if cf_can_fold_phi(line, table) { cf_folded_phi(line, table) }
    else { cf_try_simplify_select(line, table) };

fn cf_try_simplify_select(line: String, table: String) -> String =
    if cf_can_simplify_select(line, table) { cf_simplified_select(line, table) }
    else { line };

fn cf_fold_fn_lines(mir: String, pos: i64, sb: i64, table: String) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let out_line = cf_try_simplify(line, table);
        let new_table = cf_update_table(out_line, table);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, out_line);
        if pipe_pos >= mir.len() { 0 }
        else { cf_fold_fn_lines(mir, pipe_pos + 1, sb, new_table) }
    };

// Process one function's MIR
fn cf_fold_function(fn_mir: String) -> String =
    let sb = sb_new();
    let w = cf_fold_fn_lines(fn_mir, 0, sb, "");
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// Process entire program MIR function by function
fn cf_fold_program(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let folded = cf_fold_function(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, folded);
        if fn_end + 2 >= mir.len() { 0 }
        else { cf_fold_program(mir, fn_end + 2, sb) }
    };

// Main entry: constant folding optimization
fn optimize_const_folding(mir: String) -> String =
    let sb = sb_new();
    let w = cf_fold_program(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// ============================================================================
// MIR Dead Code Elimination Pass
// Removes instructions whose results are never used downstream.
// ============================================================================

// Check if line has side effects (calls, stores — must keep even if result unused)
fn dce_has_side_effects(line: String) -> bool =
    find_pattern_at(line, "call ", 0) >= 0 or
    find_pattern_at(line, "store ", 0) >= 0 or
    find_pattern_at(line, "store_ptr ", 0) >= 0;

// Check if target variable appears in line's RHS (after " = ")
fn dce_var_in_rhs(line: String, target: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 {
        find_pattern_at(line, target, 0) >= 0
    } else {
        let rhs = line.slice(eq_pos + 3, line.len());
        find_pattern_at(rhs, target, 0) >= 0
    };

// Check if target variable is used in any line after pos in fn_mir
fn dce_var_used_after(fn_mir: String, target: String, pos: i64) -> bool =
    if pos >= fn_mir.len() { false } else {
        let pipe = find_char(fn_mir, pos, 124);
        let line = fn_mir.slice(pos, pipe);
        if dce_var_in_rhs(line, target) { true }
        else if pipe >= fn_mir.len() { false }
        else { dce_var_used_after(fn_mir, target, pipe + 1) }
    };

// Combined DCE + UBE: remove unreachable blocks and dead instructions in one pass
// reachable: 1 if in reachable block, 0 if in unreachable block
fn dce_ube_fn_lines(fn_mir: String, pos: i64, sb: i64, targets: String, reachable: i64) -> i64 =
    if pos >= fn_mir.len() { 0 } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let line = fn_mir.slice(pos, pipe);
        // Update reachability when we see a label
        let new_reachable = if ube_is_label(line) {
            let label = ube_label_name(line);
            if ube_is_entry(label) or ube_has_target(targets, label) { 1 } else { 0 }
        } else { reachable };
        // If unreachable, skip the line entirely
        let keep = if new_reachable == 0 { false }
        else {
            // Simplify phi nodes with dead incoming edges
            let processed = if ube_is_phi(line) { ube_simplify_phi(line, targets) } else { line };
            // Standard DCE check
            let dest = cf_extract_dest(processed);
            let dce_keep = if dest == "" { true }
                else if dce_has_side_effects(processed) { true }
                else if pipe >= fn_mir.len() { true }
                else { dce_var_used_after(fn_mir, dest, pipe + 1) };
            let len = sb_len(sb);
            let w1 = if dce_keep {
                let w2 = if len > 0 { sb_push(sb, "|") } else { 0 };
                sb_push(sb, processed)
            } else { 0 };
            dce_keep
        };
        if pipe >= fn_mir.len() { 0 }
        else { dce_ube_fn_lines(fn_mir, pipe + 1, sb, targets, new_reachable) }
    };

// DCE a single function (with integrated UBE to remove unreachable blocks)
fn dce_function(fn_mir: String) -> String =
    let targets = ube_collect_targets(fn_mir, 0, "");
    let sb = sb_new();
    let w = dce_ube_fn_lines(fn_mir, 0, sb, targets, 1);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// DCE across all functions in the program
fn dce_program(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let cleaned = dce_function(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, cleaned);
        if fn_end + 2 >= mir.len() { 0 }
        else { dce_program(mir, fn_end + 2, sb) }
    };

// Main entry: dead code elimination
fn optimize_dce(mir: String) -> String =
    let sb = sb_new();
    let w = dce_program(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// ============================================================================
// MIR Unreachable Block Elimination (UBE) Pass
// After branch simplification converts branch→goto, some labels become
// unreachable. This pass removes those blocks and simplifies phi nodes.
// ============================================================================

// Check if a MIR line is a label (trimmed line ends with ':')
fn ube_is_label(line: String) -> bool =
    let s = low_skip_ws(line, 0);
    if s >= line.len() { false } else {
        let trimmed = trim_end(line.slice(s, line.len()));
        if trimmed.len() == 0 { false }
        else {
            let last = trimmed.byte_at(trimmed.len() - 1);
            // Must end with ':' (58) and not contain '=' (not an instruction)
            last == 58 and find_pattern_at(line, " = ", 0) < 0
        }
    };

// Extract label name from a label line (everything before ':')
fn ube_label_name(line: String) -> String =
    let s = low_skip_ws(line, 0);
    let trimmed = trim_end(line.slice(s, line.len()));
    trimmed.slice(0, trimmed.len() - 1);

// Check if a label is an entry-like label (always reachable)
fn ube_is_entry(label: String) -> bool =
    label == "entry" or starts_with(label, "i32_entry", 0);

// Extract goto target from "  goto label"
fn ube_goto_target(line: String) -> String =
    let s = low_skip_ws(line, 0);
    if find_pattern_at(line, "goto ", s) == s {
        trim_end(line.slice(s + 5, line.len()))
    } else { "" };

// Collect all jump targets from function MIR (comma-separated label list)
fn ube_collect_targets(fn_mir: String, pos: i64, targets: String) -> String =
    if pos >= fn_mir.len() { targets } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let line = fn_mir.slice(pos, pipe);
        let new_targets = if find_pattern_at(line, "goto ", low_skip_ws(line, 0)) == low_skip_ws(line, 0) {
            let target = ube_goto_target(line);
            if target == "" { targets }
            else if targets == "" { target }
            else { targets + "," + target }
        } else if cf_is_branch(line) {
            let t1 = cf_branch_then(line);
            let t2 = cf_branch_else(line);
            let acc = if targets == "" { t1 } else { targets + "," + t1 };
            acc + "," + t2
        } else { targets };
        if pipe >= fn_mir.len() { new_targets }
        else { ube_collect_targets(fn_mir, pipe + 1, new_targets) }
    };

// Check if label is in comma-separated target list
fn ube_has_target(targets: String, label: String) -> bool =
    if targets == "" { false }
    else { ube_has_target_at(targets, label, 0) };

fn ube_has_target_at(targets: String, label: String, pos: i64) -> bool =
    if pos >= targets.len() { false } else {
        let comma = find_char(targets, pos, 44);
        let entry = targets.slice(pos, comma);
        if entry == label { true }
        else if comma >= targets.len() { false }
        else { ube_has_target_at(targets, label, comma + 1) }
    };

// Check if a MIR line is a phi node: %dest = phi [...]
fn ube_is_phi(line: String) -> bool =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { false } else {
        starts_with(line.slice(eq_pos + 3, line.len()), "phi ", 0)
    };

// Extract phi value from "[%val, label]" bracket expression
// Returns the %val part
fn ube_phi_val(bracket: String) -> String =
    // bracket = "[%val, label]"
    let start = 1;
    let comma = find_char(bracket, start, 44);
    trim_end(bracket.slice(start, comma));

// Extract phi label from "[%val, label]" bracket expression
fn ube_phi_label(bracket: String) -> String =
    let comma = find_char(bracket, 0, 44);
    let start = low_skip_ws(bracket, comma + 1);
    let end_bracket = find_char(bracket, start, 93);
    trim_end(bracket.slice(start, end_bracket));

// Simplify phi: if an incoming label was eliminated, remove that edge.
// If only one edge remains, convert to "copy %val".
// Input: phi line like "  %dest = phi [%v1, l1], [%v2, l2]"
// targets: comma-separated reachable labels
fn ube_simplify_phi(line: String, targets: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    let dest = line.slice(low_skip_ws(line, 0), eq_pos);
    let rhs = line.slice(eq_pos + 3, line.len());
    // rhs starts with "phi "
    let phi_args = rhs.slice(4, rhs.len());
    // Parse bracket pairs: find [ and ] delimiters
    let b1_start = find_char(phi_args, 0, 91);
    let b1_end = find_char(phi_args, b1_start, 93);
    let bracket1 = phi_args.slice(b1_start, b1_end + 1);
    let label1 = ube_phi_label(bracket1);
    let val1 = ube_phi_val(bracket1);
    let b2_start = find_char(phi_args, b1_end + 1, 91);
    let b2_end = find_char(phi_args, b2_start, 93);
    let bracket2 = phi_args.slice(b2_start, b2_end + 1);
    let label2 = ube_phi_label(bracket2);
    let val2 = ube_phi_val(bracket2);
    let l1_live = ube_is_entry(label1) or ube_has_target(targets, label1);
    let l2_live = ube_is_entry(label2) or ube_has_target(targets, label2);
    // Both values are the same → redundant phi, convert to copy
    if val1 == val2 { "  " + dest + " = copy " + val1 }
    else if l1_live and l2_live { line }
    else if l1_live { "  " + dest + " = copy " + val1 }
    else if l2_live { "  " + dest + " = copy " + val2 }
    else { line };

// ============================================================================
// MIR Copy Propagation Pass
// Replaces uses of %b with %a when %b = copy %a.
// ============================================================================

// Check if character is alphanumeric or underscore (valid in variable names)
fn cp_is_var_char(c: i64) -> bool =
    (c >= 48 and c <= 57) or (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or c == 95;

// Find end of variable name starting after '%'
fn cp_var_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if cp_is_var_char(s.byte_at(pos)) { cp_var_end(s, pos + 1) }
    else { pos };

// Copy table: "key1=val1;key2=val2" using ';' (59) and '=' (61)
fn cp_table_set(table: String, key: String, val: String) -> String =
    if table == "" { key + "=" + val } else { table + ";" + key + "=" + val };

fn cp_table_get_at(table: String, key: String, pos: i64) -> String =
    if pos >= table.len() { "" } else {
        let semi = find_char(table, pos, 59);
        let entry = table.slice(pos, semi);
        let eq = find_char(entry, 0, 61);
        if eq >= entry.len() { cp_table_get_at(table, key, semi + 1) } else {
            let entry_key = entry.slice(0, eq);
            if entry_key == key { entry.slice(eq + 1, entry.len()) }
            else { cp_table_get_at(table, key, semi + 1) }
        }
    };

fn cp_table_get(table: String, key: String) -> String = cp_table_get_at(table, key, 0);

// Replace %var patterns in text using copy table, starting from pos
fn cp_replace_vars(text: String, table: String, pos: i64) -> String =
    if pos >= text.len() { text }
    else if text.byte_at(pos) == 37 {
        let var_end = cp_var_end(text, pos + 1);
        let var_name = text.slice(pos, var_end);
        let replacement = cp_table_get(table, var_name);
        if replacement == "" { cp_replace_vars(text, table, var_end) }
        else {
            let new_text = text.slice(0, pos) + replacement + text.slice(var_end, text.len());
            cp_replace_vars(new_text, table, pos + replacement.len())
        }
    } else { cp_replace_vars(text, table, pos + 1) };

// Replace variables in line's RHS only (preserve LHS destination)
// Special handling for store: only replace value operand, not destination
fn cp_replace_in_line(line: String, table: String) -> String =
    if table == "" { line } else {
        let trimmed_start = low_skip_ws(line, 0);
        let eq_pos = find_pattern_at(line, " = ", 0);
        if eq_pos >= 0 {
            let lhs = line.slice(0, eq_pos + 3);
            let rhs = line.slice(eq_pos + 3, line.len());
            lhs + cp_replace_vars(rhs, table, 0)
        } else if find_pattern_at(line, "store ", trimmed_start) == trimmed_start {
            let comma_pos = find_char(line, 0, 44);
            if comma_pos >= line.len() { line } else {
                let before = line.slice(0, comma_pos + 2);
                let after = line.slice(comma_pos + 2, line.len());
                before + cp_replace_vars(after, table, 0)
            }
        } else {
            cp_replace_vars(line, table, 0)
        }
    };

// Process each line: track copies and replace in subsequent lines
fn cp_fn_lines(fn_mir: String, pos: i64, sb: i64, table: String) -> i64 =
    if pos >= fn_mir.len() { 0 } else {
        let pipe = find_char(fn_mir, pos, 124);
        let line = fn_mir.slice(pos, pipe);
        let new_line = cp_replace_in_line(line, table);
        let new_table = if cf_is_copy(new_line) {
            let dest = cf_extract_dest(new_line);
            let src = cf_copy_src(new_line);
            // Only propagate SSA-to-SSA copies (source is %_t temp, not user var alloca)
            if find_pattern_at(src, "%_t", 0) == 0 {
                let resolved = cp_table_get(table, src);
                let actual = if resolved == "" { src } else { resolved };
                cp_table_set(table, dest, actual)
            } else { table }
        } else { table };
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, new_line);
        if pipe >= fn_mir.len() { 0 }
        else { cp_fn_lines(fn_mir, pipe + 1, sb, new_table) }
    };

fn cp_function(fn_mir: String) -> String =
    let sb = sb_new();
    let w = cp_fn_lines(fn_mir, 0, sb, "");
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

fn cp_program(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let propagated = cp_function(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, propagated);
        if fn_end + 2 >= mir.len() { 0 }
        else { cp_program(mir, fn_end + 2, sb) }
    };

fn optimize_copy_prop(mir: String) -> String =
    let sb = sb_new();
    let w = cp_program(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// ============================================================================
// Redundant Phi Elimination (RPE)
// Replaces phi nodes where all incoming values resolve to the same constant.
// E.g., %_t77 = phi [%_t75, L1], [%_t76, L2] where %_t75 = const 0, %_t76 = const 0
//   → %_t77 = const 0
// ============================================================================

// Look up a variable's const definition in fn_mir.
// Returns the constant value string if `var = const VAL`, else "".
fn rpe_lookup_const(fn_mir: String, vname: String) -> String =
    rpe_lookup_const_depth(fn_mir, vname, 0);

// Look up a variable's const value, chasing through copy chains (up to depth 4)
fn rpe_lookup_const_depth(fn_mir: String, vname: String, depth: i64) -> String =
    if depth >= 4 { "" }
    else {
        let pattern = vname + " = const ";
        let pos = find_pattern_at(fn_mir, pattern, 0);
        if pos >= 0 {
            let val_start = pos + pattern.len();
            let pipe = find_char(fn_mir, val_start, 124);
            trim_end(fn_mir.slice(val_start, pipe))
        } else {
            // Check if it's a copy of another variable
            let cp_pattern = vname + " = copy ";
            let cp_pos = find_pattern_at(fn_mir, cp_pattern, 0);
            if cp_pos < 0 { "" }
            else {
                let src_start = cp_pos + cp_pattern.len();
                let pipe = find_char(fn_mir, src_start, 124);
                let src = trim_end(fn_mir.slice(src_start, pipe));
                // Chase the copy chain
                if find_pattern_at(src, "%_t", 0) == 0 {
                    rpe_lookup_const_depth(fn_mir, src, depth + 1)
                } else { "" }
            }
        }
    };

// Simplify a phi line if all incoming values are the same constant.
// Returns simplified line or original.
fn rpe_simplify_phi(fn_mir: String, line: String) -> String =
    let eq_pos = find_pattern_at(line, " = ", 0);
    if eq_pos < 0 { line }
    else {
        let dest = line.slice(low_skip_ws(line, 0), eq_pos);
        let rhs = line.slice(eq_pos + 3, line.len());
        let phi_args = rhs.slice(4, rhs.len());
        let b1_start = find_char(phi_args, 0, 91);
        let b1_end = find_char(phi_args, b1_start, 93);
        let bracket1 = phi_args.slice(b1_start, b1_end + 1);
        let val1 = ube_phi_val(bracket1);
        let b2_start = find_char(phi_args, b1_end + 1, 91);
        let b2_end = find_char(phi_args, b2_start, 93);
        let bracket2 = phi_args.slice(b2_start, b2_end + 1);
        let val2 = ube_phi_val(bracket2);
        // If values are already the same, simplify directly
        if val1 == val2 { "  " + dest + " = copy " + val1 }
        else {
            // Look up const definitions for both values
            let c1 = rpe_lookup_const(fn_mir, val1);
            let c2 = rpe_lookup_const(fn_mir, val2);
            if c1 != "" and c1 == c2 { "  " + dest + " = const " + c1 }
            else { line }
        }
    };

// Walk lines in a function, simplifying redundant phis
fn rpe_fn_lines(fn_mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= fn_mir.len() { 0 } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let line = fn_mir.slice(pos, pipe);
        let new_line = if ube_is_phi(line) { rpe_simplify_phi(fn_mir, line) } else { line };
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, new_line);
        if pipe >= fn_mir.len() { 0 }
        else { rpe_fn_lines(fn_mir, pipe + 1, sb) }
    };

// Process a single function
fn rpe_function(fn_mir: String) -> String =
    let sb = sb_new();
    let w = rpe_fn_lines(fn_mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// Process all functions
fn rpe_program(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let simplified = rpe_function(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, simplified);
        if fn_end + 2 >= mir.len() { 0 }
        else { rpe_program(mir, fn_end + 2, sb) }
    };

fn optimize_redundant_phi(mir: String) -> String =
    let sb = sb_new();
    let w = rpe_program(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// === If-to-Select Conversion ===
// Pattern: branch %c, L1, L2 | L1: | goto L3 | L2: | goto L3 | L3: | %d = phi [v1, L1], [v2, L2]
// Becomes: %d = select %c, v1, v2
// Only handles empty branches (both just goto same merge).

// Get the Nth pipe-separated line from fn_mir starting at pos
// Returns (line_start, line_end, next_pos) packed as: line_start * 1000000000 + line_end
fn ifs_line_at(fn_mir: String, pos: i64) -> String =
    if pos >= fn_mir.len() { "" } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        fn_mir.slice(pos, pipe)
    };

fn ifs_next_pos(fn_mir: String, pos: i64) -> i64 =
    if pos >= fn_mir.len() { fn_mir.len() } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        if pipe >= fn_mir.len() { fn_mir.len() } else { pipe + 1 }
    };

// Check if the 7-line pattern matches at the given branch position
// Returns "" if no match, or "cond,val1,val2,dest" if match
fn ifs_check_pattern(fn_mir: String, branch_line: String, branch_pos: i64) -> String =
    let cond = cf_branch_cond(branch_line);
    let l_then = cf_branch_then(branch_line);
    let l_else = cf_branch_else(branch_line);
    // Line 2: L_then:
    let p1 = ifs_next_pos(fn_mir, branch_pos);
    let line1 = ifs_line_at(fn_mir, p1);
    if ube_is_label(line1) and ube_label_name(line1) == l_then {
        // Line 3: goto L_merge
        let p2 = ifs_next_pos(fn_mir, p1);
        let line2 = ifs_line_at(fn_mir, p2);
        let goto1 = ube_goto_target(line2);
        if goto1 != "" {
            // Line 4: L_else:
            let p3 = ifs_next_pos(fn_mir, p2);
            let line3 = ifs_line_at(fn_mir, p3);
            if ube_is_label(line3) and ube_label_name(line3) == l_else {
                // Line 5: goto L_merge (same target)
                let p4 = ifs_next_pos(fn_mir, p3);
                let line4 = ifs_line_at(fn_mir, p4);
                let goto2 = ube_goto_target(line4);
                if goto2 == goto1 {
                    // Line 6: L_merge:
                    let p5 = ifs_next_pos(fn_mir, p4);
                    let line5 = ifs_line_at(fn_mir, p5);
                    if ube_is_label(line5) and ube_label_name(line5) == goto1 {
                        // Line 7: %dest = phi [val1, L_then], [val2, L_else]
                        let p6 = ifs_next_pos(fn_mir, p5);
                        let line6 = ifs_line_at(fn_mir, p6);
                        if ube_is_phi(line6) {
                            let dest = cf_extract_dest(line6);
                            // Parse phi brackets
                            let eq_pos = find_pattern_at(line6, " = ", 0);
                            let rhs = line6.slice(eq_pos + 3, line6.len());
                            let b1s = find_char(rhs, 0, 91);
                            let b1e = find_char(rhs, b1s, 93);
                            let bracket1 = rhs.slice(b1s, b1e + 1);
                            let b2s = find_char(rhs, b1e + 1, 91);
                            let b2e = find_char(rhs, b2s, 93);
                            let bracket2 = rhs.slice(b2s, b2e + 1);
                            let phi_val1 = ube_phi_val(bracket1);
                            let phi_label1 = ube_phi_label(bracket1);
                            let phi_val2 = ube_phi_val(bracket2);
                            let phi_label2 = ube_phi_label(bracket2);
                            // Phi edges must match then/else labels
                            if phi_label1 == l_then and phi_label2 == l_else {
                                // Match! val1 is "then" value, val2 is "else" value
                                cond + "," + phi_val1 + "," + phi_val2 + "," + dest
                            } else if phi_label1 == l_else and phi_label2 == l_then {
                                // Swapped order: val2 is "then" value, val1 is "else" value
                                cond + "," + phi_val2 + "," + phi_val1 + "," + dest
                            } else { "" }
                        } else { "" }
                    } else { "" }
                } else { "" }
            } else { "" }
        } else { "" }
    } else { "" };

// Check if a line is a pure (side-effect-free, non-trapping) instruction
// Pure: non-trapping arithmetic (+,-,*), comparison, shift, bitwise, neg, not, copy, const
// NOT pure: div, mod (trap on zero), call, store, load, alloca, branch, goto, return, label
fn ifs_is_pure(line: String) -> bool =
    let s = low_skip_ws(line, 0);
    if s >= line.len() { false }
    else if line.byte_at(s) != 37 { false }
    else {
        let eq_pos = find_pattern_at(line, " = ", s);
        if eq_pos < 0 { false } else {
            let rhs = line.slice(eq_pos + 3, line.len());
            // const, copy, neg, not, select
            if starts_with(rhs, "const ", 0) { true }
            else if starts_with(rhs, "copy ", 0) { true }
            else if starts_with(rhs, "neg ", 0) { true }
            else if starts_with(rhs, "not ", 0) { true }
            else if starts_with(rhs, "select ", 0) { true }
            // Non-trapping arithmetic/cmp/shift/bitwise (div/mod excluded — they trap on zero)
            else { cf_is_non_trapping_arith(line) or cf_is_cmp(line) or cf_is_shift(line) or cf_is_bitwise(line) }
        }
    };

// Extended pattern: then has 1 pure instruction, else is empty (8 lines)
// branch %c, L1, L2 | L1: | <instr> | goto L3 | L2: | goto L3 | L3: | phi
// Returns: "extra~cond~val1~val2~dest" or ""
fn ifs_check_then_one(fn_mir: String, branch_line: String, branch_pos: i64) -> String =
    let cond = cf_branch_cond(branch_line);
    let l_then = cf_branch_then(branch_line);
    let l_else = cf_branch_else(branch_line);
    let p1 = ifs_next_pos(fn_mir, branch_pos);
    let line1 = ifs_line_at(fn_mir, p1);
    if ube_is_label(line1) and ube_label_name(line1) == l_then {
        let p2 = ifs_next_pos(fn_mir, p1);
        let instr = ifs_line_at(fn_mir, p2);
        if ifs_is_pure(instr) {
            let p3 = ifs_next_pos(fn_mir, p2);
            let goto1_line = ifs_line_at(fn_mir, p3);
            let goto1 = ube_goto_target(goto1_line);
            if goto1 != "" {
                ifs_check_then_one_rest(fn_mir, p3, instr, cond, l_then, l_else, goto1)
            } else { "" }
        } else { "" }
    } else { "" };

// Continue checking: L2: | goto L3 | L3: | phi
fn ifs_check_then_one_rest(fn_mir: String, p3: i64, instr: String, cond: String, l_then: String, l_else: String, goto1: String) -> String =
    let p4 = ifs_next_pos(fn_mir, p3);
    let line4 = ifs_line_at(fn_mir, p4);
    if ube_is_label(line4) and ube_label_name(line4) == l_else {
        let p5 = ifs_next_pos(fn_mir, p4);
        let goto2_line = ifs_line_at(fn_mir, p5);
        let goto2 = ube_goto_target(goto2_line);
        if goto2 == goto1 {
            let p6 = ifs_next_pos(fn_mir, p5);
            let line6 = ifs_line_at(fn_mir, p6);
            if ube_is_label(line6) and ube_label_name(line6) == goto1 {
                let p7 = ifs_next_pos(fn_mir, p6);
                let phi_line = ifs_line_at(fn_mir, p7);
                if ube_is_phi(phi_line) {
                    ifs_match_phi_select(phi_line, instr, cond, l_then, l_else)
                } else { "" }
            } else { "" }
        } else { "" }
    } else { "" };

// Extended pattern: then is empty, else has 1 pure instruction (8 lines)
// branch %c, L1, L2 | L1: | goto L3 | L2: | <instr> | goto L3 | L3: | phi
fn ifs_check_else_one(fn_mir: String, branch_line: String, branch_pos: i64) -> String =
    let cond = cf_branch_cond(branch_line);
    let l_then = cf_branch_then(branch_line);
    let l_else = cf_branch_else(branch_line);
    let p1 = ifs_next_pos(fn_mir, branch_pos);
    let line1 = ifs_line_at(fn_mir, p1);
    if ube_is_label(line1) and ube_label_name(line1) == l_then {
        let p2 = ifs_next_pos(fn_mir, p1);
        let goto1_line = ifs_line_at(fn_mir, p2);
        let goto1 = ube_goto_target(goto1_line);
        if goto1 != "" {
            let p3 = ifs_next_pos(fn_mir, p2);
            let line3 = ifs_line_at(fn_mir, p3);
            if ube_is_label(line3) and ube_label_name(line3) == l_else {
                ifs_check_else_one_rest(fn_mir, p3, cond, l_then, l_else, goto1)
            } else { "" }
        } else { "" }
    } else { "" };

// Continue: <instr> | goto L3 | L3: | phi
fn ifs_check_else_one_rest(fn_mir: String, p3: i64, cond: String, l_then: String, l_else: String, goto1: String) -> String =
    let p4 = ifs_next_pos(fn_mir, p3);
    let instr = ifs_line_at(fn_mir, p4);
    if ifs_is_pure(instr) {
        let p5 = ifs_next_pos(fn_mir, p4);
        let goto2_line = ifs_line_at(fn_mir, p5);
        let goto2 = ube_goto_target(goto2_line);
        if goto2 == goto1 {
            let p6 = ifs_next_pos(fn_mir, p5);
            let line6 = ifs_line_at(fn_mir, p6);
            if ube_is_label(line6) and ube_label_name(line6) == goto1 {
                let p7 = ifs_next_pos(fn_mir, p6);
                let phi_line = ifs_line_at(fn_mir, p7);
                if ube_is_phi(phi_line) {
                    ifs_match_phi_select(phi_line, instr, cond, l_then, l_else)
                } else { "" }
            } else { "" }
        } else { "" }
    } else { "" };

// Common: match phi edges to then/else, return "extra~cond~val1~val2~dest"
fn ifs_match_phi_select(phi_line: String, instr: String, cond: String, l_then: String, l_else: String) -> String =
    let dest = cf_extract_dest(phi_line);
    let eq_pos = find_pattern_at(phi_line, " = ", 0);
    let rhs = phi_line.slice(eq_pos + 3, phi_line.len());
    let b1s = find_char(rhs, 0, 91);
    let b1e = find_char(rhs, b1s, 93);
    let bracket1 = rhs.slice(b1s, b1e + 1);
    let b2s = find_char(rhs, b1e + 1, 91);
    let b2e = find_char(rhs, b2s, 93);
    let bracket2 = rhs.slice(b2s, b2e + 1);
    let pv1 = ube_phi_val(bracket1);
    let pl1 = ube_phi_label(bracket1);
    let pv2 = ube_phi_val(bracket2);
    let pl2 = ube_phi_label(bracket2);
    if pl1 == l_then and pl2 == l_else { instr + "~" + cond + "~" + pv1 + "~" + pv2 + "~" + dest }
    else if pl1 == l_else and pl2 == l_then { instr + "~" + cond + "~" + pv2 + "~" + pv1 + "~" + dest }
    else { "" };

// Process function MIR: replace branch+empty_blocks+phi with select
fn ifs_fn_lines(fn_mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= fn_mir.len() { 0 } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let line = fn_mir.slice(pos, pipe);
        if cf_is_branch(line) {
            let match_result = ifs_check_pattern(fn_mir, line, pos);
            if match_result != "" {
                // Parse match: cond,val1,val2,dest
                let c1 = find_char(match_result, 0, 44);
                let cond = match_result.slice(0, c1);
                let c2 = find_char(match_result, c1 + 1, 44);
                let val1 = match_result.slice(c1 + 1, c2);
                let c3 = find_char(match_result, c2 + 1, 44);
                let val2 = match_result.slice(c2 + 1, c3);
                let dest = match_result.slice(c3 + 1, match_result.len());
                // Emit select instruction
                let select_line = "  " + dest + " = select " + cond + ", " + val1 + ", " + val2;
                let len = sb_len(sb);
                let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
                let w2 = sb_push(sb, select_line);
                // Skip 6 lines (branch already consumed, skip then_label, goto, else_label, goto, merge_label, phi)
                let p1 = ifs_next_pos(fn_mir, pos);
                let p2 = ifs_next_pos(fn_mir, p1);
                let p3 = ifs_next_pos(fn_mir, p2);
                let p4 = ifs_next_pos(fn_mir, p3);
                let p5 = ifs_next_pos(fn_mir, p4);
                let p6 = ifs_next_pos(fn_mir, p5);
                // Keep merge label alive only if referenced in downstream phis
                let ml = ifs_line_at(fn_mir, p5);
                let mn = ube_label_name(ml);
                let w3 = if gcs_label_in_phi(fn_mir, mn) {
                    let wa = sb_push(sb, "|");
                    let wb = sb_push(sb, "  goto " + mn);
                    let wc = sb_push(sb, "|");
                    sb_push(sb, mn + ":")
                } else { 0 };
                // Continue after the phi line
                let p7 = ifs_next_pos(fn_mir, p6);
                if p7 >= fn_mir.len() { 0 }
                else { ifs_fn_lines(fn_mir, p7, sb) }
            } else {
                // Try extended patterns (one side has 1 pure instruction)
                ifs_try_extended(fn_mir, line, pos, pipe, sb)
            }
        } else {
            let len = sb_len(sb);
            let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
            let w2 = sb_push(sb, line);
            if pipe >= fn_mir.len() { 0 }
            else { ifs_fn_lines(fn_mir, pipe + 1, sb) }
        }
    };

// Try extended patterns: then-one-instr, else-one-instr, or both-sides
fn ifs_try_extended(fn_mir: String, line: String, pos: i64, pipe: i64, sb: i64) -> i64 =
    let ext_a = ifs_check_then_one(fn_mir, line, pos);
    if ext_a != "" {
        ifs_emit_extended(fn_mir, pos, ext_a, sb)
    } else {
        let ext_b = ifs_check_else_one(fn_mir, line, pos);
        if ext_b != "" {
            ifs_emit_extended(fn_mir, pos, ext_b, sb)
        } else {
            ifs_try_both_or_fallback(fn_mir, line, pos, pipe, sb)
        }
    };

// Continue: try both-sides pattern or fall back to emitting branch
fn ifs_try_both_or_fallback(fn_mir: String, line: String, pos: i64, pipe: i64, sb: i64) -> i64 =
    let ext_c = ifs_check_both(fn_mir, line, pos);
    if ext_c != "" {
        ifs_emit_both(fn_mir, pos, ext_c, sb)
    } else {
        ifs_try_two_or_fallback(fn_mir, line, pos, pipe, sb)
    };

// Try 2-instruction patterns (then-two, else-two, flex-copy-else) or fall back
fn ifs_try_two_or_fallback(fn_mir: String, line: String, pos: i64, pipe: i64, sb: i64) -> i64 =
    let ext_d = ifs_check_then_two(fn_mir, line, pos);
    if ext_d != "" {
        ifs_emit_both(fn_mir, pos, ext_d, sb)
    } else {
        let ext_e = ifs_check_else_two(fn_mir, line, pos);
        if ext_e != "" {
            ifs_emit_both(fn_mir, pos, ext_e, sb)
        } else {
            // Try generalized flex pattern: both sides copies+pure (up to 3 pure each)
            let flex = ifs_check_flex_both_sides(fn_mir, line, pos, sb);
            if flex >= 0 { flex }
            else { ifs_emit_branch_fallback(fn_mir, line, pipe, sb) }
        }
    };

// Fallback: emit branch as-is and continue
fn ifs_emit_branch_fallback(fn_mir: String, line: String, pipe: i64, sb: i64) -> i64 =
    let len = sb_len(sb);
    let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
    let w2 = sb_push(sb, line);
    if pipe >= fn_mir.len() { 0 }
    else { ifs_fn_lines(fn_mir, pipe + 1, sb) };

// Both-sides pattern: 9 lines
// branch %c, L1, L2 | L1: | <instr1> | goto L3 | L2: | <instr2> | goto L3 | L3: | phi
// Returns: "instr1~instr2~cond~val1~val2~dest" or ""
fn ifs_check_both(fn_mir: String, branch_line: String, branch_pos: i64) -> String =
    let cond = cf_branch_cond(branch_line);
    let l_then = cf_branch_then(branch_line);
    let l_else = cf_branch_else(branch_line);
    let p1 = ifs_next_pos(fn_mir, branch_pos);
    let line1 = ifs_line_at(fn_mir, p1);
    if ube_is_label(line1) and ube_label_name(line1) == l_then {
        let p2 = ifs_next_pos(fn_mir, p1);
        let instr1 = ifs_line_at(fn_mir, p2);
        if ifs_is_pure(instr1) {
            let p3 = ifs_next_pos(fn_mir, p2);
            let goto1_line = ifs_line_at(fn_mir, p3);
            let goto1 = ube_goto_target(goto1_line);
            if goto1 != "" {
                ifs_check_both_rest(fn_mir, p3, instr1, cond, l_then, l_else, goto1)
            } else { "" }
        } else { "" }
    } else { "" };

// Continue: L2: | <instr2> | goto L3 | L3: | phi
fn ifs_check_both_rest(fn_mir: String, p3: i64, instr1: String, cond: String, l_then: String, l_else: String, goto1: String) -> String =
    let p4 = ifs_next_pos(fn_mir, p3);
    let line4 = ifs_line_at(fn_mir, p4);
    if ube_is_label(line4) and ube_label_name(line4) == l_else {
        let p5 = ifs_next_pos(fn_mir, p4);
        let instr2 = ifs_line_at(fn_mir, p5);
        if ifs_is_pure(instr2) {
            let p6 = ifs_next_pos(fn_mir, p5);
            let goto2_line = ifs_line_at(fn_mir, p6);
            let goto2 = ube_goto_target(goto2_line);
            if goto2 == goto1 {
                ifs_check_both_rest2(fn_mir, p6, instr1, instr2, cond, l_then, l_else, goto1)
            } else { "" }
        } else { "" }
    } else { "" };

// Continue: L3: | phi
fn ifs_check_both_rest2(fn_mir: String, p6: i64, instr1: String, instr2: String, cond: String, l_then: String, l_else: String, goto1: String) -> String =
    let p7 = ifs_next_pos(fn_mir, p6);
    let line7 = ifs_line_at(fn_mir, p7);
    if ube_is_label(line7) and ube_label_name(line7) == goto1 {
        let p8 = ifs_next_pos(fn_mir, p7);
        let phi_line = ifs_line_at(fn_mir, p8);
        if ube_is_phi(phi_line) {
            ifs_match_phi_both(phi_line, instr1, instr2, cond, l_then, l_else)
        } else { "" }
    } else { "" };

// Match phi for both-sides pattern, returns "instr1~instr2~cond~val1~val2~dest"
fn ifs_match_phi_both(phi_line: String, instr1: String, instr2: String, cond: String, l_then: String, l_else: String) -> String =
    let dest = cf_extract_dest(phi_line);
    let eq_pos = find_pattern_at(phi_line, " = ", 0);
    let rhs = phi_line.slice(eq_pos + 3, phi_line.len());
    let b1s = find_char(rhs, 0, 91);
    let b1e = find_char(rhs, b1s, 93);
    let bracket1 = rhs.slice(b1s, b1e + 1);
    let b2s = find_char(rhs, b1e + 1, 91);
    let b2e = find_char(rhs, b2s, 93);
    let bracket2 = rhs.slice(b2s, b2e + 1);
    let pv1 = ube_phi_val(bracket1);
    let pl1 = ube_phi_label(bracket1);
    let pv2 = ube_phi_val(bracket2);
    let pl2 = ube_phi_label(bracket2);
    if pl1 == l_then and pl2 == l_else { instr1 + "~" + instr2 + "~" + cond + "~" + pv1 + "~" + pv2 + "~" + dest }
    else if pl1 == l_else and pl2 == l_then { instr1 + "~" + instr2 + "~" + cond + "~" + pv2 + "~" + pv1 + "~" + dest }
    else { "" };

// 2-instruction then pattern (9 lines):
// branch %c, L1, L2 | L1: | <i1> | <i2> | goto L3 | L2: | goto L3 | L3: | phi
fn ifs_check_then_two(fn_mir: String, branch_line: String, branch_pos: i64) -> String =
    let cond = cf_branch_cond(branch_line);
    let l_then = cf_branch_then(branch_line);
    let l_else = cf_branch_else(branch_line);
    let p1 = ifs_next_pos(fn_mir, branch_pos);
    let line1 = ifs_line_at(fn_mir, p1);
    if ube_is_label(line1) and ube_label_name(line1) == l_then {
        let p2 = ifs_next_pos(fn_mir, p1);
        let instr1 = ifs_line_at(fn_mir, p2);
        if ifs_is_pure(instr1) {
            let p3 = ifs_next_pos(fn_mir, p2);
            let instr2 = ifs_line_at(fn_mir, p3);
            if ifs_is_pure(instr2) {
                ifs_check_then_two_rest(fn_mir, p3, instr1, instr2, cond, l_then, l_else)
            } else { "" }
        } else { "" }
    } else { "" };

// Continue: goto L3 | L2: | goto L3 | L3: | phi
fn ifs_check_then_two_rest(fn_mir: String, p3: i64, instr1: String, instr2: String, cond: String, l_then: String, l_else: String) -> String =
    let p4 = ifs_next_pos(fn_mir, p3);
    let goto1_line = ifs_line_at(fn_mir, p4);
    let goto1 = ube_goto_target(goto1_line);
    if goto1 != "" {
        let p5 = ifs_next_pos(fn_mir, p4);
        let line5 = ifs_line_at(fn_mir, p5);
        if ube_is_label(line5) and ube_label_name(line5) == l_else {
            let p6 = ifs_next_pos(fn_mir, p5);
            let goto2_line = ifs_line_at(fn_mir, p6);
            let goto2 = ube_goto_target(goto2_line);
            if goto2 == goto1 {
                ifs_check_both_rest2(fn_mir, p6, instr1, instr2, cond, l_then, l_else, goto1)
            } else { "" }
        } else { "" }
    } else { "" };

// 2-instruction else pattern (9 lines):
// branch %c, L1, L2 | L1: | goto L3 | L2: | <i1> | <i2> | goto L3 | L3: | phi
fn ifs_check_else_two(fn_mir: String, branch_line: String, branch_pos: i64) -> String =
    let cond = cf_branch_cond(branch_line);
    let l_then = cf_branch_then(branch_line);
    let l_else = cf_branch_else(branch_line);
    let p1 = ifs_next_pos(fn_mir, branch_pos);
    let line1 = ifs_line_at(fn_mir, p1);
    if ube_is_label(line1) and ube_label_name(line1) == l_then {
        let p2 = ifs_next_pos(fn_mir, p1);
        let goto1_line = ifs_line_at(fn_mir, p2);
        let goto1 = ube_goto_target(goto1_line);
        if goto1 != "" {
            let p3 = ifs_next_pos(fn_mir, p2);
            let line3 = ifs_line_at(fn_mir, p3);
            if ube_is_label(line3) and ube_label_name(line3) == l_else {
                ifs_check_else_two_rest(fn_mir, p3, cond, l_then, l_else, goto1)
            } else { "" }
        } else { "" }
    } else { "" };

// Continue: <i1> | <i2> | goto L3 | L3: | phi
fn ifs_check_else_two_rest(fn_mir: String, p3: i64, cond: String, l_then: String, l_else: String, goto1: String) -> String =
    let p4 = ifs_next_pos(fn_mir, p3);
    let instr1 = ifs_line_at(fn_mir, p4);
    if ifs_is_pure(instr1) {
        let p5 = ifs_next_pos(fn_mir, p4);
        let instr2 = ifs_line_at(fn_mir, p5);
        if ifs_is_pure(instr2) {
            let p6 = ifs_next_pos(fn_mir, p5);
            let goto2_line = ifs_line_at(fn_mir, p6);
            let goto2 = ube_goto_target(goto2_line);
            if goto2 == goto1 {
                ifs_check_both_rest2(fn_mir, p6, instr1, instr2, cond, l_then, l_else, goto1)
            } else { "" }
        } else { "" }
    } else { "" };

// Generalized flex pattern: both sides have copies + pure instructions (variable lines)
// branch %c, L1, L2 | L1: | <then: copies+pure> | goto L3 | L2: | <else: copies+pure> | goto L3 | L3: | phi
// Handles parameter copies in both blocks by scanning flexibly and emitting select
fn ifs_check_flex_both_sides(fn_mir: String, branch_line: String, branch_pos: i64, sb: i64) -> i64 =
    let cond = cf_branch_cond(branch_line);
    let l_then = cf_branch_then(branch_line);
    let l_else = cf_branch_else(branch_line);
    // Check then label
    let p1 = ifs_next_pos(fn_mir, branch_pos);
    let line1 = ifs_line_at(fn_mir, p1);
    if ube_is_label(line1) and ube_label_name(line1) == l_then {
        // Scan then block (any goto target accepted)
        let then_sb = sb_new();
        let then_goto_pos = ifs_flex_scan_block(fn_mir, p1, then_sb, 0, 3, "");
        if then_goto_pos > 0 {
            let then_goto_line = ifs_line_at(fn_mir, then_goto_pos);
            let goto_target = ube_goto_target(then_goto_line);
            // Check else label
            let p_else = ifs_next_pos(fn_mir, then_goto_pos);
            let line_else = ifs_line_at(fn_mir, p_else);
            if ube_is_label(line_else) and ube_label_name(line_else) == l_else {
                // Scan else block (must match goto_target)
                let else_sb = sb_new();
                let else_goto_pos = ifs_flex_scan_block(fn_mir, p_else, else_sb, 0, 3, goto_target);
                if else_goto_pos > 0 {
                    // Check merge label + phi
                    let p_merge = ifs_next_pos(fn_mir, else_goto_pos);
                    let merge_line = ifs_line_at(fn_mir, p_merge);
                    if ube_is_label(merge_line) and ube_label_name(merge_line) == goto_target {
                        let p_phi = ifs_next_pos(fn_mir, p_merge);
                        let phi_line = ifs_line_at(fn_mir, p_phi);
                        if ube_is_phi(phi_line) {
                            ifs_flex_emit_select(phi_line, cond, l_then, l_else, then_sb, else_sb, fn_mir, p_phi, sb, goto_target)
                        } else { let _tf = sb_free(then_sb); let _ef = sb_free(else_sb); 0 - 1 }
                    } else { let _tf = sb_free(then_sb); let _ef = sb_free(else_sb); 0 - 1 }
                } else { let _tf = sb_free(then_sb); let _ef = sb_free(else_sb); 0 - 1 }
            } else { let _tf = sb_free(then_sb); 0 - 1 }
        } else { let _tf = sb_free(then_sb); 0 - 1 }
    } else { 0 - 1 };

// Helper: parse phi and emit select for generalized flex patterns
fn ifs_flex_emit_select(phi_line: String, cond: String, l_then: String, l_else: String, then_sb: i64, else_sb: i64, fn_mir: String, p_phi: i64, sb: i64, merge_name: String) -> i64 =
    let dest = cf_extract_dest(phi_line);
    let eq_pos = find_pattern_at(phi_line, " = ", 0);
    let rhs = phi_line.slice(eq_pos + 3, phi_line.len());
    let b1s = find_char(rhs, 0, 91);
    let b1e = find_char(rhs, b1s, 93);
    let bracket1 = rhs.slice(b1s, b1e + 1);
    let b2s = find_char(rhs, b1e + 1, 91);
    let b2e = find_char(rhs, b2s, 93);
    let bracket2 = rhs.slice(b2s, b2e + 1);
    let pv1 = ube_phi_val(bracket1);
    let pl1 = ube_phi_label(bracket1);
    let pv2 = ube_phi_val(bracket2);
    let pl2 = ube_phi_label(bracket2);
    let val_then = if pl1 == l_then { pv1 } else if pl2 == l_then { pv2 } else { "" };
    let val_else = if pl1 == l_else { pv1 } else if pl2 == l_else { pv2 } else { "" };
    if val_then != "" and val_else != "" {
        // Emit: then_content | else_content | select
        let then_content = sb_build(then_sb);
        let _tf = sb_free(then_sb);
        let else_content = sb_build(else_sb);
        let _ef = sb_free(else_sb);
        let w1 = if then_content.len() > 0 {
            let l1 = sb_len(sb);
            let ww1 = if l1 > 0 { sb_push(sb, "|") } else { 0 };
            sb_push(sb, then_content)
        } else { 0 };
        let w2 = if else_content.len() > 0 {
            let l2 = sb_len(sb);
            let ww2 = if l2 > 0 { sb_push(sb, "|") } else { 0 };
            sb_push(sb, else_content)
        } else { 0 };
        let select_line = "  " + dest + " = select " + cond + ", " + val_then + ", " + val_else;
        let l3 = sb_len(sb);
        let w3 = if l3 > 0 { sb_push(sb, "|") } else { 0 };
        let w4 = sb_push(sb, select_line);
        // Keep merge label alive only if referenced in downstream phis
        let wf1 = if gcs_label_in_phi(fn_mir, merge_name) {
            let wfa = sb_push(sb, "|");
            let wfb = sb_push(sb, "  goto " + merge_name);
            let wfc = sb_push(sb, "|");
            sb_push(sb, merge_name + ":")
        } else { 0 };
        // Continue after phi
        let p_after = ifs_next_pos(fn_mir, p_phi);
        if p_after >= fn_mir.len() { 0 }
        else { ifs_fn_lines(fn_mir, p_after, sb) }
    } else { let _tf = sb_free(then_sb); let _ef = sb_free(else_sb); 0 - 1 };

// Scan block lines: collect copies + up to max_pure non-copy pure instructions, stop at goto
// Helper: check goto target match and pure count limit
fn ifs_flex_check_goto(n_pure: i64, max_pure: i64, goto_target: String, goto_tgt: String, next_p: i64) -> i64 =
    if n_pure > max_pure { 0 }
    else if goto_target == "" { next_p }
    else if goto_tgt == goto_target { next_p }
    else { 0 };

// If goto_target is "", any goto is accepted; otherwise must match
// Returns position of goto line on success, 0 on failure
fn ifs_flex_scan_block(fn_mir: String, pos_after_label: i64, block_sb: i64, n_pure: i64, max_pure: i64, goto_target: String) -> i64 =
    let next_p = ifs_next_pos(fn_mir, pos_after_label);
    if next_p >= fn_mir.len() { 0 } else {
        let line = ifs_line_at(fn_mir, next_p);
        let goto_tgt = ube_goto_target(line);
        if goto_tgt != "" {
            ifs_flex_check_goto(n_pure, max_pure, goto_target, goto_tgt, next_p)
        } else if cf_is_copy(line) {
            // Copy: add to block_sb, don't count as effective instruction
            let blen = sb_len(block_sb);
            let w1 = if blen > 0 { sb_push(block_sb, "|") } else { 0 };
            let w2 = sb_push(block_sb, line);
            ifs_flex_scan_block(fn_mir, next_p, block_sb, n_pure, max_pure, goto_target)
        } else if ifs_is_pure(line) and n_pure < max_pure {
            // Non-copy pure instruction: add and count
            let blen = sb_len(block_sb);
            let w1 = if blen > 0 { sb_push(block_sb, "|") } else { 0 };
            let w2 = sb_push(block_sb, line);
            ifs_flex_scan_block(fn_mir, next_p, block_sb, n_pure + 1, max_pure, goto_target)
        } else { 0 }
    };

// Emit both-sides select pattern (instr1 + instr2 + select) and skip 9 lines
fn ifs_emit_both(fn_mir: String, pos: i64, result: String, sb: i64) -> i64 =
    // Parse: instr1~instr2~cond~val1~val2~dest
    let t1 = find_char(result, 0, 126);
    let instr1 = result.slice(0, t1);
    let t2 = find_char(result, t1 + 1, 126);
    let instr2 = result.slice(t1 + 1, t2);
    let t3 = find_char(result, t2 + 1, 126);
    let cond = result.slice(t2 + 1, t3);
    let t4 = find_char(result, t3 + 1, 126);
    let val1 = result.slice(t3 + 1, t4);
    let t5 = find_char(result, t4 + 1, 126);
    let val2 = result.slice(t4 + 1, t5);
    let dest = result.slice(t5 + 1, result.len());
    // Emit instr1 + instr2 + select
    let len = sb_len(sb);
    let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
    let w2 = sb_push(sb, instr1);
    let w3 = sb_push(sb, "|");
    let w4 = sb_push(sb, instr2);
    let select_line = "  " + dest + " = select " + cond + ", " + val1 + ", " + val2;
    let w5 = sb_push(sb, "|");
    let w6 = sb_push(sb, select_line);
    // Skip 9 lines and continue
    ifs_skip_both_continue(fn_mir, pos, sb);

// Skip 8 lines after branch (9 total) and continue processing
fn ifs_skip_both_continue(fn_mir: String, pos: i64, sb: i64) -> i64 =
    let p1 = ifs_next_pos(fn_mir, pos);
    let p2 = ifs_next_pos(fn_mir, p1);
    let p3 = ifs_next_pos(fn_mir, p2);
    let p4 = ifs_next_pos(fn_mir, p3);
    let p5 = ifs_next_pos(fn_mir, p4);
    let p6 = ifs_next_pos(fn_mir, p5);
    let p7 = ifs_next_pos(fn_mir, p6);
    let p8 = ifs_next_pos(fn_mir, p7);
    // Keep merge label (p7) alive only if referenced in downstream phis
    let ml_b = ifs_line_at(fn_mir, p7);
    let mn_b = ube_label_name(ml_b);
    let wb1 = if gcs_label_in_phi(fn_mir, mn_b) {
        let wba = sb_push(sb, "|");
        let wbb = sb_push(sb, "  goto " + mn_b);
        let wbc = sb_push(sb, "|");
        sb_push(sb, mn_b + ":")
    } else { 0 };
    let p9 = ifs_next_pos(fn_mir, p8);
    if p9 >= fn_mir.len() { 0 }
    else { ifs_fn_lines(fn_mir, p9, sb) };

// Emit extended select pattern (extra_instr + select) and skip 8 lines
fn ifs_emit_extended(fn_mir: String, pos: i64, result: String, sb: i64) -> i64 =
    // Parse result: extra~cond~val1~val2~dest
    let t1 = find_char(result, 0, 126);
    let extra = result.slice(0, t1);
    let t2 = find_char(result, t1 + 1, 126);
    let cond = result.slice(t1 + 1, t2);
    let t3 = find_char(result, t2 + 1, 126);
    let val1 = result.slice(t2 + 1, t3);
    let t4 = find_char(result, t3 + 1, 126);
    let val2 = result.slice(t3 + 1, t4);
    let dest = result.slice(t4 + 1, result.len());
    // Emit extra instruction
    let len = sb_len(sb);
    let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
    let w2 = sb_push(sb, extra);
    // Emit select
    let select_line = "  " + dest + " = select " + cond + ", " + val1 + ", " + val2;
    let w3 = sb_push(sb, "|");
    let w4 = sb_push(sb, select_line);
    // Skip 7 more lines after branch (8 total: branch + label + instr_or_goto + goto + label + goto + label + phi)
    let p1 = ifs_next_pos(fn_mir, pos);
    let p2 = ifs_next_pos(fn_mir, p1);
    let p3 = ifs_next_pos(fn_mir, p2);
    let p4 = ifs_next_pos(fn_mir, p3);
    let p5 = ifs_next_pos(fn_mir, p4);
    let p6 = ifs_next_pos(fn_mir, p5);
    let p7 = ifs_next_pos(fn_mir, p6);
    // Keep merge label (p6) alive only if referenced in downstream phis
    let ml_e = ifs_line_at(fn_mir, p6);
    let mn_e = ube_label_name(ml_e);
    let w5 = if gcs_label_in_phi(fn_mir, mn_e) {
        let wea = sb_push(sb, "|");
        let web = sb_push(sb, "  goto " + mn_e);
        let wec = sb_push(sb, "|");
        sb_push(sb, mn_e + ":")
    } else { 0 };
    let p8 = ifs_next_pos(fn_mir, p7);
    if p8 >= fn_mir.len() { 0 }
    else { ifs_fn_lines(fn_mir, p8, sb) };

fn ifs_function(fn_mir: String) -> String =
    let sb = sb_new();
    let w = ifs_fn_lines(fn_mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

fn ifs_program(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let converted = ifs_function(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, converted);
        if fn_end + 2 >= mir.len() { 0 }
        else { ifs_program(mir, fn_end + 2, sb) }
    };

fn optimize_if_select(mir: String) -> String =
    let sb = sb_new();
    let w = ifs_program(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// === Goto Chain Simplification (GCS) ===
// Redirect goto/branch targets through empty intermediate blocks
// E.g., goto L1 where L1: goto L2 → goto L2

// Check if a label is referenced as a phi predecessor anywhere in the function
fn gcs_label_in_phi(fn_mir: String, label: String) -> bool =
    let pattern = ", " + label + "]";
    find_pattern_at(fn_mir, pattern, 0) >= 0;

// Check if line at pos is a forwarding label (label: followed by goto)
// Returns "label=target" or ""
// Skip labels that appear as phi predecessors (forwarding would break phi edges)
fn gcs_is_forward(fn_mir: String, pos: i64, pipe: i64) -> String =
    let line = fn_mir.slice(pos, pipe);
    if ube_is_label(line) and pipe < fn_mir.len() {
        let label = ube_label_name(line);
        if ube_is_entry(label) { "" }
        else if gcs_label_in_phi(fn_mir, label) { "" }
        else {
            let p2 = pipe + 1;
            let pipe2 = find_pipe_skip_quotes(fn_mir, p2);
            let next_line = fn_mir.slice(p2, pipe2);
            let target = ube_goto_target(next_line);
            if target != "" { label + "=" + target }
            else { "" }
        }
    } else { "" };

// Build forwarding map: "label1=target1,label2=target2,..."
fn gcs_find_forwards(fn_mir: String, pos: i64, map: String) -> String =
    if pos >= fn_mir.len() { map } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let entry = gcs_is_forward(fn_mir, pos, pipe);
        let new_map = if entry != "" {
            if map == "" { entry } else { map + "," + entry }
        } else { map };
        if pipe >= fn_mir.len() { new_map }
        else { gcs_find_forwards(fn_mir, pipe + 1, new_map) }
    };

// Find "search" in map ensuring it's at position 0 or preceded by ','
fn gcs_find_in_map(map: String, search: String, from: i64) -> i64 =
    let pos = find_pattern_at(map, search, from);
    if pos < 0 { 0 - 1 }
    else if pos == 0 { pos }
    else if map.byte_at(pos - 1) == 44 { pos }
    else { gcs_find_in_map(map, search, pos + 1) };

// Look up label in forwarding map
fn gcs_map_get(map: String, label: String) -> String =
    let search = label + "=";
    let pos = gcs_find_in_map(map, search, 0);
    if pos < 0 { "" }
    else {
        let val_start = pos + search.len();
        let comma = find_char(map, val_start, 44);
        if comma >= map.len() { map.slice(val_start, map.len()) }
        else { map.slice(val_start, comma) }
    };

// Follow forwarding chain to final destination (max 5 hops)
fn gcs_resolve(map: String, label: String, depth: i64) -> String =
    if depth >= 5 { label }
    else {
        let target = gcs_map_get(map, label);
        if target == "" { label }
        else { gcs_resolve(map, target, depth + 1) }
    };

// Rewrite a goto line using forwarding map
fn gcs_rewrite_goto(line: String, map: String) -> String =
    let target = ube_goto_target(line);
    if target == "" { line }
    else {
        let resolved = gcs_resolve(map, target, 0);
        if resolved == target { line }
        else { "  goto " + resolved }
    };

// Rewrite a branch line using forwarding map
fn gcs_rewrite_branch(line: String, map: String) -> String =
    let cond = cf_branch_cond(line);
    let t1 = cf_branch_then(line);
    let t2 = cf_branch_else(line);
    let r1 = gcs_resolve(map, t1, 0);
    let r2 = gcs_resolve(map, t2, 0);
    if r1 == t1 and r2 == t2 { line }
    else { "  branch " + cond + ", " + r1 + ", " + r2 };

// Rewrite a single line: replace goto/branch targets if forwarded
fn gcs_rewrite_line(line: String, map: String) -> String =
    if ube_goto_target(line) != "" { gcs_rewrite_goto(line, map) }
    else if cf_is_branch(line) { gcs_rewrite_branch(line, map) }
    else { line };

// Rewrite function MIR with forwarding map
fn gcs_rewrite_fn(fn_mir: String, pos: i64, map: String, sb: i64) -> i64 =
    if pos >= fn_mir.len() { 0 } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let line = fn_mir.slice(pos, pipe);
        let new_line = gcs_rewrite_line(line, map);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, new_line);
        if pipe >= fn_mir.len() { 0 }
        else { gcs_rewrite_fn(fn_mir, pipe + 1, map, sb) }
    };

// Simplify goto chains in a single function
fn gcs_function(fn_mir: String) -> String =
    let map = gcs_find_forwards(fn_mir, 0, "");
    if map == "" { fn_mir }
    else {
        let sb = sb_new();
        let w = gcs_rewrite_fn(fn_mir, 0, map, sb);
        let result = sb_build(sb);
        let _f = sb_free(sb);
        result
    };

// Process all functions in the program
fn gcs_program(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let simplified = gcs_function(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, simplified);
        if fn_end + 2 >= mir.len() { 0 }
        else { gcs_program(mir, fn_end + 2, sb) }
    };

fn optimize_goto_chain(mir: String) -> String =
    let sb = sb_new();
    let w = gcs_program(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// ============================================================================
// Phi-Aware Empty Block Threading (PHT)
// Eliminates forwarding blocks (label: | goto target) that appear in phi nodes.
// The goto chain pass skips these because forwarding would break phi edges.
// PHT handles them by also updating phi predecessors.
// ============================================================================

// Check if a forwarding block is in a phi (opposite of gcs_is_forward)
fn pht_is_phi_fwd(fn_mir: String, pos: i64, pipe: i64) -> String =
    let line = fn_mir.slice(pos, pipe);
    if ube_is_label(line) and pipe < fn_mir.len() {
        let label = ube_label_name(line);
        if ube_is_entry(label) { "" }
        else if not gcs_label_in_phi(fn_mir, label) { "" }
        else {
            let p2 = pipe + 1;
            let pipe2 = find_pipe_skip_quotes(fn_mir, p2);
            let next_line = fn_mir.slice(p2, pipe2);
            // Case 1: label: | goto target (empty forwarding block)
            let target = ube_goto_target(next_line);
            if target != "" { label + "=" + target }
            // Case 2: label: | copy %param | goto target (single-copy with safe source)
            else if cf_is_copy(next_line) and pipe2 < fn_mir.len() {
                let p3 = pipe2 + 1;
                let pipe3 = find_pipe_skip_quotes(fn_mir, p3);
                let goto_line = fn_mir.slice(p3, pipe3);
                let target2 = ube_goto_target(goto_line);
                if target2 != "" {
                    // Only forward if copy source is safe (not an alloca variable)
                    let src = cf_copy_src(next_line);
                    if pht_has_alloca(fn_mir, src) { "" }
                    else { label + "=" + target2 }
                } else { "" }
            } else { "" }
        }
    } else { "" };

// Check if a variable name has an alloca in the function MIR
fn pht_has_alloca(fn_mir: String, name: String) -> bool =
    let pattern = "alloca " + name;
    find_pattern_at(fn_mir, pattern, 0) >= 0;

// Build copy-value map for copy-only forwarding blocks
// For blocks like "label: | %dest = copy %src | goto target", record "label:%dest=%src"
// Only include copies where src is a parameter (no alloca), not a mutable variable
fn pht_get_copy_info(fn_mir: String, pos: i64, pipe: i64) -> String =
    let line = fn_mir.slice(pos, pipe);
    if ube_is_label(line) and pipe < fn_mir.len() {
        let label = ube_label_name(line);
        let p2 = pipe + 1;
        let pipe2 = find_pipe_skip_quotes(fn_mir, p2);
        let next_line = fn_mir.slice(p2, pipe2);
        if cf_is_copy(next_line) and pipe2 < fn_mir.len() {
            let p3 = pipe2 + 1;
            let pipe3 = find_pipe_skip_quotes(fn_mir, p3);
            let goto_line = fn_mir.slice(p3, pipe3);
            if ube_goto_target(goto_line) != "" {
                let dest = cf_extract_dest(next_line);
                let src = cf_copy_src(next_line);
                // Only fold if source is a parameter (not an alloca variable)
                // Alloca vars are mutable and may have different types (ptr vs i64)
                if pht_has_alloca(fn_mir, src) { "" }
                else { label + ":" + dest + "=" + src }
            } else { "" }
        } else { "" }
    } else { "" };

fn pht_find_copy_map(fn_mir: String, pos: i64, map: String) -> String =
    if pos >= fn_mir.len() { map } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let entry = pht_get_copy_info(fn_mir, pos, pipe);
        let new_map = if entry != "" {
            if map == "" { entry } else { map + "," + entry }
        } else { map };
        if pipe >= fn_mir.len() { new_map }
        else { pht_find_copy_map(fn_mir, pipe + 1, new_map) }
    };

// Look up a label's copy value replacement in the copy_map
// copy_map format: "label1:%dest1=%src1,label2:%dest2=%src2"
// Returns "%src" if val matches %dest for the given label, else ""
fn pht_copy_lookup(copy_map: String, label: String, val: String, pos: i64) -> String =
    if pos >= copy_map.len() { "" } else {
        let comma = find_char(copy_map, pos, 44);
        let entry = copy_map.slice(pos, comma);
        let colon = find_char(entry, 0, 58);
        let entry_label = entry.slice(0, colon);
        if entry_label == label {
            let eq = find_char(entry, colon + 1, 61);
            let dest = entry.slice(colon + 1, eq);
            let src = entry.slice(eq + 1, entry.len());
            if dest == val { src } else { "" }
        } else if comma >= copy_map.len() { "" }
        else { pht_copy_lookup(copy_map, label, val, comma + 1) }
    };

// Build phi-forwarding map (label=target for forwarding blocks in phis)
fn pht_find_phi_fwds(fn_mir: String, pos: i64, map: String) -> String =
    if pos >= fn_mir.len() { map } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let entry = pht_is_phi_fwd(fn_mir, pos, pipe);
        let new_map = if entry != "" {
            if map == "" { entry } else { map + "," + entry }
        } else { map };
        if pipe >= fn_mir.len() { new_map }
        else { pht_find_phi_fwds(fn_mir, pipe + 1, new_map) }
    };

// Find predecessor block of a label (scan function for goto/branch targeting label)
// Returns predecessor block label, or "" if not found or has multiple predecessors
fn pht_find_pred(fn_mir: String, label: String, pos: i64, cur_label: String, found: String) -> String =
    if pos >= fn_mir.len() { found } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let line = fn_mir.slice(pos, pipe);
        let new_cur = if ube_is_label(line) { ube_label_name(line) } else { cur_label };
        let targets_label = if ube_goto_target(line) == label { true }
            else if cf_is_branch(line) and (cf_branch_then(line) == label or cf_branch_else(line) == label) { true }
            else { false };
        let new_found = if targets_label {
            if found == "" { new_cur }
            else { "MULTI" }
        } else { found };
        if new_found == "MULTI" { "" }
        else if pipe >= fn_mir.len() { new_found }
        else { pht_find_pred(fn_mir, label, pipe + 1, new_cur, new_found) }
    };

// Build phi predecessor map from forwarding map
// For each L=T in fwd_map, find predecessor P and add L=P to phi_map
fn pht_build_phi_map(fn_mir: String, fwd_map: String, pos: i64, phi_map: String) -> String =
    if pos >= fwd_map.len() { phi_map } else {
        let eq_pos = find_char(fwd_map, pos, 61);
        let comma = find_char(fwd_map, eq_pos, 44);
        let label = fwd_map.slice(pos, eq_pos);
        let pred = pht_find_pred(fn_mir, label, 0, "entry", "");
        let new_phi_map = if pred == "" { phi_map }
            else if phi_map == "" { label + "=" + pred }
            else { phi_map + "," + label + "=" + pred };
        if comma >= fwd_map.len() { new_phi_map }
        else { pht_build_phi_map(fn_mir, fwd_map, comma + 1, new_phi_map) }
    };

// Replace label in a phi line: ", old_label]" → ", new_label]"
fn pht_replace_phi_label(line: String, old_label: String, new_label: String) -> String =
    let pattern = ", " + old_label + "]";
    let pos = find_pattern_at(line, pattern, 0);
    if pos < 0 { line }
    else {
        let before = line.slice(0, pos);
        let after = line.slice(pos + pattern.len(), line.len());
        before + ", " + new_label + "]" + after
    };

// Look up a label in the copy_map. Returns "dest=src" or ""
fn pht_copy_get(copy_map: String, label: String, pos: i64) -> String =
    if copy_map == "" or pos >= copy_map.len() { "" } else {
        let comma = find_char(copy_map, pos, 44);
        let entry = copy_map.slice(pos, comma);
        let colon = find_char(entry, 0, 58);
        let entry_label = entry.slice(0, colon);
        if entry_label == label { entry.slice(colon + 1, entry.len()) }
        else if comma >= copy_map.len() { "" }
        else { pht_copy_get(copy_map, label, comma + 1) }
    };

// Replace both value and label in a phi operand: [old_val, old_label] → [new_val, new_label]
fn pht_replace_phi_operand(line: String, old_label: String, new_label: String, old_val: String, new_val: String) -> String =
    let pattern = old_val + ", " + old_label + "]";
    let pos = find_pattern_at(line, pattern, 0);
    if pos < 0 { pht_replace_phi_label(line, old_label, new_label) }
    else {
        let before = line.slice(0, pos);
        let after = line.slice(pos + pattern.len(), line.len());
        before + new_val + ", " + new_label + "]" + after
    };

// Apply phi map and copy map to a phi line (replace predecessors and values)
fn pht_update_phi_line(line: String, phi_map: String, copy_map: String, pos: i64) -> String =
    if pos >= phi_map.len() { line } else {
        let eq_pos = find_char(phi_map, pos, 61);
        let comma = find_char(phi_map, eq_pos, 44);
        let old_label = phi_map.slice(pos, eq_pos);
        let new_label = phi_map.slice(eq_pos + 1, comma);
        // Check if this forwarding block has a copy to fold into the phi
        let copy_info = pht_copy_get(copy_map, old_label, 0);
        let updated = if copy_info == "" {
            pht_replace_phi_label(line, old_label, new_label)
        } else {
            let ceq = find_char(copy_info, 0, 61);
            let old_val = copy_info.slice(0, ceq);
            let new_val = copy_info.slice(ceq + 1, copy_info.len());
            pht_replace_phi_operand(line, old_label, new_label, old_val, new_val)
        };
        if comma >= phi_map.len() { updated }
        else { pht_update_phi_line(updated, phi_map, copy_map, comma + 1) }
    };

// Rewrite a single line: forward gotos/branches and update phi predecessors + values
fn pht_rewrite_line(line: String, fwd_map: String, phi_map: String, copy_map: String) -> String =
    if ube_goto_target(line) != "" { gcs_rewrite_goto(line, fwd_map) }
    else if cf_is_branch(line) { gcs_rewrite_branch(line, fwd_map) }
    else if ube_is_phi(line) { pht_update_phi_line(line, phi_map, copy_map, 0) }
    else { line };

// Rewrite function MIR with phi-aware forwarding
fn pht_rewrite_fn(fn_mir: String, pos: i64, fwd_map: String, phi_map: String, copy_map: String, sb: i64) -> i64 =
    if pos >= fn_mir.len() { 0 } else {
        let pipe = find_pipe_skip_quotes(fn_mir, pos);
        let line = fn_mir.slice(pos, pipe);
        let new_line = pht_rewrite_line(line, fwd_map, phi_map, copy_map);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, new_line);
        if pipe >= fn_mir.len() { 0 }
        else { pht_rewrite_fn(fn_mir, pipe + 1, fwd_map, phi_map, copy_map, sb) }
    };

// Apply phi-threading to a single function
fn pht_function(fn_mir: String) -> String =
    let fwd_map = pht_find_phi_fwds(fn_mir, 0, "");
    if fwd_map == "" { fn_mir }
    else {
        let phi_map = pht_build_phi_map(fn_mir, fwd_map, 0, "");
        if phi_map == "" { fn_mir }
        else {
            let copy_map = pht_find_copy_map(fn_mir, 0, "");
            let sb = sb_new();
            let w = pht_rewrite_fn(fn_mir, 0, fwd_map, phi_map, copy_map, sb);
            let result = sb_build(sb);
            let _f = sb_free(sb);
            result
        }
    };

// Apply phi-threading to all functions
fn pht_program(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let threaded = pht_function(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, threaded);
        if fn_end + 2 >= mir.len() { 0 }
        else { pht_program(mir, fn_end + 2, sb) }
    };

fn optimize_phi_thread(mir: String) -> String =
    let sb = sb_new();
    let w = pht_program(mir, 0, sb);
    let result = sb_build(sb);
    let _f = sb_free(sb);
    result;

// Run if-to-select twice to handle nested if-else (inner then outer in same iteration)
fn optimize_if_select_twice(mir: String) -> String =
    let first = optimize_if_select(mir);
    optimize_if_select(first);

// Iterative optimization: CF + CP + DCE + if-select(x2) + goto-chain + phi-thread + DCE until stable (max 4 iterations)
fn optimize_cf_dce_loop(mir: String, iter: i64) -> String =
    if iter >= 4 { mir } else {
        let folded = optimize_const_folding(mir);
        let propagated = optimize_copy_prop(folded);
        // Redundant phi elimination: simplify phis where all values are the same constant
        let phi_simplified = optimize_redundant_phi(propagated);
        let cleaned = optimize_dce(phi_simplified);
        let selected = optimize_if_select_twice(cleaned);
        let chained = optimize_goto_chain(selected);
        // Phi-aware threading: forward through empty blocks that appear in phi nodes
        let threaded = optimize_phi_thread(chained);
        // Post-chain DCE: remove dead forwarding blocks
        let final_clean = optimize_dce(threaded);
        if final_clean == mir { mir }
        else { optimize_cf_dce_loop(final_clean, iter + 1) }
    };

fn build_param_sig(params: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { acc } else {
        let comma = find_comma_or_end(params, p);
        let param = trim_end(params.slice(p, comma));
        let colon_pos = find_char(param, 0, 58);
        let param_type = trim(param.slice(colon_pos + 1, param.len()));
        // v0.95: i32 params map to "s" (passed as i32, sext to i64 in prologue)
        let sig = if param_type == "f64" { "d" } else if param_type == "ptr" { "p" } else if param_type == "i32" { "s" } else if is_struct_ptr_type(param_type) { "i" } else { "i" };
        let new_acc = acc + sig;
        if comma >= params.len() { new_acc } else { build_param_sig(params, comma + 1, new_acc) }
    };

fn lookup_fn_ret(registry: String, fn_name: String) -> String =
    let clean_fn = if fn_name.len() > 0 and fn_name.byte_at(0) == 64 { fn_name.slice(1, fn_name.len()) } else { fn_name };
    lookup_fn_ret_at(registry, 0, clean_fn);

fn lookup_fn_ret_at(registry: String, pos: i64, fn_name: String) -> String =
    if pos >= registry.len() { "" } else {
        let comma_pos = find_char(registry, pos, 44);
        let colon1 = find_char(registry, pos, 58);
        let name_start = if pos < colon1 and registry.byte_at(pos) == 64 { pos + 1 } else { pos };
        if colon1 - name_start == fn_name.len() and match_bytes(registry, fn_name, name_start, 0) {
            let colon2 = find_char(registry, colon1 + 1, 58);
            registry.slice(colon1 + 1, colon2)
        } else {
            if comma_pos >= registry.len() { "" } else { lookup_fn_ret_at(registry, comma_pos + 1, fn_name) }
        }
    };


fn lookup_fn_both(registry: String, fn_name: String) -> String =
    let clean_fn = if fn_name.len() > 0 and fn_name.byte_at(0) == 64 { fn_name.slice(1, fn_name.len()) } else { fn_name };
    lookup_fn_both_at(registry, 0, clean_fn);

fn lookup_fn_both_at(registry: String, pos: i64, fn_name: String) -> String =
    if pos >= registry.len() { "" } else {
        let comma_pos = find_char(registry, pos, 44);
        let colon1 = find_char(registry, pos, 58);
        let name_start = if pos < colon1 and registry.byte_at(pos) == 64 { pos + 1 } else { pos };
        if colon1 - name_start == fn_name.len() and match_bytes(registry, fn_name, name_start, 0) {
            // Return "ret_type:param_sig" — everything after first colon
            registry.slice(colon1 + 1, comma_pos)
        } else {
            if comma_pos >= registry.len() { "" } else { lookup_fn_both_at(registry, comma_pos + 1, fn_name) }
        }
    };


fn find_mir_annotation(s: String) -> String =
    find_mir_annotation_at(s, 0);

fn find_mir_annotation_at(s: String, pos: i64) -> String =
    if pos >= s.len() { "" }
    else if s.byte_at(pos) == 64 {
        let name_end = low_find_ident_end(s, pos + 1);
        s.slice(pos + 1, name_end)
    } else { find_mir_annotation_at(s, pos + 1) };

fn strip_annotation(s: String) -> String =
    strip_annotation_at(s, 0);

fn strip_annotation_at(s: String, pos: i64) -> String =
    if pos >= s.len() { s }
    else if s.byte_at(pos) == 64 { trim(s.slice(0, pos)) }
    else { strip_annotation_at(s, pos + 1) };

fn llvm_gen_fn_header(line: String, pos: i64) -> String =
    let name_start = pos + 3;
    let paren_pos = find_char(line, name_start, 40);
    let fn_name = line.slice(name_start, paren_pos);
    let close_pos = find_char(line, paren_pos, 41);
    let params = line.slice(paren_pos + 1, close_pos);
    let formatted_params = format_fn_params(params, 0, "");
    let arrow_pos = find_arrow(line, close_pos);
    let brace_pos = find_char(line, arrow_pos, 123);
    // v0.46: Use trim to handle leading/trailing whitespace in return type
    let raw_ret_type = trim(line.slice(arrow_pos + 2, brace_pos));
    let ann = find_mir_annotation(raw_ret_type);
    let ret_type = if ann == "" { raw_ret_type } else { strip_annotation(raw_ret_type) };
    // v0.95: i32 return type support
    let llvm_ret = if ret_type == "f64" { "double" } else if ret_type == "i32" { "i32" } else { "i64" };
    let emitted_name = if fn_name == "main" { "bmb_user_main" } else { fn_name };
    let base_attrs = if fn_name == "main" { " mustprogress" } else { " mustprogress nounwind willreturn nosync" };
    let pure_attrs = if ann == "pure" or ann == "const" { " memory(none) nofree" } else { "" };
    let inline_attrs = if ann == "inline" { " alwaysinline" } else { "" };
    let attrs = base_attrs + pure_attrs + inline_attrs;
    // Prevents symbol collision and enables better optimization for inlined functions
    let linkage = if ann == "inline" and fn_name != "main" { "define private " } else { "define " };
    let header = linkage + llvm_ret + " @" + emitted_name + "(" + formatted_params + ")" + attrs + " {";
    // v0.95: Generate sext prologue for i32 parameters
    let i32_prologue = gen_i32_param_sexts(params, 0, "");
    if i32_prologue == "" { header } else { header + "|i32_entry:|" + i32_prologue + "|  br label %entry" };

// v0.95: Generate sext instructions for i32 parameters
// Scans parameter list, for each i32 param emits: %name = sext i32 %name_i32 to i64
fn gen_i32_param_sexts(params: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { acc } else {
        let comma = find_comma_or_end(params, p);
        let param = trim_end(params.slice(p, comma));
        let colon_pos = find_char(param, 0, 58);
        let name = param.slice(0, colon_pos);
        let param_type = trim(param.slice(colon_pos + 1, param.len()));
        let new_acc = if param_type == "i32" {
            let sext_line = "  %" + name + " = sext i32 %" + name + "_i32 to i64";
            if acc == "" { sext_line } else { acc + "|" + sext_line }
        } else { acc };
        if comma >= params.len() { new_acc } else { gen_i32_param_sexts(params, comma + 1, new_acc) }
    };

// v0.46: Added String parameter type support
fn format_fn_params(params: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { acc } else {
        let comma = find_comma_or_end(params, p);
        let param = trim_end(params.slice(p, comma));
        let colon_pos = find_char(param, 0, 58);
        let name = param.slice(0, colon_pos);
        let param_type = trim(param.slice(colon_pos + 1, param.len()));
        // v0.95: i32 params declared as i32 with _i32 suffix (sext in prologue)
        let llvm_type = if param_type == "f64" { "double" } else if param_type == "i32" { "i32" } else { "i64" };
        let param_name = if param_type == "i32" { "%" + name + "_i32" } else { "%" + name };
        let typed_param = llvm_type + " " + param_name;
        let new_acc = if acc == "" { typed_param } else { acc + ", " + typed_param };
        if comma >= params.len() { new_acc } else { format_fn_params(params, comma + 1, new_acc) }
    };

fn find_arrow(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { pos } else if s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 62 { pos } else { find_arrow(s, pos + 1) };

fn ends_with_colon(s: String) -> bool =
    if s.len() == 0 { false } else {
        let last = trim_end(s);
        if last.len() == 0 { false } else { last.byte_at(last.len() - 1) == 58 }
    };

fn find_double_pipe(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { s.len() }
    else if s.byte_at(pos) == 124 and s.byte_at(pos + 1) == 124 { pos }
    else if s.byte_at(pos) == 34 { find_double_pipe(s, skip_quoted_string(s, pos + 1)) }
    else { find_double_pipe(s, pos + 1) };


fn gen_module_header() -> String =
    "; ModuleID = bmb_bootstrap";

// Runtime declarations — all LLVM extern function declarations
fn gen_runtime_decls() -> String =
    // I/O + Math + Array
    "declare void @println(i64) nounwind willreturn" + "|" +
    "declare void @print_str(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare void @println_str(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare void @eprint(i64) nounwind willreturn" + "|" +
    "declare void @eprintln(i64) nounwind willreturn" + "|" +
    "declare void @eprint_str(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare void @eprintln_str(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare void @eprint_f64(double) nounwind willreturn" + "|" +
    "declare void @eprintln_f64(double) nounwind willreturn" + "|" +
    "declare i64 @bmb_abs(i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_min(i64, i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_max(i64, i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_clamp(i64, i64, i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_pow(i64, i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare noalias ptr @bmb_array_push(ptr nocapture readonly, i64) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_array_pop(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_array_concat(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_array_slice(ptr nocapture readonly, i64, i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_array_len(ptr nocapture readonly) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    // String operations
    "declare noalias ptr @bmb_string_new(ptr nocapture readonly, i64) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_from_cstr(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare i64 @bmb_string_len(ptr nocapture readonly) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    "declare i64 @bmb_string_char_at(ptr nocapture readonly, i64) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    "declare noalias ptr @bmb_string_slice(ptr nocapture readonly, i64, i64) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_concat(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_concat3(ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_concat5(ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_concat7(ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare i64 @bmb_string_eq(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn memory(argmem: read)" + "|" +
    "declare i64 @bmb_string_cmp(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn memory(argmem: read)" + "|" +
    "declare i64 @bmb_string_hash(ptr nocapture readonly) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    "declare i64 @bmb_string_starts_with(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    "declare i64 @bmb_string_ends_with(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    "declare i64 @bmb_string_contains(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    "declare i64 @bmb_string_index_of(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    "declare noalias ptr @bmb_string_trim(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_replace(ptr nocapture readonly, ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_to_upper(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_to_lower(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_repeat(ptr nocapture readonly, i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_string_is_empty(ptr nocapture readonly) nounwind willreturn memory(argmem: read) speculatable" + "|" +
    "declare i64 @bmb_string_count(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn memory(argmem: read)" + "|" +
    "declare noalias ptr @bmb_string_reverse(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_pad_left(ptr nocapture readonly, i64, i64) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_string_pad_right(ptr nocapture readonly, i64, i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_string_last_index_of(ptr nocapture readonly, ptr nocapture readonly) nounwind willreturn memory(argmem: read)" + "|" +
    "declare noalias ptr @bmb_chr(i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_ord(ptr nocapture readonly) nounwind willreturn memory(argmem: read)" + "|" +
    "declare noalias ptr @bmb_int_to_string(i64) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_f64_to_string(double) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_to_hex(i64) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_to_binary(i64) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_to_octal(i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_parse_int(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare double @bmb_parse_f64(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare noalias ptr @bmb_fast_i2s(i64) nounwind willreturn" + "|" +
    // File I/O
    "declare i64 @bmb_file_exists(ptr nocapture readonly) nounwind" + "|" +
    "declare i64 @bmb_file_size(ptr nocapture readonly) nounwind" + "|" +
    "declare noalias ptr @bmb_read_file(ptr nocapture readonly) nounwind" + "|" +
    "declare i64 @bmb_write_file(ptr nocapture readonly, ptr nocapture readonly) nounwind" + "|" +
    "declare i64 @bmb_append_file(ptr nocapture readonly, ptr nocapture readonly) nounwind" + "|" +
    "declare i64 @write_file_newlines(ptr nocapture readonly, ptr nocapture readonly) nounwind" + "|" +
    // StringBuilder + System + Arena
    "declare i64 @bmb_sb_new() nounwind willreturn" + "|" +
    "declare i64 @bmb_sb_push(i64, ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare i64 @sb_push_range(i64, ptr nocapture readonly, i64, i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_sb_push_int(i64, i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_sb_push_char(i64, i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_sb_push_escaped(i64, ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare i64 @bmb_sb_len(i64) nounwind willreturn memory(read)" + "|" +
    "declare noalias ptr @bmb_sb_build(i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_sb_clear(i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_sb_contains(i64, ptr nocapture readonly) nounwind willreturn memory(read)" + "|" +
    "declare i64 @bmb_system(ptr nocapture readonly)" + "|" +
    "declare void @bmb_exit(i64) noreturn nounwind" + "|" +
    "declare i64 @bmb_time_ms() nounwind willreturn" + "|" +
    "declare void @bmb_sleep_ms(i64) nounwind" + "|" +
    "declare i64 @bmb_random_i64() nounwind" + "|" +
    "declare void @bmb_random_seed(i64) nounwind" + "|" +
    "declare noalias ptr @bmb_getenv(ptr nocapture readonly) nounwind" + "|" +
    "declare noalias ptr @bmb_system_capture(ptr nocapture readonly)" + "|" +
    "declare i64 @bmb_string_free(ptr) nounwind" + "|" +
    "declare i64 @bmb_sb_free(i64) nounwind" + "|" +
    "declare i64 @bmb_arena_mode(i64) nounwind willreturn" + "|" +
    "declare i64 @bmb_arena_reset() nounwind willreturn" + "|" +
    "declare i64 @bmb_arena_save() nounwind willreturn" + "|" +
    "declare i64 @bmb_arena_restore() nounwind willreturn" + "|" +
    "declare i64 @bmb_arena_usage() nounwind willreturn" + "|" +
    "declare i64 @arg_count() nounwind willreturn" + "|" +
    "declare noalias ptr @get_arg(i64) nounwind willreturn" + "|" +
    "declare void @bmb_panic(ptr nocapture readonly) noreturn nounwind" + "|" +
    // Memory + Float + HashMap + Vec
    "declare noalias ptr @malloc(i64) nounwind" + "|" +
    "declare noalias ptr @calloc(i64, i64) nounwind" + "|" +
    "declare void @free(ptr)" + "|" +
    "declare double @sqrt(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @sin(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @cos(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @tan(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @atan(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @atan2(double, double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @log(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @log2(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @log10(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @exp(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @fmod(double, double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @pow_f64(double, double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare void @print_f64(double) nounwind willreturn" + "|" +
    "declare void @println_f64(double) nounwind willreturn" + "|" +
    "declare void @bmb_print_i64(i64) nounwind willreturn" + "|" +
    "declare void @puts_cstr(ptr nocapture readonly) nounwind willreturn" + "|" +
    "declare void @store_u8(ptr, i64, i64) nounwind willreturn" + "|" +
    "declare i64 @load_u8(ptr, i64) nounwind willreturn memory(argmem: read)" + "|" +
    "declare void @store_i64(ptr, i64, i64) nounwind willreturn" + "|" +
    "declare i64 @load_i64(ptr, i64) nounwind willreturn memory(argmem: read)" + "|" +
    "declare i64 @char_at(ptr nocapture readonly, i64) nounwind willreturn memory(argmem: read)" + "|" +
    "declare noalias ptr @hashmap_new() nounwind" + "|" +
    "declare void @hashmap_insert(ptr, ptr nocapture readonly, i64) nounwind" + "|" +
    "declare i64 @hashmap_get(ptr, ptr nocapture readonly) nounwind" + "|" +
    "declare void @hashmap_free(ptr) nounwind" + "|" +
    "declare i64 @hashmap_remove(ptr, ptr nocapture readonly) nounwind" + "|" +
    "declare i64 @hashmap_contains(ptr, ptr nocapture readonly) nounwind memory(argmem: read)" + "|" +
    "declare i64 @hashmap_len(ptr) nounwind memory(argmem: read)" + "|" +
    "declare noalias ptr @str_hashmap_new() nounwind" + "|" +
    "declare i64 @str_hashmap_insert(ptr, ptr nocapture readonly, i64) nounwind" + "|" +
    "declare i64 @str_hashmap_get(ptr, ptr nocapture readonly) nounwind" + "|" +
    "declare void @str_hashmap_free(ptr) nounwind" + "|" +
    "declare i64 @str_hashmap_contains(ptr, ptr nocapture readonly) nounwind" + "|" +
    "declare i64 @str_hashmap_len(ptr) nounwind willreturn" + "|" +
    "declare i64 @str_hashmap_remove(ptr, ptr nocapture readonly) nounwind" + "|" +
    "declare i64 @str_hashmap_keys(ptr) nounwind" + "|" +
    "declare i64 @str_hashmap_values(ptr) nounwind" + "|" +
    "declare noalias ptr @reg_cached_lookup(ptr, ptr nocapture readonly, i64) nounwind" + "|" +
    "declare noalias ptr @vec_new() nounwind" + "|" +
    "declare i64 @vec_push(ptr, i64) nounwind" + "|" +
    "declare i64 @vec_get(ptr, i64) nounwind" + "|" +
    "declare void @vec_set(ptr, i64, i64) nounwind" + "|" +
    "declare i64 @vec_len(ptr) nounwind memory(argmem: read)" + "|" +
    "declare void @vec_free(ptr) nounwind" + "|" +
    "declare void @vec_reverse(ptr) nounwind" + "|" +
    "declare i64 @vec_contains(ptr, i64) nounwind memory(argmem: read)" + "|" +
    "declare i64 @vec_index_of(ptr, i64) nounwind memory(argmem: read)" + "|" +
    "declare void @vec_swap(ptr, i64, i64) nounwind" + "|" +
    "declare void @vec_sort(ptr) nounwind" + "|" +
    "declare noalias ptr @vec_with_capacity(i64) nounwind" + "|" +
    "declare void @vec_clear(ptr) nounwind" + "|" +
    "declare i64 @sb_println(i64) nounwind" + "|" +
    "declare i64 @sb_with_capacity(i64) nounwind willreturn" + "|" +
    "declare double @bmb_f64_floor(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @bmb_f64_ceil(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @bmb_f64_round(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @bmb_f64_sqrt(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @bmb_f64_abs(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_f64_is_nan(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @bmb_f64_min(double, double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare double @bmb_f64_max(double, double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_f64_to_int(double) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_delete_file(ptr) nounwind" + "|" +
    "declare noalias ptr @bmb_getcwd() nounwind" + "|" +
    "declare i64 @vec_pop(ptr) nounwind" + "|" +
    "declare i64 @vec_cap(ptr) nounwind willreturn" + "|" +
    "declare i64 @bmb_time_ns() nounwind" + "|" +
    "declare noalias ptr @bmb_exec_output(ptr, ptr) nounwind" + "|" +
    "declare i64 @bmb_string_split(ptr, ptr) nounwind" + "|" +
    "declare noalias ptr @bmb_string_join(i64, ptr) nounwind" + "|" +
    "declare i64 @bmb_sb_push_f64(i64, double) nounwind" + "|" +
    "declare i64 @bmb_sb_push_hex(i64, i64) nounwind" + "|" +
    "declare i64 @bmb_sb_push_bool(i64, i64) nounwind" + "|" +
    "declare i64 @bmb_popcount(i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_clz(i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_ctz(i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @bmb_bit_reverse(i64) nounwind willreturn memory(none) speculatable" + "|" +
    "declare i64 @vec_slice(ptr, i64, i64) nounwind" + "|" +
    "declare void @vec_extend(ptr, ptr) nounwind" + "|" +
    "declare i64 @vec_remove(ptr, i64) nounwind" + "|" +
    "declare void @vec_insert(ptr, i64, i64) nounwind" + "|" +
    "declare i64 @hashmap_keys(ptr) nounwind" + "|" +
    "declare i64 @hashmap_values(ptr) nounwind" + "|" +
    "declare void @vec_dedup(ptr) nounwind" + "|" +
    "declare void @vec_fill(ptr, i64) nounwind" + "|" +
    "declare i64 @vec_copy(ptr) nounwind" + "|" +
    "declare i64 @vec_sum(ptr) nounwind willreturn" + "|" +
    "declare i64 @strmap_new() nounwind willreturn" + "|" +
    "declare void @strmap_free(i64) nounwind" + "|" +
    "declare i64 @strmap_insert(i64, ptr nocapture readonly, i64) nounwind" + "|" +
    "declare i64 @strmap_get(i64, ptr nocapture readonly) nounwind willreturn memory(argmem: read)" + "|" +
    "declare i64 @strmap_contains(i64, ptr nocapture readonly) nounwind willreturn memory(argmem: read)" + "|" +
    "declare i64 @strmap_size(i64) nounwind willreturn memory(argmem: read)" + "|" +
    "declare i64 @strmap_remove(i64, ptr nocapture readonly) nounwind" + "|" +
    "declare i64 @strmap_keys(i64) nounwind" + "|" +
    "declare i64 @strmap_values(i64) nounwind" + "|" +
    "declare i64 @bmb_read_int() nounwind" + "|" +
    "declare i64 @vec_min(ptr) nounwind willreturn memory(argmem: read)" + "|" +
    "declare i64 @vec_max(ptr) nounwind willreturn memory(argmem: read)" + "|" +
    "declare i64 @vec_product(ptr) nounwind willreturn memory(argmem: read)";

// ============================================================================
// SECTION 12b: String Literal Handling (v0.60.109)
// ============================================================================

// Collect all string literals from MIR, returns tab-separated list
// Now passes current list as parameter instead of rebuilding every iteration
fn collect_strings_from_mir(mir: String) -> String =
    collect_strings_acc_v2(mir, 0, "");

// Uses String accumulator directly, trading some allocation for avoiding
// the O(N) sb_build call that was happening on every string found
// "empty list" from "list containing empty string" in tab-separated format
fn collect_strings_acc_v2(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else {
        let next = find_string_in_mir(mir, pos);
        if next < 0 { acc } else {
            let str_start = next + 8;
            let str_end = find_quote_in_mir(mir, str_start);
            let str_content_raw = mir.slice(str_start, str_end);
            let str_content = if str_content_raw == "" { chr(2) } else { str_content_raw };
            let is_dup = string_in_list(acc, str_content);
            let new_acc = if is_dup == 0 {
                if acc == "" { str_content } else { acc + chr(9) + str_content }
            } else { acc };
            collect_strings_acc_v2(mir, str_end + 1, new_acc)
        }
    };

// Find "string " pattern in MIR (returns position or -1)
fn find_string_in_mir(mir: String, pos: i64) -> i64 =
    if pos + 8 > mir.len() { 0 - 1 }
    else if matches_string_pattern(mir, pos) { pos }
    else { find_string_in_mir(mir, pos + 1) };

fn matches_string_pattern(s: String, pos: i64) -> bool =
    s.byte_at(pos) == 115 and s.byte_at(pos + 1) == 116 and
    s.byte_at(pos + 2) == 114 and s.byte_at(pos + 3) == 105 and
    s.byte_at(pos + 4) == 110 and s.byte_at(pos + 5) == 103 and
    s.byte_at(pos + 6) == 32 and s.byte_at(pos + 7) == 34;

fn find_quote_in_mir(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 92 and pos + 1 < s.len() { find_quote_in_mir(s, pos + 2) }
    else if s.byte_at(pos) == 34 { pos }
    else { find_quote_in_mir(s, pos + 1) };

fn string_in_list(list: String, target: String) -> i64 =
    if list == "" { 0 } else { string_in_list_scan(list, target, 0) };

fn string_in_list_scan(list: String, target: String, pos: i64) -> i64 =
    if pos >= list.len() { 0 } else {
        let pipe = find_tab_in_list(list, pos);
        let end = if pipe >= list.len() { list.len() } else { pipe };
        let item = list.slice(pos, end);
        if item == target { 1 }
        else if pipe >= list.len() { 0 }
        else { string_in_list_scan(list, target, pipe + 1) }
    };

fn find_tab_in_list(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 9 { pos }
    else { find_tab_in_list(s, pos + 1) };

// Find index of string in list
fn find_string_index(list: String, target: String) -> i64 =
    find_string_index_scan(list, target, 0, 0);

fn find_string_index_scan(list: String, target: String, pos: i64, idx: i64) -> i64 =
    if pos >= list.len() { 0 } else {
        let pipe = find_tab_in_list(list, pos);
        let end = if pipe >= list.len() { list.len() } else { pipe };
        let item = list.slice(pos, end);
        let search = if target == "" { chr(2) } else { target };
        if item == search { idx }
        else if pipe >= list.len() { 0 }
        else { find_string_index_scan(list, search, pipe + 1, idx + 1) }
    };

// Returns comma-separated list of function names
fn collect_string_fns_from_mir(mir: String) -> String =
    collect_string_fns_acc(mir, 0, "");

fn collect_string_fns_acc(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc }
    else {
        // Find next function definition
        let fn_start = find_fn_start(mir, pos);
        if fn_start < 0 { acc }
        else {
            let fn_name = extract_fn_name_from_mir(mir, fn_start);
            let ret_type = extract_fn_ret_type_from_mir(mir, fn_start);
            let new_acc = if ret_type == "String" {
                if acc == "" { fn_name } else { acc + "," + fn_name }
            } else { acc };
            // Find end of this function and continue
            let fn_end = find_fn_end(mir, fn_start);
            if fn_end < 0 { new_acc } else { collect_string_fns_acc(mir, fn_end, new_acc) }
        }
    };

// Find "fn " at or after pos
fn find_fn_start(mir: String, pos: i64) -> i64 =
    if pos + 3 > mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 102 and mir.byte_at(pos + 1) == 110 and mir.byte_at(pos + 2) == 32 { pos }
    else { find_fn_start(mir, pos + 1) };

// Extract function name after "fn "
fn extract_fn_name_from_mir(mir: String, fn_start: i64) -> String =
    let name_start = fn_start + 3;
    let paren = find_char(mir, name_start, 40);
    if paren < name_start { "" } else { mir.slice(name_start, paren) };

// Extract return type after "-> "
fn extract_fn_ret_type_from_mir(mir: String, fn_start: i64) -> String =
    let arrow = find_arrow_in_mir(mir, fn_start);
    if arrow < 0 { "i64" }
    else {
        let type_start = arrow + 3;
        let brace = find_char(mir, type_start, 123);
        if brace < type_start { "i64" } else { trim(mir.slice(type_start, brace)) }
    };

// Find "-> " after fn_start
fn find_arrow_in_mir(mir: String, pos: i64) -> i64 =
    if pos + 3 > mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 45 and mir.byte_at(pos + 1) == 62 and mir.byte_at(pos + 2) == 32 { pos }
    else if mir.byte_at(pos) == 123 { 0 - 1 }  // Hit '{' before finding arrow
    else { find_arrow_in_mir(mir, pos + 1) };

// Find end of function (||)
fn find_fn_end(mir: String, pos: i64) -> i64 =
    if pos + 1 >= mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 124 and mir.byte_at(pos + 1) == 124 { pos + 2 }
    else { find_fn_end(mir, pos + 1) };

// Check if function name is in dynamic string functions list
fn is_dynamic_string_fn(fn_name: String, string_fns: String) -> bool =
    if string_fns == "" { false }
    else { check_fn_in_list(fn_name, string_fns, 0) };

fn check_fn_in_list(fn_name: String, list: String, pos: i64) -> bool =
    if pos >= list.len() { false }
    else {
        let comma = find_comma_or_end(list, pos);
        let item = list.slice(pos, comma);
        if item == fn_name { true }
        else if comma >= list.len() { false }
        else { check_fn_in_list(fn_name, list, comma + 1) }
    };

// Generate global string constants
fn gen_string_globals(strings: String) -> String =
    if strings == "" { "" } else {
        let sb = sb_new();
        let w1 = gen_string_globals_acc(strings, 0, 0, sb);
        sb_build(sb)
    };

// confusion with the output line separator. Use \7C for | (byte 124).
fn escape_llvm_string(s: String) -> String =
    escape_llvm_string_acc(s, 0, "");

fn escape_llvm_string_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc }
    else {
        let ch = s.byte_at(pos);
        if ch == 92 and pos + 1 < s.len() {
            let next = s.byte_at(pos + 1);
            if next == 110 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "0A") }
            else if next == 116 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "09") }
            else if next == 114 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "0D") }
            else if next == 48 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "00") }
            else if next == 92 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "5C") }
            else if next == 34 { escape_llvm_string_acc(s, pos + 2, acc + chr(92) + "22") }
            else { escape_llvm_string_acc(s, pos + 1, acc + chr(92) + "5C") }
        } else if ch == 124 { escape_llvm_string_acc(s, pos + 1, acc + chr(92) + "7C") }
        else if ch == 34 { escape_llvm_string_acc(s, pos + 1, acc + chr(92) + "22") }
        else { escape_llvm_string_acc(s, pos + 1, acc + chr(ch)) }
    };

fn count_string_bytes(s: String) -> i64 =
    count_string_bytes_acc(s, 0, 0);

fn count_string_bytes_acc(s: String, pos: i64, count: i64) -> i64 =
    if pos >= s.len() { count }
    else {
        let ch = s.byte_at(pos);
        if ch == 92 and pos + 1 < s.len() {
            let next = s.byte_at(pos + 1);
            if next == 110 or next == 116 or next == 114 or next == 48 or next == 92 or next == 34 {
                count_string_bytes_acc(s, pos + 2, count + 1)
            } else { count_string_bytes_acc(s, pos + 1, count + 1) }
        } else { count_string_bytes_acc(s, pos + 1, count + 1) }
    };

fn gen_string_globals_acc(strings: String, pos: i64, idx: i64, sb: i64) -> i64 =
    if pos >= strings.len() { 0 } else {
        let pipe = find_tab_in_list(strings, pos);
        let end = if pipe >= strings.len() { strings.len() } else { pipe };
        let str_content_raw = strings.slice(pos, end);
        let str_content = if str_content_raw == chr(2) { "" } else { str_content_raw };
        let escaped_content = escape_llvm_string(str_content);
        let byte_count = count_string_bytes(str_content);
        let str_len = byte_count + 1;
        let idx_str = int_to_string(idx);
        let data_name = "@str_data_" + idx_str;
        let global = data_name + " = private unnamed_addr constant [" +
            int_to_string(str_len) + " x i8] c" + chr(34) + escaped_content + chr(92) + "00" + chr(34);
        // Pre-allocated BmbString: { ptr data, i64 len, i64 cap }
        let bmb_global = "@str_bmb_" + idx_str + " = private unnamed_addr constant { ptr, i64, i64 } { ptr " +
            data_name + ", i64 " + int_to_string(byte_count) + ", i64 " + int_to_string(byte_count) + " }";
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, global);
        let w3 = sb_push(sb, "|");
        let w4 = sb_push(sb, bmb_global);
        if pipe >= strings.len() { 0 } else { gen_string_globals_acc(strings, pipe + 1, idx + 1, sb) }
    };

// Generate program with string table
fn gen_program_sb_with_strings_fns_structs(mir: String, strings: String, string_fns: String, struct_reg: String) -> String =
    let fn_rsb = sb_new();
    let ptr_rsb = sb_new();
    let w0 = build_all_registries(mir, fn_rsb, ptr_rsb);
    let registry = sb_build(fn_rsb);
    let ptr_ret_reg = sb_build(ptr_rsb);
    let _f1 = sb_free(fn_rsb);
    let _f2 = sb_free(ptr_rsb);
    let sb = sb_new();
    let fn_sb = sb_new();
    let str_sb = sb_new();
    let ptr_sb = sb_new();
    let w1 = gen_program_acc_sb_structs_reuse(mir, 0, strings, string_fns, sb, registry, struct_reg, ptr_ret_reg, fn_sb, str_sb, ptr_sb);
    let _ff1 = sb_free(fn_sb);
    let _ff2 = sb_free(str_sb);
    let _ff3 = sb_free(ptr_sb);
    sb_build(sb);

fn gen_program_acc_sb_structs_reuse(mir: String, pos: i64, strings: String, string_fns: String, sb: i64, registry: String, struct_reg: String, ptr_ret_reg: String, fn_sb: i64, str_sb: i64, ptr_sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let _save = bmb_arena_save();
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function_sb_structs_reuse(fn_mir, strings, string_fns, registry, struct_reg, ptr_ret_reg, fn_sb, str_sb, ptr_sb);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_llvm);
        let _restore = bmb_arena_restore();
        if fn_end + 2 >= mir.len() { 0 } else { gen_program_acc_sb_structs_reuse(mir, fn_end + 2, strings, string_fns, sb, registry, struct_reg, ptr_ret_reg, fn_sb, str_sb, ptr_sb) }
    };

// v0.93.4: Check if MIR contains a self-call (direct recursion)
fn mir_has_self_call(mir: String, fn_name: String) -> bool =
    let pattern = "call @" + fn_name + "(";
    find_pattern_noa(mir, pattern, 0) >= 0;

// v0.93.4: Add norecurse attribute to non-recursive functions
fn add_norecurse_attr(ir: String) -> String =
    // Find "mustprogress" in the first line (define header) and add norecurse before it
    let pipe_pos = find_pipe_skip_quotes(ir, 0);
    let header = ir.slice(0, pipe_pos);
    let rest = if pipe_pos >= ir.len() { "" } else { ir.slice(pipe_pos, ir.len()) };
    let mp_pos = find_pattern_noa(header, "mustprogress", 0);
    if mp_pos < 0 { ir }
    else {
        let before = header.slice(0, mp_pos);
        let after = header.slice(mp_pos, header.len());
        before + "norecurse " + after + rest
    };

fn gen_function_sb_structs_reuse(mir: String, strings: String, string_fns: String, registry: String, struct_reg: String, ptr_ret_reg: String, fn_sb: i64, str_sb: i64, ptr_sb: i64) -> String =
    let _c1 = sb_clear(fn_sb);
    let _c2 = sb_clear(str_sb);
    let _c3 = sb_clear(ptr_sb);
    let ret_type = extract_mir_return_type(mir);
    // v0.93.4: Detect direct recursion for norecurse attribute
    let fn_start = find_pattern_at(mir, "fn ", 0);
    let fn_name = if fn_start >= 0 { extract_fn_name_from_mir(mir, fn_start) } else { "" };
    let is_recursive = if fn_name == "" { true } else { mir_has_self_call(mir, fn_name) };
    let w0 = init_string_params_sb(mir, str_sb);
    let w0p = init_ptr_params_sb(mir, ptr_sb);
    let w0r = init_fn_ptr_returns(ptr_ret_reg, ptr_sb);
    let w0i = init_i64_params_sb(mir, str_sb);
    let w1 = gen_fn_lines_structs(mir, 0, fn_sb, ret_type, strings, string_fns, "", str_sb, registry, struct_reg, ptr_sb);
    let raw_ir = sb_build(fn_sb);
    let pass0 = eliminate_store_load_ir(raw_ir);
    let pass0b = eliminate_dead_stores_ir(pass0);
    let pass1 = eliminate_identity_copies_ir(pass0b);
    let pass2 = eliminate_zext_trunc_ir(pass1);
    let pass3 = eliminate_dead_zexts_ir(pass2);
    let pass4 = eliminate_inttoptr_roundtrips_ir(pass3);
    let pass5 = eliminate_dead_ptrtoints_ir(pass4);
    let pass6 = annotate_memory_none_ir(pass5);
    // v0.93.6: Annotate read-only functions with memory(read)
    let pass7 = annotate_memory_read_ir(pass6);
    // v0.93.4: Add norecurse for non-recursive functions
    if is_recursive { pass7 } else { add_norecurse_attr(pass7) };

fn init_string_params_sb(mir: String, str_sb: i64) -> i64 =
    let fn_start = find_pattern_at(mir, "fn ", 0);
    if fn_start < 0 { 0 } else {
        let paren_start = find_char(mir, fn_start, 40);
        let paren_end = find_char(mir, paren_start, 41);
        if paren_start < 0 or paren_end < 0 { 0 }
        else {
            let params = mir.slice(paren_start + 1, paren_end);
            collect_string_params_sb(params, 0, str_sb)
        }
    };

// Collect string parameters and push "S:%name," markers to SB
fn collect_string_params_sb(params: String, pos: i64, str_sb: i64) -> i64 =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { 0 }
    else {
        let comma_pos = find_comma_or_end(params, p);
        let param = params.slice(p, comma_pos);
        let colon_pos = find_char(param, 0, 58);
        if colon_pos < param.len() {
            let param_name = trim(param.slice(0, colon_pos));
            let param_type = trim(param.slice(colon_pos + 1, param.len()));
            let w = if param_type == "String" {
                let w1 = sb_push(str_sb, "S:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else if param_type == "f64" {
                let w1 = sb_push(str_sb, "D:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else if param_type == "*f64" {
                let w1 = sb_push(str_sb, "F:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else if param_type == "i32" {
                // v0.95: Track i32 parameters for type-correct codegen
                let w1 = sb_push(str_sb, "W:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else { 0 };
            if comma_pos >= params.len() { 0 }
            else { collect_string_params_sb(params, comma_pos + 1, str_sb) }
        } else {
            if comma_pos >= params.len() { 0 }
            else { collect_string_params_sb(params, comma_pos + 1, str_sb) }
        }
    };

// v0.95: Track i64 parameter names in str_sb with "P:%name," prefix
// Used for indirect call detection when call target is a function parameter
fn init_i64_params_sb(mir: String, str_sb: i64) -> i64 =
    let fn_start = find_pattern_at(mir, "fn ", 0);
    if fn_start < 0 { 0 } else {
        let paren_start = find_char(mir, fn_start, 40);
        let paren_end = find_char(mir, paren_start, 41);
        if paren_start < 0 or paren_end < 0 { 0 }
        else {
            let params = mir.slice(paren_start + 1, paren_end);
            collect_i64_params_sb(params, 0, str_sb)
        }
    };

fn collect_i64_params_sb(params: String, pos: i64, str_sb: i64) -> i64 =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { 0 }
    else {
        let comma_pos = find_comma_or_end(params, p);
        let param = params.slice(p, comma_pos);
        let colon_pos = find_char(param, 0, 58);
        let w = if colon_pos < param.len() {
            let param_name = trim(param.slice(0, colon_pos));
            let param_type = trim(param.slice(colon_pos + 1, param.len()));
            if param_type == "i64" {
                let w1 = sb_push(str_sb, "P:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else { 0 }
        } else { 0 };
        if comma_pos >= params.len() { 0 }
        else { collect_i64_params_sb(params, comma_pos + 1, str_sb) }
    };

// Format: "fn_name:StructName,fn_name2:StructName2,"

fn register_ptr_return(fn_mir: String, rsb: i64) -> i64 =
    let first_pipe = find_char(fn_mir, 0, 124);
    let header = fn_mir.slice(0, first_pipe);
    if header.len() < 4 { 0 }
    else if low_starts_with_at(header, 0, "fn ") {
        let name_start = 3;
        let paren_pos = find_char(header, name_start, 40);
        let fn_name = header.slice(name_start, paren_pos);
        let close_pos = find_char(header, paren_pos, 41);
        let arrow_pos = find_arrow(header, close_pos);
        let brace_pos = find_char(header, arrow_pos, 123);
        let raw_ret = trim(header.slice(arrow_pos + 2, brace_pos));
        let ann = find_mir_annotation(raw_ret);
        let ret_type = if ann == "" { raw_ret } else { strip_annotation(raw_ret) };
        if is_struct_ptr_type(ret_type) {
            let struct_name = extract_struct_name_from_ptr_type(ret_type);
            let w1 = sb_push(rsb, fn_name);
            let w2 = sb_push(rsb, ":");
            let w3 = sb_push(rsb, struct_name);
            sb_push(rsb, ",")
        } else { 0 }
    } else { 0 };

fn init_fn_ptr_returns(ptr_ret_reg: String, ptr_sb: i64) -> i64 =
    init_fn_ptr_returns_at(ptr_ret_reg, 0, ptr_sb);

fn init_fn_ptr_returns_at(reg: String, pos: i64, ptr_sb: i64) -> i64 =
    if pos >= reg.len() { 0 } else {
        let comma_pos = find_comma_or_end(reg, pos);
        let entry = reg.slice(pos, comma_pos);
        let colon_pos = find_char(entry, 0, 58);
        if colon_pos < entry.len() {
            let fn_name = entry.slice(0, colon_pos);
            let struct_name = entry.slice(colon_pos + 1, entry.len());
            let w1 = sb_push(ptr_sb, "F:@");
            let w2 = sb_push(ptr_sb, fn_name);
            let w3 = sb_push(ptr_sb, ":");
            let w4 = sb_push(ptr_sb, struct_name);
            let w5 = sb_push(ptr_sb, ",");
            if comma_pos >= reg.len() { 0 }
            else { init_fn_ptr_returns_at(reg, comma_pos + 1, ptr_sb) }
        } else {
            if comma_pos >= reg.len() { 0 }
            else { init_fn_ptr_returns_at(reg, comma_pos + 1, ptr_sb) }
        }
    };

fn is_struct_ptr_type(t: String) -> bool =
    t.len() >= 2 and t.byte_at(0) == 42;

fn extract_struct_name_from_ptr_type(t: String) -> String =
    if t.len() >= 2 and t.byte_at(0) == 42 { t.slice(1, t.len()) }
    else { "" };

// Format: "P:%name:StructName," for each *StructName parameter
fn init_ptr_params_sb(mir: String, ptr_sb: i64) -> i64 =
    let fn_start = find_pattern_at(mir, "fn ", 0);
    if fn_start < 0 { 0 } else {
        let paren_start = find_char(mir, fn_start, 40);
        let paren_end = find_char(mir, paren_start, 41);
        if paren_start < 0 or paren_end < 0 { 0 }
        else {
            let params = mir.slice(paren_start + 1, paren_end);
            collect_ptr_params_sb(params, 0, ptr_sb)
        }
    };

fn collect_ptr_params_sb(params: String, pos: i64, ptr_sb: i64) -> i64 =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { 0 }
    else {
        let comma_pos = find_comma_or_end(params, p);
        let param = params.slice(p, comma_pos);
        let colon_pos = find_char(param, 0, 58);
        if colon_pos < param.len() {
            let param_name = trim(param.slice(0, colon_pos));
            let param_type = trim(param.slice(colon_pos + 1, param.len()));
            let w = if is_struct_ptr_type(param_type) {
                let struct_name = extract_struct_name_from_ptr_type(param_type);
                let w1 = sb_push(ptr_sb, "P:%");
                let w2 = sb_push(ptr_sb, param_name);
                let w3 = sb_push(ptr_sb, ":");
                let w4 = sb_push(ptr_sb, struct_name);
                sb_push(ptr_sb, ",")
            } else { 0 };
            if comma_pos >= params.len() { 0 }
            else { collect_ptr_params_sb(params, comma_pos + 1, ptr_sb) }
        } else {
            if comma_pos >= params.len() { 0 }
            else { collect_ptr_params_sb(params, comma_pos + 1, ptr_sb) }
        }
    };

fn push_ptr_marker(ptr_sb: i64, varname: String, struct_name: String) -> i64 =
    let w1 = sb_push(ptr_sb, "P:");
    let w2 = sb_push(ptr_sb, varname);
    let w3 = sb_push(ptr_sb, ":");
    let w4 = sb_push(ptr_sb, struct_name);
    sb_push(ptr_sb, ",");

fn get_struct_ptr_type(varname: String, ptr_sb: i64) -> String =
    let content = sb_build(ptr_sb);
    get_struct_ptr_type_from(varname, content, 0);

fn get_struct_ptr_type_from(varname: String, content: String, pos: i64) -> String =
    if pos >= content.len() { "" } else {
        let comma_pos = find_comma_or_end(content, pos);
        let entry = content.slice(pos, comma_pos);
        // Entry format: "P:%varname:StructName"
        if entry.len() >= 4 and entry.byte_at(0) == 80 and entry.byte_at(1) == 58 {
            let after_p = 2;
            let second_colon = find_char_from(entry, after_p, 58);
            if second_colon < entry.len() {
                let entry_var = entry.slice(after_p, second_colon);
                let entry_struct = entry.slice(second_colon + 1, entry.len());
                if entry_var == varname { entry_struct }
                else if comma_pos >= content.len() { "" }
                else { get_struct_ptr_type_from(varname, content, comma_pos + 1) }
            }
            else if comma_pos >= content.len() { "" }
            else { get_struct_ptr_type_from(varname, content, comma_pos + 1) }
        }
        else if comma_pos >= content.len() { "" }
        else { get_struct_ptr_type_from(varname, content, comma_pos + 1) }
    };

fn find_char_from(s: String, pos: i64, ch: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == ch { pos }
    else { find_char_from(s, pos + 1, ch) };


fn count_struct_fields(registry: String, struct_name: String) -> i64 =
    count_struct_fields_at(registry, 0, struct_name);

fn count_struct_fields_at(registry: String, pos: i64, struct_name: String) -> i64 =
    if pos >= registry.len() { 0 } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let name = entry.slice(0, colon_pos);
        if name == struct_name {
            let fields = entry.slice(colon_pos + 1, entry.len());
            count_commas(fields, 0) + 1
        }
        else if semi_pos + 1 >= registry.len() { 0 }
        else { count_struct_fields_at(registry, semi_pos + 1, struct_name) }
    };

fn count_commas(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 }
    else if s.byte_at(pos) == 44 { 1 + count_commas(s, pos + 1) }
    else { count_commas(s, pos + 1) };

fn build_struct_gep_type(struct_reg: String, struct_name: String) -> String =
    let field_count = count_struct_fields(struct_reg, struct_name);
    "{ " + build_field_types_str(struct_reg, struct_name, field_count) + " }";

fn build_field_types_str(struct_reg: String, struct_name: String, count: i64) -> String =
    build_field_types_acc(struct_reg, struct_name, 0, count, "");

fn build_field_types_acc(struct_reg: String, struct_name: String, idx: i64, count: i64, acc: String) -> String =
    if idx >= count { acc } else {
        let is_f64 = is_field_f64_by_index(struct_reg, struct_name, idx);
        let field_type = if is_f64 { "double" } else { "i64" };
        let new_acc = if acc == "" { field_type } else { acc + ", " + field_type };
        build_field_types_acc(struct_reg, struct_name, idx + 1, count, new_acc)
    };

fn is_field_f64_by_index(struct_reg: String, struct_name: String, idx: i64) -> bool =
    is_field_f64_by_index_at(struct_reg, 0, struct_name, idx);

fn is_field_f64_by_index_at(registry: String, pos: i64, struct_name: String, idx: i64) -> bool =
    if pos >= registry.len() { false } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let name = entry.slice(0, colon_pos);
        if name == struct_name {
            let fields = entry.slice(colon_pos + 1, entry.len());
            check_field_f64_at_index(fields, 0, 0, idx)
        }
        else if semi_pos + 1 >= registry.len() { false }
        else { is_field_f64_by_index_at(registry, semi_pos + 1, struct_name, idx) }
    };

fn check_field_f64_at_index(fields: String, pos: i64, cur_idx: i64, target_idx: i64) -> bool =
    if pos >= fields.len() { false } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        if cur_idx == target_idx {
            let tilde_pos = find_char(raw_name, 0, 126);
            tilde_pos < raw_name.len()
        }
        else if comma_pos >= fields.len() { false }
        else { check_field_f64_at_index(fields, comma_pos + 1, cur_idx + 1, target_idx) }
    };

fn find_pattern_at(s: String, pat: String, pos: i64) -> i64 =
    // Check from start - MIR functions always start with "fn "
    if pos == 0 and pat.len() <= s.len() and match_bytes(s, pat, 0, 0) { 0 }
    // If not at start, do linear search
    else { find_pattern_noa(s, pat, pos) };

// Legacy alias — redirects to zero-allocation implementation
fn find_pattern_at_slow(s: String, pat: String, pos: i64) -> i64 =
    find_pattern_noa(s, pat, pos);

fn gen_fn_lines_structs(mir: String, pos: i64, sb: i64, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let result = llvm_gen_fn_line_structs(line, ret_type, strings, string_fns, mapping, str_sb, registry, struct_reg, ptr_sb);
        let is_changed = result.len() > 0 and result.byte_at(0) == 33;
        let new_mapping = if is_changed { extract_new_mapping(result) } else { mapping };
        let llvm_line = if is_changed { extract_new_llvm_line(result) } else { result };
        let len = sb_len(sb);
        let w1 = if len > 0 and llvm_line != "" { sb_push(sb, "|") } else { 0 };
        let w2 = if llvm_line != "" { sb_push(sb, llvm_line) } else { 0 };
        if pipe_pos >= mir.len() { 0 } else { gen_fn_lines_structs(mir, pipe_pos + 1, sb, ret_type, strings, string_fns, new_mapping, str_sb, registry, struct_reg, ptr_sb) }
    };

fn llvm_gen_fn_line_structs(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if low_starts_with_at(line, p, "fn ") { same_mapping(llvm_gen_fn_header(line, p)) }
    else if ends_with_colon(line) { same_mapping(line) }
    else if line == "}" { same_mapping("}") }
    else { llvm_gen_line_structs(line, ret_type, strings, string_fns, mapping, str_sb, registry, struct_reg, ptr_sb) };

fn llvm_gen_line_structs(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if line.byte_at(p) == 37 { llvm_gen_assign_structs(line, p, strings, string_fns, mapping, str_sb, registry, struct_reg, ptr_sb) }
    else if low_starts_with_at(line, p, "return") { same_mapping(llvm_gen_return_typed(line, p, ret_type)) }
    else if low_starts_with_at(line, p, "branch") { same_mapping(llvm_gen_branch(line, p)) }
    else if low_starts_with_at(line, p, "goto") { same_mapping(llvm_gen_goto(line, p)) }
    else if low_starts_with_at(line, p, "alloca") { llvm_gen_alloca(line, p, mapping) }
    else if low_starts_with_at(line, p, "store_ptr") { llvm_gen_store_ptr_sb(line, p + 9, str_sb) }
    else if low_starts_with_at(line, p, "store") { llvm_gen_store_sb(line, p, mapping, str_sb) }
    else if low_starts_with_at(line, p, "field-store") { llvm_gen_field_store(line, p + 11, struct_reg, str_sb) }
    else if low_starts_with_at(line, p, "mark_f64_ptr") { llvm_handle_mark_f64_ptr(line, p, str_sb) }
    else if low_starts_with_at(line, p, "mark_str_ptr") { llvm_handle_mark_str_ptr(line, p, str_sb) }
    else if low_starts_with_at(line, p, "mutex-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "arc-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "atomic-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "channel-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "rwlock-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "condvar-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "async-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-pool-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-join") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "scope-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if line.byte_at(p) == 40 { same_mapping(llvm_gen_channel_new(line, p)) }
    else { same_mapping(line) };

fn llvm_gen_assign_structs(line: String, pos: i64, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs_structs(line, after_eq, dest, strings, string_fns, mapping, str_sb, registry, struct_reg, ptr_sb);

fn llvm_gen_rhs_structs(line: String, pos: i64, dest: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, struct_reg: String, ptr_sb: i64) -> String =
    if low_starts_with_at(line, pos, "field-access") {
        llvm_gen_field_access(line, pos + 12, dest, struct_reg, str_sb, ptr_sb)
    }
    else if low_starts_with_at(line, pos, "+") {
        llvm_gen_add_struct_aware(line, pos + 1, dest, mapping, str_sb, struct_reg, ptr_sb)
    }
    else if low_starts_with_at(line, pos, "copy") {
        llvm_gen_copy_struct_aware(line, pos, dest, mapping, str_sb, ptr_sb, registry)
    }
    else if low_starts_with_at(line, pos, "call") {
        llvm_gen_call_struct_aware(line, pos, dest, strings, string_fns, mapping, str_sb, registry, ptr_sb)
    }
    else {
        // Delegate to existing registry-aware RHS handler
        llvm_gen_rhs_with_strings_map_and_fns_reg(line, pos, dest, strings, string_fns, mapping, str_sb, registry)
    };

fn llvm_gen_rhs_with_strings_map_and_fns_reg(line: String, pos: i64, dest: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String) -> String =
    if low_starts_with_at(line, pos, "const") {
        let val_start = low_skip_ws(line, pos + 5);
        let val = line.slice(val_start, line.len());
        let trimmed_val = trim_end(val);
        if trimmed_val.len() >= 2 and trimmed_val.byte_at(0) == 70 and trimmed_val.byte_at(1) == 58 {
            let float_val = trimmed_val.slice(2, trimmed_val.len());
            let w = push_double_marker(str_sb, dest);
            same_mapping("  " + dest + " = fadd nsz double 0.0, " + float_val)
        } else {
            same_mapping("  " + dest + " = add nsw i64 0, " + trimmed_val)
        }
    } else if low_starts_with_at(line, pos, "copy") {
        let src_start = low_skip_ws(line, pos + 4);
        let src = trim_end(line.slice(src_start, line.len()));
        if is_user_variable(dest) {
            let resolved_src = resolve_variable(src, mapping);
            let src_is_string = is_string_var_sb(src, str_sb);
            let src_is_double = is_double_var_sb(src, str_sb);
            let src_is_f64_ptr = is_f64_ptr_sb(src, str_sb);
            let src_is_str_ptr = is_str_ptr_sb(src, str_sb);
            // v0.95: Propagate i32 marker through copy
            let src_is_i32 = is_i32_var_sb(src, str_sb);
            let w = if src_is_string { push_string_marker(str_sb, dest) } else if src_is_double { push_double_marker(str_sb, dest) } else if src_is_f64_ptr { push_f64_ptr_marker(str_sb, dest) } else if src_is_str_ptr { push_str_ptr_marker(str_sb, dest) } else if src_is_i32 { push_i32_marker(str_sb, dest) } else { 0 };
            let name_mapping = add_mapping(mapping, dest, resolved_src);
            changed_mapping_empty(name_mapping)
        } else {
            let resolved_src = resolve_variable(src, mapping);
            if resolved_src == "ALLOCA" {
                let alloca_is_double = is_double_var_sb(src, str_sb);
                let alloca_is_string = is_string_var_sb(src, str_sb);
                let alloca_is_f64_ptr = is_f64_ptr_sb(src, str_sb);
                let alloca_is_str_ptr = is_str_ptr_sb(src, str_sb);
                let alloca_is_i32 = is_i32_var_sb(src, str_sb);
                let w2 = if alloca_is_string { push_string_marker(str_sb, dest) }
                    else if alloca_is_f64_ptr { push_f64_ptr_marker(str_sb, dest) }
                    else if alloca_is_str_ptr { push_str_ptr_marker(str_sb, dest) }
                    else if alloca_is_i32 { push_i32_marker(str_sb, dest) }
                    else { 0 };
                if alloca_is_double {
                    let w = push_double_marker(str_sb, dest);
                    same_mapping("  " + dest + " = load double, ptr " + src)
                } else {
                    same_mapping("  " + dest + " = load i64, ptr " + src)
                }
            } else {
                let src_is_string = is_string_var_sb(src, str_sb);
                let src_is_double = is_double_var_sb(src, str_sb);
                let src_is_f64_ptr = is_f64_ptr_sb(src, str_sb);
                let src_is_str_ptr = is_str_ptr_sb(src, str_sb);
                // v0.95: Propagate i32 marker through copy
                let src_is_i32 = is_i32_var_sb(src, str_sb);
                let w = if src_is_string { push_string_marker(str_sb, dest) } else if src_is_double { push_double_marker(str_sb, dest) } else if src_is_f64_ptr { push_f64_ptr_marker(str_sb, dest) } else if src_is_str_ptr { push_str_ptr_marker(str_sb, dest) } else if src_is_i32 { push_i32_marker(str_sb, dest) } else { 0 };
                if src_is_double {
                    same_mapping("  " + dest + " = fadd nsz double 0.0, " + resolved_src)
                } else {
                    same_mapping("  " + dest + " = add nsw i64 0, " + resolved_src)
                }
            }
        }
    } else if low_starts_with_at(line, pos, "string") {
        let str_start = low_skip_ws(line, pos + 6);
        let str_content = line.slice(str_start + 1, line.len() - 1);
        let w = push_string_marker(str_sb, dest);
        same_mapping(llvm_gen_string_ref(dest, str_content, strings))
    } else if low_starts_with_at(line, pos, "fptosi") {
        let src_start = low_skip_ws(line, pos + 6);
        let src = trim_end(line.slice(src_start, line.len()));
        // v0.95: Check source type — only emit fptosi for f64, identity for int (i32/i64)
        if is_double_var_sb(src, str_sb) {
            same_mapping("  " + dest + " = fptosi double " + src + " to i64")
        } else {
            same_mapping("  " + dest + " = add nsw i64 " + src + ", 0")
        }
    } else if low_starts_with_at(line, pos, "sitofp") {
        let src_start = low_skip_ws(line, pos + 6);
        let src = trim_end(line.slice(src_start, line.len()));
        let w = push_double_marker(str_sb, dest);
        same_mapping("  " + dest + " = sitofp i64 " + src + " to double")
    // v0.95: trunc_i32 — string-tracking+registry variant
    } else if low_starts_with_at(line, pos, "trunc_i32") {
        let src_start = low_skip_ws(line, pos + 9);
        let src = trim_end(line.slice(src_start, line.len()));
        let w = push_i32_marker(str_sb, dest);
        same_mapping("  " + dest + "_w = trunc i64 " + src + " to i32|  " + dest + " = sext i32 " + dest + "_w to i64")
    } else if low_starts_with_at(line, pos, "f+") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fadd", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f-") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fsub", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f*") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fmul", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f/") { let w = push_double_marker(str_sb, dest); same_mapping(llvm_gen_float_binop("fdiv", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f<=") { same_mapping(llvm_gen_float_cmp("ole", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f>=") { same_mapping(llvm_gen_float_cmp("oge", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f<") { same_mapping(llvm_gen_float_cmp("olt", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f>") { same_mapping(llvm_gen_float_cmp("ogt", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "f==") { same_mapping(llvm_gen_float_cmp("oeq", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "f!=") { same_mapping(llvm_gen_float_cmp("one", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "+") { llvm_gen_add_with_strings_sb(line, pos + 1, dest, mapping, str_sb) }
    else if low_starts_with_at(line, pos, "-") { llvm_gen_binop_sb("sub", "fsub", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "*") { llvm_gen_binop_sb("mul", "fmul", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "/") { llvm_gen_binop_sb("sdiv", "fdiv", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "%") { same_mapping(llvm_gen_binop("srem", line, pos + 1, dest)) }
    else if low_starts_with_at(line, pos, "bxor") { same_mapping(llvm_gen_binop("xor", line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "band") { same_mapping(llvm_gen_binop("and", line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "bor") { same_mapping(llvm_gen_binop("or", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "bnot") { same_mapping(llvm_gen_bnot(line, pos + 4, dest)) }
    else if low_starts_with_at(line, pos, "<<") { same_mapping(llvm_gen_binop("shl", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, ">>") { same_mapping(llvm_gen_binop("ashr", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "<=") { llvm_gen_cmp_sb("sle", "ole", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, ">=") { llvm_gen_cmp_sb("sge", "oge", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "<") { llvm_gen_cmp_sb("slt", "olt", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, ">") { llvm_gen_cmp_sb("sgt", "ogt", line, pos + 1, dest, str_sb) }
    else if low_starts_with_at(line, pos, "==") { llvm_gen_cmp_with_strings_sb("eq", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "!=") { llvm_gen_cmp_with_strings_sb("ne", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "and") { same_mapping(llvm_gen_binop("and", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "or") { same_mapping(llvm_gen_binop("or", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "not") { same_mapping(llvm_gen_not(line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "neg") { llvm_gen_neg_sb(line, pos + 3, dest, str_sb) }
    else if low_starts_with_at(line, pos, "phi") { llvm_gen_phi_with_strings_sb(line, pos, dest, str_sb) }
    else if low_starts_with_at(line, pos, "call") { llvm_gen_call_with_string_tracking_sb_reg(line, pos, dest, str_sb, string_fns, registry) }
    else if low_starts_with_at(line, pos, "mutex-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "thread-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "arc-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "atomic-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "channel-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "sender-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "rwlock-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "barrier-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "condvar-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "block-on") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "async-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "thread-pool-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "scope-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "gep") { llvm_gen_gep_sb(line, pos + 3, dest, str_sb) }
    else if low_starts_with_at(line, pos, "load_ptr") { llvm_gen_load_ptr_sb(line, pos + 8, dest, str_sb) }
    else if low_starts_with_at(line, pos, "store_ptr") { llvm_gen_store_ptr_sb(line, pos + 9, str_sb) }
    else if low_starts_with_at(line, pos, "nullable_select") { same_mapping(llvm_gen_nullable_select(line, pos + 15, dest)) }
    else if low_starts_with_at(line, pos, "select") { same_mapping(llvm_gen_select(line, pos + 6, dest)) }
    // v0.95: closure_new @fn, count, %cap0, ... — allocate closure struct
    else if low_starts_with_at(line, pos, "closure_new") {
        llvm_gen_closure_new_sb(line, pos + 11, dest, mapping, str_sb)
    }
    // v0.95: closure_load %__closure, N — load capture from closure struct
    else if low_starts_with_at(line, pos, "closure_load") {
        same_mapping(llvm_gen_closure_load(line, pos + 12, dest))
    }
    // v0.95: fn_ref @name — get function pointer as i64
    else if low_starts_with_at(line, pos, "fn_ref") {
        let name_start = low_skip_ws(line, pos + 6);
        let fn_name = trim_end(line.slice(name_start, line.len()));
        same_mapping("  " + dest + " = ptrtoint ptr " + fn_name + " to i64")
    }
    else { same_mapping("  ; unknown: " + line) };

fn llvm_gen_nullable_select(line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let recv = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let default_val = trim_end(line.slice(p2, line.len()));
    "  " + dest + "_ns = icmp ne i64 " + recv + ", 0|  " + dest + " = select i1 " + dest + "_ns, i64 " + recv + ", i64 " + default_val;

fn llvm_gen_select(line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma1 = find_comma(line, p1);
    let cond = trim_end(line.slice(p1, comma1));
    let p2 = low_skip_ws(line, comma1 + 1);
    let comma2 = find_comma(line, p2);
    let val_true = trim_end(line.slice(p2, comma2));
    let p3 = low_skip_ws(line, comma2 + 1);
    let val_false = trim_end(line.slice(p3, line.len()));
    // Same-value select: skip trunc+select, just assign
    if val_true == val_false { "  " + dest + " = add nsw i64 0, " + val_true }
    else { "  " + dest + "_s = trunc i64 " + cond + " to i1|  " + dest + " = select i1 " + dest + "_s, i64 " + val_true + ", i64 " + val_false };

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_add_struct_aware(line: String, pos: i64, dest: String, mapping: String, str_sb: i64, struct_reg: String, ptr_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let right = trim_end(line.slice(p2, line.len()));
    // Check if left operand is a struct pointer
    let left_struct = get_struct_ptr_type(left, ptr_sb);
    if left_struct != "" {
        // Struct pointer arithmetic: emit GEP with struct type for proper scaling
        let struct_type = build_struct_gep_type(struct_reg, left_struct);
        let conv = "  " + left + "_p0 = inttoptr i64 " + left + " to ptr";
        let gep = "  " + dest + "_gep = getelementptr " + struct_type + ", ptr " + left + "_p0, i64 " + right;
        let to_int = "  " + dest + " = ptrtoint ptr " + dest + "_gep to i64";
        // Propagate struct pointer type to dest
        let _w = push_ptr_marker(ptr_sb, dest, left_struct);
        same_mapping(conv + "|" + gep + "|" + to_int)
    } else {
        // Regular integer add - delegate to existing handler
        llvm_gen_add_with_strings_sb(line, pos, dest, mapping, str_sb)
    };

fn llvm_gen_copy_struct_aware(line: String, pos: i64, dest: String, mapping: String, str_sb: i64, ptr_sb: i64, registry: String) -> String =
    let src_start = low_skip_ws(line, pos + 4);
    let src = trim_end(line.slice(src_start, line.len()));
    // Propagate struct pointer type through copy
    let src_struct = get_struct_ptr_type(src, ptr_sb);
    let _w = if src_struct != "" { push_ptr_marker(ptr_sb, dest, src_struct) } else { 0 };
    // Delegate to existing copy handler in the struct-aware path
    // Re-dispatch through the main RHS handler for proper string/double tracking
    llvm_gen_rhs_with_strings_map_and_fns_reg(line, pos, dest, "", "", mapping, str_sb, registry);

fn llvm_gen_call_struct_aware(line: String, pos: i64, dest: String, strings: String, string_fns: String, mapping: String, str_sb: i64, registry: String, ptr_sb: i64) -> String =
    // v0.95: Check for indirect call (function pointer in variable or parameter)
    let call_fn = extract_call_fn_name(line, pos);
    let var_name = "%" + call_fn;
    let resolved = resolve_variable(var_name, mapping);
    if resolved == "ALLOCA" {
        // v0.95: Uniform closure call — all ALLOCA indirect calls use closure protocol
        llvm_gen_indirect_call(line, pos, dest, var_name, str_sb)
    } else if is_i64_param_sb(var_name, str_sb) {
        // v0.95: Uniform closure call — all param indirect calls use closure protocol
        llvm_gen_indirect_call_param(line, pos, dest, var_name, str_sb)
    } else {
    // First delegate to existing call handler for proper codegen
    let result = llvm_gen_rhs_with_strings_map_and_fns_reg(line, pos, dest, strings, string_fns, mapping, str_sb, registry);
    // Check if the called function returns a struct pointer
    // Extract function name from MIR: "call @fn_name(...)"
    let call_start = low_skip_ws(line, pos + 4);
    let fn_name_end = find_fn_name_end(line, call_start);
    let fn_name = line.slice(call_start, fn_name_end);
    // Look up the function's return type in MIR (from the MIR function headers)
    // For now, use the ptr_sb to check if any param or call result has been marked
    // The function name should have been registered with its ptr return type
    let fn_ret_struct = get_fn_ptr_return_type(fn_name, ptr_sb);
    let _w = if fn_ret_struct != "" { push_ptr_marker(ptr_sb, dest, fn_ret_struct) } else { 0 };
    result
    };

// v0.95: Generate indirect call through function pointer stored in alloca variable
// MIR: %_tN = call @var_name(args) → loads from alloca, inttoptr, indirect call
fn llvm_gen_indirect_call(line: String, pos: i64, dest: String, var_name: String, str_sb: i64) -> String =
    // Parse args from MIR line: %_tN = call @name(arg1, arg2, ...)
    let at_pos = find_char(line, pos, 64);
    let paren_pos = find_char(line, at_pos, 40);
    let close_pos = find_char(line, paren_pos, 41);
    let args = line.slice(paren_pos + 1, close_pos);
    // v0.95: Uniform closure protocol — load struct, extract fn_ptr, pass closure as first arg
    let cl_tmp = dest + "_cl";
    let env_tmp = dest + "_envp";
    let fni_tmp = dest + "_fni";
    let ptr_tmp = dest + "_fptr";
    let load_ir = "  " + cl_tmp + " = load i64, ptr " + var_name;
    let env_ir = "  " + env_tmp + " = inttoptr i64 " + cl_tmp + " to ptr";
    let fni_ir = "  " + fni_tmp + " = load i64, ptr " + env_tmp;
    let cast_ir = "  " + ptr_tmp + " = inttoptr i64 " + fni_tmp + " to ptr";
    let formatted_args = format_indirect_call_args(args, 0, "", str_sb);
    let all_args = "i64 " + cl_tmp + (if formatted_args == "" { "" } else { ", " + formatted_args });
    let call_ir = "  " + dest + " = call i64 " + ptr_tmp + "(" + all_args + ")";
    same_mapping(load_ir + "|" + env_ir + "|" + fni_ir + "|" + cast_ir + "|" + call_ir);

// v0.95: Indirect call through function pointer parameter — uniform closure protocol
fn llvm_gen_indirect_call_param(line: String, pos: i64, dest: String, var_name: String, str_sb: i64) -> String =
    let at_pos = find_char(line, pos, 64);
    let paren_pos = find_char(line, at_pos, 40);
    let close_pos = find_char(line, paren_pos, 41);
    let args = line.slice(paren_pos + 1, close_pos);
    // v0.95: Uniform closure protocol — extract fn_ptr from struct, pass closure as first arg
    let env_tmp = dest + "_envp";
    let fni_tmp = dest + "_fni";
    let ptr_tmp = dest + "_fptr";
    let env_ir = "  " + env_tmp + " = inttoptr i64 " + var_name + " to ptr";
    let fni_ir = "  " + fni_tmp + " = load i64, ptr " + env_tmp;
    let cast_ir = "  " + ptr_tmp + " = inttoptr i64 " + fni_tmp + " to ptr";
    let formatted_args = format_indirect_call_args(args, 0, "", str_sb);
    let all_args = "i64 " + var_name + (if formatted_args == "" { "" } else { ", " + formatted_args });
    let call_ir = "  " + dest + " = call i64 " + ptr_tmp + "(" + all_args + ")";
    same_mapping(env_ir + "|" + fni_ir + "|" + cast_ir + "|" + call_ir);

// Format arguments for indirect function call: %_t0 → i64 %_t0
fn format_indirect_call_args(args: String, pos: i64, acc: String, str_sb: i64) -> String =
    let p = low_skip_ws(args, pos);
    if p >= args.len() { acc }
    else {
        let comma = find_comma_or_end(args, p);
        let arg = trim_end(args.slice(p, comma));
        let arg_is_double = is_double_var_sb(arg, str_sb);
        let typed_arg = if arg_is_double { "double " + arg } else { "i64 " + arg };
        let new_acc = if acc == "" { typed_arg } else { acc + ", " + typed_arg };
        if comma >= args.len() { new_acc } else { format_indirect_call_args(args, comma + 1, new_acc, str_sb) }
    };

// v0.95: Generate closure allocation — malloc struct, store fn_ptr + captures
// MIR: closure_new @fn_name, count, %cap0, %cap1, ...
fn llvm_gen_closure_new_sb(line: String, pos: i64, dest: String, mapping: String, str_sb: i64) -> String =
    // pos points right after "closure_new"
    let p = low_skip_ws(line, pos);
    let at_pos = p + 1;
    let comma1 = find_comma(line, at_pos);
    let fn_name = "@" + trim(line.slice(at_pos, comma1));
    let count_start = low_skip_ws(line, comma1 + 1);
    let comma2 = find_comma_or_end(line, count_start);
    let count_str = trim(line.slice(count_start, comma2));
    let cap_count = parse_int_from(count_str, 0, 0);
    let struct_size = (2 + cap_count) * 8;
    let csb = sb_new();
    // 1. Get fn pointer as i64
    let w1 = sb_push(csb, "  " + dest + "_fn = ptrtoint ptr " + fn_name + " to i64");
    // 2. Allocate struct
    let w2 = sb_push(csb, "|  " + dest + "_env = call noalias ptr @malloc(i64 " + int_to_string(struct_size) + ")");
    // 3. Store fn pointer at offset 0
    let w3 = sb_push(csb, "|  store i64 " + dest + "_fn, ptr " + dest + "_env");
    // 4. Store count at offset 1
    let w4 = sb_push(csb, "|  " + dest + "_cnp = getelementptr i64, ptr " + dest + "_env, i32 1");
    let w5 = sb_push(csb, "|  store i64 " + int_to_string(cap_count) + ", ptr " + dest + "_cnp");
    // 5. Store each capture
    let caps_start = if comma2 >= line.len() { line.len() } else { comma2 + 1 };
    let w6 = gen_closure_cap_stores(line, caps_start, dest, mapping, csb, 0, cap_count);
    // 6. Convert struct ptr to i64
    let w7 = sb_push(csb, "|  " + dest + " = ptrtoint ptr " + dest + "_env to i64");
    // Mark as closure in str_sb
    let w8 = push_closure_marker(str_sb, dest, cap_count);
    let ir = sb_build(csb);
    same_mapping(ir);

fn gen_closure_cap_stores(line: String, pos: i64, dest: String, mapping: String, csb: i64, idx: i64, count: i64) -> i64 =
    if idx >= count { 0 }
    else {
        let p = low_skip_ws(line, pos);
        let comma = find_comma_or_end(line, p);
        let cap_var = trim(line.slice(p, comma));
        let resolved = resolve_variable(cap_var, mapping);
        let cap_val = if resolved == "ALLOCA" {
            let val_tmp = dest + "_cv" + int_to_string(idx);
            let w = sb_push(csb, "|  " + val_tmp + " = load i64, ptr " + cap_var);
            val_tmp
        } else { resolved };
        let offset = idx + 2;
        let w1 = sb_push(csb, "|  " + dest + "_cp" + int_to_string(idx) + " = getelementptr i64, ptr " + dest + "_env, i32 " + int_to_string(offset));
        let w2 = sb_push(csb, "|  store i64 " + cap_val + ", ptr " + dest + "_cp" + int_to_string(idx));
        let next_pos = if comma >= line.len() { line.len() } else { comma + 1 };
        gen_closure_cap_stores(line, next_pos, dest, mapping, csb, idx + 1, count)
    };

// v0.95: Load a capture from __closure struct: closure_load %__closure, N
fn llvm_gen_closure_load(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let comma = find_comma(line, p);
    let closure_var = trim(line.slice(p, comma));
    let idx_start = low_skip_ws(line, comma + 1);
    let idx_str = trim_end(line.slice(idx_start, line.len()));
    let idx = parse_int_from(idx_str, 0, 0);
    let offset = idx + 2;
    let ptr_tmp = dest + "_p";
    let gep_tmp = dest + "_g";
    "  " + ptr_tmp + " = inttoptr i64 " + closure_var + " to ptr|  " + gep_tmp + " = getelementptr i64, ptr " + ptr_tmp + ", i32 " + int_to_string(offset) + "|  " + dest + " = load i64, ptr " + gep_tmp;

fn find_fn_name_end(line: String, pos: i64) -> i64 =
    if pos >= line.len() { pos }
    else if line.byte_at(pos) == 40 { pos }  // '('
    else { find_fn_name_end(line, pos + 1) };

// This looks in ptr_sb for "F:@fn_name:StructName," entries
fn get_fn_ptr_return_type(fn_name: String, ptr_sb: i64) -> String =
    let content = sb_build(ptr_sb);
    get_fn_ptr_return_from(fn_name, content, 0);

fn get_fn_ptr_return_from(fn_name: String, content: String, pos: i64) -> String =
    if pos >= content.len() { "" } else {
        let comma_pos = find_comma_or_end(content, pos);
        let entry = content.slice(pos, comma_pos);
        // Entry format: "F:@fn_name:StructName"
        if entry.len() >= 4 and entry.byte_at(0) == 70 and entry.byte_at(1) == 58 {
            let after_f = 2;
            let second_colon = find_char_from(entry, after_f, 58);
            if second_colon < entry.len() {
                let entry_fn = entry.slice(after_f, second_colon);
                let entry_struct = entry.slice(second_colon + 1, entry.len());
                if entry_fn == fn_name { entry_struct }
                else if comma_pos >= content.len() { "" }
                else { get_fn_ptr_return_from(fn_name, content, comma_pos + 1) }
            }
            else if comma_pos >= content.len() { "" }
            else { get_fn_ptr_return_from(fn_name, content, comma_pos + 1) }
        }
        else if comma_pos >= content.len() { "" }
        else { get_fn_ptr_return_from(fn_name, content, comma_pos + 1) }
    };

// MIR: %dest = field-access %base.fieldname
// LLVM: %dest_ptr = getelementptr i64, ptr %base, i32 field_index
//       %dest = load i64, ptr %dest_ptr
fn llvm_gen_field_access(line: String, pos: i64, dest: String, struct_reg: String, str_sb: i64, ptr_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    // Find dot separator in %base.field
    let dot_pos = find_char(line, p1, 46);
    let base = trim_end(line.slice(p1, dot_pos));
    let field = trim_end(line.slice(dot_pos + 1, line.len()));
    let field_idx = if field.len() > 0 and is_digit(field.byte_at(0)) { parse_int_simple(field, 0, 0) } else { lookup_field_by_name(struct_reg, field) };
    let field_is_dbl = is_field_f64(struct_reg, field);
    let load_type = if field_is_dbl == 1 { "double" } else { "i64" };
    // Mark result as double if f64 field
    let _dm = if field_is_dbl == 1 { push_double_marker(str_sb, dest) } else { 0 };
    let field_ptr = get_field_ptr_from_registry(struct_reg, field);
    let _pm = if field_ptr != "" { push_ptr_marker(ptr_sb, dest, field_ptr) } else { 0 };
    let ptr_name = dest + "_ptr";
    let conv = "  " + base + "_p = inttoptr i64 " + base + " to ptr";
    let gep_line = "  " + ptr_name + " = getelementptr i64, ptr " + base + "_p, i32 " + i2s(field_idx);
    let load_line = "  " + dest + " = load " + load_type + ", ptr " + ptr_name;
    same_mapping(conv + "|" + gep_line + "|" + load_line);

fn lookup_field_by_name(registry: String, field_name: String) -> i64 =
    lookup_field_by_name_at(registry, 0, field_name);

fn lookup_field_by_name_at(registry: String, pos: i64, field_name: String) -> i64 =
    if pos >= registry.len() { 0 } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let fields = entry.slice(colon_pos + 1, entry.len());
        let idx = find_field_index_or_neg(fields, 0, 0, field_name);
        if idx >= 0 { idx }
        else if semi_pos + 1 >= registry.len() { 0 }
        else { lookup_field_by_name_at(registry, semi_pos + 1, field_name) }
    };

fn find_field_index_or_neg(fields: String, pos: i64, idx: i64, target: String) -> i64 =
    if pos >= fields.len() { 0 - 1 } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        // Strip ~d suffix for comparison
        let name = strip_type_suffix(raw_name);
        if name == target { idx }
        else if comma_pos >= fields.len() { 0 - 1 }
        else { find_field_index_or_neg(fields, comma_pos + 1, idx + 1, target) }
    };

// Strip ~d type suffix from field name
fn strip_type_suffix(name: String) -> String =
    let tilde_pos = find_char(name, 0, 126);
    if tilde_pos < name.len() { name.slice(0, tilde_pos) } else { name };

// Check if a field is f64 by looking up in registry
fn is_field_f64(registry: String, field_name: String) -> i64 =
    is_field_f64_at(registry, 0, field_name);

fn is_field_f64_at(registry: String, pos: i64, field_name: String) -> i64 =
    if pos >= registry.len() { 0 } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let fields = entry.slice(colon_pos + 1, entry.len());
        let result = check_field_is_f64(fields, 0, field_name);
        if result >= 0 { result }
        else if semi_pos + 1 >= registry.len() { 0 }
        else { is_field_f64_at(registry, semi_pos + 1, field_name) }
    };

// Search fields for name and check if it has ~d suffix. Returns 1 if f64, 0 if found not f64, -1 if not found
fn check_field_is_f64(fields: String, pos: i64, target: String) -> i64 =
    if pos >= fields.len() { 0 - 1 } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        let name = strip_type_suffix(raw_name);
        if name == target {
            let suffix = if raw_name.len() > name.len() { raw_name.slice(name.len(), raw_name.len()) } else { "" };
            if suffix == "~d" { 1 } else { 0 }
        }
        else if comma_pos >= fields.len() { 0 - 1 }
        else { check_field_is_f64(fields, comma_pos + 1, target) }
    };

fn get_field_ptr_from_registry(registry: String, field_name: String) -> String =
    get_field_ptr_from_registry_at(registry, 0, field_name);

fn get_field_ptr_from_registry_at(registry: String, pos: i64, field_name: String) -> String =
    if pos >= registry.len() { "" } else {
        let semi_pos = find_char(registry, pos, 59);
        let entry = registry.slice(pos, semi_pos);
        let colon_pos = find_char(entry, 0, 58);
        let fields = entry.slice(colon_pos + 1, entry.len());
        let result = check_field_ptr_type(fields, 0, field_name);
        if result != "" { result }
        else if semi_pos + 1 >= registry.len() { "" }
        else { get_field_ptr_from_registry_at(registry, semi_pos + 1, field_name) }
    };

// Search fields for name and extract ~p-StructName. Returns struct name or ""
fn check_field_ptr_type(fields: String, pos: i64, target: String) -> String =
    if pos >= fields.len() { "" } else {
        let comma_pos = find_comma_or_end(fields, pos);
        let raw_name = fields.slice(pos, comma_pos);
        let name = strip_type_suffix(raw_name);
        if name == target {
            let suffix = if raw_name.len() > name.len() { raw_name.slice(name.len(), raw_name.len()) } else { "" };
            // Check for ~p- prefix (at least 4 chars: ~p-X)
            if suffix.len() >= 4 and suffix.byte_at(0) == 126 and suffix.byte_at(1) == 112 and suffix.byte_at(2) == 45 {
                suffix.slice(3, suffix.len())
            } else { "" }
        }
        else if comma_pos >= fields.len() { "" }
        else { check_field_ptr_type(fields, comma_pos + 1, target) }
    };

// MIR: field-store %base.fieldname, %value
// LLVM: %_fst_N_p = inttoptr i64 %base to ptr
//       %_fst_N_ptr = getelementptr i64, ptr %_fst_N_p, i32 field_index
//       store i64 %value, ptr %_fst_N_ptr
fn llvm_gen_field_store(line: String, pos: i64, struct_reg: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    // Find dot separator in %base.field
    let dot_pos = find_char(line, p1, 46);
    let base = trim_end(line.slice(p1, dot_pos));
    // Find comma separator between base.field and value
    let comma_pos = find_comma(line, dot_pos);
    let field = trim_end(line.slice(dot_pos + 1, comma_pos));
    let p2 = low_skip_ws(line, comma_pos + 1);
    let value = trim_end(line.slice(p2, line.len()));
    // Look up field index
    let field_idx = lookup_field_by_name(struct_reg, field);
    let prefix = base + "_fs" + i2s(field_idx);
    let conv = "  " + prefix + "_p = inttoptr i64 " + base + " to ptr";
    let gep_line = "  " + prefix + "_ptr = getelementptr i64, ptr " + prefix + "_p, i32 " + i2s(field_idx);
    let is_dbl_val = is_double_var_sb(value, str_sb);
    let is_dbl_field = is_field_f64(struct_reg, field);
    let is_dbl = if is_dbl_val { 1 } else { is_dbl_field };
    let store_type = if is_dbl == 1 { "double" } else { "i64" };
    let store_line = "  store " + store_type + " " + value + ", ptr " + prefix + "_ptr";
    same_mapping(conv + "|" + gep_line + "|" + store_line);

// Add a string marker to the mapping: "S:varname" (prepend for O(1) recent lookup)
fn push_string_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "S:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

fn is_string_var_sb(varname: String, str_sb: i64) -> bool =
    let marker = "S:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

fn push_double_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "D:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

fn is_double_var_sb(varname: String, str_sb: i64) -> bool =
    let marker = "D:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

fn is_f64_ptr_sb(varname: String, str_sb: i64) -> bool =
    let marker = "F:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

fn push_f64_ptr_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "F:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

// v0.95: Check if variable is an i64 function parameter (for indirect call detection)
fn is_i64_param_sb(varname: String, str_sb: i64) -> bool =
    let marker = "P:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

// v0.95: Check if variable is marked as i32 in SB
fn is_i32_var_sb(varname: String, str_sb: i64) -> bool =
    let marker = "W:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

// v0.95: Mark variable as i32 in SB
fn push_i32_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "W:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

fn is_str_ptr_sb(varname: String, str_sb: i64) -> bool =
    let marker = "R:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

fn push_str_ptr_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "R:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

// v0.95: Closure variable markers — CN:%varname, where N is capture count
fn is_closure_var_sb(varname: String, str_sb: i64) -> bool =
    check_closure_marker(varname, str_sb, 9);

fn check_closure_marker(varname: String, str_sb: i64, n: i64) -> bool =
    if n <= 0 { false }
    else {
        let marker = "C" + int_to_string(n) + ":" + varname + ",";
        if bmb_sb_contains(str_sb, marker) > 0 { true }
        else { check_closure_marker(varname, str_sb, n - 1) }
    };

fn get_closure_cap_count_sb(varname: String, str_sb: i64) -> i64 =
    find_closure_count(varname, str_sb, 9);

fn find_closure_count(varname: String, str_sb: i64, n: i64) -> i64 =
    if n <= 0 { 0 }
    else {
        let marker = "C" + int_to_string(n) + ":" + varname + ",";
        if bmb_sb_contains(str_sb, marker) > 0 { n }
        else { find_closure_count(varname, str_sb, n - 1) }
    };

fn push_closure_marker(str_sb: i64, name: String, count: i64) -> i64 =
    let w1 = sb_push(str_sb, "C");
    let w2 = sb_push(str_sb, int_to_string(count));
    let w3 = sb_push(str_sb, ":");
    let w4 = sb_push(str_sb, name);
    sb_push(str_sb, ",");

// "mark_f64_ptr" = 12 chars, then space, then %varname starts at p+13
fn llvm_handle_mark_f64_ptr(line: String, p: i64, str_sb: i64) -> String =
    let varname = trim_end(line.slice(p + 13, line.len()));
    let w = push_f64_ptr_marker(str_sb, varname);
    same_mapping("");

// "mark_str_ptr" = 12 chars, then space, then %varname starts at p+13
fn llvm_handle_mark_str_ptr(line: String, p: i64, str_sb: i64) -> String =
    let varname = trim_end(line.slice(p + 13, line.len()));
    let w = push_str_ptr_marker(str_sb, varname);
    same_mapping("");

fn llvm_gen_cmp_with_strings_sb(pred: String, line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_cmp_with_strings_sb_2(pred, line, pos, dest, str_sb, left, comma);

fn llvm_gen_cmp_with_strings_sb_2(pred: String, line: String, pos: i64, dest: String, str_sb: i64, left: String, comma: i64) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_cmp_with_strings_sb_3(pred, line, pos, dest, str_sb, left_trimmed, right_trimmed);

fn llvm_gen_cmp_with_strings_sb_3(pred: String, line: String, pos: i64, dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_sb(left_trimmed, str_sb);
    let right_is_string = is_string_var_sb(right_trimmed, str_sb);
    if left_is_string or right_is_string {
        // Reuse existing string cmp (mapping param unused for string cmp result - it returns same_mapping)
        llvm_gen_string_cmp(pred, left_trimmed, right_trimmed, dest, "")
    } else {
        let left_is_double = is_double_var_sb(left_trimmed, str_sb);
        let right_is_double = is_double_var_sb(right_trimmed, str_sb);
        if left_is_double or right_is_double {
            let float_pred = if pred == "eq" { "oeq" } else { "one" };
            same_mapping("  " + dest + "_cmp = fcmp " + float_pred + " double " + left_trimmed + ", " + right_trimmed + "|  " + dest + " = zext i1 " + dest + "_cmp to i64")
        } else {
            same_mapping(llvm_gen_cmp(pred, line, pos, dest))
        }
    };

fn llvm_gen_add_with_strings_sb(line: String, pos: i64, dest: String, mapping: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_add_with_strings_sb_2(line, pos, dest, mapping, str_sb, p1, comma, left);

fn llvm_gen_add_with_strings_sb_2(line: String, pos: i64, dest: String, mapping: String, str_sb: i64, p1: i64, comma: i64, left: String) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_add_with_strings_sb_3(dest, mapping, str_sb, left_trimmed, right_trimmed);

fn llvm_gen_add_with_strings_sb_3(dest: String, mapping: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_sb(left_trimmed, str_sb);
    let right_is_string = is_string_var_sb(right_trimmed, str_sb);
    if left_is_string or right_is_string {
        llvm_gen_add_string_concat_sb(dest, str_sb, left_trimmed, right_trimmed)
    } else {
        let left_is_double = is_double_var_sb(left_trimmed, str_sb);
        let right_is_double = is_double_var_sb(right_trimmed, str_sb);
        if left_is_double or right_is_double {
            let w = push_double_marker(str_sb, dest);
            same_mapping("  " + dest + " = fadd double " + left_trimmed + ", " + right_trimmed)
        } else {
            same_mapping("  " + dest + " = add nsw i64 " + left_trimmed + ", " + right_trimmed)
        }
    };

fn llvm_gen_add_string_concat_sb(dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let lptr = dest + "_l";
    let rptr = dest + "_r";
    let cptr = dest + "_c";
    llvm_gen_add_string_concat_sb_2(dest, str_sb, left_trimmed, right_trimmed, lptr, rptr, cptr);

fn llvm_gen_add_string_concat_sb_2(dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String, lptr: String, rptr: String, cptr: String) -> String =
    let line1 = "  " + lptr + " = inttoptr i64 " + left_trimmed + " to ptr";
    let line2 = "  " + rptr + " = inttoptr i64 " + right_trimmed + " to ptr";
    let line3 = "  " + cptr + " = call ptr @bmb_string_concat(ptr " + lptr + ", ptr " + rptr + ")";
    let line4 = "  " + dest + " = ptrtoint ptr " + cptr + " to i64";
    let w = push_string_marker(str_sb, dest);
    same_mapping(line1 + "|" + line2 + "|" + line3 + "|" + line4);

// Checks if operands are double-marked; if so, emits float op instead
fn llvm_gen_binop_sb(int_op: String, float_op: String, line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let right = trim_end(line.slice(p2, line.len()));
    let left_is_double = is_double_var_sb(left, str_sb);
    let right_is_double = is_double_var_sb(right, str_sb);
    if left_is_double or right_is_double {
        let w = push_double_marker(str_sb, dest);
        same_mapping("  " + dest + " = " + float_op + " double " + left + ", " + right)
    } else {
        let op_with_nsw = if int_op == "add" { "add nsw" } else if int_op == "sub" { "sub nsw" } else if int_op == "mul" { "mul nsw" } else { int_op };
        same_mapping("  " + dest + " = " + op_with_nsw + " i64 " + left + ", " + right)
    };

// Checks if operands are double-marked; if so, emits fcmp instead of icmp
fn llvm_gen_cmp_sb(int_pred: String, float_pred: String, line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = trim_end(line.slice(p1, comma));
    let p2 = low_skip_ws(line, comma + 1);
    let right = trim_end(line.slice(p2, line.len()));
    let left_is_double = is_double_var_sb(left, str_sb);
    let right_is_double = is_double_var_sb(right, str_sb);
    if left_is_double or right_is_double {
        same_mapping("  " + dest + "_cmp = fcmp " + float_pred + " double " + left + ", " + right + "|  " + dest + " = zext i1 " + dest + "_cmp to i64")
    } else {
        same_mapping("  " + dest + "_cmp = icmp " + int_pred + " i64 " + left + ", " + right + "|  " + dest + " = zext i1 " + dest + "_cmp to i64")
    };

fn llvm_gen_neg_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p = low_skip_ws(line, pos);
    let operand = trim_end(line.slice(p, line.len()));
    let is_double = is_double_var_sb(operand, str_sb);
    if is_double {
        let w = push_double_marker(str_sb, dest);
        same_mapping("  " + dest + " = fneg double " + operand)
    } else {
        same_mapping("  " + dest + " = sub nsw i64 0, " + operand)
    };

fn llvm_gen_phi_with_strings_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let first_val = extract_phi_val(first_content);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    let second_val = extract_phi_val(second_content);
    let first_is_string = is_string_var_sb(first_val, str_sb);
    let second_is_string = is_string_var_sb(second_val, str_sb);
    let first_is_double = is_double_var_sb(first_val, str_sb);
    let second_is_double = is_double_var_sb(second_val, str_sb);
    let w = if first_is_string or second_is_string { push_string_marker(str_sb, dest) }
            else if first_is_double or second_is_double { push_double_marker(str_sb, dest) }
            else { 0 };
    if first_is_double or second_is_double {
        same_mapping(llvm_gen_phi_typed(line, pos, dest, "f64"))
    } else {
        same_mapping(llvm_gen_phi(line, pos, dest))
    };

fn llvm_gen_call_with_string_tracking_sb_reg(line: String, pos: i64, dest: String, str_sb: i64, string_fns: String, registry: String) -> String =
    let llvm_code = llvm_gen_call_reg(line, pos, dest, registry);
    let fn_name = extract_call_fn_name(line, pos);
    let is_hardcoded_string_fn = is_string_returning_fn(fn_name);
    let is_dynamic_string_fn_result = is_dynamic_string_fn(fn_name, string_fns);
    let is_string_fn = is_hardcoded_string_fn or is_dynamic_string_fn_result;
    let ret_type = lookup_fn_ret(registry, fn_name);
    let is_double_fn = ret_type == "double" or is_builtin_double_fn(fn_name);
    // v0.95: Track i32-returning functions
    let is_i32_fn = ret_type == "i32";
    let w = if is_string_fn { push_string_marker(str_sb, dest) }
            else if is_double_fn { push_double_marker(str_sb, dest) }
            else if is_i32_fn { push_i32_marker(str_sb, dest) }
            else { 0 };
    same_mapping(llvm_code);

fn is_builtin_double_fn(name: String) -> bool =
    name == "sqrt" or name == "i64_to_f64" or name == "sin" or name == "cos" or name == "tan" or name == "atan" or name == "atan2" or name == "log" or name == "log2" or name == "log10" or name == "exp" or name == "fmod" or name == "pow_f64" or
    name == "bmb_f64_floor" or name == "bmb_f64_ceil" or name == "bmb_f64_round" or
    name == "bmb_f64_sqrt" or name == "bmb_f64_abs" or
    name == "bmb_f64_min" or name == "bmb_f64_max" or name == "parse_f64" or
    name == "fabs" or name == "floor" or name == "ceil" or name == "round";

// Check if a variable is marked as a string in the mapping

fn llvm_gen_string_cmp(pred: String, left: String, right: String, dest: String, mapping: String) -> String =
    let lptr = dest + "_lp";
    let rptr = dest + "_rp";
    let eq_dest = dest + "_streq";
    let conv_l = "  " + lptr + " = inttoptr i64 " + left + " to ptr";
    llvm_gen_string_cmp_2(pred, right, dest, mapping, lptr, rptr, eq_dest, conv_l);

fn llvm_gen_string_cmp_2(pred: String, right: String, dest: String, mapping: String, lptr: String, rptr: String, eq_dest: String, conv_l: String) -> String =
    let conv_r = "  " + rptr + " = inttoptr i64 " + right + " to ptr";
    let call_ln = "  " + eq_dest + " = call i64 @bmb_string_eq(ptr " + lptr + ", ptr " + rptr + ")";
    let cmp_ln = "  " + dest + "_cmp = icmp ne i64 " + eq_dest + ", 0";
    llvm_gen_string_cmp_3(pred, dest, mapping, conv_l, conv_r, call_ln, cmp_ln);

fn llvm_gen_string_cmp_3(pred: String, dest: String, mapping: String, conv_l: String, conv_r: String, call_ln: String, cmp_ln: String) -> String =
    let res_ln = "  " + dest + " = zext i1 " + dest + "_cmp to i64";
    if pred == "ne" {
        let inv_cmp = "  " + dest + "_cmp = icmp eq i64 " + dest + "_streq, 0";
        same_mapping(conv_l + "|" + conv_r + "|" + call_ln + "|" + inv_cmp + "|" + res_ln)
    } else {
        same_mapping(conv_l + "|" + conv_r + "|" + call_ln + "|" + cmp_ln + "|" + res_ln)
    };

// Track string-returning function calls


fn is_string_returning_fn(name: String) -> bool =
    is_string_fn_group1(name) or is_string_fn_group2(name) or is_string_fn_group3(name) or
    is_string_fn_group4(name) or is_string_fn_group5(name);

fn is_string_fn_group1(name: String) -> bool =
    name == "get_node_type" or name == "get_child" or name == "extract_name" or
    name == "bmb_string_slice" or name == "bmb_string_concat" or
    name == "bmb_string_from_cstr" or name == "bmb_chr" or name == "bmb_read_file" or
    name == "bmb_getenv" or name == "get_arg" or name == "int_to_string" or
    name == "chr" or name == "slice" or name == "concat" or
    name == "concat3" or name == "concat5" or name == "concat7" or
    name == "bmb_string_concat3" or name == "bmb_string_concat5" or name == "bmb_string_concat7";

fn is_string_fn_group2(name: String) -> bool =
    name == "sb_build" or name == "digit_char" or name == "escape_parens" or
    name == "unescape_parens_from_ast" or name == "extract_string_content" or
    name == "get_fn_return_type" or name == "collect_params" or name == "get_fn_body" or
    name == "lower_function_sb" or name == "lower_program_sb" or
    name == "compile_function" or name == "compile_source";

fn is_string_fn_group3(name: String) -> bool =
    name == "parse_source" or name == "gen_function" or name == "gen_program" or
    name == "tokenize" or name == "read_file" or name == "make_error" or
    name == "gen_module_header" or name == "gen_runtime_decls" or
    name == "gen_string_globals" or name == "gen_program_sb_with_strings" or
    name == "collect_strings_from_mir" or name == "compile_program";

fn is_string_fn_group4(name: String) -> bool =
    name == "gen_extern_println" or name == "gen_extern_print_str" or
    name == "llvm_gen_binop" or name == "llvm_gen_cmp" or name == "llvm_gen_call" or
    name == "llvm_gen_not" or name == "llvm_gen_neg" or name == "llvm_gen_phi" or
    name == "llvm_gen_branch" or name == "llvm_gen_goto" or name == "llvm_gen_return_typed" or
    name == "llvm_gen_string_ref" or name == "llvm_gen_line_with_ret";

fn is_string_fn_group5(name: String) -> bool =
    name == "llvm_gen_assign_typed" or name == "llvm_gen_rhs_typed" or
    name == "gen_function_lines_typed" or name == "gen_function_sb_typed" or
    name == "llvm_gen_fn_line_typed" or name == "llvm_gen_fn_header" or
    name == "gen_all_externs" or name == "pack_result" or name == "unpack_ast" or
    name == "make_step" or name == "make_work" or name == "make_work3" or name == "make_work4" or
    name == "step_work" or name == "get_field" or name == "trim_end" or name == "i2s" or
    name == "sb_build" or name == "pack_lower_result" or name == "unescape_parens";

// Extract function name from call instruction
fn extract_call_fn_name(line: String, pos: i64) -> String =
    let after_call = low_skip_ws(line, pos + 4);
    let at_pos = if line.byte_at(after_call) == 64 { after_call + 1 } else { after_call };
    let paren_pos = find_char(line, at_pos, 40);
    if paren_pos > at_pos { line.slice(at_pos, paren_pos) } else { "" };

// Check if a variable name is a user variable (not %_t)
// v0.92: Fixed to handle short names like %i (len=2) - they ARE user vars
fn is_user_variable(name: String) -> bool =
    if name.len() < 2 { false }
    else if name.len() == 2 { true }
    else {
        let after_pct = name.byte_at(1);
        // User vars don't start with _t after the %
        not (after_pct == 95 and name.byte_at(2) == 116)
    };

// Resolve a variable using the mapping
fn resolve_variable(varname: String, mapping: String) -> String =
    if not is_user_variable(varname) { varname }
    else { lookup_mapping(mapping, varname, varname) };

// Look up a variable in the mapping, return default if not found
fn lookup_mapping(mapping: String, name: String, default_val: String) -> String =
    if mapping == "" { default_val }
    else { lookup_mapping_at(mapping, name, 0, default_val) };

fn lookup_mapping_at(mapping: String, name: String, pos: i64, default_val: String) -> String =
    if pos >= mapping.len() { default_val }
    else {
        let comma = find_comma_or_end(mapping, pos);
        let colon = find_char(mapping, pos, 58);
        if colon - pos == name.len() and match_bytes(mapping, name, pos, 0) {
            mapping.slice(colon + 1, comma)
        } else if comma >= mapping.len() { default_val }
        else { lookup_mapping_at(mapping, name, comma + 1, default_val) }
    };

// Add a name:value pair to the mapping (prepend for O(1) recent lookup)
fn add_mapping(mapping: String, name: String, value: String) -> String =
    let entry = name + ":" + value;
    if mapping == "" { entry } else { entry + "," + mapping };

fn same_mapping(llvm_line: String) -> String = llvm_line;
fn same_mapping_empty() -> String = "";
fn changed_mapping(new_mapping: String, llvm_line: String) -> String =
    "!" + int_to_string(new_mapping.len()) + ":" + new_mapping + llvm_line;
fn changed_mapping_empty(new_mapping: String) -> String =
    "!" + int_to_string(new_mapping.len()) + ":" + new_mapping;

fn extract_new_mapping(result: String) -> String =
    let colon_pos = find_char(result, 1, 58);
    let map_len = parse_len_at(result, 1, colon_pos);
    result.slice(colon_pos + 1, colon_pos + 1 + map_len);

fn extract_new_llvm_line(result: String) -> String =
    let colon_pos = find_char(result, 1, 58);
    let map_len = parse_len_at(result, 1, colon_pos);
    result.slice(colon_pos + 1 + map_len, result.len());

fn parse_len_at(s: String, start: i64, end_pos: i64) -> i64 =
    parse_len_acc(s, start, end_pos, 0);

fn parse_len_acc(s: String, pos: i64, end_pos: i64, acc: i64) -> i64 =
    if pos >= end_pos { acc }
    else { parse_len_acc(s, pos + 1, end_pos, acc * 10 + s.byte_at(pos) - 48) };

// Extract single operand from "opcode %operand" format
// pos points to start of operand (after opcode + whitespace)
fn conc_extract_single_op(line: String, pos: i64) -> String =
    trim_end(line.slice(pos, line.len()));

// Extract two space-separated operands: "%op1 %op2"
fn conc_extract_two_ops_first(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    line.slice(pos, sp);

fn conc_extract_two_ops_second(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp + 1);
    trim_end(line.slice(p2, line.len()));

// Extract three space-separated operands: "%op1 %op2 %op3"
fn conc_extract_three_first(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    line.slice(pos, sp);

fn conc_extract_three_second(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    line.slice(p2, sp2);

fn conc_extract_three_third(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    let p3 = low_skip_ws(line, sp2 + 1);
    trim_end(line.slice(p3, line.len()));

// Extract four space-separated operands


fn conc_gen_call_i64_1(dest: String, fn_name: String, op: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op + ")";

// Generate i64 call with 2 args
fn conc_gen_call_i64_2(dest: String, fn_name: String, op1: String, op2: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ")";

// Generate i64 call with 3 args
fn conc_gen_call_i64_3(dest: String, fn_name: String, op1: String, op2: String, op3: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ", i64 " + op3 + ")";

// Generate void call with 1 arg
fn conc_gen_call_void_1(fn_name: String, op: String) -> String =
    "  call void @" + fn_name + "(i64 " + op + ")";

// Generate void call with 2 args
fn conc_gen_call_void_2(fn_name: String, op1: String, op2: String) -> String =
    "  call void @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ")";

// Generate i64 call with 0 args
fn conc_gen_call_i64_0(dest: String, fn_name: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "()";

// Input: line is full MIR line, pos points to start of RHS (after "= "), dest is "%varname"
fn llvm_gen_conc_rhs(line: String, pos: i64, dest: String) -> String =
    // Thread operations
    if low_starts_with_at(line, pos, "thread-spawn") {
        // Phase 1: synchronous. %dest = thread-spawn func(captures...)
        // The first capture is the pre-computed result
        let after = low_skip_ws(line, pos + 12);
        let paren = find_char(line, after, 40);
        let args_start = paren + 1;
        let args_end = find_char(line, args_start, 41);
        let args = line.slice(args_start, args_end);
        let first_arg = if args.len() > 0 {
            let c = find_comma_or_end(args, 0);
            trim_end(args.slice(0, c))
        } else { "0" };
        "  ; Phase 1: ThreadSpawn - body executed synchronously|  " + dest + " = add i64 " + first_arg + ", 0"
    } else if low_starts_with_at(line, pos, "thread-join") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        "  ; Phase 1: ThreadJoin - handle is the result|  " + dest + " = add i64 " + op + ", 0"
    }
    // Mutex operations
    else if low_starts_with_at(line, pos, "mutex-new") {
        let op_start = low_skip_ws(line, pos + 9);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_new", op))
    } else if low_starts_with_at(line, pos, "mutex-try-lock") {
        let op_start = low_skip_ws(line, pos + 14);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_try_lock", op))
    } else if low_starts_with_at(line, pos, "mutex-lock") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_lock", op))
    }
    // Arc operations
    else if low_starts_with_at(line, pos, "arc-new") {
        let op_start = low_skip_ws(line, pos + 7);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_new", op))
    } else if low_starts_with_at(line, pos, "arc-clone") {
        let op_start = low_skip_ws(line, pos + 9);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_clone", op))
    } else if low_starts_with_at(line, pos, "arc-get") {
        let op_start = low_skip_ws(line, pos + 7);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_get", op))
    } else if low_starts_with_at(line, pos, "arc-strong-count") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_strong_count", op))
    }
    // Atomic operations
    else if low_starts_with_at(line, pos, "atomic-new") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        // Allocate heap memory for atomic, store value, return as i64 ptr
        "  " + dest + "_ptr = call ptr @malloc(i64 8)|  store atomic i64 " + op + ", ptr " + dest + "_ptr seq_cst, align 8|  " + dest + " = ptrtoint ptr " + dest + "_ptr to i64"
    } else if low_starts_with_at(line, pos, "atomic-load") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op + " to ptr|  " + dest + " = load atomic i64, ptr " + dest + "_ptr seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-fetch-add") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw add ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-fetch-sub") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw sub ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-swap") {
        let op_start = low_skip_ws(line, pos + 11);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw xchg ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-cmpxchg") {
        let op_start = low_skip_ws(line, pos + 14);
        let op1 = conc_extract_three_first(line, op_start);
        let op2 = conc_extract_three_second(line, op_start);
        let op3 = conc_extract_three_third(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + "_result = cmpxchg ptr " + dest + "_ptr, i64 " + op2 + ", i64 " + op3 + " seq_cst seq_cst, align 8|  " + dest + " = extractvalue { i64, i1 } " + dest + "_result, 0"
    }
    // Channel operations (assignment form)
    else if low_starts_with_at(line, pos, "channel-recv-timeout") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_alloc = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_recv_timeout(i64 " + op1 + ", i64 " + op2 + ", ptr " + dest + "_alloc)|  " + dest + "_loaded = load i64, ptr " + dest + "_alloc|  " + dest + "_is_success = icmp ne i64 " + dest + "_success, 0|  " + dest + " = select i1 " + dest + "_is_success, i64 " + dest + "_loaded, i64 -1"
    } else if low_starts_with_at(line, pos, "channel-recv-opt") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_ptr = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_recv_opt(i64 " + op + ", ptr " + dest + "_ptr)|  " + dest + "_tmp = load i64, ptr " + dest + "_ptr|  " + dest + "_cond = icmp eq i64 " + dest + "_success, 1|  " + dest + " = select i1 " + dest + "_cond, i64 " + dest + "_tmp, i64 -1"
    } else if low_starts_with_at(line, pos, "channel-recv") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_channel_recv", op))
    } else if low_starts_with_at(line, pos, "channel-try-send") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_channel_try_send", op1, op2))
    } else if low_starts_with_at(line, pos, "channel-try-recv") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_alloc = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_try_recv(i64 " + op + ", ptr " + dest + "_alloc)|  " + dest + " = load i64, ptr " + dest + "_alloc"
    } else if low_starts_with_at(line, pos, "channel-send-timeout") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_three_first(line, op_start);
        let op2 = conc_extract_three_second(line, op_start);
        let op3 = conc_extract_three_third(line, op_start);
        same_mapping(conc_gen_call_i64_3(dest, "bmb_channel_send_timeout", op1, op2, op3))
    } else if low_starts_with_at(line, pos, "channel-is-closed") {
        let op_start = low_skip_ws(line, pos + 17);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_channel_is_closed", op))
    } else if low_starts_with_at(line, pos, "sender-clone") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_sender_clone", op))
    }
    // RwLock operations
    else if low_starts_with_at(line, pos, "rwlock-new") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_new", op))
    } else if low_starts_with_at(line, pos, "rwlock-read") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_read", op))
    } else if low_starts_with_at(line, pos, "rwlock-write") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_write", op))
    }
    // Barrier operations
    else if low_starts_with_at(line, pos, "barrier-new") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_barrier_new", op))
    } else if low_starts_with_at(line, pos, "barrier-wait") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_barrier_wait", op))
    }
    // Condvar operations
    else if low_starts_with_at(line, pos, "condvar-new") {
        same_mapping(conc_gen_call_i64_0(dest, "bmb_condvar_new"))
    } else if low_starts_with_at(line, pos, "condvar-wait") {
        let op_start = low_skip_ws(line, pos + 12);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_condvar_wait", op1, op2))
    }
    // Block-on
    else if low_starts_with_at(line, pos, "block-on") {
        let op_start = low_skip_ws(line, pos + 8);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_block_on", op))
    }
    // Async I/O operations
    else if low_starts_with_at(line, pos, "async-file-open") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_file_open", op))
    } else if low_starts_with_at(line, pos, "async-file-read") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_file_read", op))
    } else if low_starts_with_at(line, pos, "async-socket-connect") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_async_socket_connect", op1, op2))
    } else if low_starts_with_at(line, pos, "async-socket-read") {
        let op_start = low_skip_ws(line, pos + 17);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_socket_read", op))
    }
    // ThreadPool
    else if low_starts_with_at(line, pos, "thread-pool-new") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_thread_pool_new", op))
    }
    // Scope
    else if low_starts_with_at(line, pos, "scope-new") {
        same_mapping(conc_gen_call_i64_0(dest, "bmb_scope_new"))
    }
    // Unknown concurrency instruction
    else { same_mapping("  ; unknown-conc: " + line) };

// Handles MIR lines like "mutex-unlock %h = %v", "channel-send %s %v", etc.
fn llvm_gen_conc_stmt(line: String, p: i64) -> String =
    if low_starts_with_at(line, p, "mutex-unlock") {
        // mutex-unlock %handle = %value
        let op_start = low_skip_ws(line, p + 12);
        let eq_pos = find_eq(line, op_start);
        let handle = trim_end(line.slice(op_start, eq_pos - 1));
        let val_start = low_skip_ws(line, eq_pos + 1);
        let value = trim_end(line.slice(val_start, line.len()));
        conc_gen_call_void_2("bmb_mutex_unlock", handle, value)
    } else if low_starts_with_at(line, p, "mutex-free") {
        let op_start = low_skip_ws(line, p + 10);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_mutex_free", op)
    } else if low_starts_with_at(line, p, "arc-drop") {
        let op_start = low_skip_ws(line, p + 8);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_arc_drop", op)
    } else if low_starts_with_at(line, p, "atomic-store") {
        // atomic-store %ptr = %value
        let op_start = low_skip_ws(line, p + 12);
        let eq_pos = find_eq(line, op_start);
        let ptr_op = trim_end(line.slice(op_start, eq_pos - 1));
        let val_start = low_skip_ws(line, eq_pos + 1);
        let value = trim_end(line.slice(val_start, line.len()));
        "  %_atomic_store_ptr = inttoptr i64 " + ptr_op + " to ptr|  store atomic i64 " + value + ", ptr %_atomic_store_ptr seq_cst, align 8"
    } else if low_starts_with_at(line, p, "channel-send") {
        let op_start = low_skip_ws(line, p + 12);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_channel_send", op1, op2)
    } else if low_starts_with_at(line, p, "channel-close") {
        let op_start = low_skip_ws(line, p + 13);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_channel_close", op)
    } else if low_starts_with_at(line, p, "rwlock-read-unlock") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_rwlock_read_unlock", op)
    } else if low_starts_with_at(line, p, "rwlock-write-unlock") {
        let op_start = low_skip_ws(line, p + 19);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_rwlock_write_unlock", op1, op2)
    } else if low_starts_with_at(line, p, "condvar-notify-one") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_condvar_notify_one", op)
    } else if low_starts_with_at(line, p, "condvar-notify-all") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_condvar_notify_all", op)
    } else if low_starts_with_at(line, p, "async-file-write") {
        let op_start = low_skip_ws(line, p + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_async_file_write", op1, op2)
    } else if low_starts_with_at(line, p, "async-file-close") {
        let op_start = low_skip_ws(line, p + 16);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_async_file_close", op)
    } else if low_starts_with_at(line, p, "async-socket-write") {
        let op_start = low_skip_ws(line, p + 18);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_async_socket_write", op1, op2)
    } else if low_starts_with_at(line, p, "async-socket-close") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_async_socket_close", op)
    } else if low_starts_with_at(line, p, "thread-pool-execute") {
        let op_start = low_skip_ws(line, p + 19);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_thread_pool_execute", op1, op2)
    } else if low_starts_with_at(line, p, "thread-pool-join") {
        let op_start = low_skip_ws(line, p + 16);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_thread_pool_join", op)
    } else if low_starts_with_at(line, p, "thread-pool-shutdown") {
        let op_start = low_skip_ws(line, p + 20);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_thread_pool_shutdown", op)
    } else if low_starts_with_at(line, p, "scope-spawn") {
        let op_start = low_skip_ws(line, p + 11);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_scope_spawn", op1, op2)
    } else if low_starts_with_at(line, p, "scope-wait") {
        let op_start = low_skip_ws(line, p + 10);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_scope_wait", op)
    } else if low_starts_with_at(line, p, "thread-join") {
        // thread-join without dest (discard result)
        let op_start = low_skip_ws(line, p + 11);
        let op = conc_extract_single_op(line, op_start);
        "  call i64 @bmb_thread_join(i64 " + op + ")"
    } else { "  ; unknown-conc-stmt: " + line };

fn llvm_gen_channel_new(line: String, p: i64) -> String =
    // Parse: (%sender, %receiver) = channel-new %capacity
    let p1 = p + 1;
    let comma = find_comma(line, p1);
    let sender_dest = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let rparen = find_char(line, p2, 41);
    let receiver_dest = line.slice(p2, rparen);
    let eq_pos = find_eq(line, rparen + 1);
    let rhs_start = low_skip_ws(line, eq_pos + 1);
    // Skip "channel-new"
    let cap_start = low_skip_ws(line, rhs_start + 11);
    let cap = trim_end(line.slice(cap_start, line.len()));
    // Generate alloca + call + load
    "  " + sender_dest + "_alloc = alloca i64, align 8|  " + receiver_dest + "_alloc = alloca i64, align 8|  call void @bmb_channel_new(i64 " + cap + ", ptr " + sender_dest + "_alloc, ptr " + receiver_dest + "_alloc)|  " + sender_dest + " = load i64, ptr " + sender_dest + "_alloc|  " + receiver_dest + " = load i64, ptr " + receiver_dest + "_alloc";

// Legacy versions for compatibility


fn llvm_gen_string_ref(dest: String, str_content: String, strings: String) -> String =
    let idx = find_string_index(strings, str_content);
    let idx_str = int_to_string(idx);
    "  " + dest + " = ptrtoint ptr @str_bmb_" + idx_str + " to i64";

// ============================================================================
// SECTION 13: Unified Compiler Entry Point (v0.10.9)
// ============================================================================

// Compile BMB source code to LLVM IR module
// Returns complete LLVM IR module text with:
// - Module header
// - Runtime declarations
// - Function definitions
fn compile_program(source: String) -> String =
    let ast_raw = parse_source(source);
    if is_error(ast_raw) { "ERR:PARSE:" + ast_raw.slice(4, ast_raw.len()) } else {
        let enum_reg = build_enum_registry(source);
        let ast = resolve_enum_variants_in_ast(ast_raw, enum_reg);
        let struct_reg = build_struct_registry(source);
        let mir_raw = lower_program_sb(ast);
        if mir_raw == "" { "ERR:LOWERING:empty" } else {
            let mir1 = optimize_const_inlining(mir_raw);
            let mir = optimize_cf_dce_loop(mir1, 0);
            let header = gen_module_header();
            let decls = gen_runtime_decls();
            let strings = collect_strings_from_mir(mir);
            let string_globals = gen_string_globals(strings);
            let string_fns = collect_string_fns_from_mir(mir);
            let code = gen_program_sb_with_strings_fns_structs(mir, strings, string_fns, struct_reg);
            // with chained string concat on large strings
            let base = header + "|";
            let base2 = base + decls;
            // Build with_globals without nesting
            let base3 = base2 + "|";
            let base4 = base3 + string_globals;
            let with_globals = if string_globals == "" { base2 } else { base4 };
            let final1 = with_globals + "||";
            // v0.95: Append metadata for !invariant.load on string struct loads
            let module_ir = final1 + code + "||!0 = !{}";
            eliminate_dead_functions_ir(module_ir)
        }
    };

// Compile single function source to LLVM IR
fn is_compile_error(result: String) -> bool =
    result.len() >= 4 and result.slice(0, 4) == "ERR:";

fn err_no_file(input: String) -> i64 =
    { print_str("Error: Cannot read file: "); println_str(input); 1 };

fn print_compile_err(input: String, llvm: String) -> i64 =
    let end = if llvm.len() > 500 { 500 } else { llvm.len() };
    let err_detail = llvm.slice(4, end);
    { print_str("error["); print_str(input); print_str("]: "); println_str(err_detail); 1 };

// ============================================================================
// SECTION 14: Test Utilities
// ============================================================================


// v0.88: Emit LLVM IR to file
// Note: Full native build requires external tools (opt, clang)
// Use golden-bootstrap.sh for complete native compilation
fn emit_ir(input: String, output: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            print_compile_err(input, llvm)
        } else {
            let w1 = write_file_newlines(output, llvm);
            { print_str("Wrote: "); println_str(output); 0 }
        }
    };

// ============================================================================
// SECTION: Index command - extract function signatures for AI tooling (v0.95)
// ============================================================================

// Extract contract text from source between pos and '=' sign
// Returns "pre <expr>" and/or "post <expr>" text, or "" if no contracts
fn extract_contract_text(src: String, pos: i64) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() { "" }
    else if k == TK_PRE() {
        let expr_start = tok_end(t);
        let re = parse_expr(src, expr_start);
        if is_error(re) { "" }
        else {
            let expr_text = src.slice(expr_start, unpack_pos(re));
            let rest = extract_contract_text(src, unpack_pos(re));
            if rest == "" { "pre " + trim_ws(expr_text) }
            else { "pre " + trim_ws(expr_text) + " " + rest }
        }
    }
    else if k == TK_POST() {
        let expr_start = tok_end(t);
        let re = parse_expr(src, expr_start);
        if is_error(re) { "" }
        else {
            let expr_text = src.slice(expr_start, unpack_pos(re));
            let rest = extract_contract_text(src, unpack_pos(re));
            if rest == "" { "post " + trim_ws(expr_text) }
            else { "post " + trim_ws(expr_text) + " " + rest }
        }
    }
    else { "" };

// Trim leading/trailing whitespace from a string
fn trim_ws(s: String) -> String =
    let start = trim_ws_start(s, 0);
    let end_pos = trim_ws_end(s, s.len());
    if start >= end_pos { "" } else { s.slice(start, end_pos) };

fn trim_ws_start(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if is_whitespace(s.byte_at(pos)) { trim_ws_start(s, pos + 1) }
    else { pos };

fn trim_ws_end(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if is_whitespace(s.byte_at(pos - 1)) { trim_ws_end(s, pos - 1) }
    else { pos };

// Extract a single parameter as "name: type" text
fn index_parse_param_text(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_COLON() {
            let type_start = tok_end(t2);
            let type_text = index_read_type_text(src, type_start);
            pack_result(unpack_pos(type_text), name + ": " + unpack_ast(type_text))
        } else { pack_result(tok_end(t1), name) }
    } else { pack_result(tok_end(t1), "?") };

// Read type text (i32, i64, f64, bool, String, *T, [T], [T;N])
fn index_read_type_text(src: String, pos: i64) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_I32() { pack_result(skip_nullable_idx(src, tok_end(t)), "i32") }
    else if k == TK_I64() { pack_result(skip_nullable_idx(src, tok_end(t)), "i64") }
    else if k == TK_F64() { pack_result(skip_nullable_idx(src, tok_end(t)), "f64") }
    else if k == TK_BOOL() { pack_result(skip_nullable_idx(src, tok_end(t)), "bool") }
    else if k == TK_STRING_TYPE() { pack_result(skip_nullable_idx(src, tok_end(t)), "String") }
    else if k == TK_STAR() {
        let inner = index_read_type_text(src, tok_end(t));
        pack_result(unpack_pos(inner), "*" + unpack_ast(inner))
    }
    else if k == TK_LBRACKET() {
        let end_bracket = index_skip_to_bracket(src, tok_end(t));
        pack_result(skip_nullable_idx(src, end_bracket), "[..]")
    }
    else if k == TK_IDENT() {
        let name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
        pack_result(skip_nullable_idx(src, tok_end(t)), name)
    }
    else { pack_result(tok_end(t), "?") };

// Skip to closing bracket
fn index_skip_to_bracket(src: String, pos: i64) -> i64 =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RBRACKET() { tok_end(t) }
    else if tok_kind(t) == TK_EOF() { pos }
    else { index_skip_to_bracket(src, tok_end(t)) };

// Skip nullable ? suffix for index type reading
fn skip_nullable_idx(src: String, pos: i64) -> i64 =
    let p = skip_ws_comments(src, pos);
    if p < src.len() and src.byte_at(p) == 63 { p + 1 } else { p };

// Collect parameters as comma-separated text
fn index_collect_params(src: String, pos: i64, acc: String) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_RPAREN() { pack_result(tok_end(t), acc) }
    else {
        let rp = index_parse_param_text(src, pos);
        if is_error(rp) { pack_result(pos, acc) }
        else {
            let new_acc = if acc == "" { unpack_ast(rp) } else { acc + ", " + unpack_ast(rp) };
            let next = next_token_raw(src, unpack_pos(rp));
            if tok_kind(next) == TK_COMMA() { index_collect_params(src, tok_end(next), new_acc) }
            else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) }
            else { pack_result(unpack_pos(rp), new_acc) }
        }
    };

// Extract return type text
fn index_read_ret_type(src: String, pos: i64) -> String =
    let t = next_token_raw(src, pos);
    if tok_kind(t) == TK_ARROW() {
        index_read_type_text(src, tok_end(t))
    } else { pack_result(pos, "?") };

// Check if position marks the start of a new top-level declaration (fn, struct, @, EOF)
fn index_is_decl_start(src: String, pos: i64) -> bool =
    let ann = skip_annotation(src, pos);
    if ann.len() > 0 { true }
    else {
        let tok = next_token_raw(src, pos);
        let k = tok_kind(tok);
        k == TK_FN() or k == TK_STRUCT() or k == TK_EOF() or k == TK_PUB() or k == TK_TYPE() or k == TK_ENUM() or k == TK_TRAIT() or k == TK_IMPL() or k == TK_CONST()
    };

// Skip past a function body, stop when next top-level declaration starts
fn index_skip_body(src: String, pos: i64, depth: i64) -> i64 =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EOF() { pos }
    else if k == TK_SEMI() and depth == 0 {
        // Check if next thing is a new declaration
        if index_is_decl_start(src, tok_end(t)) { tok_end(t) }
        else { index_skip_body(src, tok_end(t), depth) }
    }
    else if k == TK_LBRACE() or k == TK_LPAREN() or k == TK_LBRACKET() {
        index_skip_body(src, tok_end(t), depth + 1)
    }
    else if k == TK_RBRACE() or k == TK_RPAREN() or k == TK_RBRACKET() {
        if depth > 0 { index_skip_body(src, tok_end(t), depth - 1) }
        else { index_skip_body(src, tok_end(t), 0) }
    }
    else { index_skip_body(src, tok_end(t), depth) };

// Check if a name already exists in a comma-separated list
fn index_has_name(list: String, name: String) -> bool =
    if list == "" { false }
    else if list == name { true }
    else { index_has_name_search(list, name, 0) };

fn index_has_name_search(list: String, name: String, pos: i64) -> bool =
    if pos >= list.len() { false }
    else {
        // Find next comma or end
        let end_pos = index_find_comma_or_end(list, pos);
        let segment = list.slice(pos, end_pos);
        if segment == name { true }
        else if end_pos >= list.len() { false }
        else { index_has_name_search(list, name, end_pos + 2) }  // skip ", "
    };

fn index_find_comma_or_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 44 { pos }  // comma
    else { index_find_comma_or_end(s, pos + 1) };

// Scan function body and collect called function names
// Returns packed: "pos:calls_string"
fn index_scan_body(src: String, pos: i64, depth: i64, calls: String, prev_was_dot: bool) -> String =
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EOF() { pack_result(pos, calls) }
    else if k == TK_SEMI() and depth == 0 {
        // Check if next thing is a new declaration (end of function body)
        if index_is_decl_start(src, tok_end(t)) { pack_result(tok_end(t), calls) }
        else { index_scan_body(src, tok_end(t), depth, calls, false) }
    }
    else if k == TK_LBRACE() or k == TK_LPAREN() or k == TK_LBRACKET() {
        index_scan_body(src, tok_end(t), depth + 1, calls, false)
    }
    else if k == TK_RBRACE() or k == TK_RPAREN() or k == TK_RBRACKET() {
        if depth > 0 { index_scan_body(src, tok_end(t), depth - 1, calls, false) }
        else { index_scan_body(src, tok_end(t), 0, calls, false) }
    }
    else if k == TK_DOT() {
        index_scan_body(src, tok_end(t), depth, calls, true)
    }
    else if k == TK_IDENT() {
        // Check if next token is LPAREN (function call)
        let next = next_token_raw(src, tok_end(t));
        if tok_kind(next) == TK_LPAREN() and not prev_was_dot {
            // This is a function call, not a method call
            let call_name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
            // Add to calls if not already present and not a keyword
            let new_calls = if index_has_name(calls, call_name) { calls }
                           else if calls == "" { call_name }
                           else { calls + ", " + call_name };
            index_scan_body(src, tok_end(t), depth, new_calls, false)
        } else {
            index_scan_body(src, tok_end(t), depth, calls, false)
        }
    }
    else { index_scan_body(src, tok_end(t), depth, calls, false) };

// Process one function: extract signature, calls, and print it, return position after function
fn index_one_fn(src: String, pos: i64, ann: String) -> i64 =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LPAREN() {
            let params = index_collect_params(src, tok_end(t2), "");
            let params_text = unpack_ast(params);
            let rtype = index_read_ret_type(src, unpack_pos(params));
            let ret_text = unpack_ast(rtype);
            let ret_pos = unpack_pos(rtype);
            // Extract contracts before = sign
            let contracts = extract_contract_text(src, ret_pos);
            // Print the function signature
            let prefix = if ann == "" { "" } else { "@" + ann + " " };
            let sig = prefix + "fn " + name + "(" + params_text + ") -> " + ret_text;
            let _p1 = if contracts == "" { println_str(sig) }
                       else { println_str(sig + " | " + contracts) };
            // Scan body for function calls
            let eq_pos = skip_contracts(src, ret_pos);
            let body_result = index_scan_body(src, eq_pos, 0, "", false);
            let calls = unpack_ast(body_result);
            let _p2 = if calls != "" { println_str("  calls: " + calls) } else { println_str("") };
            unpack_pos(body_result)
        } else { tok_end(t1) }
    } else { tok_end(t1) };

// Walk source and extract all function signatures
// Extract struct field as "name: type" text
fn index_struct_field(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() or kind == TK_EOF() { pack_result(pos, "") }
    else if kind == TK_IDENT() {
        let field_name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) == TK_COLON() {
            let type_result = index_read_type_text(src, tok_end(t2));
            pack_result(unpack_pos(type_result), field_name + ": " + unpack_ast(type_result))
        } else { pack_result(tok_end(tok), field_name) }
    }
    else { pack_result(tok_end(tok), "") };

// Collect all struct fields as comma-separated text
fn index_struct_fields(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), acc) }
    else if kind == TK_EOF() { pack_result(pos, acc) }
    else {
        let field_result = index_struct_field(src, pos);
        let field_text = unpack_ast(field_result);
        let field_end = unpack_pos(field_result);
        if field_text == "" {
            // Skip non-field tokens (commas, etc.)
            index_struct_fields(src, tok_end(tok), acc)
        } else {
            let new_acc = if acc == "" { field_text } else { acc + ", " + field_text };
            // Skip comma if present
            let next = next_token_raw(src, field_end);
            if tok_kind(next) == TK_COMMA() { index_struct_fields(src, tok_end(next), new_acc) }
            else { index_struct_fields(src, field_end, new_acc) }
        }
    };

// Index a struct declaration: print "struct Name { fields }"
fn index_one_struct(src: String, pos: i64) -> i64 =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LBRACE() {
            let fields = index_struct_fields(src, tok_end(t2), "");
            let _p = println_str("struct " + name + " { " + unpack_ast(fields) + " }");
            unpack_pos(fields)
        } else {
            let _p = println_str("struct " + name);
            tok_end(t1)
        }
    } else { tok_end(t1) };

// Walk source and extract all function signatures and struct definitions
// Returns packed count: fn_count * 10000 + struct_count
fn index_source(src: String, pos: i64, fn_count: i64, struct_count: i64) -> i64 =
    let ann = skip_annotation(src, pos);
    if ann.len() > 0 {
        let after_ann = pos_after_annotation(src, pos);
        let tok = next_token_raw(src, after_ann);
        if tok_kind(tok) == TK_FN() {
            let next_pos = index_one_fn(src, tok_end(tok), ann);
            index_source(src, next_pos, fn_count + 1, struct_count)
        } else { index_source(src, tok_end(tok), fn_count, struct_count) }
    } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() { fn_count * 10000 + struct_count }
        else if kind == TK_FN() {
            let next_pos = index_one_fn(src, tok_end(tok), "");
            index_source(src, next_pos, fn_count + 1, struct_count)
        }
        else if kind == TK_STRUCT() {
            let end_pos = index_one_struct(src, tok_end(tok));
            index_source(src, end_pos, fn_count, struct_count + 1)
        }
        else { index_source(src, tok_end(tok), fn_count, struct_count) }
    };

// Index file: read source and extract all function signatures
fn index_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Index: " + input);
        let counts = index_source(source, 0, 0, 0);
        let fn_count = counts / 10000;
        let struct_count = counts - fn_count * 10000;
        let _sep = println_str("---");
        let _s1 = println_str("# Summary: " + int_to_string(fn_count) + " functions, " + int_to_string(struct_count) + " structs");
        0
    };

// v0.95: Query command - search functions by name pattern
// Returns packed "pos:matched" where matched = 1 if printed, 0 if skipped
fn query_one_fn(src: String, pos: i64, ann: String, pattern: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LPAREN() {
            let params = index_collect_params(src, tok_end(t2), "");
            let params_text = unpack_ast(params);
            let rtype = index_read_ret_type(src, unpack_pos(params));
            let ret_text = unpack_ast(rtype);
            let ret_pos = unpack_pos(rtype);
            let contracts = extract_contract_text(src, ret_pos);
            let eq_pos = skip_contracts(src, ret_pos);
            let body_result = index_scan_body(src, eq_pos, 0, "", false);
            let calls = unpack_ast(body_result);
            let body_end = unpack_pos(body_result);
            // Check if name matches pattern (substring match, or * for all)
            if pattern == "*" or has_pattern(name, pattern, 0) {
                let prefix = if ann == "" { "" } else { "@" + ann + " " };
                let sig = prefix + "fn " + name + "(" + params_text + ") -> " + ret_text;
                let _p1 = if contracts == "" { println_str(sig) }
                           else { println_str(sig + " | " + contracts) };
                let _p2 = if calls != "" { println_str("  calls: " + calls) } else { println_str("") };
                pack_result(body_end, "1")
            } else { pack_result(body_end, "0") }
        } else { pack_result(tok_end(t1), "0") }
    } else { pack_result(tok_end(t1), "0") };

// Query structs: print if name matches pattern
fn query_one_struct(src: String, pos: i64, pattern: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
        if pattern == "*" or has_pattern(name, pattern, 0) {
            let t2 = next_token_raw(src, tok_end(t1));
            if tok_kind(t2) == TK_LBRACE() {
                let fields = index_struct_fields(src, tok_end(t2), "");
                let _p = println_str("struct " + name + " { " + unpack_ast(fields) + " }");
                pack_result(unpack_pos(fields), "1")
            } else {
                let _p = println_str("struct " + name);
                pack_result(tok_end(t1), "1")
            }
        } else {
            // Skip struct body without printing
            let t2 = next_token_raw(src, tok_end(t1));
            if tok_kind(t2) == TK_LBRACE() {
                let end_pos = index_skip_body(src, tok_end(t2), 1);
                pack_result(end_pos, "0")
            } else { pack_result(tok_end(t1), "0") }
        }
    } else { pack_result(tok_end(t1), "0") };

// Walk source and query matching functions/structs
// Returns match_count
fn query_source(src: String, pos: i64, pattern: String, match_count: i64) -> i64 =
    let ann = skip_annotation(src, pos);
    if ann.len() > 0 {
        let after_ann = pos_after_annotation(src, pos);
        let tok = next_token_raw(src, after_ann);
        if tok_kind(tok) == TK_FN() {
            let result = query_one_fn(src, tok_end(tok), ann, pattern);
            let matched = if unpack_ast(result) == "1" { 1 } else { 0 };
            query_source(src, unpack_pos(result), pattern, match_count + matched)
        } else { query_source(src, tok_end(tok), pattern, match_count) }
    } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() { match_count }
        else if kind == TK_FN() {
            let result = query_one_fn(src, tok_end(tok), "", pattern);
            let matched = if unpack_ast(result) == "1" { 1 } else { 0 };
            query_source(src, unpack_pos(result), pattern, match_count + matched)
        }
        else if kind == TK_STRUCT() {
            let result = query_one_struct(src, tok_end(tok), pattern);
            let matched = if unpack_ast(result) == "1" { 1 } else { 0 };
            query_source(src, unpack_pos(result), pattern, match_count + matched)
        }
        else { query_source(src, tok_end(tok), pattern, match_count) }
    };

// Query file: search functions/structs by name pattern
fn query_file(input: String, pattern: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Query: \"" + pattern + "\" in " + input);
        let match_count = query_source(source, 0, pattern, 0);
        let _sep = println_str("---");
        let _s = println_str("# Matches: " + int_to_string(match_count));
        0
    };

// v0.95: Callers command - reverse call graph (who calls a given function)
// Collect one function's name and calls as "name\tcalls_csv\n"
fn callers_collect_fn(src: String, pos: i64, ann: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = src.slice(skip_ws_comments(src, pos), scan_ident_end(src, skip_ws_comments(src, pos)));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LPAREN() {
            let params = index_collect_params(src, tok_end(t2), "");
            let rtype = index_read_ret_type(src, unpack_pos(params));
            let ret_pos = unpack_pos(rtype);
            let eq_pos = skip_contracts(src, ret_pos);
            let body_result = index_scan_body(src, eq_pos, 0, "", false);
            let calls = unpack_ast(body_result);
            let prefix = if ann == "" { "" } else { "@" + ann + " " };
            let sig = prefix + "fn " + name + "(" + unpack_ast(params) + ") -> " + unpack_ast(rtype);
            pack_result(unpack_pos(body_result), name + "\t" + calls + "\t" + sig)
        } else { pack_result(tok_end(t1), "") }
    } else { pack_result(tok_end(t1), "") };

// Walk source collecting all function entries as "name\tcalls\tsig\n" strings
fn callers_collect_source(src: String, pos: i64, acc: String) -> String =
    let ann = skip_annotation(src, pos);
    if ann.len() > 0 {
        let after_ann = pos_after_annotation(src, pos);
        let tok = next_token_raw(src, after_ann);
        if tok_kind(tok) == TK_FN() {
            let result = callers_collect_fn(src, tok_end(tok), ann);
            let entry = unpack_ast(result);
            let new_acc = if entry == "" { acc } else { acc + entry + "\n" };
            callers_collect_source(src, unpack_pos(result), new_acc)
        } else { callers_collect_source(src, tok_end(tok), acc) }
    } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() { acc }
        else if kind == TK_FN() {
            let result = callers_collect_fn(src, tok_end(tok), "");
            let entry = unpack_ast(result);
            let new_acc = if entry == "" { acc } else { acc + entry + "\n" };
            callers_collect_source(src, unpack_pos(result), new_acc)
        }
        else { callers_collect_source(src, tok_end(tok), acc) }
    };

// Extract tab-separated field from entry: field 0 = name, 1 = calls, 2 = sig
fn callers_get_field(ent: String, field: i64, pos: i64, cur_field: i64) -> String =
    if pos >= ent.len() {
        if cur_field == field { ent.slice(callers_field_start(ent, field, 0, 0), ent.len()) }
        else { "" }
    }
    else if ent.byte_at(pos) == 9 {  // tab
        if cur_field == field { ent.slice(callers_field_start(ent, field, 0, 0), pos) }
        else { callers_get_field(ent, field, pos + 1, cur_field + 1) }
    }
    else { callers_get_field(ent, field, pos + 1, cur_field) };

fn callers_field_start(ent: String, field: i64, pos: i64, cur_field: i64) -> i64 =
    if cur_field == field { pos }
    else if pos >= ent.len() { pos }
    else if ent.byte_at(pos) == 9 { callers_field_start(ent, field, pos + 1, cur_field + 1) }
    else { callers_field_start(ent, field, pos + 1, cur_field) };

// Search entries for callers of target, printing matches
fn callers_search(entries: String, pos: i64, target: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        // Find end of line
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { callers_search(entries, eol + 1, target, count) }
        else {
            let calls = callers_get_field(line, 1, 0, 0);
            // Check if target appears in calls list
            if callers_calls_contain(calls, target, 0) {
                let caller_name = callers_get_field(line, 0, 0, 0);
                let sig = callers_get_field(line, 2, 0, 0);
                let _p = println_str(sig);
                let _p2 = println_str("  calls: " + calls);
                callers_search(entries, eol + 1, target, count + 1)
            } else { callers_search(entries, eol + 1, target, count) }
        }
    };

fn callers_find_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 10 { pos }
    else { callers_find_eol(s, pos + 1) };

// Check if comma-separated calls list contains target name (exact match)
fn callers_calls_contain(calls: String, target: String, pos: i64) -> bool =
    if calls == "" { false }
    else if calls == target { true }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let segment = calls.slice(pos, end);
        if segment == target { true }
        else if end >= calls.len() { false }
        else { callers_calls_contain(calls, target, end + 2) }
    };

// Entry point: find all callers of a function
fn callers_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Callers of \"" + target + "\" in " + input);
        let entries = callers_collect_source(source, 0, "");
        let count = callers_search(entries, 0, target, 0);
        let _sep = println_str("---");
        let _s = println_str("# Callers: " + int_to_string(count));
        0
    };

// v0.95: Deps command - transitive dependency analysis
// Find calls for a specific function name from entries database
fn deps_find_calls(entries: String, pos: i64, name: String) -> String =
    if pos >= entries.len() { "" }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { deps_find_calls(entries, eol + 1, name) }
        else {
            let fn_name = callers_get_field(line, 0, 0, 0);
            if fn_name == name { callers_get_field(line, 1, 0, 0) }
            else { deps_find_calls(entries, eol + 1, name) }
        }
    };

// Process one name from a comma-separated calls list, recursing into deps
// Returns updated visited set
fn deps_visit_call(entries: String, calls: String, pos: i64, visited: String, depth: i64) -> String =
    if pos >= calls.len() { visited }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let name = calls.slice(pos, end);
        let new_visited = if index_has_name(visited, name) { visited }
                          else { deps_traverse(entries, name, visited, depth + 1) };
        if end >= calls.len() { new_visited }
        else { deps_visit_call(entries, calls, end + 2, new_visited, depth) }
    };

// DFS traversal: add name to visited, print it, then recurse into its calls
fn deps_traverse(entries: String, name: String, visited: String, depth: i64) -> String =
    if index_has_name(visited, name) { visited }
    else {
        let new_visited = if visited == "" { name } else { visited + ", " + name };
        let indent = deps_indent(depth, "");
        let calls = deps_find_calls(entries, 0, name);
        let _p = if calls == "" { println_str(indent + name) }
                 else { println_str(indent + name + " -> " + calls) };
        if calls == "" { new_visited }
        else { deps_visit_call(entries, calls, 0, new_visited, depth) }
    };

// Build indentation string for depth
fn deps_indent(depth: i64, acc: String) -> String =
    if depth <= 0 { acc }
    else { deps_indent(depth - 1, acc + "  ") };

// Entry point: find all transitive dependencies of a function
fn deps_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Dependencies of " + target + " in " + input);
        let entries = callers_collect_source(source, 0, "");
        let visited = deps_traverse(entries, target, "", 0);
        let _sep = println_str("---");
        let count = deps_count_names(visited, 0, 0);
        let _s = println_str("# Total: " + int_to_string(count) + " functions in dependency chain");
        0
    };

// Count names in comma-separated list
fn deps_count_names(s: String, pos: i64, count: i64) -> i64 =
    if s == "" { 0 }
    else if pos >= s.len() { count + 1 }
    else if s.byte_at(pos) == 44 { deps_count_names(s, pos + 2, count + 1) }
    else { deps_count_names(s, pos + 1, count) };

// v0.95: Context command - gather full AI context for a function
// Find a function in source by name, return packed "start_pos:end_pos" or ""
fn ctx_find_fn(src: String, pos: i64, target: String) -> String =
    let ann = skip_annotation(src, pos);
    if ann.len() > 0 {
        let after_ann = pos_after_annotation(src, pos);
        let tok = next_token_raw(src, after_ann);
        if tok_kind(tok) == TK_FN() {
            let t1 = next_token_raw(src, tok_end(tok));
            if tok_kind(t1) == TK_IDENT() {
                let name = src.slice(skip_ws_comments(src, tok_end(tok)), scan_ident_end(src, skip_ws_comments(src, tok_end(tok))));
                if name == target {
                    // Found! Start from annotation, scan to end of body
                    let fn_start = pos;
                    let t2 = next_token_raw(src, tok_end(t1));
                    if tok_kind(t2) == TK_LPAREN() {
                        let params = index_collect_params(src, tok_end(t2), "");
                        let rtype = index_read_ret_type(src, unpack_pos(params));
                        let eq_pos = skip_contracts(src, unpack_pos(rtype));
                        let body_result = index_scan_body(src, eq_pos, 0, "", false);
                        pack_result(fn_start, int_to_string(unpack_pos(body_result)))
                    } else { pack_result(fn_start, int_to_string(tok_end(t1))) }
                } else {
                    // Skip this function and continue
                    let t2 = next_token_raw(src, tok_end(t1));
                    if tok_kind(t2) == TK_LPAREN() {
                        let params = index_collect_params(src, tok_end(t2), "");
                        let rtype = index_read_ret_type(src, unpack_pos(params));
                        let eq_pos = skip_contracts(src, unpack_pos(rtype));
                        let body_result = index_scan_body(src, eq_pos, 0, "", false);
                        ctx_find_fn(src, unpack_pos(body_result), target)
                    } else { ctx_find_fn(src, tok_end(t1), target) }
                }
            } else { ctx_find_fn(src, tok_end(tok), target) }
        } else { ctx_find_fn(src, tok_end(tok), target) }
    } else {
        let tok = next_token_raw(src, pos);
        let kind = tok_kind(tok);
        if kind == TK_EOF() { "" }
        else if kind == TK_FN() {
            let t1 = next_token_raw(src, tok_end(tok));
            if tok_kind(t1) == TK_IDENT() {
                let name = src.slice(skip_ws_comments(src, tok_end(tok)), scan_ident_end(src, skip_ws_comments(src, tok_end(tok))));
                if name == target {
                    let fn_start = pos;
                    let t2 = next_token_raw(src, tok_end(t1));
                    if tok_kind(t2) == TK_LPAREN() {
                        let params = index_collect_params(src, tok_end(t2), "");
                        let rtype = index_read_ret_type(src, unpack_pos(params));
                        let eq_pos = skip_contracts(src, unpack_pos(rtype));
                        let body_result = index_scan_body(src, eq_pos, 0, "", false);
                        pack_result(fn_start, int_to_string(unpack_pos(body_result)))
                    } else { pack_result(fn_start, int_to_string(tok_end(t1))) }
                } else {
                    let t2 = next_token_raw(src, tok_end(t1));
                    if tok_kind(t2) == TK_LPAREN() {
                        let params = index_collect_params(src, tok_end(t2), "");
                        let rtype = index_read_ret_type(src, unpack_pos(params));
                        let eq_pos = skip_contracts(src, unpack_pos(rtype));
                        let body_result = index_scan_body(src, eq_pos, 0, "", false);
                        ctx_find_fn(src, unpack_pos(body_result), target)
                    } else { ctx_find_fn(src, tok_end(t1), target) }
                }
            } else { ctx_find_fn(src, tok_end(tok), target) }
        }
        else if kind == TK_STRUCT() {
            let t1 = next_token_raw(src, tok_end(tok));
            let t2 = next_token_raw(src, tok_end(t1));
            if tok_kind(t2) == TK_LBRACE() {
                let end_pos = index_skip_body(src, tok_end(t2), 1);
                ctx_find_fn(src, end_pos, target)
            } else { ctx_find_fn(src, tok_end(t1), target) }
        }
        else { ctx_find_fn(src, tok_end(tok), target) }
    };

// Print signatures of functions in a comma-separated calls list
fn ctx_print_sigs(entries: String, calls: String, pos: i64) -> i64 =
    if pos >= calls.len() { 0 }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let name = calls.slice(pos, end);
        let sig = ctx_find_sig(entries, 0, name);
        let _p = if sig != "" { println_str("  " + sig) } else { println_str("") };
        if end >= calls.len() { 0 }
        else { ctx_print_sigs(entries, calls, end + 2) }
    };

// Find signature for a function name from entries database
fn ctx_find_sig(entries: String, pos: i64, name: String) -> String =
    if pos >= entries.len() { "" }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { ctx_find_sig(entries, eol + 1, name) }
        else {
            let fn_name = callers_get_field(line, 0, 0, 0);
            if fn_name == name { callers_get_field(line, 2, 0, 0) }
            else { ctx_find_sig(entries, eol + 1, name) }
        }
    };

// Find all callers of a target from entries, return as comma-separated names
fn ctx_find_callers(entries: String, pos: i64, target: String, acc: String) -> String =
    if pos >= entries.len() { acc }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { ctx_find_callers(entries, eol + 1, target, acc) }
        else {
            let calls = callers_get_field(line, 1, 0, 0);
            if callers_calls_contain(calls, target, 0) {
                let caller_name = callers_get_field(line, 0, 0, 0);
                let new_acc = if acc == "" { caller_name } else { acc + ", " + caller_name };
                ctx_find_callers(entries, eol + 1, target, new_acc)
            } else { ctx_find_callers(entries, eol + 1, target, acc) }
        }
    };

// Entry point: gather full context for a function
fn context_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Context: \"" + target + "\" in " + input);
        // Build call graph
        let entries = callers_collect_source(source, 0, "");
        // Find and print target function source
        let span = ctx_find_fn(source, 0, target);
        let _sec1 = println_str("");
        let _sec1h = println_str("## Source");
        let _body = if span == "" { println_str("  (not found)") }
                    else {
                        let fn_start = unpack_pos(span);
                        let fn_end_str = unpack_ast(span);
                        let fn_end = parse_int_simple(fn_end_str, 0, 0);
                        // Trim trailing whitespace from end position
                        let body_text = source.slice(fn_start, fn_end);
                        println_str(body_text)
                    };
        // Print direct callees
        let calls = deps_find_calls(entries, 0, target);
        let _sec2 = println_str("");
        let _sec2h = println_str("## Called Functions");
        let _callees = if calls == "" { let _n = println_str("  (none)"); 0 }
                       else { ctx_print_sigs(entries, calls, 0) };
        // Print callers
        let caller_list = ctx_find_callers(entries, 0, target, "");
        let _sec3 = println_str("");
        let _sec3h = println_str("## Callers");
        let _callers = if caller_list == "" { let _n = println_str("  (none)"); 0 }
                       else { ctx_print_sigs(entries, caller_list, 0) };
        let _sep = println_str("");
        let _sep2 = println_str("---");
        0
    };

// v0.95: Outline command - compact project overview
// Count how many functions call a given name
fn outline_count_callers(entries: String, pos: i64, name: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { outline_count_callers(entries, eol + 1, name, count) }
        else {
            let calls = callers_get_field(line, 1, 0, 0);
            let inc = if callers_calls_contain(calls, name, 0) { 1 } else { 0 };
            outline_count_callers(entries, eol + 1, name, count + inc)
        }
    };

// Count items in comma-separated list
fn outline_count_calls(calls: String, pos: i64, count: i64) -> i64 =
    if calls == "" { 0 }
    else if pos >= calls.len() { count + 1 }
    else if calls.byte_at(pos) == 44 { outline_count_calls(calls, pos + 2, count + 1) }
    else { outline_count_calls(calls, pos + 1, count) };

// Print outline for each function entry
fn outline_print_entries(entries: String, pos: i64, all_entries: String) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { outline_print_entries(entries, eol + 1, all_entries) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let call_count = outline_count_calls(calls, 0, 0);
            let caller_count = outline_count_callers(all_entries, 0, name, 0);
            let tag = if name == "main" { " [main]" }
                      else if caller_count == 0 { " [entry]" }
                      else if call_count == 0 { " [leaf]" }
                      else { "" };
            let _p = println_str("  " + sig + "  (" + int_to_string(call_count) + " calls, " + int_to_string(caller_count) + " callers)" + tag);
            outline_print_entries(entries, eol + 1, all_entries)
        }
    };

// Scan for structs and print them
fn outline_scan_structs(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() { 0 }
    else if kind == TK_STRUCT() {
        let t1 = next_token_raw(src, tok_end(tok));
        if tok_kind(t1) == TK_IDENT() {
            let name = src.slice(skip_ws_comments(src, tok_end(tok)), scan_ident_end(src, skip_ws_comments(src, tok_end(tok))));
            let t2 = next_token_raw(src, tok_end(t1));
            if tok_kind(t2) == TK_LBRACE() {
                let fields = index_struct_fields(src, tok_end(t2), "");
                let _p = println_str("  struct " + name + " { " + unpack_ast(fields) + " }");
                outline_scan_structs(src, unpack_pos(fields))
            } else {
                let _p = println_str("  struct " + name);
                outline_scan_structs(src, tok_end(t1))
            }
        } else { outline_scan_structs(src, tok_end(tok)) }
    }
    else { outline_scan_structs(src, tok_end(tok)) };

// Count entries in the entries string
fn outline_count_entries(entries: String, pos: i64, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { outline_count_entries(entries, eol + 1, count) }
        else { outline_count_entries(entries, eol + 1, count + 1) }
    };

// Entry point: compact project overview
fn outline_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Outline: " + input);
        let entries = callers_collect_source(source, 0, "");
        let fn_count = outline_count_entries(entries, 0, 0);
        let _sec1 = println_str("");
        let _sec1h = println_str("## Functions (" + int_to_string(fn_count) + ")");
        let _fns = outline_print_entries(entries, 0, entries);
        let _sec2 = println_str("");
        let _sec2h = println_str("## Structs");
        let _structs = outline_scan_structs(source, 0);
        let _sep = println_str("");
        let _sep2 = println_str("---");
        0
    };

// v0.95: Xref command - comprehensive cross-reference for AI
// Print source of each callee function
fn xref_print_callee_sources(src: String, calls: String, pos: i64) -> i64 =
    if pos >= calls.len() { 0 }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let name = calls.slice(pos, end);
        let span = ctx_find_fn(src, 0, name);
        let _p = if span == "" { 0 }
                 else {
                     let fn_start = unpack_pos(span);
                     let fn_end = parse_int_simple(unpack_ast(span), 0, 0);
                     let body = src.slice(fn_start, fn_end);
                     let _h = println_str("");
                     let _s = println_str("### " + name);
                     let _b = println_str(body);
                     0
                 };
        if end >= calls.len() { 0 }
        else { xref_print_callee_sources(src, calls, end + 2) }
    };

// Entry point: comprehensive cross-reference
fn xref_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Xref: \"" + target + "\" in " + input);
        let entries = callers_collect_source(source, 0, "");
        // Section 1: Target function source
        let span = ctx_find_fn(source, 0, target);
        let _sec1 = println_str("");
        let _sec1h = println_str("## 1. Target Source");
        let _body = if span == "" { println_str("  (not found)") }
                    else {
                        let fn_start = unpack_pos(span);
                        let fn_end = parse_int_simple(unpack_ast(span), 0, 0);
                        println_str(source.slice(fn_start, fn_end))
                    };
        // Section 2: Direct callee signatures
        let calls = deps_find_calls(entries, 0, target);
        let _sec2 = println_str("");
        let _sec2h = println_str("## 2. Called Functions (signatures)");
        let _callees = if calls == "" { let _n = println_str("  (none)"); 0 }
                       else { ctx_print_sigs(entries, calls, 0) };
        // Section 3: Direct callee source code
        let _sec3 = println_str("");
        let _sec3h = println_str("## 3. Called Functions (source)");
        let _callee_src = if calls == "" { let _n = println_str("  (none)"); 0 }
                          else { xref_print_callee_sources(source, calls, 0) };
        // Section 4: Callers
        let caller_list = ctx_find_callers(entries, 0, target, "");
        let _sec4 = println_str("");
        let _sec4h = println_str("## 4. Callers (signatures)");
        let _callers = if caller_list == "" { let _n = println_str("  (none)"); 0 }
                       else { ctx_print_sigs(entries, caller_list, 0) };
        // Section 5: Dependency tree (compact)
        let _sec5 = println_str("");
        let _sec5h = println_str("## 5. Dependency Tree");
        let _deps = deps_traverse(entries, target, "", 0);
        let _sep = println_str("");
        let _sep2 = println_str("---");
        0
    };

// v0.95: Impact command - reverse transitive dependency (blast radius)
// Find all callers of name from entries, return as comma-separated
fn impact_find_callers(entries: String, pos: i64, name: String, acc: String) -> String =
    if pos >= entries.len() { acc }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { impact_find_callers(entries, eol + 1, name, acc) }
        else {
            let calls = callers_get_field(line, 1, 0, 0);
            if callers_calls_contain(calls, name, 0) {
                let caller = callers_get_field(line, 0, 0, 0);
                let new_acc = if acc == "" { caller } else { acc + ", " + caller };
                impact_find_callers(entries, eol + 1, name, new_acc)
            } else { impact_find_callers(entries, eol + 1, name, acc) }
        }
    };

// DFS reverse traversal: find all transitive callers
fn impact_traverse(entries: String, name: String, visited: String, depth: i64) -> String =
    if index_has_name(visited, name) { visited }
    else {
        let new_visited = if visited == "" { name } else { visited + ", " + name };
        let callers = impact_find_callers(entries, 0, name, "");
        let indent = deps_indent(depth, "");
        let _p = if callers == "" { println_str(indent + name + " (no callers)") }
                 else { println_str(indent + name + " <- " + callers) };
        if callers == "" { new_visited }
        else { impact_visit_callers(entries, callers, 0, new_visited, depth) }
    };

// Process each caller in comma-separated list
fn impact_visit_callers(entries: String, callers: String, pos: i64, visited: String, depth: i64) -> String =
    if pos >= callers.len() { visited }
    else {
        let end = index_find_comma_or_end(callers, pos);
        let name = callers.slice(pos, end);
        let new_visited = if index_has_name(visited, name) { visited }
                          else { impact_traverse(entries, name, visited, depth + 1) };
        if end >= callers.len() { new_visited }
        else { impact_visit_callers(entries, callers, end + 2, new_visited, depth) }
    };

// Entry point: show blast radius of a change
fn impact_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Impact: changing \"" + target + "\" in " + input);
        let _sub = println_str("# (all functions that transitively depend on " + target + ")");
        let entries = callers_collect_source(source, 0, "");
        let _sec = println_str("");
        let visited = impact_traverse(entries, target, "", 0);
        let count = deps_count_names(visited, 0, 0);
        let _sep = println_str("");
        let _sep2 = println_str("---");
        let _s = println_str("# Blast radius: " + int_to_string(count) + " functions affected");
        0
    };

// v0.95: Stats command - code statistics
// Count lines in source
fn stats_count_lines(src: String, pos: i64, count: i64) -> i64 =
    if pos >= src.len() { count }
    else if src.byte_at(pos) == 10 { stats_count_lines(src, pos + 1, count + 1) }
    else { stats_count_lines(src, pos + 1, count) };

// Count entry points (functions with 0 callers, excluding main)
fn stats_count_entries(entries: String, pos: i64, all: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { stats_count_entries(entries, eol + 1, all, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            let inc = if caller_count == 0 and not (name == "main") { 1 } else { 0 };
            stats_count_entries(entries, eol + 1, all, count + inc)
        }
    };

// Count leaf functions (functions that call nothing)
fn stats_count_leaves(entries: String, pos: i64, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { stats_count_leaves(entries, eol + 1, count) }
        else {
            let calls = callers_get_field(line, 1, 0, 0);
            let inc = if calls == "" { 1 } else { 0 };
            stats_count_leaves(entries, eol + 1, count + inc)
        }
    };

// Find function with most callers
fn pick_best_name(name: String, count: i64, best_name: String, best_count: i64) -> String =
    if count > best_count { name } else { best_name };

fn pick_best_count(count: i64, best_count: i64) -> i64 =
    if count > best_count { count } else { best_count };

fn stats_most_called(entries: String, pos: i64, all: String, best_name: String, best_count: i64) -> String =
    if pos >= entries.len() { best_name + " (" + int_to_string(best_count) + " callers)" }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { stats_most_called(entries, eol + 1, all, best_name, best_count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            let new_best = pick_best_name(name, caller_count, best_name, best_count);
            let new_count = pick_best_count(caller_count, best_count);
            stats_most_called(entries, eol + 1, all, new_best, new_count)
        }
    };

// Count structs in source
fn stats_count_structs(src: String, pos: i64, count: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() { count }
    else if kind == TK_STRUCT() { stats_count_structs(src, tok_end(tok), count + 1) }
    else { stats_count_structs(src, tok_end(tok), count) };

// Entry point
fn stats_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let _header = println_str("# Stats: " + input);
        let loc = stats_count_lines(source, 0, 1);
        let _l1 = println_str("  Lines of code:     " + int_to_string(loc));
        let _l1b = println_str("  File size:         " + int_to_string(source.len()) + " bytes");
        let entries = callers_collect_source(source, 0, "");
        let fn_count = outline_count_entries(entries, 0, 0);
        let _l2 = println_str("  Functions:         " + int_to_string(fn_count));
        let struct_count = stats_count_structs(source, 0, 0);
        let _l3 = println_str("  Structs:           " + int_to_string(struct_count));
        let entry_count = stats_count_entries(entries, 0, entries, 0);
        let _l4 = println_str("  Entry points:      " + int_to_string(entry_count));
        let leaf_count = stats_count_leaves(entries, 0, 0);
        let _l5 = println_str("  Leaf functions:    " + int_to_string(leaf_count));
        let most = stats_most_called(entries, 0, entries, "(none)", 0);
        let _l6 = println_str("  Most called:       " + most);
        let _sep = println_str("---");
        0
    };

// v0.95: Unused command - find functions with 0 callers (dead code)
fn unused_print_entries(entries: String, pos: i64, all: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { unused_print_entries(entries, eol + 1, all, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            if caller_count == 0 and not (name == "main") {
                let _p = println_str("  " + sig);
                unused_print_entries(entries, eol + 1, all, count + 1)
            } else {
                unused_print_entries(entries, eol + 1, all, count)
            }
        }
    };

fn unused_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let _header = println_str("# Unused functions: " + input);
        let count = unused_print_entries(entries, 0, entries, 0);
        let _sep = println_str("---");
        let _summary = println_str("Total: " + int_to_string(count) + " unused functions");
        0
    };

// v0.95: Complexity command - per-function complexity metrics
// Count parameters in comma-separated string
fn cx_count_params(params: String, pos: i64, count: i64) -> i64 =
    if params == "" { 0 }
    else if pos >= params.len() { count }
    else if params.byte_at(pos) == 44 { cx_count_params(params, pos + 1, count + 1) }
    else { cx_count_params(params, pos + 1, count) };

// Extract params text from signature: "fn name(params) -> ret" → "params"
fn cx_extract_params(sig: String, pos: i64) -> String =
    if pos >= sig.len() { "" }
    else if sig.byte_at(pos) == 40 { cx_extract_params_end(sig, pos + 1, pos + 1) }
    else { cx_extract_params(sig, pos + 1) };

fn cx_extract_params_end(sig: String, pos: i64, start: i64) -> String =
    if pos >= sig.len() { "" }
    else if sig.byte_at(pos) == 41 { sig.slice(start, pos) }
    else { cx_extract_params_end(sig, pos + 1, start) };

// Check if function is recursive (calls itself)
fn cx_is_recursive(name: String, calls: String) -> bool =
    callers_calls_contain(calls, name, 0);

// Print complexity for each function entry
fn cx_print_entries(entries: String, pos: i64, all: String) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cx_print_entries(entries, eol + 1, all) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let params_text = cx_extract_params(sig, 0);
            let param_count = cx_count_params(params_text, 0, 1);
            let call_count = outline_count_calls(calls, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            let recursive = cx_is_recursive(name, calls);
            let rec_tag = if recursive { " [recursive]" } else { "" };
            let _p = println_str("  " + name + ": params=" + int_to_string(param_count) + " calls=" + int_to_string(call_count) + " callers=" + int_to_string(caller_count) + rec_tag);
            cx_print_entries(entries, eol + 1, all)
        }
    };

// Count recursive functions
fn cx_count_recursive(entries: String, pos: i64, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cx_count_recursive(entries, eol + 1, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let inc = if cx_is_recursive(name, calls) { 1 } else { 0 };
            cx_count_recursive(entries, eol + 1, count + inc)
        }
    };

// Find function with most parameters
fn cx_most_params(entries: String, pos: i64, best_name: String, best_count: i64) -> String =
    if pos >= entries.len() { best_name + " (" + int_to_string(best_count) + " params)" }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cx_most_params(entries, eol + 1, best_name, best_count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let params_text = cx_extract_params(sig, 0);
            let param_count = cx_count_params(params_text, 0, 1);
            let new_best = pick_best_name(name, param_count, best_name, best_count);
            let new_count = pick_best_count(param_count, best_count);
            cx_most_params(entries, eol + 1, new_best, new_count)
        }
    };

// Find function with most calls (outgoing)
fn cx_most_calls(entries: String, pos: i64, best_name: String, best_count: i64) -> String =
    if pos >= entries.len() { best_name + " (" + int_to_string(best_count) + " calls)" }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cx_most_calls(entries, eol + 1, best_name, best_count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let call_count = outline_count_calls(calls, 0, 0);
            let new_best = pick_best_name(name, call_count, best_name, best_count);
            let new_count = pick_best_count(call_count, best_count);
            cx_most_calls(entries, eol + 1, new_best, new_count)
        }
    };

fn complexity_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let fn_count = outline_count_entries(entries, 0, 0);
        let _header = println_str("# Complexity: " + input);
        let _detail = cx_print_entries(entries, 0, entries);
        let _sep = println_str("---");
        let recursive_count = cx_count_recursive(entries, 0, 0);
        let _s1 = println_str("  Functions:     " + int_to_string(fn_count));
        let _s2 = println_str("  Recursive:     " + int_to_string(recursive_count));
        let _s3 = println_str("  Most params:   " + cx_most_params(entries, 0, "(none)", 0));
        let _s4 = println_str("  Most calls:    " + cx_most_calls(entries, 0, "(none)", 0));
        0
    };

// v0.95: Similar command - find functions with similar call patterns
// Count shared callees between two comma-separated call lists
fn sim_count_shared(calls_a: String, calls_b: String, pos: i64, count: i64) -> i64 =
    if calls_a == "" or calls_b == "" { 0 }
    else if pos >= calls_a.len() {
        // end of last name
        let name = calls_a.slice(sim_find_start(calls_a, pos), calls_a.len());
        if name.len() > 0 and callers_calls_contain(calls_b, name, 0) { count + 1 }
        else { count }
    }
    else if calls_a.byte_at(pos) == 44 {
        // found comma, extract name before it
        let name = calls_a.slice(sim_find_start(calls_a, pos), pos);
        let inc = if callers_calls_contain(calls_b, name, 0) { 1 } else { 0 };
        sim_count_shared(calls_a, calls_b, pos + 2, count + inc)
    }
    else { sim_count_shared(calls_a, calls_b, pos + 1, count) };

// Find start of current name (backtrack from pos to last comma+space or start)
fn sim_find_start(s: String, pos: i64) -> i64 =
    sim_find_start_rev(s, pos - 1);

fn sim_find_start_rev(s: String, pos: i64) -> i64 =
    if pos < 0 { 0 }
    else if s.byte_at(pos) == 44 { pos + 2 }
    else { sim_find_start_rev(s, pos - 1) };

// Get target function's calls from entries
fn sim_get_calls(entries: String, pos: i64, target: String) -> String =
    if pos >= entries.len() { "" }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { sim_get_calls(entries, eol + 1, target) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            if name == target { callers_get_field(line, 1, 0, 0) }
            else { sim_get_calls(entries, eol + 1, target) }
        }
    };

// Print similar functions (those sharing callees with target)
fn sim_print_entries(entries: String, pos: i64, target: String, target_calls: String, min_shared: i64) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { sim_print_entries(entries, eol + 1, target, target_calls, min_shared) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            if name == target { sim_print_entries(entries, eol + 1, target, target_calls, min_shared) }
            else {
                let shared = sim_count_shared(target_calls, calls, 0, 0);
                if shared >= min_shared {
                    let _p = println_str("  [" + int_to_string(shared) + " shared] " + sig);
                    sim_print_entries(entries, eol + 1, target, target_calls, min_shared)
                } else {
                    sim_print_entries(entries, eol + 1, target, target_calls, min_shared)
                }
            }
        }
    };

fn similar_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let target_calls = sim_get_calls(entries, 0, target);
        if target_calls == "" {
            { print_str("No calls found for: "); println_str(target); 1 }
        } else {
            let call_count = outline_count_calls(target_calls, 0, 0);
            let _header = println_str("# Similar to: " + target + " (" + int_to_string(call_count) + " callees)");
            let _detail = sim_print_entries(entries, 0, target, target_calls, 1);
            let _sep = println_str("---");
            0
        }
    };

// v0.95: Layers command - architectural layer analysis
// Check if a function is a leaf (0 calls)
fn layer_is_leaf(entries: String, pos: i64, name: String) -> bool =
    if pos >= entries.len() { false }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { layer_is_leaf(entries, eol + 1, name) }
        else {
            let n = callers_get_field(line, 0, 0, 0);
            if n == name {
                let calls = callers_get_field(line, 1, 0, 0);
                calls == ""
            } else { layer_is_leaf(entries, eol + 1, name) }
        }
    };

// Check if all callees of a function are leaves
fn layer_all_callees_leaf(entries: String, calls: String, pos: i64) -> bool =
    if calls == "" { true }
    else if pos >= calls.len() {
        let name = calls.slice(sim_find_start(calls, pos), calls.len());
        if name.len() == 0 { true }
        else { layer_is_leaf(entries, 0, name) }
    }
    else if calls.byte_at(pos) == 44 {
        let name = calls.slice(sim_find_start(calls, pos), pos);
        if layer_is_leaf(entries, 0, name) { layer_all_callees_leaf(entries, calls, pos + 2) }
        else { false }
    }
    else { layer_all_callees_leaf(entries, calls, pos + 1) };

// Determine layer of a function: 0=leaf, 1=near-leaf, 2=mid, 3=entry
fn layer_classify(entries: String, name: String, calls: String, caller_count: i64) -> i64 =
    if calls == "" { 0 }
    else if layer_all_callees_leaf(entries, calls, 0) { 1 }
    else if caller_count == 0 and not (name == "main") { 3 }
    else { 2 };

fn layer_name(layer: i64) -> String =
    if layer == 0 { "leaf" }
    else if layer == 1 { "near-leaf" }
    else if layer == 2 { "mid" }
    else { "entry" };

// Count functions in each layer
fn layer_count_at(entries: String, pos: i64, all: String, target_layer: i64, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { layer_count_at(entries, eol + 1, all, target_layer, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            let layer = layer_classify(all, name, calls, caller_count);
            let inc = if layer == target_layer { 1 } else { 0 };
            layer_count_at(entries, eol + 1, all, target_layer, count + inc)
        }
    };

// Print functions in a specific layer
fn layer_print_at(entries: String, pos: i64, all: String, target_layer: i64) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { layer_print_at(entries, eol + 1, all, target_layer) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            let layer = layer_classify(all, name, calls, caller_count);
            if layer == target_layer {
                let _p = println_str("    " + name);
                layer_print_at(entries, eol + 1, all, target_layer)
            } else {
                layer_print_at(entries, eol + 1, all, target_layer)
            }
        }
    };

fn layers_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let fn_count = outline_count_entries(entries, 0, 0);
        let _header = println_str("# Layers: " + input + " (" + int_to_string(fn_count) + " functions)");
        let l0 = layer_count_at(entries, 0, entries, 0, 0);
        let l1 = layer_count_at(entries, 0, entries, 1, 0);
        let l2 = layer_count_at(entries, 0, entries, 2, 0);
        let l3 = layer_count_at(entries, 0, entries, 3, 0);
        let _s0 = println_str("  Layer 0 (leaf):      " + int_to_string(l0));
        let _s1 = println_str("  Layer 1 (near-leaf): " + int_to_string(l1));
        let _s2 = println_str("  Layer 2 (mid):       " + int_to_string(l2));
        let _s3 = println_str("  Layer 3 (entry):     " + int_to_string(l3));
        let _sep = println_str("---");
        // Print entry points (most architecturally significant)
        let _eh = println_str("  Entry points:");
        let _ep = layer_print_at(entries, 0, entries, 3);
        0
    };

// v0.95: Hotspots command - identify most connected functions
// Precompute all scores in a single pass: "name\tcalls\tcallers\tscore\n..."
fn hot_precompute(entries: String, pos: i64, all: String, scored: String) -> String =
    if pos >= entries.len() { scored }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { hot_precompute(entries, eol + 1, all, scored) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let call_count = outline_count_calls(calls, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            let score = call_count + caller_count;
            let entry = name + "\t" + int_to_string(call_count) + "\t" + int_to_string(caller_count) + "\t" + int_to_string(score);
            let new_scored = if scored == "" { entry } else { scored + "\n" + entry };
            hot_precompute(entries, eol + 1, all, new_scored)
        }
    };

// Find best from precomputed scores (no recalculation needed)
fn hot_find_best(scored: String, pos: i64, exclude: String, best_name: String, best_score: i64) -> String =
    if pos >= scored.len() { best_name + "\t" + int_to_string(best_score) }
    else {
        let eol = callers_find_eol(scored, pos);
        let line = scored.slice(pos, eol);
        if line.len() == 0 { hot_find_best(scored, eol + 1, exclude, best_name, best_score) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            if index_has_name(exclude, name) { hot_find_best(scored, eol + 1, exclude, best_name, best_score) }
            else {
                let score = parse_int_simple(callers_get_field(line, 3, 0, 0), 0, 0);
                let new_best = pick_best_name(name, score, best_name, best_score);
                let new_score = pick_best_count(score, best_score);
                hot_find_best(scored, eol + 1, exclude, new_best, new_score)
            }
        }
    };

fn hot_result_name(result: String, pos: i64) -> String =
    if pos >= result.len() { result }
    else if result.byte_at(pos) == 9 { result.slice(0, pos) }
    else { hot_result_name(result, pos + 1) };

fn hot_get_detail(scored: String, pos: i64, name: String) -> String =
    if pos >= scored.len() { "0\t0" }
    else {
        let eol = callers_find_eol(scored, pos);
        let line = scored.slice(pos, eol);
        if line.len() == 0 { hot_get_detail(scored, eol + 1, name) }
        else {
            let n = callers_get_field(line, 0, 0, 0);
            if n == name { callers_get_field(line, 1, 0, 0) + "\t" + callers_get_field(line, 2, 0, 0) }
            else { hot_get_detail(scored, eol + 1, name) }
        }
    };

fn hot_print_top(scored: String, exclude: String, remaining: i64, rank: i64) -> i64 =
    if remaining <= 0 { 0 }
    else {
        let result = hot_find_best(scored, 0, exclude, "(none)", 0);
        let name = hot_result_name(result, 0);
        if name == "(none)" { 0 }
        else {
            let detail = hot_get_detail(scored, 0, name);
            let call_count = callers_get_field(detail, 0, 0, 0);
            let caller_count = callers_get_field(detail, 1, 0, 0);
            let score_str = callers_get_field(result, 1, 0, 0);
            let _p = println_str("  " + int_to_string(rank) + ". " + name + " (calls=" + call_count + " callers=" + caller_count + " total=" + score_str + ")");
            let new_exclude = if exclude == "" { name } else { exclude + ", " + name };
            hot_print_top(scored, new_exclude, remaining - 1, rank + 1)
        }
    };

fn hotspots_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let fn_count = outline_count_entries(entries, 0, 0);
        let scored = hot_precompute(entries, 0, entries, "");
        let _header = println_str("# Hotspots: " + input + " (top 10 of " + int_to_string(fn_count) + ")");
        let _detail = hot_print_top(scored, "", 10, 1);
        let _sep = println_str("---");
        0
    };

fn body_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let result = ctx_find_fn(source, 0, target);
        let fn_start = unpack_pos(result);
        let end_str = unpack_ast(result);
        if end_str == "" or fn_start >= source.len() {
            { print_str("Function not found: "); println_str(target); 1 }
        } else {
            let fn_end = parse_int_simple(end_str, 0, 0);
            let body = source.slice(fn_start, fn_end);
            let _p = println_str(body);
            0
        }
    };

fn iface_count(entries: String, pos: i64, all: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { iface_count(entries, eol + 1, all, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let callers = outline_count_callers(all, 0, name, 0);
            if callers == 0 and not (name == "main") {
                iface_count(entries, eol + 1, all, count + 1)
            } else { iface_count(entries, eol + 1, all, count) }
        }
    };

fn iface_print(entries: String, pos: i64, all: String) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { iface_print(entries, eol + 1, all) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let callers = outline_count_callers(all, 0, name, 0);
            let _p = if callers == 0 and not (name == "main") {
                let calls = callers_get_field(line, 1, 0, 0);
                let call_count = outline_count_calls(calls, 0, 0);
                let _s = println_str("  " + sig + "  [calls=" + int_to_string(call_count) + "]");
                0
            } else { 0 };
            iface_print(entries, eol + 1, all)
        }
    };

fn interface_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let total = iface_count(entries, 0, entries, 0);
        let _h = println_str("# Interface: " + input + " (" + int_to_string(total) + " entry points)");
        let _list = iface_print(entries, 0, entries);
        let _sep = println_str("---");
        0
    };

fn clust_prefix(name: String, pos: i64) -> String =
    if pos >= name.len() { name }
    else if name.byte_at(pos) == 95 { name.slice(0, pos) }
    else { clust_prefix(name, pos + 1) };

fn clust_has_prefix(prefixes: String, prefix: String) -> bool =
    if prefixes == "" { false }
    else { index_has_name(prefixes, prefix) };

fn clust_collect_prefixes(entries: String, pos: i64, prefixes: String) -> String =
    if pos >= entries.len() { prefixes }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { clust_collect_prefixes(entries, eol + 1, prefixes) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let prefix = clust_prefix(name, 0);
            let new_prefixes = if prefix == name or clust_has_prefix(prefixes, prefix) { prefixes }
                               else if prefixes == "" { prefix }
                               else { prefixes + ", " + prefix };
            clust_collect_prefixes(entries, eol + 1, new_prefixes)
        }
    };

fn clust_count_prefix(entries: String, pos: i64, prefix: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { clust_count_prefix(entries, eol + 1, prefix, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let p = clust_prefix(name, 0);
            if p == prefix and not (p == name) {
                clust_count_prefix(entries, eol + 1, prefix, count + 1)
            } else { clust_count_prefix(entries, eol + 1, prefix, count) }
        }
    };

fn clust_print_prefix(entries: String, pos: i64, prefix: String) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { clust_print_prefix(entries, eol + 1, prefix) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let p = clust_prefix(name, 0);
            let _p = if p == prefix and not (p == name) {
                let sig = callers_get_field(line, 2, 0, 0);
                let _s = println_str("    " + sig);
                0
            } else { 0 };
            clust_print_prefix(entries, eol + 1, prefix)
        }
    };

fn clust_print_all(entries: String, prefixes: String, pos: i64) -> i64 =
    if pos >= prefixes.len() { 0 }
    else {
        let end = index_find_comma_or_end(prefixes, pos);
        let prefix = prefixes.slice(pos, end);
        let count = clust_count_prefix(entries, 0, prefix, 0);
        let _p = if count >= 2 {
            let _h = println_str("  " + prefix + "_* (" + int_to_string(count) + " functions):");
            clust_print_prefix(entries, 0, prefix)
        } else { 0 };
        if end >= prefixes.len() { 0 }
        else { clust_print_all(entries, prefixes, end + 2) }
    };

fn clusters_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let prefixes = clust_collect_prefixes(entries, 0, "");
        let _h = println_str("# Clusters: " + input);
        let _g = clust_print_all(entries, prefixes, 0);
        let _sep = println_str("---");
        0
    };

fn cov_reachable(entries: String, name: String, visited: String) -> String =
    if index_has_name(visited, name) { visited }
    else {
        let new_visited = if visited == "" { name } else { visited + ", " + name };
        let calls = deps_find_calls(entries, 0, name);
        cov_visit_calls(entries, calls, 0, new_visited)
    };

fn cov_visit_calls(entries: String, calls: String, pos: i64, visited: String) -> String =
    if pos >= calls.len() { visited }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let name = calls.slice(pos, end);
        let new_visited = cov_reachable(entries, name, visited);
        if end >= calls.len() { new_visited }
        else { cov_visit_calls(entries, calls, end + 2, new_visited) }
    };

fn cov_count_covered(entries: String, pos: i64, reachable: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cov_count_covered(entries, eol + 1, reachable, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let inc = if index_has_name(reachable, name) { 1 } else { 0 };
            cov_count_covered(entries, eol + 1, reachable, count + inc)
        }
    };

fn cov_print_uncovered(entries: String, pos: i64, reachable: String) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cov_print_uncovered(entries, eol + 1, reachable) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let _p = if not index_has_name(reachable, name) {
                let _s = println_str("  " + sig);
                0
            } else { 0 };
            cov_print_uncovered(entries, eol + 1, reachable)
        }
    };

fn coverage_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let fn_count = outline_count_entries(entries, 0, 0);
        let reachable = cov_reachable(entries, "main", "");
        let covered = cov_count_covered(entries, 0, reachable, 0);
        let uncovered = fn_count - covered;
        let _h = println_str("# Coverage: " + input);
        let _s1 = println_str("  Total functions: " + int_to_string(fn_count));
        let _s2 = println_str("  Reachable from main: " + int_to_string(covered));
        let _s3 = println_str("  Unreachable: " + int_to_string(uncovered));
        let _u = if uncovered > 0 {
            let _uh = println_str("  Unreachable functions:");
            cov_print_uncovered(entries, 0, reachable)
        } else { let _s = println_str("  All functions reachable!"); 0 };
        let _sep = println_str("---");
        0
    };

fn pat_classify(entries: String, name: String, calls: String) -> String =
    let call_count = outline_count_calls(calls, 0, 0);
    let caller_count = outline_count_callers(entries, 0, name, 0);
    let is_rec = cx_is_recursive(name, calls);
    if name == "main" { "entry" }
    else if call_count == 0 and caller_count == 0 { "orphan" }
    else if call_count == 0 { "leaf" }
    else if is_rec and call_count == 1 { "tail-recursive" }
    else if is_rec { "recursive" }
    else if caller_count == 0 { "entry" }
    else if call_count == 1 { "wrapper" }
    else { "composite" };

fn pat_count(entries: String, pos: i64, all: String, pattern: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { pat_count(entries, eol + 1, all, pattern, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let p = pat_classify(all, name, calls);
            let inc = if p == pattern { 1 } else { 0 };
            pat_count(entries, eol + 1, all, pattern, count + inc)
        }
    };

fn pattern_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let fn_count = outline_count_entries(entries, 0, 0);
        let _h = println_str("# Patterns: " + input + " (" + int_to_string(fn_count) + " functions)");
        let c1 = pat_count(entries, 0, entries, "leaf", 0);
        let c2 = pat_count(entries, 0, entries, "wrapper", 0);
        let c3 = pat_count(entries, 0, entries, "composite", 0);
        let c4 = pat_count(entries, 0, entries, "tail-recursive", 0);
        let c5 = pat_count(entries, 0, entries, "recursive", 0);
        let c6 = pat_count(entries, 0, entries, "entry", 0);
        let c7 = pat_count(entries, 0, entries, "orphan", 0);
        let _p1 = println_str("  leaf:           " + int_to_string(c1));
        let _p2 = println_str("  wrapper:        " + int_to_string(c2));
        let _p3 = println_str("  composite:      " + int_to_string(c3));
        let _p4 = println_str("  tail-recursive: " + int_to_string(c4));
        let _p5 = println_str("  recursive:      " + int_to_string(c5));
        let _p6 = println_str("  entry:          " + int_to_string(c6));
        let _p7 = println_str("  orphan:         " + int_to_string(c7));
        let _sep = println_str("---");
        0
    };

fn export_print(entries: String, pos: i64, all: String) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { export_print(entries, eol + 1, all) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let call_count = outline_count_calls(calls, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            let layer = layer_classify(all, name, calls, caller_count);
            let layer_str = layer_name(layer);
            let pattern = pat_classify(all, name, calls);
            let is_rec = cx_is_recursive(name, calls);
            let rec_str = if is_rec { "yes" } else { "no" };
            let _p = println_str(name + "\t" + int_to_string(call_count) + "\t" + int_to_string(caller_count) + "\t" + layer_str + "\t" + pattern + "\t" + rec_str + "\t" + sig);
            export_print(entries, eol + 1, all)
        }
    };

fn export_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let _h = println_str("# name\tcalls\tcallers\tlayer\tpattern\trecursive\tsignature");
        let _p = export_print(entries, 0, entries);
        0
    };

fn dc_get_calls(entries: String, pos: i64, target: String) -> String =
    if pos >= entries.len() { "" }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { dc_get_calls(entries, eol + 1, target) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            if name == target { callers_get_field(line, 1, 0, 0) }
            else { dc_get_calls(entries, eol + 1, target) }
        }
    };

fn dc_print_diff_item(items: String, pos: i64, other: String, prefix: String, count: i64) -> i64 =
    if items == "" { count }
    else if pos >= items.len() { count }
    else {
        let end = index_find_comma_or_end(items, pos);
        let item = items.slice(pos, end);
        let next = if end < items.len() { end + 2 } else { end };
        if item.len() == 0 { dc_print_diff_item(items, next, other, prefix, count) }
        else if index_has_name(other, item) { dc_print_diff_item(items, next, other, prefix, count) }
        else {
            let _p = println_str("    " + prefix + item);
            dc_print_diff_item(items, next, other, prefix, count + 1)
        }
    };

fn dc_print_changes(new_entries: String, pos: i64, old_entries: String, count: i64) -> i64 =
    if pos >= new_entries.len() { count }
    else {
        let eol = callers_find_eol(new_entries, pos);
        let line = new_entries.slice(pos, eol);
        if line.len() == 0 { dc_print_changes(new_entries, eol + 1, old_entries, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let new_calls = callers_get_field(line, 1, 0, 0);
            let old_calls = dc_get_calls(old_entries, 0, name);
            if old_calls == "" { dc_print_changes(new_entries, eol + 1, old_entries, count) }
            else if new_calls == old_calls { dc_print_changes(new_entries, eol + 1, old_entries, count) }
            else {
                let _h = println_str("  " + name + ":");
                let added = dc_print_diff_item(new_calls, 0, old_calls, "+ ", 0);
                let removed = dc_print_diff_item(old_calls, 0, new_calls, "- ", 0);
                let total = added + removed;
                let new_count = if total > 0 { count + 1 } else { count };
                dc_print_changes(new_entries, eol + 1, old_entries, new_count)
            }
        }
    };

fn diff_calls_file(old_input: String, new_input: String) -> i64 =
    let old_source = read_file(old_input);
    let new_source = read_file(new_input);
    if old_source.len() == 0 {
        err_no_file(old_input)
    } else if new_source.len() == 0 {
        err_no_file(new_input)
    } else {
        let old_entries = callers_collect_source(old_source, 0, "");
        let new_entries = callers_collect_source(new_source, 0, "");
        let _h = println_str("# Diff-calls: " + old_input + " -> " + new_input);
        let changed = dc_print_changes(new_entries, 0, old_entries, 0);
        let _sep = println_str("---");
        let _s = println_str("  Functions with changed calls: " + int_to_string(changed));
        0
    };

fn cls_category(name: String) -> String =
    let prefix = clust_prefix(name, 0);
    if prefix == "parse" or prefix == "parser" or prefix == "tok" or prefix == "lex" { "parser" }
    else if prefix == "emit" or prefix == "gen" or prefix == "llvm" or prefix == "ir" or prefix == "codegen" { "codegen" }
    else if prefix == "type" or prefix == "infer" or prefix == "unify" or prefix == "check" { "types" }
    else if prefix == "mir" or prefix == "lower" or prefix == "opt" { "mir" }
    else if prefix == "test" or prefix == "assert" or prefix == "verify" { "testing" }
    else if prefix == "print" or prefix == "println" or prefix == "fmt" or prefix == "format" or prefix == "show" { "output" }
    else if prefix == "read" or prefix == "write" or prefix == "open" or prefix == "close" or prefix == "io" { "io" }
    else if prefix == "str" or prefix == "string" or prefix == "char" { "string" }
    else if prefix == "int" or prefix == "float" or prefix == "math" or prefix == "abs" or prefix == "max" or prefix == "min" { "math" }
    else if prefix == "arr" or prefix == "array" or prefix == "vec" or prefix == "list" or prefix == "map" or prefix == "set" { "collection" }
    else if prefix == "is" or prefix == "has" or prefix == "can" or prefix == "should" { "predicate" }
    else if prefix == "get" or prefix == "find" or prefix == "lookup" or prefix == "search" { "accessor" }
    else if prefix == "init" or prefix == "new" or prefix == "create" or prefix == "make" { "constructor" }
    else if prefix == "sort" or prefix == "merge" or prefix == "swap" or prefix == "partition" { "algorithm" }
    else if name == "main" { "entry" }
    else { "other" };

fn cls_count(entries: String, pos: i64, all: String, category: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cls_count(entries, eol + 1, all, category, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let cat = cls_category(name);
            let inc = if cat == category { 1 } else { 0 };
            cls_count(entries, eol + 1, all, category, count + inc)
        }
    };

fn cls_print_cat(entries: String, pos: i64, category: String) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cls_print_cat(entries, eol + 1, category) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let cat = cls_category(name);
            let _p = if cat == category { let _s = println_str("    " + name); 0 } else { 0 };
            cls_print_cat(entries, eol + 1, category)
        }
    };

fn cls_print_if_nonzero(entries: String, all: String, category: String) -> i64 =
    let count = cls_count(entries, 0, all, category, 0);
    if count == 0 { 0 }
    else {
        let _h = println_str("  " + category + " (" + int_to_string(count) + "):");
        cls_print_cat(entries, 0, category)
    };

fn classify_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let fn_count = outline_count_entries(entries, 0, 0);
        let _h = println_str("# Classify: " + input + " (" + int_to_string(fn_count) + " functions)");
        let _c1 = cls_print_if_nonzero(entries, entries, "parser");
        let _c2 = cls_print_if_nonzero(entries, entries, "codegen");
        let _c3 = cls_print_if_nonzero(entries, entries, "types");
        let _c4 = cls_print_if_nonzero(entries, entries, "mir");
        let _c5 = cls_print_if_nonzero(entries, entries, "testing");
        let _c6 = cls_print_if_nonzero(entries, entries, "output");
        let _c7 = cls_print_if_nonzero(entries, entries, "io");
        let _c8 = cls_print_if_nonzero(entries, entries, "string");
        let _c9 = cls_print_if_nonzero(entries, entries, "math");
        let _c10 = cls_print_if_nonzero(entries, entries, "collection");
        let _c11 = cls_print_if_nonzero(entries, entries, "predicate");
        let _c12 = cls_print_if_nonzero(entries, entries, "accessor");
        let _c13 = cls_print_if_nonzero(entries, entries, "constructor");
        let _c14 = cls_print_if_nonzero(entries, entries, "algorithm");
        let _c15 = cls_print_if_nonzero(entries, entries, "entry");
        let _c16 = cls_print_if_nonzero(entries, entries, "other");
        let _sep = println_str("---");
        0
    };

fn rename_check_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let sig = ctx_find_sig(entries, 0, target);
        let _h = println_str("# Rename check: " + target);
        if sig == "" {
            let _p = println_str("  Function not found: " + target);
            1
        } else {
            let _s = println_str("  Signature: " + sig);
            let callers_list = sibl_collect_callers(entries, 0, target, "");
            let caller_count = outline_count_callers(entries, 0, target, 0);
            let calls = deps_find_calls(entries, 0, target);
            let is_rec = cx_is_recursive(target, calls);
            let _c = println_str("  Callers: " + int_to_string(caller_count));
            let _r = if is_rec { println_str("  Recursive: yes (self-references must also be renamed)") } else { println_str("  Recursive: no") };
            let _cl = if callers_list == "" { println_str("  Caller list: (none — safe to rename freely)") }
                      else { println_str("  Must update: " + callers_list) };
            let _sep = println_str("---");
            0
        }
    };

fn sibl_collect_callers(entries: String, pos: i64, target: String, acc: String) -> String =
    if pos >= entries.len() { acc }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { sibl_collect_callers(entries, eol + 1, target, acc) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            if callers_calls_contain(calls, target, 0) {
                let new_acc = if acc == "" { name } else { acc + ", " + name };
                sibl_collect_callers(entries, eol + 1, target, new_acc)
            } else { sibl_collect_callers(entries, eol + 1, target, acc) }
        }
    };

fn sibl_add_from_calls(calls: String, pos: i64, target: String, acc: String) -> String =
    if pos >= calls.len() { acc }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let name = calls.slice(pos, end);
        let new_acc = if name == target or index_has_name(acc, name) { acc }
                      else if acc == "" { name }
                      else { acc + ", " + name };
        if end >= calls.len() { new_acc }
        else { sibl_add_from_calls(calls, end + 2, target, new_acc) }
    };

fn sibl_collect_siblings(entries: String, callers_list: String, pos: i64, target: String, acc: String) -> String =
    if pos >= callers_list.len() { acc }
    else {
        let end = index_find_comma_or_end(callers_list, pos);
        let caller = callers_list.slice(pos, end);
        let calls = deps_find_calls(entries, 0, caller);
        let new_acc = sibl_add_from_calls(calls, 0, target, acc);
        if end >= callers_list.len() { new_acc }
        else { sibl_collect_siblings(entries, callers_list, end + 2, target, new_acc) }
    };

fn sibl_print_list(entries: String, siblings: String, pos: i64, count: i64) -> i64 =
    if pos >= siblings.len() { count }
    else {
        let end = index_find_comma_or_end(siblings, pos);
        let name = siblings.slice(pos, end);
        let sig = ctx_find_sig(entries, 0, name);
        let _p = if sig == "" { println_str("  " + name) }
                 else { println_str("  " + sig) };
        if end >= siblings.len() { count + 1 }
        else { sibl_print_list(entries, siblings, end + 2, count + 1) }
    };

fn siblings_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let callers_list = sibl_collect_callers(entries, 0, target, "");
        let siblings = sibl_collect_siblings(entries, callers_list, 0, target, "");
        let _h = println_str("# Siblings of: " + target);
        let caller_display = if callers_list == "" { "(none)" } else { callers_list };
        let _h2 = println_str("  Shared callers: " + caller_display);
        let count = if siblings == "" { { let _p = println_str("  (no siblings)"); 0 } }
                    else { sibl_print_list(entries, siblings, 0, 0) };
        let _sep = println_str("---");
        let _s = println_str("  Total: " + int_to_string(count) + " siblings");
        0
    };

fn summary_count_recursive(entries: String, pos: i64, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { summary_count_recursive(entries, eol + 1, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let inc = if cx_is_recursive(name, calls) { 1 } else { 0 };
            summary_count_recursive(entries, eol + 1, count + inc)
        }
    };

fn summary_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let loc = stats_count_lines(source, 0, 1);
        let fn_count = outline_count_entries(entries, 0, 0);
        let struct_count = stats_count_structs(source, 0, 0);
        let entry_count = stats_count_entries(entries, 0, entries, 0);
        let leaf_count = stats_count_leaves(entries, 0, 0);
        let recursive_count = summary_count_recursive(entries, 0, 0);
        let most = stats_most_called(entries, 0, entries, "(none)", 0);
        // Layers
        let l0 = layer_count_at(entries, 0, entries, 0, 0);
        let l1 = layer_count_at(entries, 0, entries, 1, 0);
        let l2 = layer_count_at(entries, 0, entries, 2, 0);
        let l3 = layer_count_at(entries, 0, entries, 3, 0);
        // Print
        let _h = println_str("# Summary: " + input);
        let _s1 = println_str("  LOC:        " + int_to_string(loc));
        let _s2 = println_str("  Size:       " + int_to_string(source.len()) + " bytes");
        let _s3 = println_str("  Functions:  " + int_to_string(fn_count));
        let _s4 = println_str("  Structs:    " + int_to_string(struct_count));
        let _s5 = println_str("  Recursive:  " + int_to_string(recursive_count));
        let _s6 = println_str("  Entry pts:  " + int_to_string(entry_count));
        let _s7 = println_str("  Most called: " + most);
        let _l = println_str("  Layers: leaf=" + int_to_string(l0) + " near-leaf=" + int_to_string(l1) + " mid=" + int_to_string(l2) + " entry=" + int_to_string(l3));
        let _sep = println_str("---");
        0
    };

fn graph_print_calls(calls: String, pos: i64, from_name: String) -> i64 =
    if pos >= calls.len() { 0 }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let name = calls.slice(pos, end);
        let _p = println_str("  " + from_name + " -> " + name);
        if end >= calls.len() { 0 }
        else { graph_print_calls(calls, end + 2, from_name) }
    };

fn graph_print(entries: String, pos: i64) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { graph_print(entries, eol + 1) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let _p = if calls == "" { 0 }
                     else { graph_print_calls(calls, 0, name) };
            graph_print(entries, eol + 1)
        }
    };

fn graph_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let _h = println_str("# Call Graph: " + input);
        let _g = graph_print(entries, 0);
        let _sep = println_str("---");
        0
    };

fn split_count_params(sig: String, pos: i64) -> i64 =
    if pos >= sig.len() { 0 }
    else if sig.slice(pos, pos + 1) == "(" {
        split_count_inner(sig, pos + 1, 0)
    }
    else { split_count_params(sig, pos + 1) };

fn split_count_inner(sig: String, pos: i64, commas: i64) -> i64 =
    if pos >= sig.len() { commas + 1 }
    else if sig.slice(pos, pos + 1) == ")" {
        if commas == 0 and sig.slice(pos - 1, pos) == "(" { 0 }
        else { commas + 1 }
    }
    else if sig.slice(pos, pos + 1) == "," { split_count_inner(sig, pos + 1, commas + 1) }
    else { split_count_inner(sig, pos + 1, commas) };

fn split_print(entries: String, pos: i64, all: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { split_print(entries, eol + 1, all, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let call_count = outline_count_calls(calls, 0, 0);
            let param_count = split_count_params(sig, 0);
            if call_count > 8 or param_count > 5 {
                let reason = if call_count > 8 and param_count > 5 { "calls=" + int_to_string(call_count) + " params=" + int_to_string(param_count) }
                             else if call_count > 8 { "calls=" + int_to_string(call_count) }
                             else { "params=" + int_to_string(param_count) };
                let _p = println_str("  " + sig + "  [" + reason + "]");
                split_print(entries, eol + 1, all, count + 1)
            } else { split_print(entries, eol + 1, all, count) }
        }
    };

fn split_candidates_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let _h = println_str("# Split candidates: " + input);
        let _h2 = println_str("  (>8 calls or >5 params)");
        let count = split_print(entries, 0, entries, 0);
        let _sep = println_str("---");
        let _s = println_str("  Total: " + int_to_string(count) + " candidates");
        0
    };

fn inline_print(entries: String, pos: i64, all: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { inline_print(entries, eol + 1, all, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let calls = callers_get_field(line, 1, 0, 0);
            let sig = callers_get_field(line, 2, 0, 0);
            let caller_count = outline_count_callers(all, 0, name, 0);
            let call_count = outline_count_calls(calls, 0, 0);
            // Inline candidate: exactly 1 caller, not recursive, few calls
            if caller_count == 1 and call_count <= 3 and not (name == "main") and not cx_is_recursive(name, calls) {
                let _p = println_str("  " + sig + "  [calls=" + int_to_string(call_count) + "]");
                inline_print(entries, eol + 1, all, count + 1)
            } else { inline_print(entries, eol + 1, all, count) }
        }
    };

fn inline_candidates_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let _h = println_str("# Inline candidates: " + input);
        let _h2 = println_str("  (1 caller, <=3 calls, not recursive)");
        let count = inline_print(entries, 0, entries, 0);
        let _sep = println_str("---");
        let _s = println_str("  Total: " + int_to_string(count) + " candidates");
        0
    };

// DFS search: returns path string "a -> b -> c" or "" if not found
fn chain_dfs_calls(entries: String, calls: String, pos: i64, target: String, visited: String, depth: i64, path: String) -> String =
    if pos >= calls.len() { "" }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let name = calls.slice(pos, end);
        let result = if name == target { path + " -> " + target }
                     else if depth <= 0 { "" }
                     else if index_has_name(visited, name) { "" }
                     else {
                         let sub_calls = deps_find_calls(entries, 0, name);
                         let new_visited = if visited == "" { name } else { visited + ", " + name };
                         chain_dfs_calls(entries, sub_calls, 0, target, new_visited, depth - 1, path + " -> " + name)
                     };
        if result == "" {
            if end >= calls.len() { "" }
            else { chain_dfs_calls(entries, calls, end + 2, target, visited, depth, path) }
        } else { result }
    };

fn chain_search(entries: String, from_name: String, target: String, depth: i64, max_depth: i64) -> String =
    if depth > max_depth { "" }
    else {
        let calls = deps_find_calls(entries, 0, from_name);
        let result = chain_dfs_calls(entries, calls, 0, target, from_name, depth - 1, from_name);
        if result == "" { chain_search(entries, from_name, target, depth + 1, max_depth) }
        else { result }
    };

fn chain_file(input: String, from_name: String, to_name: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let _h = println_str("# Chain: " + from_name + " -> " + to_name);
        if from_name == to_name {
            let _p = println_str("  " + from_name + " (same function)");
            let _sep = println_str("---");
            0
        } else {
            // Check direct call first, then iterative deepening up to depth 10
            let result = chain_search(entries, from_name, to_name, 1, 10);
            let _p = if result == "" { println_str("  No path found (max depth 10)") }
                     else { println_str("  " + result) };
            let _sep = println_str("---");
            0
        }
    };

fn suggest_search(entries: String, pos: i64, pattern: String, count: i64) -> i64 =
    if pos >= entries.len() { count }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { suggest_search(entries, eol + 1, pattern, count) }
        else {
            let sig = callers_get_field(line, 2, 0, 0);
            if has_pattern(sig, pattern, 0) {
                let name = callers_get_field(line, 0, 0, 0);
                let calls_csv = callers_get_field(line, 1, 0, 0);
                let call_count = outline_count_calls(calls_csv, 0, 0);
                let _p = println_str("  " + sig + "  [calls=" + int_to_string(call_count) + "]");
                suggest_search(entries, eol + 1, pattern, count + 1)
            } else { suggest_search(entries, eol + 1, pattern, count) }
        }
    };

fn suggest_file(input: String, pattern: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let _h = println_str("# Suggest: \"" + pattern + "\" in " + input);
        let count = suggest_search(entries, 0, pattern, 0);
        let _sep = println_str("---");
        let _s = println_str("  Matches: " + int_to_string(count));
        0
    };

fn scope_print_callees(entries: String, calls: String, pos: i64) -> i64 =
    if pos >= calls.len() { 0 }
    else {
        let end = index_find_comma_or_end(calls, pos);
        let name = calls.slice(pos, end);
        let sig = ctx_find_sig(entries, 0, name);
        let _p = if sig != "" { println_str("    " + sig) } else { println_str("") };
        if end >= calls.len() { 0 }
        else { scope_print_callees(entries, calls, end + 2) }
    };

fn scope_print_callers(entries: String, pos: i64, target: String) -> i64 =
    if pos >= entries.len() { 0 }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { scope_print_callers(entries, eol + 1, target) }
        else {
            let calls = callers_get_field(line, 1, 0, 0);
            let _p = if callers_calls_contain(calls, target, 0) {
                let sig = callers_get_field(line, 2, 0, 0);
                let _s = println_str("    " + sig);
                0
            } else { 0 };
            scope_print_callers(entries, eol + 1, target)
        }
    };

fn scope_file(input: String, target: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let entries = callers_collect_source(source, 0, "");
        let span = ctx_find_fn(source, 0, target);
        if unpack_ast(span) == "" {
            { print_str("Function not found: "); println_str(target); 1 }
        } else {
            // Header
            let _h = println_str("# Scope: " + target);
            let _h2 = println_str("  File: " + input);
            // Signature
            let sig = ctx_find_sig(entries, 0, target);
            let _s = println_str("  Sig:  " + sig);
            // Layer
            let calls = deps_find_calls(entries, 0, target);
            let callers_count = outline_count_callers(entries, 0, target, 0);
            let layer = layer_classify(entries, target, calls, callers_count);
            let _l = println_str("  Layer: " + layer_name(layer) + " (calls=" + int_to_string(outline_count_calls(calls, 0, 0)) + " callers=" + int_to_string(callers_count) + ")");
            // Body
            let _b1 = println_str("");
            let _b2 = println_str("## Body");
            let fn_start = unpack_pos(span);
            let fn_end = parse_int_simple(unpack_ast(span), 0, 0);
            let _body = println_str(source.slice(fn_start, fn_end));
            // Callees
            let _c1 = println_str("## Calls");
            let _callees = if calls == "" { let _n = println_str("    (none)"); 0 }
                           else { scope_print_callees(entries, calls, 0) };
            // Callers
            let _cr1 = println_str("");
            let _cr2 = println_str("## Called by");
            let _callers = if callers_count == 0 { let _n = println_str("    (none)"); 0 }
                           else { scope_print_callers(entries, 0, target) };
            let _end = println_str("---");
            0
        }
    };

// v0.95: Changelog command - diff function signatures between two files
// Check if name exists in entries
fn cl_has_name(entries: String, pos: i64, target: String) -> bool =
    if pos >= entries.len() { false }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cl_has_name(entries, eol + 1, target) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            if name == target { true }
            else { cl_has_name(entries, eol + 1, target) }
        }
    };

// Get signature for a function name from entries
fn cl_get_sig(entries: String, pos: i64, target: String) -> String =
    if pos >= entries.len() { "" }
    else {
        let eol = callers_find_eol(entries, pos);
        let line = entries.slice(pos, eol);
        if line.len() == 0 { cl_get_sig(entries, eol + 1, target) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            if name == target { callers_get_field(line, 2, 0, 0) }
            else { cl_get_sig(entries, eol + 1, target) }
        }
    };

// Print added functions (in new but not in old)
fn cl_print_added(new_entries: String, pos: i64, old_entries: String, count: i64) -> i64 =
    if pos >= new_entries.len() { count }
    else {
        let eol = callers_find_eol(new_entries, pos);
        let line = new_entries.slice(pos, eol);
        if line.len() == 0 { cl_print_added(new_entries, eol + 1, old_entries, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            if cl_has_name(old_entries, 0, name) {
                cl_print_added(new_entries, eol + 1, old_entries, count)
            } else {
                let sig = callers_get_field(line, 2, 0, 0);
                let _p = println_str("  + " + sig);
                cl_print_added(new_entries, eol + 1, old_entries, count + 1)
            }
        }
    };

// Print removed functions (in old but not in new)
fn cl_print_removed(old_entries: String, pos: i64, new_entries: String, count: i64) -> i64 =
    if pos >= old_entries.len() { count }
    else {
        let eol = callers_find_eol(old_entries, pos);
        let line = old_entries.slice(pos, eol);
        if line.len() == 0 { cl_print_removed(old_entries, eol + 1, new_entries, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            if cl_has_name(new_entries, 0, name) {
                cl_print_removed(old_entries, eol + 1, new_entries, count)
            } else {
                let sig = callers_get_field(line, 2, 0, 0);
                let _p = println_str("  - " + sig);
                cl_print_removed(old_entries, eol + 1, new_entries, count + 1)
            }
        }
    };

// Print changed functions (same name, different signature)
fn cl_print_changed(new_entries: String, pos: i64, old_entries: String, count: i64) -> i64 =
    if pos >= new_entries.len() { count }
    else {
        let eol = callers_find_eol(new_entries, pos);
        let line = new_entries.slice(pos, eol);
        if line.len() == 0 { cl_print_changed(new_entries, eol + 1, old_entries, count) }
        else {
            let name = callers_get_field(line, 0, 0, 0);
            let new_sig = callers_get_field(line, 2, 0, 0);
            let old_sig = cl_get_sig(old_entries, 0, name);
            if old_sig == "" { cl_print_changed(new_entries, eol + 1, old_entries, count) }
            else if new_sig == old_sig { cl_print_changed(new_entries, eol + 1, old_entries, count) }
            else {
                let _p1 = println_str("  ~ " + name + ":");
                let _p2 = println_str("    old: " + old_sig);
                let _p3 = println_str("    new: " + new_sig);
                cl_print_changed(new_entries, eol + 1, old_entries, count + 1)
            }
        }
    };

fn changelog_file(old_input: String, new_input: String) -> i64 =
    let old_source = read_file(old_input);
    let new_source = read_file(new_input);
    if old_source.len() == 0 {
        err_no_file(old_input)
    } else if new_source.len() == 0 {
        err_no_file(new_input)
    } else {
        let old_entries = callers_collect_source(old_source, 0, "");
        let new_entries = callers_collect_source(new_source, 0, "");
        let old_count = outline_count_entries(old_entries, 0, 0);
        let new_count = outline_count_entries(new_entries, 0, 0);
        let _header = println_str("# Changelog: " + old_input + " -> " + new_input);
        let _counts = println_str("  Old: " + int_to_string(old_count) + " functions, New: " + int_to_string(new_count) + " functions");
        let _ah = println_str("");
        let _a1 = println_str("## Added:");
        let added = cl_print_added(new_entries, 0, old_entries, 0);
        let _rh = println_str("");
        let _r1 = println_str("## Removed:");
        let removed = cl_print_removed(old_entries, 0, new_entries, 0);
        let _ch = println_str("");
        let _c1 = println_str("## Changed:");
        let changed = cl_print_changed(new_entries, 0, old_entries, 0);
        let _sep = println_str("---");
        let _summary = println_str("  Added: " + int_to_string(added) + " | Removed: " + int_to_string(removed) + " | Changed: " + int_to_string(changed));
        0
    };

fn check_file(input: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            print_compile_err(input, llvm)
        } else {
            { print_str("OK: "); println_str(input); 0 }
        }
    };

// v0.90: Build command - compile BMB source to native executable
// Pipeline: source -> LLVM IR -> opt -O3 -> clang -> executable
fn build_file(input: String, output: String, fast: bool, runtime_path: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            print_compile_err(input, llvm)
        } else {
            // Write IR to temp file
            let ir_file = output + ".ll";
            let w1 = write_file_newlines(ir_file, llvm);
            let runtime_lib = runtime_path + "/libbmb_runtime.a";
            // Build pipeline: opt -> clang
            let result = if fast {
                build_native_fast(ir_file, output, runtime_lib)
            } else {
                build_native_opt(ir_file, output, runtime_lib)
            };
            result
        }
    };

// Build with full optimization: opt -O3 then clang
fn build_native_opt(ir_file: String, output: String, runtime_lib: String) -> i64 =
    let opt_file = output + "_opt.ll";
    // Step 1: Optimize IR
    let dq = chr(34);
    let opt_cmd = "opt --mcpu=native --vectorize-slp=false -passes=" + dq + "default<O3>,scalarizer" + dq + " " + ir_file + " -S -o " + opt_file;
    let opt_result = system(opt_cmd);
    if opt_result != 0 {
        // Fallback: try without scalarizer
        let opt_cmd2 = "opt -O3 " + ir_file + " -S -o " + opt_file;
        let opt_result2 = system(opt_cmd2);
        if opt_result2 != 0 {
            { println_str("Error: opt failed. Falling back to direct compilation."); build_native_direct(ir_file, output, runtime_lib) }
        } else {
            build_link(opt_file, output, runtime_lib, ir_file)
        }
    } else {
        build_link(opt_file, output, runtime_lib, ir_file)
    };

// Build fast: skip opt, use clang -O2 directly
fn build_native_fast(ir_file: String, output: String, runtime_lib: String) -> i64 =
    build_link(ir_file, output, runtime_lib, "");

// Build without opt: direct clang on IR
fn build_native_direct(ir_file: String, output: String, runtime_lib: String) -> i64 =
    build_link(ir_file, output, runtime_lib, "");

// Link step: clang IR + runtime -> executable
fn build_link(ir_file: String, output: String, runtime_lib: String, cleanup_file: String) -> i64 =
    let link_cmd = "clang -O3 " + ir_file + " " + runtime_lib + " -o " + output + " -lm -lws2_32";
    let link_result = system(link_cmd);
    if link_result != 0 {
        // Try without ws2_32 (Linux/macOS)
        let link_cmd2 = "clang -O3 " + ir_file + " " + runtime_lib + " -o " + output + " -lm -lpthread";
        let link_result2 = system(link_cmd2);
        if link_result2 != 0 {
            { println_str("Error: linking failed"); 1 }
        } else {
            build_cleanup(output, cleanup_file)
        }
    } else {
        build_cleanup(output, cleanup_file)
    };

// Report success and optionally clean temp files
fn build_cleanup(output: String, cleanup_file: String) -> i64 =
    { print_str("{"); print_str(chr(34)); print_str("type"); print_str(chr(34)); print_str(":"); print_str(chr(34)); print_str("build_success"); print_str(chr(34)); print_str(","); print_str(chr(34)); print_str("output"); print_str(chr(34)); print_str(":"); print_str(chr(34)); print_str(output); print_str(chr(34)); println_str("}"); 0 };

// Derive output name from input: foo.bmb -> foo (or foo.exe on Windows)
fn derive_output_name(input: String) -> String =
    if input.len() > 4 and input.slice(input.len() - 4, input.len()) == ".bmb" {
        input.slice(0, input.len() - 4)
    } else { input + ".out" };

// Bootstrap version - extended CLI
fn main() -> i64 =
    let _arena = arena_mode(1);
    let argc = arg_count();
    if argc < 2 {
        show_help()
    } else {
        let cmd = get_arg(1);
        if cmd == "--version" or cmd == "version" {
            println_str("BMB Bootstrap Compiler v0.96.0");
            0
        } else if cmd == "--help" or cmd == "help" {
            show_help()
        } else if cmd == "build" and argc >= 3 {
            // v0.90: Build to native executable
            let input = get_arg(2);
            let output = parse_build_output(argc, input);
            let fast = parse_build_fast(argc);
            let runtime = parse_build_runtime(argc);
            build_file(input, output, fast, runtime)
        } else if cmd == "emit-ir" and argc >= 4 {
            emit_ir(get_arg(2), get_arg(3))
        } else if cmd == "emit-ir" and argc >= 3 {
            // Default output name: replace .bmb with .ll
            let input = get_arg(2);
            let output = if input.len() > 4 and input.slice(input.len() - 4, input.len()) == ".bmb" {
                input.slice(0, input.len() - 4) + ".ll"
            } else { input + ".ll" };
            emit_ir(input, output)
        } else if cmd == "check" and argc >= 3 {
            check_file(get_arg(2))
        } else if cmd == "index" and argc >= 3 {
            // v0.95: Index command - extract function signatures for AI tooling
            index_file(get_arg(2))
        } else if cmd == "query" and argc >= 4 {
            // v0.95: Query command - search functions by name pattern
            query_file(get_arg(2), get_arg(3))
        } else if cmd == "callers" and argc >= 4 {
            // v0.95: Callers command - reverse call graph
            callers_file(get_arg(2), get_arg(3))
        } else if cmd == "deps" and argc >= 4 {
            // v0.95: Deps command - transitive dependency analysis
            deps_file(get_arg(2), get_arg(3))
        } else if cmd == "context" and argc >= 4 {
            // v0.95: Context command - gather full AI context
            context_file(get_arg(2), get_arg(3))
        } else if cmd == "outline" and argc >= 3 {
            // v0.95: Outline command - compact project overview
            outline_file(get_arg(2))
        } else if cmd == "xref" and argc >= 4 {
            // v0.95: Xref command - comprehensive cross-reference
            xref_file(get_arg(2), get_arg(3))
        } else if cmd == "impact" and argc >= 4 {
            // v0.95: Impact command - change blast radius
            impact_file(get_arg(2), get_arg(3))
        } else if cmd == "stats" and argc >= 3 {
            // v0.95: Stats command - code statistics
            stats_file(get_arg(2))
        } else if cmd == "unused" and argc >= 3 {
            // v0.95: Unused command - find dead functions
            unused_file(get_arg(2))
        } else if cmd == "complexity" and argc >= 3 {
            // v0.95: Complexity command - per-function metrics
            complexity_file(get_arg(2))
        } else if cmd == "similar" and argc >= 4 {
            // v0.95: Similar command - find similar functions
            similar_file(get_arg(2), get_arg(3))
        } else if cmd == "layers" and argc >= 3 {
            // v0.95: Layers command - architectural layer analysis
            layers_file(get_arg(2))
        } else if cmd == "hotspots" and argc >= 3 {
            // v0.95: Hotspots command - most connected functions
            hotspots_file(get_arg(2))
        } else if cmd == "changelog" and argc >= 4 {
            // v0.95: Changelog command - diff function signatures
            changelog_file(get_arg(2), get_arg(3))
        } else if cmd == "body" and argc >= 4 {
            body_file(get_arg(2), get_arg(3))
        } else if cmd == "scope" and argc >= 4 {
            scope_file(get_arg(2), get_arg(3))
        } else if cmd == "suggest" and argc >= 4 {
            suggest_file(get_arg(2), get_arg(3))
        } else if cmd == "interface" and argc >= 3 {
            interface_file(get_arg(2))
        } else if cmd == "chain" and argc >= 5 {
            chain_file(get_arg(2), get_arg(3), get_arg(4))
        } else if cmd == "inline-candidates" and argc >= 3 {
            inline_candidates_file(get_arg(2))
        } else if cmd == "split-candidates" and argc >= 3 {
            split_candidates_file(get_arg(2))
        } else if cmd == "graph" and argc >= 3 {
            graph_file(get_arg(2))
        } else if cmd == "siblings" and argc >= 4 {
            siblings_file(get_arg(2), get_arg(3))
        } else if cmd == "summary" and argc >= 3 {
            summary_file(get_arg(2))
        } else if cmd == "clusters" and argc >= 3 {
            clusters_file(get_arg(2))
        } else if cmd == "rename-check" and argc >= 4 {
            rename_check_file(get_arg(2), get_arg(3))
        } else if cmd == "coverage" and argc >= 3 {
            coverage_file(get_arg(2))
        } else if cmd == "pattern" and argc >= 3 {
            pattern_file(get_arg(2))
        } else if cmd == "export" and argc >= 3 {
            export_file(get_arg(2))
        } else if cmd == "diff-calls" and argc >= 4 {
            diff_calls_file(get_arg(2), get_arg(3))
        } else if cmd == "classify" and argc >= 3 {
            classify_file(get_arg(2))
        } else if argc >= 3 {
            // Legacy mode: compiler input.bmb output.ll
            compile_file_to(get_arg(1), get_arg(2))
        } else {
            show_help()
        }
    };

// Parse -o flag from build args
fn parse_build_output(argc: i64, input: String) -> String =
    if argc >= 5 and get_arg(3) == "-o" { get_arg(4) }
    else { derive_output_name(input) };

// Parse --fast-compile flag from build args
fn parse_build_fast(argc: i64) -> bool =
    check_arg_flag(argc, 3, "--fast-compile");

// Parse --runtime flag from build args (default: bmb/runtime)
fn parse_build_runtime(argc: i64) -> String =
    find_arg_value(argc, 3, "--runtime", "bmb/runtime");

fn find_arg_value(argc: i64, idx: i64, flag: String, default_val: String) -> String =
    if idx >= argc { default_val }
    else if get_arg(idx) == flag and idx + 1 < argc { get_arg(idx + 1) }
    else { find_arg_value(argc, idx + 1, flag, default_val) };

fn check_arg_flag(argc: i64, idx: i64, flag: String) -> bool =
    if idx >= argc { false }
    else if get_arg(idx) == flag { true }
    else { check_arg_flag(argc, idx + 1, flag) };

fn show_help() -> i64 = {
    println_str("BMB Bootstrap Compiler v0.96.0");
    println_str("");
    println_str("Core commands:");
    println_str("  build <file> [-o output] [--fast-compile] [--runtime <path>]");
    println_str("  emit-ir <file> [output.ll]    Emit LLVM IR");
    println_str("  check <file>                  Type check only");
    println_str("  --version                     Show version");
    println_str("");
    println_str("Code analysis:");
    println_str("  index <file>                  Extract function signatures");
    println_str("  query <file> <pattern>        Search functions by name");
    println_str("  body <file> <function>        Extract function source");
    println_str("  stats <file>                  Code statistics");
    println_str("  complexity <file>             Per-function metrics");
    println_str("  unused <file>                 Find unused functions");
    println_str("  coverage <file>               Reachability from main");
    println_str("  pattern <file>                Classify function patterns");
    println_str("  classify <file>               Auto-classify purpose");
    println_str("");
    println_str("Dependency analysis:");
    println_str("  callers <file> <function>     Find callers");
    println_str("  deps <file> <function>        Transitive dependencies");
    println_str("  impact <file> <function>      Change blast radius");
    println_str("  xref <file> <function>        Cross-reference");
    println_str("  chain <file> <from> <to>      Call path between functions");
    println_str("  siblings <file> <function>    Functions sharing callers");
    println_str("  graph <file>                  Export call graph");
    println_str("  hotspots <file>               Most connected functions");
    println_str("  layers <file>                 Architectural layers");
    println_str("  clusters <file>               Group by name prefix");
    println_str("");
    println_str("AI tooling:");
    println_str("  context <file> <function>     Gather AI context");
    println_str("  scope <file> <function>       AI-optimized context");
    println_str("  outline <file>                Compact overview");
    println_str("  summary <file>                AI-friendly summary");
    println_str("  suggest <file> <pattern>      Search by signature");
    println_str("  interface <file>              API surface");
    println_str("  export <file>                 Structured data (TSV)");
    println_str("");
    println_str("Refactoring:");
    println_str("  similar <file> <function>     Find similar functions");
    println_str("  inline-candidates <file>      Small functions called once");
    println_str("  split-candidates <file>       Complex functions to refactor");
    println_str("  rename-check <file> <fn>      Check rename safety");
    println_str("");
    println_str("Comparison:");
    println_str("  changelog <old> <new>         Diff function signatures");
    println_str("  diff-calls <old> <new>        Compare call graphs");
    0
};


// v0.46: Compile with output file
fn compile_file_to(input: String, output: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        err_no_file(input)
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            { println_str(llvm); 1 }
        } else {
            let w2 = write_file_newlines(output, llvm);
            0
        }
    };
