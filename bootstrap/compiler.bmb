// BMB Unified Compiler (v0.60.235: Fix int_to_string runtime function mapping)
// v0.60.235 changes:
// - Removed int_to_string -> bmb_int_to_string runtime mapping
// - BMB program's int_to_string should call itself, not the runtime function
// - Runtime bmb_int_to_string returns char*, not BmbString*, causing type mismatch
// v0.60.234 changes:
// - Fixed find_marker_limited to search from END instead of beginning
// - String markers are appended at end, so must search backwards
// - Fixes Stage 3 "add nsw i64" instead of bmb_string_concat bug
// v0.60.230 changes:
// - Split is_string_returning_fn into 5 helper functions (is_string_fn_group1-5)
// - Reduces work stack depth during compilation to prevent stack overflow
// - Enables Stage 2 to compile full compiler.bmb with 400+ functions
// v0.60.224 changes:
// - Removed target triple from IR header (let LLVM use host default)
// - Fixes Windows linking issues caused by Linux target triple
// v0.60.223 changes:
// - Added llvm_gen_add_with_strings for string concatenation detection
// - String marker propagation through copy operations
// - Enabled call string tracking (llvm_gen_call_with_string_tracking)
// - Expanded is_string_returning_fn list
// - Fixed void function handling in error messages
// Complete compilation pipeline: Source -> AST -> MIR -> LLVM IR
//
// ARCHITECTURE:
// 1. Source (BMB) -> parse_source() -> S-expression AST
// 2. AST -> lower_program() -> MIR text
// 3. MIR -> gen_program() -> LLVM IR text
// 4. Assembly: header + declarations + functions
//
// This file integrates pipeline.bmb and llvm_ir.bmb to provide
// a unified entry point for BMB compilation.
//
// Note: Uses | as separator instead of newlines (BMB string limitation)

// ============================================================================
// SECTION 1: String Utilities (required - no imports in bootstrap)
// ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.byte_at(pos)) { skip_ws(s, pos + 1) } else { pos };

// Error handling utilities
fn is_error(s: String) -> bool = s.len() >= 3 and s.slice(0, 3) == "ERR";
fn make_error(msg: String) -> String = "ERR:" + msg;

// v0.88.8: Position-aware error with line:col info
fn count_line_at(src: String, pos: i64, cur: i64, line: i64) -> i64 =
    if cur >= pos or cur >= src.len() { line }
    else if src.byte_at(cur) == 10 { count_line_at(src, pos, cur + 1, line + 1) }
    else { count_line_at(src, pos, cur + 1, line) };

fn count_col_at(src: String, pos: i64, cur: i64) -> i64 =
    if cur >= pos or cur >= src.len() { pos - cur }
    else if src.byte_at(cur) == 10 { count_col_at(src, pos, cur + 1) }
    else { count_col_at(src, pos, cur) };

fn find_line_start(src: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if src.byte_at(pos - 1) == 10 { pos }
    else { find_line_start(src, pos - 1) };

fn find_line_end(src: String, pos: i64) -> i64 =
    if pos >= src.len() { pos }
    else if src.byte_at(pos) == 10 { pos }
    else { find_line_end(src, pos + 1) };

fn make_error_at(msg: String, src: String, pos: i64) -> String =
    let line = count_line_at(src, pos, 0, 1);
    let ls = find_line_start(src, pos);
    let col = pos - ls + 1;
    "ERR:" + msg + " at line " + int_to_string(line) + ":" + int_to_string(col);

// Check if string starts with pattern
fn starts_with(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else { s.slice(pos, pos + pat.len()) == pat };

fn has_pattern(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else if starts_with(s, pat, pos) { true } else { has_pattern(s, pat, pos + 1) };

// v0.60.222: Safe if-chain accumulation (no recursion, no find/replace)
// Uses prefix+suffix approach: prefix="(if c1 t1 (if c2 t2 " suffix="))"
// Final AST = prefix + else_body + suffix

// ============================================================================
// SECTION 2: Token Constants (from pipeline.bmb)
// ============================================================================

// v0.60.116: Token constants in 1000-1999 range (reserved for tokens)
// Integer literals: 0-999 and 2000+ are parsed as integers
// Token constants: 1000-1999 are reserved for token types
// IMPORTANT: Token values use (9999999 + 1 + N) = 10000000 + N to avoid collision with integer literals
// v0.88.7: Token constants in 10000000-10000999 range (integers 0-9999999 and 10001000+ work)
// (v0.60.118 used 10000-10999 but integers 10000-10999 collided with token kinds)
fn TK_FN() -> i64 = 9999999 + 1 + 100;
fn TK_LET() -> i64 = 9999999 + 1 + 101;
fn TK_IF() -> i64 = 9999999 + 1 + 102;
fn TK_THEN() -> i64 = 9999999 + 1 + 103;
fn TK_ELSE() -> i64 = 9999999 + 1 + 104;
fn TK_TRUE() -> i64 = 9999999 + 1 + 105;
fn TK_FALSE() -> i64 = 9999999 + 1 + 106;
fn TK_AND() -> i64 = 9999999 + 1 + 107;
fn TK_OR() -> i64 = 9999999 + 1 + 108;
fn TK_NOT() -> i64 = 9999999 + 1 + 109;
fn TK_PRE() -> i64 = 9999999 + 1 + 110;
fn TK_POST() -> i64 = 9999999 + 1 + 111;
fn TK_MUT() -> i64 = 9999999 + 1 + 117;
fn TK_WHILE() -> i64 = 9999999 + 1 + 118;  // v0.60.248: while loop support
// v0.88: Concurrency keywords
fn TK_ASYNC() -> i64 = 9999999 + 1 + 119;
fn TK_AWAIT() -> i64 = 9999999 + 1 + 120;
fn TK_SELECT() -> i64 = 9999999 + 1 + 121;

fn TK_I32() -> i64 = 9999999 + 1 + 150;
fn TK_I64() -> i64 = 9999999 + 1 + 151;
fn TK_F64() -> i64 = 9999999 + 1 + 152;
fn TK_BOOL() -> i64 = 9999999 + 1 + 153;
fn TK_STRING_TYPE() -> i64 = 9999999 + 1 + 154;
// v0.88: Concurrency type tokens
fn TK_FUTURE() -> i64 = 9999999 + 1 + 155;
fn TK_MUTEX() -> i64 = 9999999 + 1 + 156;
fn TK_ATOMIC() -> i64 = 9999999 + 1 + 157;
fn TK_CHANNEL() -> i64 = 9999999 + 1 + 158;
fn TK_SENDER() -> i64 = 9999999 + 1 + 159;
fn TK_RECEIVER() -> i64 = 9999999 + 1 + 160;
fn TK_RWLOCK() -> i64 = 9999999 + 1 + 161;
fn TK_THREADPOOL() -> i64 = 9999999 + 1 + 162;
fn TK_SCOPE() -> i64 = 9999999 + 1 + 163;

fn TK_INT() -> i64 = 9999999 + 1 + 200;
fn TK_IDENT() -> i64 = 9999999 + 1 + 201;
fn TK_STRING_LIT() -> i64 = 9999999 + 1 + 202;

fn TK_COLON() -> i64 = 9999999 + 1 + 300;
fn TK_EQ() -> i64 = 9999999 + 1 + 302;
fn TK_SEMI() -> i64 = 9999999 + 1 + 303;
fn TK_COMMA() -> i64 = 9999999 + 1 + 304;
fn TK_LPAREN() -> i64 = 9999999 + 1 + 305;
fn TK_RPAREN() -> i64 = 9999999 + 1 + 306;
// v0.46: Brace tokens for v0.32 braced if-else syntax
fn TK_LBRACE() -> i64 = 9999999 + 1 + 307;
fn TK_RBRACE() -> i64 = 9999999 + 1 + 308;

fn TK_ARROW() -> i64 = 9999999 + 1 + 321;
fn TK_DOT() -> i64 = 9999999 + 1 + 322;
fn TK_DOTDOT() -> i64 = 9999999 + 1 + 323;

fn TK_PLUS() -> i64 = 9999999 + 1 + 400;
fn TK_MINUS() -> i64 = 9999999 + 1 + 401;
fn TK_STAR() -> i64 = 9999999 + 1 + 402;
fn TK_SLASH() -> i64 = 9999999 + 1 + 403;
fn TK_PERCENT() -> i64 = 9999999 + 1 + 404;
fn TK_LT() -> i64 = 9999999 + 1 + 405;
fn TK_GT() -> i64 = 9999999 + 1 + 406;

fn TK_EQEQ() -> i64 = 9999999 + 1 + 410;
fn TK_NEQ() -> i64 = 9999999 + 1 + 411;
fn TK_LTEQ() -> i64 = 9999999 + 1 + 412;
fn TK_GTEQ() -> i64 = 9999999 + 1 + 413;

fn TK_EOF() -> i64 = 9999999 + 1 + 900;

// ============================================================================
// SECTION 3: Lexer (from pipeline.bmb)
// ============================================================================

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 10 { pos + 1 } else { skip_to_eol(s, pos + 1) };

// v0.46: Support both -- (legacy) and // (v0.32) comment styles
fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 45 { skip_comment(s, skip_to_eol(s, pos + 2)) }
    else if pos + 1 < s.len() and s.byte_at(pos) == 47 and s.byte_at(pos + 1) == 47 { skip_comment(s, skip_to_eol(s, pos + 2)) }
    else { pos };

fn skip_ws_comments(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == p1 { p1 } else { skip_ws_comments(s, p2) };

fn scan_int(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc * 1000000 + pos } else {
        let c = s.byte_at(pos);
        if is_digit(c) { scan_int(s, pos + 1, acc * 10 + (c - 48)) } else { acc * 1000000 + pos }
    };

fn scan_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_alnum_or_underscore(s.byte_at(pos)) { scan_ident_end(s, pos + 1) } else { pos };

// v0.60.109: Scan string literal - find closing quote
// Returns position after closing quote, or s.len() if not found
fn scan_string_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 34 { pos + 1 }
    else { scan_string_end(s, pos + 1) };

fn tok_val(r: i64) -> i64 = r / 1000000;
fn tok_end(r: i64) -> i64 = r - (r / 1000000) * 1000000;
fn tok_kind(r: i64) -> i64 = tok_val(r);
fn make_tok(kind: i64, endpos: i64) -> i64 = kind * 1000000 + endpos;

// v0.60.243: Optimized keyword matching with length-based dispatch
// Reduces average comparisons from 9.5 to ~2-3 by checking length first
fn keyword_or_ident(s: String, start: i64, endpos: i64) -> i64 =
    let word = s.slice(start, endpos);
    let len = endpos - start;
    if len == 2 { keyword_len2(word, endpos) }
    else if len == 3 { keyword_len3(word, endpos) }
    else if len == 4 { keyword_len4(word, endpos) }
    else if len == 5 { keyword_len5(word, endpos) }
    else if len == 6 { keyword_len6(word, endpos) }
    else if len == 7 { keyword_len7(word, endpos) }  // v0.88
    else if len == 8 { keyword_len8(word, endpos) }  // v0.88
    else if len == 10 { keyword_len10(word, endpos) }  // v0.88
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len2(word: String, endpos: i64) -> i64 =
    if word == "fn" { make_tok(TK_FN(), endpos) }
    else if word == "if" { make_tok(TK_IF(), endpos) }
    else if word == "or" { make_tok(TK_OR(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len3(word: String, endpos: i64) -> i64 =
    if word == "let" { make_tok(TK_LET(), endpos) }
    else if word == "and" { make_tok(TK_AND(), endpos) }
    else if word == "not" { make_tok(TK_NOT(), endpos) }
    else if word == "pre" { make_tok(TK_PRE(), endpos) }
    else if word == "mut" { make_tok(TK_MUT(), endpos) }
    else if word == "i32" { make_tok(TK_I32(), endpos) }
    else if word == "i64" { make_tok(TK_I64(), endpos) }
    else if word == "f64" { make_tok(TK_F64(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len4(word: String, endpos: i64) -> i64 =
    if word == "then" { make_tok(TK_THEN(), endpos) }
    else if word == "else" { make_tok(TK_ELSE(), endpos) }
    else if word == "true" { make_tok(TK_TRUE(), endpos) }
    else if word == "bool" { make_tok(TK_BOOL(), endpos) }
    else if word == "post" { make_tok(TK_POST(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len5(word: String, endpos: i64) -> i64 =
    if word == "false" { make_tok(TK_FALSE(), endpos) }
    else if word == "while" { make_tok(TK_WHILE(), endpos) }  // v0.60.248
    else if word == "async" { make_tok(TK_ASYNC(), endpos) }  // v0.88
    else if word == "await" { make_tok(TK_AWAIT(), endpos) }  // v0.88
    else if word == "Mutex" { make_tok(TK_MUTEX(), endpos) }  // v0.88
    else if word == "Scope" { make_tok(TK_SCOPE(), endpos) }  // v0.88
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len6(word: String, endpos: i64) -> i64 =
    if word == "String" { make_tok(TK_STRING_TYPE(), endpos) }
    else if word == "select" { make_tok(TK_SELECT(), endpos) }  // v0.88
    else if word == "Future" { make_tok(TK_FUTURE(), endpos) }  // v0.88
    else if word == "Atomic" { make_tok(TK_ATOMIC(), endpos) }  // v0.88
    else if word == "Sender" { make_tok(TK_SENDER(), endpos) }  // v0.88
    else if word == "RwLock" { make_tok(TK_RWLOCK(), endpos) }  // v0.88
    else { make_tok(TK_IDENT(), endpos) };

// v0.88: Concurrency type keywords
fn keyword_len7(word: String, endpos: i64) -> i64 =
    if word == "Channel" { make_tok(TK_CHANNEL(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len8(word: String, endpos: i64) -> i64 =
    if word == "Receiver" { make_tok(TK_RECEIVER(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn keyword_len10(word: String, endpos: i64) -> i64 =
    if word == "ThreadPool" { make_tok(TK_THREADPOOL(), endpos) }
    else { make_tok(TK_IDENT(), endpos) };

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_ws_comments(s, pos);
    if p >= s.len() { make_tok(TK_EOF(), p) } else {
        let c = s.byte_at(p);
        if is_digit(c) { scan_int(s, p, 0) } else if is_ident_start(c) {
            let ident_end = scan_ident_end(s, p + 1);
            keyword_or_ident(s, p, ident_end)
        } else if c == 34 {
            // v0.60.109: String literal - scan to closing quote
            let str_end = scan_string_end(s, p + 1);
            make_tok(TK_STRING_LIT(), str_end)
        } else if c == 58 { make_tok(TK_COLON(), p + 1) } else if c == 61 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_EQEQ(), p + 2) } else { make_tok(TK_EQ(), p + 1) } } else if c == 59 { make_tok(TK_SEMI(), p + 1) } else if c == 44 { make_tok(TK_COMMA(), p + 1) } else if c == 40 { make_tok(TK_LPAREN(), p + 1) } else if c == 41 { make_tok(TK_RPAREN(), p + 1) } else if c == 43 { make_tok(TK_PLUS(), p + 1) } else if c == 45 { if p + 1 < s.len() and s.byte_at(p + 1) == 62 { make_tok(TK_ARROW(), p + 2) } else { make_tok(TK_MINUS(), p + 1) } } else if c == 42 { make_tok(TK_STAR(), p + 1) } else if c == 47 { make_tok(TK_SLASH(), p + 1) } else if c == 37 { make_tok(TK_PERCENT(), p + 1) } else if c == 60 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_LTEQ(), p + 2) } else { make_tok(TK_LT(), p + 1) } } else if c == 62 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_GTEQ(), p + 2) } else { make_tok(TK_GT(), p + 1) } } else if c == 33 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_NEQ(), p + 2) } else { make_tok(TK_EOF(), p) } } else if c == 46 { if p + 1 < s.len() and s.byte_at(p + 1) == 46 { make_tok(TK_DOTDOT(), p + 2) } else { make_tok(TK_DOT(), p + 1) } } else if c == 123 { make_tok(TK_LBRACE(), p + 1) } else if c == 125 { make_tok(TK_RBRACE(), p + 1) } else { make_tok(TK_EOF(), p) }
    };

fn get_ident_text(s: String, pos: i64, tok: i64) -> String =
    let start = tok_end(tok) - (tok_val(tok) / 1000000);
    let p = skip_ws_comments(s, pos);
    let endp = scan_ident_end(s, p + 1);
    s.slice(p, endp);

// v0.60.109: Extract string literal content (without quotes)
fn get_string_text(s: String, pos: i64, tok: i64) -> String =
    let p = skip_ws_comments(s, pos);
    let endpos = tok_end(tok);
    s.slice(p + 1, endpos - 1);

// v0.60.120: Escape parens in string content for AST representation
// This prevents unbalanced parens in strings from breaking AST parsing
// Uses \L for (, \R for ), \B for \ to avoid actual parens in escaped content
// v0.60.245: Rewritten with StringBuilder for O(n) instead of O(n²)
fn escape_parens_for_ast(s: String) -> String =
    let sb = sb_new();
    let _p1 = escape_parens_sb(s, 0, sb);
    sb_build(sb);

fn escape_parens_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else {
        let c = s.byte_at(pos);
        // 92=\, 40=(, 41=), 76=L, 82=R, 66=B
        let _p2 = if c == 92 {
            let _p3 = sb_push(sb, chr(92));
            sb_push(sb, chr(66))
        } else if c == 40 {
            let _p4 = sb_push(sb, chr(92));
            sb_push(sb, chr(76))
        } else if c == 41 {
            let _p5 = sb_push(sb, chr(92));
            sb_push(sb, chr(82))
        } else {
            sb_push(sb, chr(c))
        };
        escape_parens_sb(s, pos + 1, sb)
    };

// v0.60.120: Unescape parens from AST string content
// \L -> (, \R -> ), \B -> \
// v0.60.245: Rewritten with StringBuilder for O(n) instead of O(n²)
fn unescape_parens_from_ast(s: String) -> String =
    let sb = sb_new();
    let _q1 = unescape_parens_sb(s, 0, sb);
    sb_build(sb);

fn unescape_parens_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else if s.byte_at(pos) == 92 and pos + 1 < s.len() {
        let next = s.byte_at(pos + 1);
        // 76=L -> 40=(, 82=R -> 41=), 66=B -> 92=\
        let _q2 = if next == 76 { sb_push(sb, chr(40)) }
                  else if next == 82 { sb_push(sb, chr(41)) }
                  else if next == 66 { sb_push(sb, chr(92)) }
                  else {
                      let _q3 = sb_push(sb, chr(92));
                      sb_push(sb, chr(next))
                  };
        unescape_parens_sb(s, pos + 2, sb)
    }
    else {
        let _q4 = sb_push(sb, chr(s.byte_at(pos)));
        unescape_parens_sb(s, pos + 1, sb)
    };

// ============================================================================
// SECTION 4: Parser Result Packing
// ============================================================================

fn pack_result(pos: i64, ast: String) -> String = int_to_string(pos) + ":" + ast;

fn unpack_pos(r: String) -> i64 = unpack_pos_acc(r, 0, 0);

fn unpack_pos_acc(r: String, pos: i64, acc: i64) -> i64 =
    if pos >= r.len() { acc } else {
        let c = r.byte_at(pos);
        if c == 58 { acc } else if is_digit(c) { unpack_pos_acc(r, pos + 1, acc * 10 + (c - 48)) } else { acc }
    };

fn unpack_ast(r: String) -> String =
    let cpos = find_colon(r, 0);
    if cpos >= r.len() { r } else { r.slice(cpos + 1, r.len()) };

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 58 { pos } else { find_colon(s, pos + 1) };

// ============================================================================
// SECTION 5: Expression Parser (recursive descent)
// ============================================================================

// v0.60.118: Helper to check if token kind is an integer literal
// Token constants use 10000-10999 range, so integers are < 10000 OR >= 11000
fn is_int_literal(kind: i64) -> bool = kind < 9999999 + 1 or kind >= 9999999 + 1 + 999 + 1;

// v0.60.117: Parse integer literal
fn parse_int_lit(tok: i64) -> String = pack_result(tok_end(tok), "(int " + int_to_string(tok_val(tok)) + ")");

// v0.60.117: Parse boolean literal
fn parse_bool_lit(tok: i64, kind: i64) -> String =
    if kind == TK_TRUE() { pack_result(tok_end(tok), "(bool true)") }
    else { pack_result(tok_end(tok), "(bool false)") };

// v0.60.117: Parse identifier or function call
fn parse_ident_or_call(src: String, pos: i64, tok: i64) -> String =
    let name = get_ident_text(src, pos, tok);
    let next = next_token_raw(src, tok_end(tok));
    if tok_kind(next) == TK_LPAREN() {
        let rargs = parse_args(src, tok_end(next), "");
        pack_result(unpack_pos(rargs), "(call <" + name + ">" + unpack_ast(rargs) + ")")
    } else {
        pack_result(tok_end(tok), "(var <" + name + ">)")
    };

// v0.60.117: Parse unary expression (not or minus)
fn parse_unary(src: String, tok: i64, op: String) -> String =
    let re = parse_atom(src, tok_end(tok));
    pack_result(unpack_pos(re), "(unary " + op + " " + unpack_ast(re) + ")");

// v0.60.117: Parse parenthesized expression
fn parse_paren_expr(src: String, tok: i64) -> String =
    let re = parse_expr(src, tok_end(tok));
    let next = next_token_raw(src, unpack_pos(re));
    if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), unpack_ast(re)) } else { make_error_at("expected ')' after expression", src, unpack_pos(re)) };

// v0.60.126: Block expression parser
// Block syntax: { stmt; stmt; ... final_expr }
// Where stmt is: let name = expr; or { lhs = rhs }; or expr;
fn parse_block_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RBRACE() {
        // Empty block: { } -> unit
        pack_result(tok_end(tok), "(unit)")
    } else {
        // Parse block contents
        let rb = parse_block_stmts(src, pos);
        if is_error(rb) { rb } else {
            let t2 = next_token_raw(src, unpack_pos(rb));
            if tok_kind(t2) != TK_RBRACE() {
                make_error_at("expected '}' to close block", src, unpack_pos(rb))
            } else {
                pack_result(tok_end(t2), "(block " + unpack_ast(rb) + ")")
            }
        }
    };

// Parse block statements: let binding or assignment or expression
fn parse_block_stmts(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LET() {
        // Let binding: let name = val; body
        parse_block_let(src, tok_end(tok))
    } else if kind == TK_LBRACE() {
        // Assignment block: { lhs = rhs }; rest
        parse_block_assign(src, pos)
    } else {
        // Expression or expression-statement
        parse_block_expr_stmt(src, pos)
    };

// Parse let binding inside block: let name = val; rest
fn parse_block_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_EQ() {
            let rv = parse_expr(src, tok_end(t2));
            if is_error(rv) { rv } else {
                let t3 = next_token_raw(src, unpack_pos(rv));
                if tok_kind(t3) == TK_SEMI() {
                    let rb = parse_block_stmts(src, tok_end(t3));
                    pack_result(unpack_pos(rb), "(let <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")")
                } else { make_error_at("expected ';' after let binding", src, unpack_pos(rv)) }
            }
        } else { make_error_at("expected '=' in let binding", src, tok_end(t1)) }
    } else { make_error_at("expected variable name after 'let'", src, pos) };

// Parse assignment inside block: { lhs = rhs }; rest
fn parse_block_assign(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' for assignment", src, pos) } else {
        let rl = parse_expr(src, tok_end(t1));
        if is_error(rl) { rl } else {
            let t2 = next_token_raw(src, unpack_pos(rl));
            if tok_kind(t2) != TK_EQ() { make_error_at("expected '=' in assignment", src, unpack_pos(rl)) } else {
                let rr = parse_expr(src, tok_end(t2));
                if is_error(rr) { rr } else {
                    let t3 = next_token_raw(src, unpack_pos(rr));
                    if tok_kind(t3) != TK_RBRACE() { make_error_at("expected '}' to close assignment", src, unpack_pos(rr)) } else {
                        let assign_ast = "(assign " + unpack_ast(rl) + " " + unpack_ast(rr) + ")";
                        let after_assign = tok_end(t3);
                        // Check for semicolon (more statements follow)
                        let t4 = next_token_raw(src, after_assign);
                        if tok_kind(t4) == TK_SEMI() {
                            // More statements after assignment
                            let rest = parse_block_stmts(src, tok_end(t4));
                            pack_result(unpack_pos(rest), "(seq " + assign_ast + " " + unpack_ast(rest) + ")")
                        } else {
                            // Assignment is the final expression
                            pack_result(after_assign, assign_ast)
                        }
                    }
                }
            }
        }
    };

// Parse expression statement: expr; rest or just expr at end
fn parse_block_expr_stmt(src: String, pos: i64) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re } else {
        let t1 = next_token_raw(src, unpack_pos(re));
        if tok_kind(t1) == TK_SEMI() {
            // Expression statement followed by more
            let rest = parse_block_stmts(src, tok_end(t1));
            pack_result(unpack_pos(rest), "(seq " + unpack_ast(re) + " " + unpack_ast(rest) + ")")
        } else {
            // Final expression (no semicolon)
            re
        }
    };

fn parse_atom(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    // v0.60.117: Refactored to use helper functions to reduce nesting depth
    // v0.60.126: Add block expression support
    if is_int_literal(kind) { parse_int_lit(tok) }
    else if kind == TK_TRUE() or kind == TK_FALSE() { parse_bool_lit(tok, kind) }
    else if kind == TK_IDENT() { parse_ident_or_call(src, pos, tok) }
    else if kind == TK_STRING_LIT() { pack_result(tok_end(tok), "(string " + escape_parens_for_ast(get_string_text(src, pos, tok)) + ")") }
    else if kind == TK_NOT() { parse_unary(src, tok, "not") }
    else if kind == TK_MINUS() { parse_unary(src, tok, "-") }
    else if kind == TK_LPAREN() { parse_paren_expr(src, tok) }
    else if kind == TK_LBRACE() { parse_block_expr(src, tok_end(tok)) }
    else { make_error_at("unexpected token in expression", src, pos) };

fn parse_args(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), acc) } else {
        let re = parse_expr(src, pos);
        if is_error(re) { re } else {
            let new_acc = acc + " " + unpack_ast(re);
            let next = next_token_raw(src, unpack_pos(re));
            if tok_kind(next) == TK_COMMA() { parse_args(src, tok_end(next), new_acc) } else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) } else { make_error_at("expected ',' or ')' in arguments", src, unpack_pos(re)) }
        }
    };

// v0.60.110: Parse postfix operators (method calls like s.len())
fn parse_postfix(src: String, pos: i64) -> String =
    let rl = parse_atom(src, pos);
    if is_error(rl) { rl } else { parse_postfix_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_postfix_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_DOT() {
        let method_tok = next_token_raw(src, tok_end(tok));
        if tok_kind(method_tok) == TK_IDENT() {
            let method_name = get_ident_text(src, tok_end(tok), method_tok);
            let next = next_token_raw(src, tok_end(method_tok));
            if tok_kind(next) == TK_LPAREN() {
                // Method call with args: s.slice(0, 1)
                let rargs = parse_args(src, tok_end(next), "");
                let ast = "(method " + method_name + " " + left + unpack_ast(rargs) + ")";
                parse_postfix_rest(src, unpack_pos(rargs), ast)
            } else {
                // Method call with no args: s.len()
                // This shouldn't happen since len() has parens, but handle it
                make_error_at("expected '(' after method name", src, tok_end(method_tok))
            }
        } else { make_error_at("expected method name after '.'", src, tok_end(tok)) }
    } else { pack_result(pos, left) };

fn parse_mul(src: String, pos: i64) -> String =
    let rl = parse_postfix(src, pos);
    if is_error(rl) { rl } else { parse_mul_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_mul_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_STAR() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop * " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_SLASH() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop / " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_PERCENT() {
        let rr = parse_postfix(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop % " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_add(src: String, pos: i64) -> String =
    let rl = parse_mul(src, pos);
    if is_error(rl) { rl } else { parse_add_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_add_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PLUS() {
        let rr = parse_mul(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_add_rest(src, unpack_pos(rr), "(binop + " + left + " " + unpack_ast(rr) + ")") }
    } else if kind == TK_MINUS() {
        let rr = parse_mul(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_add_rest(src, unpack_pos(rr), "(binop - " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_cmp(src: String, pos: i64) -> String =
    let rl = parse_add(src, pos);
    if is_error(rl) { rl } else { parse_cmp_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_cmp_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LT() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop < " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_GT() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop > " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_LTEQ() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop <= " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_GTEQ() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop >= " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_EQEQ() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop == " + left + " " + unpack_ast(rr) + ")")
    } else if kind == TK_NEQ() {
        let rr = parse_add(src, tok_end(tok));
        pack_result(unpack_pos(rr), "(binop != " + left + " " + unpack_ast(rr) + ")")
    } else { pack_result(pos, left) };

fn parse_and(src: String, pos: i64) -> String =
    let rl = parse_cmp(src, pos);
    if is_error(rl) { rl } else { parse_and_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_and_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_AND() {
        let rr = parse_cmp(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_and_rest(src, unpack_pos(rr), "(binop and " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

fn parse_or(src: String, pos: i64) -> String =
    let rl = parse_and(src, pos);
    if is_error(rl) { rl } else { parse_or_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_or_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_OR() {
        let rr = parse_and(src, tok_end(tok));
        if is_error(rr) { rr } else { parse_or_rest(src, unpack_pos(rr), "(binop or " + left + " " + unpack_ast(rr) + ")") }
    } else { pack_result(pos, left) };

// v0.60.238: Refactored if-chain parser with reduced nesting depth
// Split into helper functions to avoid exponential compilation time
// prefix = "(if c1 t1 (if c2 t2 ...", suffix = "))"
// Final AST = prefix + else_body + suffix

fn parse_if_chain_iter(src: String, pos: i64, prefix: String, suffix: String) -> String =
    // pos is right after 'if' keyword, parse: cond { then } else ...
    let rc = parse_or(src, pos);
    if is_error(rc) { rc }
    else { parse_if_chain_then(src, unpack_pos(rc), unpack_ast(rc), prefix, suffix) };

fn parse_if_chain_then(src: String, pos: i64, cond_ast: String, prefix: String, suffix: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' after if condition", src, pos) }
    else {
        let rt = parse_expr(src, tok_end(t1));
        if is_error(rt) { rt }
        else { parse_if_chain_after_then(src, unpack_pos(rt), cond_ast, unpack_ast(rt), prefix, suffix) }
    };

fn parse_if_chain_after_then(src: String, pos: i64, cond_ast: String, then_ast: String, prefix: String, suffix: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after then branch", src, pos) }
    else {
        let new_prefix = prefix + "(if " + cond_ast + " " + then_ast + " ";
        let new_suffix = ")" + suffix;
        parse_if_chain_else(src, tok_end(t2), new_prefix, new_suffix)
    };

fn parse_if_chain_else(src: String, pos: i64, new_prefix: String, new_suffix: String) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) != TK_ELSE() { make_error_at("expected 'else' after '}'", src, pos) }
    else {
        let t4 = next_token_raw(src, tok_end(t3));
        let k4 = tok_kind(t4);
        if k4 == TK_IF() { parse_if_chain_iter(src, tok_end(t4), new_prefix, new_suffix) }
        else if k4 == TK_LBRACE() { parse_if_chain_final_else(src, tok_end(t4), new_prefix, new_suffix) }
        else { make_error_at("expected 'if' or '{' after 'else'", src, tok_end(t3)) }
    };

fn parse_if_chain_final_else(src: String, pos: i64, new_prefix: String, new_suffix: String) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re }
    else { parse_if_chain_finish(src, unpack_pos(re), unpack_ast(re), new_prefix, new_suffix) };

fn parse_if_chain_finish(src: String, pos: i64, else_ast: String, new_prefix: String, new_suffix: String) -> String =
    let t5 = next_token_raw(src, pos);
    if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after else branch", src, pos) }
    else {
        let middle = new_prefix + else_ast;
        let full = middle + new_suffix;
        pack_result(tok_end(t5), full)
    };

// v0.60.238: Refactored parse_expr to reduce nesting depth

fn parse_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_IF() { parse_if_expr(src, tok_end(tok)) }
    else if kind == TK_LET() { parse_let_expr(src, tok_end(tok), pos) }
    else if kind == TK_WHILE() { parse_while_expr(src, tok_end(tok)) }  // v0.60.248
    else { parse_or(src, pos) };

fn parse_if_expr(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(rc) { rc }
    else { parse_if_after_cond(src, unpack_pos(rc), unpack_ast(rc)) };

fn parse_if_after_cond(src: String, pos: i64, cond_ast: String) -> String =
    let t1 = next_token_raw(src, pos);
    let k1 = tok_kind(t1);
    // v0.46: Support both 'then/else' (legacy) and '{ } else { }' (v0.32) syntax
    if k1 == TK_THEN() { parse_if_then_syntax(src, tok_end(t1), cond_ast) }
    else if k1 == TK_LBRACE() { parse_if_brace_syntax(src, tok_end(t1), cond_ast) }
    else { make_error_at("expected '{' or 'then' after if condition", src, pos) };

fn parse_if_then_syntax(src: String, pos: i64, cond_ast: String) -> String =
    let rt = parse_expr(src, pos);
    if is_error(rt) { rt }
    else { parse_if_then_else(src, unpack_pos(rt), cond_ast, unpack_ast(rt)) };

fn parse_if_then_else(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_ELSE() { make_error_at("expected 'else' after then expression", src, pos) }
    else {
        let re = parse_expr(src, tok_end(t2));
        make_if_ast(unpack_pos(re), cond_ast, then_ast, unpack_ast(re))
    };

fn parse_if_brace_syntax(src: String, pos: i64, cond_ast: String) -> String =
    let rt = parse_expr(src, pos);
    if is_error(rt) { rt }
    else { parse_if_brace_then(src, unpack_pos(rt), cond_ast, unpack_ast(rt)) };

fn parse_if_brace_then(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after if body", src, pos) }
    else { parse_if_brace_else(src, tok_end(t2), cond_ast, then_ast) };

fn parse_if_brace_else(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) != TK_ELSE() { make_error_at("expected 'else' after '}'", src, pos) }
    else { parse_if_brace_else_body(src, tok_end(t3), cond_ast, then_ast) };

fn parse_if_brace_else_body(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let t4 = next_token_raw(src, pos);
    let k4 = tok_kind(t4);
    if k4 == TK_LBRACE() { parse_if_brace_final(src, tok_end(t4), cond_ast, then_ast) }
    else if k4 == TK_IF() {
        // v0.60.222: Use iterative chain parser for else-if
        let init_prefix = "(if " + cond_ast + " " + then_ast + " ";
        parse_if_chain_iter(src, tok_end(t4), init_prefix, ")")
    }
    else { make_error_at("expected '{' or 'if' after 'else'", src, pos) };

fn parse_if_brace_final(src: String, pos: i64, cond_ast: String, then_ast: String) -> String =
    let re = parse_expr(src, pos);
    if is_error(re) { re }
    else { parse_if_brace_finish(src, unpack_pos(re), cond_ast, then_ast, unpack_ast(re)) };

fn parse_if_brace_finish(src: String, pos: i64, cond_ast: String, then_ast: String, else_ast: String) -> String =
    let t5 = next_token_raw(src, pos);
    if tok_kind(t5) != TK_RBRACE() { make_error_at("expected '}' after else body", src, pos) }
    else { make_if_ast(tok_end(t5), cond_ast, then_ast, else_ast) };

fn make_if_ast(pos: i64, cond_ast: String, then_ast: String, else_ast: String) -> String =
    let p1 = "(if " + cond_ast;
    let p2 = p1 + " " + then_ast;
    let p3 = p2 + " " + else_ast;
    pack_result(pos, p3 + ")");

// v0.60.248: Support 'let mut' syntax for mutable variables
fn parse_let_expr(src: String, pos: i64, start_pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let k1 = tok_kind(t1);
    if k1 == TK_MUT() {
        // let mut name = ...
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_IDENT() { make_error_at("expected variable name after 'mut'", src, tok_end(t1)) }
        else { parse_let_name_mut(src, tok_end(t1), t2) }
    } else if k1 == TK_IDENT() {
        // let name = ...
        parse_let_name(src, pos, t1)
    } else { make_error_at("expected variable name after 'let'", src, pos) };

fn parse_let_name(src: String, pos: i64, t1: i64) -> String =
    let name = get_ident_text(src, pos, t1);
    parse_let_after_name(src, tok_end(t1), name, false);

fn parse_let_name_mut(src: String, pos: i64, t2: i64) -> String =
    let name = get_ident_text(src, pos, t2);
    parse_let_after_name(src, tok_end(t2), name, true);

// v0.60.248: Handle optional type annotation and continue to value
fn parse_let_after_name(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let t2 = next_token_raw(src, pos);
    let k2 = tok_kind(t2);
    if k2 == TK_EQ() {
        // let name = value
        parse_let_value_mut(src, tok_end(t2), name, is_mut)
    } else if k2 == TK_COLON() {
        // let name: type = value - skip type annotation
        parse_let_skip_type(src, tok_end(t2), name, is_mut)
    } else { make_error_at("expected '=' or ':' after let binding name", src, pos) };

fn parse_let_skip_type(src: String, pos: i64, name: String, is_mut: bool) -> String =
    // Skip type token(s) until we find '='
    let t = next_token_raw(src, pos);
    let k = tok_kind(t);
    if k == TK_EQ() {
        parse_let_value_mut(src, tok_end(t), name, is_mut)
    } else if k == TK_IDENT() or k == TK_I64() or k == TK_I32() or k == TK_BOOL() or k == TK_STRING_TYPE() {
        // Skip the type and continue looking for '='
        parse_let_skip_type(src, tok_end(t), name, is_mut)
    } else { make_error_at("expected '=' after type annotation in let binding", src, pos) };

fn parse_let_value_mut(src: String, pos: i64, name: String, is_mut: bool) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else { parse_let_body_mut(src, unpack_pos(rv), name, unpack_ast(rv), is_mut) };

fn parse_let_body_mut(src: String, pos: i64, name: String, val_ast: String, is_mut: bool) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) != TK_SEMI() { make_error_at("expected ';' after let binding value", src, pos) }
    else {
        let rb = parse_expr(src, tok_end(t3));
        if is_mut {
            make_let_mut_ast(unpack_pos(rb), name, val_ast, unpack_ast(rb))
        } else {
            make_let_ast(unpack_pos(rb), name, val_ast, unpack_ast(rb))
        }
    };

fn parse_let_value(src: String, pos: i64, name: String) -> String =
    let rv = parse_expr(src, pos);
    if is_error(rv) { rv }
    else { parse_let_body(src, unpack_pos(rv), name, unpack_ast(rv)) };

fn parse_let_body(src: String, pos: i64, name: String, val_ast: String) -> String =
    let t3 = next_token_raw(src, pos);
    if tok_kind(t3) != TK_SEMI() { make_error_at("expected ';' after let binding value", src, pos) }
    else {
        let rb = parse_expr(src, tok_end(t3));
        make_let_ast(unpack_pos(rb), name, val_ast, unpack_ast(rb))
    };

fn make_let_ast(pos: i64, name: String, val_ast: String, body_ast: String) -> String =
    let p1 = "(let <" + name + "> ";
    let p2 = p1 + val_ast + " ";
    pack_result(pos, p2 + body_ast + ")");

// v0.60.248: let mut creates (let_mut ...) AST node
fn make_let_mut_ast(pos: i64, name: String, val_ast: String, body_ast: String) -> String =
    let p1 = "(let_mut <" + name + "> ";
    let p2 = p1 + val_ast + " ";
    pack_result(pos, p2 + body_ast + ")");

// ============================================================================
// v0.60.248: While Expression Parser
// ============================================================================

// Parse while expression: while condition { body }
// AST format: (while condition body)
fn parse_while_expr(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(rc) { rc }
    else { parse_while_body(src, unpack_pos(rc), unpack_ast(rc)) };

fn parse_while_body(src: String, pos: i64, cond_ast: String) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_LBRACE() { make_error_at("expected '{' after while condition", src, pos) }
    else { parse_while_body_inner(src, tok_end(t1), cond_ast) };

fn parse_while_body_inner(src: String, pos: i64, cond_ast: String) -> String =
    let rb = parse_expr(src, pos);
    if is_error(rb) { rb }
    else { parse_while_finish(src, unpack_pos(rb), cond_ast, unpack_ast(rb)) };

fn parse_while_finish(src: String, pos: i64, cond_ast: String, body_ast: String) -> String =
    let t2 = next_token_raw(src, pos);
    if tok_kind(t2) != TK_RBRACE() { make_error_at("expected '}' after while body", src, pos) }
    else { pack_result(tok_end(t2), "(while " + cond_ast + " " + body_ast + ")") };

// ============================================================================
// SECTION 6: Function and Program Parser
// ============================================================================

fn parse_param(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_COLON() {
            let t3 = next_token_raw(src, tok_end(t2));
            let kind = tok_kind(t3);
            if kind == TK_I32() { pack_result(tok_end(t3), "(param <" + name + "> i32)") } else if kind == TK_I64() { pack_result(tok_end(t3), "(param <" + name + "> i64)") } else if kind == TK_F64() { pack_result(tok_end(t3), "(param <" + name + "> f64)") } else if kind == TK_BOOL() { pack_result(tok_end(t3), "(param <" + name + "> bool)") } else if kind == TK_STRING_TYPE() { pack_result(tok_end(t3), "(param <" + name + "> String)") } else { make_error_at("expected parameter type (i32, i64, f64, bool, String)", src, tok_end(t2)) }
        } else { make_error_at("expected ':' after parameter name", src, tok_end(t1)) }
    } else { make_error_at("expected parameter name", src, pos) };

fn parse_params(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), acc) } else {
        let rp = parse_param(src, pos);
        if is_error(rp) { rp } else {
            let new_acc = acc + " " + unpack_ast(rp);
            let next = next_token_raw(src, unpack_pos(rp));
            if tok_kind(next) == TK_COMMA() { parse_params(src, tok_end(next), new_acc) } else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) } else { make_error_at("expected ',' or ')' in parameter list", src, unpack_pos(rp)) }
        }
    };

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() {
        let name = get_ident_text(src, pos, t1);
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LPAREN() {
            let rp = parse_params(src, tok_end(t2), "");
            if is_error(rp) { rp } else {
                let t3 = next_token_raw(src, unpack_pos(rp));
                if tok_kind(t3) == TK_ARROW() {
                    let t4 = next_token_raw(src, tok_end(t3));
                    let ret_type = if tok_kind(t4) == TK_I32() { "i32" } else if tok_kind(t4) == TK_I64() { "i64" } else if tok_kind(t4) == TK_F64() { "f64" } else if tok_kind(t4) == TK_BOOL() { "bool" } else if tok_kind(t4) == TK_STRING_TYPE() { "String" } else { "i64" };
                    let t5 = next_token_raw(src, tok_end(t4));
                    if tok_kind(t5) == TK_EQ() {
                        let rb = parse_expr(src, tok_end(t5));
                        if is_error(rb) { rb } else {
                            let t6 = next_token_raw(src, unpack_pos(rb));
                            if tok_kind(t6) == TK_SEMI() { pack_result(tok_end(t6), "(fn <" + name + ">" + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") } else { pack_result(unpack_pos(rb), "(fn <" + name + ">" + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") }
                        }
                    } else { make_error_at("expected '=' after return type", src, tok_end(t4)) }
                } else { make_error_at("expected '->' after parameters", src, unpack_pos(rp)) }
            }
        } else { make_error_at("expected '(' after function name", src, tok_end(t1)) }
    } else { make_error_at("expected function name after 'fn'", src, pos) };

// v0.60.241: Refactored to use StringBuilder for O(1) amortized accumulation
// Previously O(N²) due to fns + " " + unpack_ast(rf) pattern
fn parse_program_sb(src: String, pos: i64, sb: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() {
        let w1 = sb_push(sb, ")");
        sb_build(sb)
    } else if kind == TK_FN() {
        let rf = parse_fn(src, tok_end(tok));
        if is_error(rf) { rf } else {
            let w1 = sb_push(sb, " ");
            let w2 = sb_push(sb, unpack_ast(rf));
            parse_program_sb(src, unpack_pos(rf), sb)
        }
    } else { make_error_at("expected 'fn' declaration", src, pos) };

fn parse_source(src: String) -> String =
    let sb = sb_new();
    let w1 = sb_push(sb, "(program");
    parse_program_sb(src, 0, sb);

// ============================================================================
// SECTION 7: S-Expression Utilities (for lowering)
// ============================================================================

fn low_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

fn low_skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_whitespace(s.byte_at(pos)) { low_skip_ws(s, pos + 1) } else { pos };

fn low_is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

fn low_is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
    c == 60 or c == 62 or c == 61 or c == 33;

fn low_find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_ident_char(s.byte_at(pos)) { low_find_ident_end(s, pos + 1) } else { pos };

fn low_find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_op_char(s.byte_at(pos)) { low_find_op_end(s, pos + 1) } else { pos };

fn low_starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() { false } else { s.slice(pos, pos + prefix.len()) == prefix };

fn low_find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() { pos } else {
        let c = s.byte_at(pos);
        if c == 40 { low_find_close_paren(s, pos + 1, depth + 1) } else if c == 41 { if depth == 1 { pos } else { low_find_close_paren(s, pos + 1, depth - 1) } } else { low_find_close_paren(s, pos + 1, depth) }
    };

fn extract_paren_content(s: String) -> String =
    if s.len() < 2 { "" } else if s.byte_at(0) == 40 {
        let end = low_find_close_paren(s, 0, 0);
        s.slice(1, end)
    } else { "" };

fn get_node_type(ast: String) -> String =
    if ast.len() == 0 { "" } else {
        let content = extract_paren_content(ast);
        let pos = low_skip_ws(content, 0);
        if pos >= content.len() { "" } else {
            let c = content.byte_at(pos);
            if low_is_ident_char(c) {
                let endp = low_find_ident_end(content, pos);
                content.slice(pos, endp)
            } else if low_is_op_char(c) {
                let endp = low_find_op_end(content, pos);
                content.slice(pos, endp)
            } else { "" }
        }
    };

fn get_child(ast: String, idx: i64) -> String =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let after_type = if end1 > pos { end1 } else { low_find_op_end(content, pos) };
    get_child_at(content, after_type, idx);

fn get_child_at(content: String, pos: i64, idx: i64) -> String =
    if idx < 0 { "" } else {
        let p = low_skip_ws(content, pos);
        if p >= content.len() { "" } else if idx == 0 { read_sexp_at(content, p) } else {
            let child = read_sexp_at(content, p);
            let next_pos = p + child.len();
            get_child_at(content, next_pos, idx - 1)
        }
    };

fn read_sexp_at(s: String, pos: i64) -> String =
    let p = low_skip_ws(s, pos);
    if p >= s.len() { "" } else {
        let c = s.byte_at(p);
        if c == 40 {
            let end = low_find_close_paren(s, p, 0);
            s.slice(p, end + 1)
        } else if c == 60 and p + 1 < s.len() and is_ident_start(s.byte_at(p + 1)) {
            // v0.60.117: Only treat <...> as angle-bracketed name if < is followed by identifier
            // This fixes parsing of < operator in AST like (binop < ...)
            let end = find_angle_end(s, p);
            s.slice(p, end)
        } else if is_digit(c) or c == 45 {
            let end = find_number_end(s, p);
            s.slice(p, end)
        } else if low_is_ident_char(c) {
            let end = low_find_ident_end(s, p);
            s.slice(p, end)
        } else if low_is_op_char(c) {
            let end = low_find_op_end(s, p);
            s.slice(p, end)
        } else { "" }
    };

fn find_angle_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 62 { pos + 1 } else { find_angle_end(s, pos + 1) };

fn find_number_end(s: String, pos: i64) -> i64 =
    let p = if pos < s.len() and s.byte_at(pos) == 45 { pos + 1 } else { pos };
    find_digits_end(s, p);

fn find_digits_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { find_digits_end(s, pos + 1) } else { pos };

fn extract_name(ast: String) -> String =
    let child = get_child(ast, 0);
    if child.len() >= 2 and child.byte_at(0) == 60 { child.slice(1, child.len() - 1) } else { child };

// v0.88.1: Rename variable references in AST for SSA-compatible let bindings
// Finds all "(var <oldname>)" patterns and replaces with "(var <newname>)"
fn rename_var_in_ast(ast: String, oldname: String, newname: String) -> String =
    rename_var_in_ast_at(ast, oldname, newname, 0, "");

fn rename_var_in_ast_at(ast: String, oldname: String, newname: String, pos: i64, acc: String) -> String =
    if pos >= ast.len() { acc } else {
        let var_pos = find_var_pattern_at(ast, pos);
        if var_pos < 0 {
            acc + ast.slice(pos, ast.len())
        } else {
            let name_start = var_pos + 6;
            let name_end = find_char_at(ast, 62, name_start);
            if name_end <= name_start {
                rename_var_in_ast_at(ast, oldname, newname, var_pos + 1, acc + ast.slice(pos, var_pos + 1))
            } else {
                let found_name = ast.slice(name_start, name_end);
                if found_name == oldname {
                    let before = ast.slice(pos, var_pos);
                    let replaced = "(var <" + newname + ">";
                    rename_var_in_ast_at(ast, oldname, newname, name_end + 1, acc + before + replaced)
                } else {
                    rename_var_in_ast_at(ast, oldname, newname, name_end + 1, acc + ast.slice(pos, name_end + 1))
                }
            }
        }
    };

// Find "(var <" pattern starting from pos (returns -1 if not found)
fn find_var_pattern_at(ast: String, pos: i64) -> i64 =
    if pos + 5 >= ast.len() { 0 - 1 }
    else if ast.byte_at(pos) == 40 and ast.byte_at(pos+1) == 118 and
            ast.byte_at(pos+2) == 97 and ast.byte_at(pos+3) == 114 and
            ast.byte_at(pos+4) == 32 and ast.byte_at(pos+5) == 60 { pos }
    else { find_var_pattern_at(ast, pos + 1) };

// Find character c starting from pos (returns -1 if not found)
fn find_char_at(ast: String, c: i64, pos: i64) -> i64 =
    if pos >= ast.len() { 0 - 1 }
    else if ast.byte_at(pos) == c { pos }
    else { find_char_at(ast, c, pos + 1) };

fn extract_int_value(ast: String) -> i64 =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let num_start = low_skip_ws(content, end1);
    parse_int_from(content, num_start, 0);

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if is_digit(c) { parse_int_from(s, pos + 1, acc * 10 + (c - 48)) } else { acc }
    };

fn is_fn_node(ast: String) -> bool = get_node_type(ast) == "fn";

// ============================================================================
// SECTION 8: MIR Result Packing
// ============================================================================

fn pack_lower_result(text: String, temp_id: i64) -> String =
    int_to_string(temp_id) + ":" + text;

fn unpack_temp_id(r: String) -> i64 = unpack_pos_acc(r, 0, 0);

fn unpack_text(r: String) -> String =
    let cpos = find_colon(r, 0);
    if cpos >= r.len() { r } else { r.slice(cpos + 1, r.len()) };

// ============================================================================
// SECTION 8B: StringBuilder-aware Lowering (v0.31.20)
// ============================================================================
// Uses StringBuilder builtins for O(1) amortized string concatenation.
// Returns just temp_id (MIR text is pushed to StringBuilder).

fn pack_lower_result_sb(temp_id: i64) -> i64 = temp_id;

// v0.60.200: Pack temp_id and block_id for tracking block label uniqueness
// temp_id in upper bits, block_id in lower bits (supports up to 1M each)
fn pack_ids(temp_id: i64, block_id: i64) -> i64 = temp_id * 1000000 + block_id;
fn unpack_temp(packed: i64) -> i64 = packed / 1000000;
fn unpack_block(packed: i64) -> i64 = packed % 1000000;

// v0.60.201: Exit label computation for correct PHI predecessors
// v0.60.203: Simplified to only check immediate node type to avoid deep recursion
fn get_exit_label(ast: String, entry_label: String, block_id: i64) -> String =
    let ntype = get_node_type(ast);
    if ntype == "if" {
        "merge_" + int_to_string(block_id)
    } else {
        // For non-if expressions, use entry label
        // This is slightly incorrect for let-with-nested-if but avoids recursion
        entry_label
    };

fn sb_push_mir(sb: i64, text: String) -> i64 =
    if text.len() > 0 {
        let len = sb_len(sb);
        let w0 = if len > 0 { sb_push(sb, "|") } else { 0 };
        sb_push(sb, text)
    } else { 0 };

// ============================================================================
// SECTION 8a: Iterative Expression Lowering (v0.60.300)
// ============================================================================
// Trampolining approach to avoid stack overflow on deeply nested expressions.
// Uses string-encoded work stack and result stack.
// Work items use TILDE (~) as field separator, TAB (chr(9)) as item separator.
// This allows the trampoline to be tail-recursive, which LLVM optimizes to a loop.

// Work item types:
// EX~ast~temp_id~block_id - Evaluate expression
// IN~ast~temp_id~block_id - Evaluate int literal
// BO~ast~temp_id~block_id - Evaluate bool literal
// ST~ast~temp_id~block_id - Evaluate string literal
// VA~ast~temp_id~block_id - Evaluate variable
// BI~op~temp_id~block_id~left_ast~right_ast - Start binop
// BM~op~left_id~temp_id~block_id~right_ast - Binop: left done, do right
// BF~op~left_id~right_id~temp_id~block_id - Binop: finalize
// UN~op~temp_id~block_id~operand_ast - Start unary
// UF~op~operand_id~temp_id~block_id - Unary: finalize
// IF~ast~temp_id~block_id - Start if
// IC~my_bid~cond_id~cond_temp~then_ast~else_ast - If: cond done, do then
// IT~my_bid~cond_id~then_label~else_label~merge_label~then_id~then_exit~then_temp~then_block~else_ast - If: then done
// IX~my_bid~then_id~then_exit~else_id~else_exit~else_temp~else_block - If: finalize
// LE~name~temp_id~block_id~value_ast~body_ast - Start let
// LB~name~val_id~val_temp~val_block~body_ast - Let: value done, do body
// CA~name~temp_id~block_id~idx~args_acc~ast - Call: start/continue
// CF~name~temp_id~block_id~args_acc - Call: finalize
// ME~fn_name~temp_id~block_id~recv_ast~idx~ast - Method: start
// MA~fn_name~recv_id~temp_id~block_id~idx~args_acc~ast - Method: continue
// MF~fn_name~temp_id~block_id~args_acc - Method: finalize

fn work_sep() -> String = chr(9);
fn field_sep() -> String = "~";

fn push_work(stack: String, item: String) -> String =
    if stack == "" { item } else { item + work_sep() + stack };

fn pop_work_item(stack: String) -> String =
    if stack == "" { "" } else {
        let sep_pos = find_work_sep(stack, 0);
        if sep_pos >= stack.len() { stack } else { stack.slice(0, sep_pos) }
    };

fn pop_work_rest(stack: String) -> String =
    if stack == "" { "" } else {
        let sep_pos = find_work_sep(stack, 0);
        if sep_pos >= stack.len() { "" } else { stack.slice(sep_pos + 1, stack.len()) }
    };

fn find_work_sep(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 9 { pos }
    else { find_work_sep(s, pos + 1) };

fn get_field(item: String, idx: i64) -> String =
    let raw = get_field_at(item, 0, idx);
    // v0.60.237: Unescape field to restore tildes
    if idx == 0 { raw } else { unescape_field(raw) };

fn get_field_at(item: String, pos: i64, idx: i64) -> String =
    if pos >= item.len() { "" }
    else if idx == 0 {
        let end = find_field_sep(item, pos);
        item.slice(pos, end)
    } else {
        let sep = find_field_sep(item, pos);
        if sep >= item.len() { "" } else { get_field_at(item, sep + 1, idx - 1) }
    };

fn find_field_sep(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 126 { pos }
    else { find_field_sep(s, pos + 1) };

// v0.60.237: Escape/unescape tilde in work item fields to prevent confusion with separator
// ~ (126) -> \^ (92, 94), \ (92) -> \\ (92, 92)
// v0.60.245: Rewritten with StringBuilder for O(n) instead of O(n²)
fn escape_field(s: String) -> String =
    let sb = sb_new();
    let _e1 = escape_field_sb(s, 0, sb);
    sb_build(sb);

fn escape_field_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else {
        let c = s.byte_at(pos);
        if c == 126 {
            let _e2 = sb_push(sb, chr(92));
            let _e3 = sb_push(sb, chr(94));
            escape_field_sb(s, pos + 1, sb)
        }
        else if c == 92 {
            let _e4 = sb_push(sb, chr(92));
            let _e5 = sb_push(sb, chr(92));
            escape_field_sb(s, pos + 1, sb)
        }
        else {
            let _e6 = sb_push(sb, chr(c));
            escape_field_sb(s, pos + 1, sb)
        }
    };

fn unescape_field(s: String) -> String =
    let sb = sb_new();
    let _u1 = unescape_field_sb(s, 0, sb);
    sb_build(sb);

fn unescape_field_sb(s: String, pos: i64, sb: i64) -> i64 =
    if pos >= s.len() { 0 }
    else {
        let c = s.byte_at(pos);
        if c == 92 and pos + 1 < s.len() {
            let next = s.byte_at(pos + 1);
            if next == 94 {
                let _u2 = sb_push(sb, chr(126));
                unescape_field_sb(s, pos + 2, sb)
            }
            else if next == 92 {
                let _u3 = sb_push(sb, chr(92));
                unescape_field_sb(s, pos + 2, sb)
            }
            else {
                let _u4 = sb_push(sb, chr(c));
                unescape_field_sb(s, pos + 1, sb)
            }
        }
        else {
            let _u5 = sb_push(sb, chr(c));
            unescape_field_sb(s, pos + 1, sb)
        }
    };

fn make_work(t: String, f1: String, f2: String, f3: String, f4: String, f5: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4) + "~" + escape_field(f5);

fn make_work3(t: String, f1: String, f2: String, f3: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3);

fn make_work4(t: String, f1: String, f2: String, f3: String, f4: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4);

fn make_work6(t: String, f1: String, f2: String, f3: String, f4: String, f5: String, f6: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4) + "~" + escape_field(f5) + "~" + escape_field(f6);

fn make_work7(t: String, f1: String, f2: String, f3: String, f4: String, f5: String, f6: String, f7: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4) + "~" + escape_field(f5) + "~" + escape_field(f6) + "~" + escape_field(f7);

fn make_work10(t: String, f1: String, f2: String, f3: String, f4: String, f5: String, f6: String, f7: String, f8: String, f9: String, f10: String) -> String =
    t + "~" + escape_field(f1) + "~" + escape_field(f2) + "~" + escape_field(f3) + "~" + escape_field(f4) + "~" + escape_field(f5) + "~" + escape_field(f6) + "~" + escape_field(f7) + "~" + escape_field(f8) + "~" + escape_field(f9) + "~" + escape_field(f10);

fn i2s(n: i64) -> String = int_to_string(n);
fn s2i(s: String) -> i64 = parse_int_simple(s, 0, 0);

fn parse_int_simple(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc }
    else {
        let c = s.byte_at(pos);
        if c >= 48 and c <= 57 { parse_int_simple(s, pos + 1, acc * 10 + (c - 48)) }
        else { acc }
    };

// Main iterative lowering entry point
// Uses a result-threaded trampoline: each step receives and returns (temp_id, block_id, exit_label)
fn lower_expr_iter(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let init_work = make_work3("EX", ast, i2s(temp_id), i2s(block_id));
    trampoline_v2(init_work, temp_id, block_id, "", sb);

// Trampoline v2: threads result (temp_id, block_id, exit_label) through work items
// Work stack format: items separated by TAB
// Each item is processed with current result, producing new result
// v0.88.6: arena_save/restore per step to bound memory for large functions
fn trampoline_v2(work_stack: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> i64 =
    if work_stack == "" { pack_ids(cur_temp, cur_block) }
    else {
        let _save = bmb_arena_save();
        let item = pop_work_item(work_stack);
        let rest = pop_work_rest(work_stack);
        // Process item with current result (MIR pushed to sb which is malloc-based)
        let step = do_step(item, cur_temp, cur_block, cur_exit_label, sb);
        let new_temp = step_temp(step);
        let new_block = step_block(step);
        // Copy exit_label to SB (survives restore)
        let exit_sb = sb_new();
        let _ep = sb_push(exit_sb, step_exit_label(step));
        // Build combined work stack in SB (survives restore)
        let work_sb = sb_new();
        let new_work = step_work(step);
        let _wp = if new_work == "" and rest == "" { 0 }
                  else if new_work == "" { sb_push(work_sb, rest) }
                  else if rest == "" { sb_push(work_sb, new_work) }
                  else { let _a = sb_push(work_sb, new_work); let _b = sb_push(work_sb, work_sep()); sb_push(work_sb, rest) };
        let _restore = bmb_arena_restore();
        // Rebuild strings from SBs in fresh arena
        let new_exit_label = sb_build(exit_sb);
        let _ef = sb_free(exit_sb);
        let combined = if sb_len(work_sb) == 0 { "" } else { sb_build(work_sb) };
        let _wf = sb_free(work_sb);
        trampoline_v2(combined, new_temp, new_block, new_exit_label, sb)
    };

// Step result: encodes new work items and result
// Format: "new_temp|new_block|exit_label|new_work"
fn make_step(temp: i64, block: i64, exit_label: String, work: String) -> String =
    i2s(temp) + "|" + i2s(block) + "|" + exit_label + "|" + work;

fn step_temp(s: String) -> i64 =
    let p1 = find_single_pipe(s, 0);
    s2i(s.slice(0, p1));

fn step_block(s: String) -> i64 =
    let p1 = find_single_pipe(s, 0);
    let p2 = find_single_pipe(s, p1 + 1);
    s2i(s.slice(p1 + 1, p2));

fn step_exit_label(s: String) -> String =
    let p1 = find_single_pipe(s, 0);
    let p2 = find_single_pipe(s, p1 + 1);
    let p3 = find_single_pipe(s, p2 + 1);
    s.slice(p2 + 1, p3);

fn step_work(s: String) -> String =
    let p1 = find_single_pipe(s, 0);
    let p2 = find_single_pipe(s, p1 + 1);
    let p3 = find_single_pipe(s, p2 + 1);
    if p3 >= s.len() { "" } else { s.slice(p3 + 1, s.len()) };

fn find_single_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 124 { pos }
    else { find_single_pipe(s, pos + 1) };

// Process a single work item with current result
fn do_step(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 0);
    if op == "EX" { step_expr(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IN" { step_int(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "BO" { step_bool(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "ST" { step_string(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "VA" { step_var(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "BI" { step_binop_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "BR" { step_binop_right(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "BF" { step_binop_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "UN" { step_unary_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "UF" { step_unary_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IS" { step_if_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IT" { step_if_then(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IE" { step_if_else(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "IX" { step_if_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "LS" { step_let_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "LB" { step_let_body(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "CS" { step_call_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "CA" { step_call_arg(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "CF" { step_call_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "MS" { step_method_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "MA" { step_method_arg(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "MF" { step_method_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    // v0.60.126: Block expression step handlers
    else if op == "UT" { step_unit(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "SQ" { step_seq_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "S2" { step_seq_second(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "AS" { step_assign_start(item, cur_temp, cur_block, cur_exit_label, sb) }
    else if op == "AF" { step_assign_final(item, cur_temp, cur_block, cur_exit_label, sb) }
    else { make_step(cur_temp, cur_block, cur_exit_label, "") };

// EX: Dispatch based on node type - expand to specific handler
fn step_expr(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let ntype = get_node_type(ast);
    if ntype == "int" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("IN", ast, "", "")) }
    else if ntype == "bool" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("BO", ast, "", "")) }
    else if ntype == "string" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("ST", ast, "", "")) }
    else if ntype == "var" { make_step(cur_temp, cur_block, cur_exit_label, make_work3("VA", ast, "", "")) }
    else if ntype == "binop" {
        let op = get_child(ast, 0);
        let left = get_child(ast, 1);
        let right = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("BI", op, left, right, ""))
    }
    else if ntype == "unary" {
        let op = get_child(ast, 0);
        let operand = get_child(ast, 1);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("UN", op, operand, ""))
    }
    else if ntype == "if" {
        let cond = get_child(ast, 0);
        let then_br = get_child(ast, 1);
        let else_br = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("IS", cond, then_br, else_br, ""))
    }
    else if ntype == "let" {
        let name = extract_name(ast);
        let value = get_child(ast, 1);
        let body = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("LS", name, value, body, ""))
    }
    // v0.60.248: let_mut support - same lowering as let
    else if ntype == "let_mut" {
        let name = extract_name(ast);
        let value = get_child(ast, 1);
        let body = get_child(ast, 2);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("LS", name, value, body, ""))
    }
    else if ntype == "call" {
        let name = extract_name(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work4("CS", name, ast, "1", ""))
    }
    else if ntype == "method" {
        let method_name = get_child(ast, 0);
        let receiver = get_child(ast, 1);
        let fn_name = method_to_runtime_fn(method_name);
        make_step(cur_temp, cur_block, cur_exit_label, make_work("MS", fn_name, receiver, ast, "2", ""))
    }
    // v0.60.126: Block, unit, seq, assign support
    else if ntype == "block" {
        let inner = block_inner(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("EX", inner, "", ""))
    }
    else if ntype == "unit" {
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("UT", "", "", ""))
    }
    else if ntype == "seq" {
        let e1 = seq_first(ast);
        let e2 = seq_second(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("SQ", e1, e2, ""))
    }
    else if ntype == "assign" {
        let lhs = assign_lhs_expr(ast);
        let rhs = assign_rhs_expr(ast);
        make_step(cur_temp, cur_block, cur_exit_label, make_work3("AS", lhs, rhs, ""))
    }
    // v0.60.248: While loop support - use recursive lowering
    else if ntype == "while" {
        let result = lower_while_sb(ast, cur_temp, cur_block, sb);
        let new_temp = unpack_temp(result);
        let new_block = unpack_block(result);
        make_step(new_temp, new_block, cur_exit_label, "")
    }
    else { make_step(cur_temp, cur_block, cur_exit_label, "") };

// IN: Integer literal - emit MIR, advance temp
fn step_int(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let val = extract_int_value(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + i2s(val));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// BO: Boolean literal
fn step_bool(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + i2s(val));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// ST: String literal
fn step_string(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let str_content = extract_string_content(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = string " + chr(34) + str_content + chr(34));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// VA: Variable reference
fn step_var(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let ast = get_field(item, 1);
    let name = extract_name(ast);
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = copy %" + name);
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// BI: Start binop - push left expr, then BR continuation
fn step_binop_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let left = get_field(item, 2);
    let right = get_field(item, 3);
    // After left, cur_temp will have advanced. BR needs to know where left result is.
    let cont = make_work("BR", op, right, i2s(cur_temp), "", "");
    let do_left = make_work3("EX", left, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_left + work_sep() + cont);

// BR: Binop right - left done, do right. cur_temp-1 is left result.
fn step_binop_right(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let right = get_field(item, 2);
    let left_start = s2i(get_field(item, 3));
    let left_id = cur_temp - 1;
    // Push right, then BF finalize
    let cont = make_work4("BF", op, i2s(left_id), i2s(cur_temp), "");
    let do_right = make_work3("EX", right, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_right + work_sep() + cont);

// BF: Binop final - both done, emit binop MIR
fn step_binop_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let left_id = s2i(get_field(item, 2));
    let right_start = s2i(get_field(item, 3));
    let right_id = cur_temp - 1;
    let result_tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + op + " %_t" + i2s(left_id) + ", %_t" + i2s(right_id));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// UN: Start unary - push operand, then UF
fn step_unary_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let operand = get_field(item, 2);
    let cont = make_work3("UF", op, i2s(cur_temp), "");
    let do_op = make_work3("EX", operand, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_op + work_sep() + cont);

// UF: Unary final - emit unary MIR
fn step_unary_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let op = get_field(item, 1);
    let operand_id = cur_temp - 1;
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let result_tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + i2s(operand_id));
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// IS: Start if - push cond, then IT
fn step_if_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let cond = get_field(item, 1);
    let then_br = get_field(item, 2);
    let else_br = get_field(item, 3);
    // After cond, we'll have cond_id and need to emit branch then do branches
    let cont = make_work("IT", then_br, else_br, i2s(cur_temp), i2s(cur_block), "");
    let do_cond = make_work3("EX", cond, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_cond + work_sep() + cont);

// IT: If then - cond done, emit branch, do then branch
// Sets exit_label to then_label for the then branch execution
fn step_if_then(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let then_br = get_field(item, 1);
    let else_br = get_field(item, 2);
    let orig_temp = s2i(get_field(item, 3));
    let orig_block = s2i(get_field(item, 4));
    let cond_id = cur_temp - 1;
    let my_block = cur_block;
    let then_label = "then_" + i2s(my_block);
    let else_label = "else_" + i2s(my_block);
    let merge_label = "merge_" + i2s(my_block);
    let w1 = sb_push_mir(sb, "  branch %_t" + i2s(cond_id) + ", " + then_label + ", " + else_label);
    let w2 = sb_push_mir(sb, then_label + ":");
    // Continue with then, then IE
    // Pass merge_label as the expected exit for then branch (will be updated by nested ifs)
    let cont = make_work7("IE", else_br, i2s(my_block), then_label, else_label, merge_label, i2s(cur_temp), then_br);
    let do_then = make_work3("EX", then_br, "", "");
    // Set exit_label to then_label - the then branch will update this if it contains nested ifs
    make_step(cur_temp, my_block + 1, then_label, do_then + work_sep() + cont);

// IE: If else - then done, emit goto, do else
// Uses cur_exit_label as the actual then_exit (propagated through trampoline)
fn step_if_else(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let else_br = get_field(item, 1);
    let my_block = s2i(get_field(item, 2));
    let then_label = get_field(item, 3);
    let else_label = get_field(item, 4);
    let merge_label = get_field(item, 5);
    let then_start = s2i(get_field(item, 6));
    let then_ast = get_field(item, 7);
    let then_id = cur_temp - 1;
    // Use the propagated exit_label from trampoline - this is the actual exit point of the then branch
    let then_exit = if cur_exit_label == "" { then_label } else { cur_exit_label };
    let w1 = sb_push_mir(sb, "  goto " + merge_label);
    let w2 = sb_push_mir(sb, else_label + ":");
    // Continue with else, then IX final
    let cont = make_work7("IX", i2s(my_block), merge_label, i2s(then_id), then_exit, i2s(cur_temp), i2s(cur_block), else_br);
    let do_else = make_work3("EX", else_br, "", "");
    // Set exit_label to else_label - the else branch will update this if it contains nested ifs
    make_step(cur_temp, cur_block, else_label, do_else + work_sep() + cont);

// IX: If final - else done, emit goto and phi
// Uses cur_exit_label as the actual else_exit (propagated through trampoline)
fn step_if_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let my_block = s2i(get_field(item, 1));
    let merge_label = get_field(item, 2);
    let then_id = s2i(get_field(item, 3));
    let then_exit = get_field(item, 4);
    let else_start = s2i(get_field(item, 5));
    let else_entry_block = s2i(get_field(item, 6));
    let else_ast = get_field(item, 7);
    let else_id = cur_temp - 1;
    // Use the propagated exit_label from trampoline - this is the actual exit point of the else branch
    let else_exit = if cur_exit_label == "" { "else_" + i2s(my_block) } else { cur_exit_label };
    let w1 = sb_push_mir(sb, "  goto " + merge_label);
    let w2 = sb_push_mir(sb, merge_label + ":");
    let phi_tmp = "%_t" + i2s(cur_temp);
    let w3 = sb_push_mir(sb, "  " + phi_tmp + " = phi [%_t" + i2s(then_id) + ", " + then_exit + "], [%_t" + i2s(else_id) + ", " + else_exit + "]");
    // After if completes, exit_label is merge_label
    make_step(cur_temp + 1, cur_block, merge_label, "");

// LS: Start let - push value, then LB
// v0.88.1: Create unique SSA-compatible variable names to avoid duplicate definitions
fn step_let_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let value = get_field(item, 2);
    let body = get_field(item, 3);
    // v0.88.1: Generate unique name: name_v{cur_temp} and rename references in body
    let unique_name = name + "_v" + i2s(cur_temp);
    let body_renamed = rename_var_in_ast(body, name, unique_name);
    let cont = make_work4("LB", unique_name, body_renamed, i2s(cur_temp), "");
    let do_val = make_work3("EX", value, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_val + work_sep() + cont);

// LB: Let body - value done, emit copy, do body
// v0.88.1: Uses unique SSA-compatible name passed from step_let_start
fn step_let_body(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let unique_name = get_field(item, 1);
    let body = get_field(item, 2);
    let val_id = cur_temp - 1;
    let w1 = sb_push_mir(sb, "  %" + unique_name + " = copy %_t" + i2s(val_id));
    let do_body = make_work3("EX", body, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_body);

// CS: Start call - begin processing args
// v0.60.211: Fixed to track actual arg result temps, not a range
fn step_call_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let arg = get_child(ast, idx);
    if arg == "" {
        // No args, emit call
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "()");
        make_step(cur_temp + 1, cur_block, cur_exit_label, "")
    } else {
        // Has args, start processing
        // Field 4: collected arg temps (starts empty)
        let cont = make_work("CA", name, ast, i2s(idx + 1), "", "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// CA: Call arg - process next arg or finalize
// v0.60.211: Fixed to collect actual arg temps, not use range
fn step_call_arg(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let collected = get_field(item, 4);
    // Append the result of the just-evaluated arg (cur_temp - 1)
    let this_arg = "%_t" + i2s(cur_temp - 1);
    let new_collected = if collected == "" { this_arg } else { collected + ", " + this_arg };
    let arg = get_child(ast, idx);
    if arg == "" {
        // Done with args, emit call
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "(" + new_collected + ")");
        make_step(cur_temp + 1, cur_block, cur_exit_label, "")
    } else {
        // More args
        let cont = make_work("CA", name, ast, i2s(idx + 1), new_collected, "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// CF: Call final (unused in new design, kept for compatibility)
fn step_call_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    make_step(cur_temp, cur_block, cur_exit_label, "");

// MS: Start method - do receiver
// v0.60.211: Fixed method call to track actual arg temps
fn step_method_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let fn_name = get_field(item, 1);
    let receiver = get_field(item, 2);
    let ast = get_field(item, 3);
    let idx = s2i(get_field(item, 4));
    // Field 4: collected arg temps (starts empty, receiver added after eval)
    let cont = make_work("MA", fn_name, ast, i2s(idx), "", "");
    let do_recv = make_work3("EX", receiver, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, do_recv + work_sep() + cont);

// MA: Method arg - process next arg or finalize
// v0.60.211: Fixed to collect actual arg temps
fn step_method_arg(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let fn_name = get_field(item, 1);
    let ast = get_field(item, 2);
    let idx = s2i(get_field(item, 3));
    let collected = get_field(item, 4);
    // Append the result of the just-evaluated arg/receiver (cur_temp - 1)
    let this_arg = "%_t" + i2s(cur_temp - 1);
    let new_collected = if collected == "" { this_arg } else { collected + ", " + this_arg };
    let arg = get_child(ast, idx);
    if arg == "" {
        // Done with args
        let result_tmp = "%_t" + i2s(cur_temp);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + fn_name + "(" + new_collected + ")");
        make_step(cur_temp + 1, cur_block, cur_exit_label, "")
    } else {
        // More args
        let cont = make_work("MA", fn_name, ast, i2s(idx + 1), new_collected, "");
        let do_arg = make_work3("EX", arg, "", "");
        make_step(cur_temp, cur_block, cur_exit_label, do_arg + work_sep() + cont)
    };

// MF: Method final (unused)
fn step_method_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    make_step(cur_temp, cur_block, cur_exit_label, "");

// v0.60.126: Unit expression step - returns 0
fn step_unit(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let tmp = "%_t" + i2s(cur_temp);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const 0");
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// v0.60.126: Sequence start - lower first expression, queue second
fn step_seq_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let e1 = get_field(item, 1);
    let e2 = get_field(item, 2);
    // First lower e1, then continue with e2
    let cont = make_work3("S2", e2, "", "");
    let eval = make_work3("EX", e1, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.60.126: Sequence second - lower second expression (first already done)
fn step_seq_second(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let e2 = get_field(item, 1);
    make_step(cur_temp, cur_block, cur_exit_label, make_work3("EX", e2, "", ""));

// v0.60.126: Assignment start - lower RHS, queue final
fn step_assign_start(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let lhs = get_field(item, 1);
    let rhs = get_field(item, 2);
    // Lower RHS, then do assignment
    let cont = make_work3("AF", lhs, "", "");
    let eval = make_work3("EX", rhs, "", "");
    make_step(cur_temp, cur_block, cur_exit_label, eval + work_sep() + cont);

// v0.60.126: Assignment final - store value and return unit
fn step_assign_final(item: String, cur_temp: i64, cur_block: i64, cur_exit_label: String, sb: i64) -> String =
    let lhs = get_field(item, 1);
    // RHS value is in %_t(cur_temp-1)
    let rhs_temp = cur_temp - 1;
    let name = extract_var_from_assign(lhs);
    let w1 = sb_push_mir(sb, "  %" + name + " = copy %_t" + i2s(rhs_temp));
    // Assignment returns unit
    let tmp = "%_t" + i2s(cur_temp);
    let w2 = sb_push_mir(sb, "  " + tmp + " = const 0");
    make_step(cur_temp + 1, cur_block, cur_exit_label, "");

// Build argument string from temp range [start, end)
fn build_args_str(start: i64, end: i64) -> String =
    build_args_str_acc(start, end, "");

fn build_args_str_acc(cur: i64, end: i64, acc: String) -> String =
    if cur >= end { acc }
    else {
        let arg = "%_t" + i2s(cur);
        let new_acc = if acc == "" { arg } else { acc + ", " + arg };
        build_args_str_acc(cur + 1, end, new_acc)
    };

// ===========================================================================
// SECTION 8b: Original Recursive Lowering (fallback)
// ===========================================================================

// v0.60.126: Added block, unit, seq, assign support
fn lower_expr_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let ntype = get_node_type(ast);
    if ntype == "int" { lower_int_sb(ast, temp_id, block_id, sb) } else if ntype == "bool" { lower_bool_sb(ast, temp_id, block_id, sb) } else if ntype == "string" { lower_string_sb(ast, temp_id, block_id, sb) } else if ntype == "var" { lower_var_sb(ast, temp_id, block_id, sb) } else if ntype == "binop" { lower_binop_sb(ast, temp_id, block_id, sb) } else if ntype == "unary" { lower_unary_sb(ast, temp_id, block_id, sb) } else if ntype == "if" { lower_if_sb(ast, temp_id, block_id, sb) } else if ntype == "let" { lower_let_sb(ast, temp_id, block_id, sb) } else if ntype == "let_mut" { lower_let_sb(ast, temp_id, block_id, sb) } else if ntype == "call" { lower_call_sb(ast, temp_id, block_id, sb) } else if ntype == "method" { lower_method_sb(ast, temp_id, block_id, sb) } else if ntype == "block" { lower_block_sb(ast, temp_id, block_id, sb) } else if ntype == "unit" { lower_unit_sb(ast, temp_id, block_id, sb) } else if ntype == "seq" { lower_seq_sb(ast, temp_id, block_id, sb) } else if ntype == "assign" { lower_assign_sb(ast, temp_id, block_id, sb) } else if ntype == "while" { lower_while_sb(ast, temp_id, block_id, sb) } else { pack_ids(temp_id, block_id) };

fn lower_int_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let val = extract_int_value(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + int_to_string(val));
    pack_ids(temp_id + 1, block_id);

fn lower_bool_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + int_to_string(val));
    pack_ids(temp_id + 1, block_id);

// v0.60.109: Lower string literal to MIR
fn lower_string_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let str_content = extract_string_content(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = string " + chr(34) + str_content + chr(34));
    pack_ids(temp_id + 1, block_id);

// v0.60.109: Extract string content from AST node "(string content)"
// v0.60.120: Updated to unescape parens that were escaped for AST representation
fn extract_string_content(ast: String) -> String =
    let start = 8;
    let end = ast.len() - 1;
    if end > start { unescape_parens_from_ast(ast.slice(start, end)) } else { "" };

fn lower_var_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let name = extract_name(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = copy %" + name);
    pack_ids(temp_id + 1, block_id);

fn lower_binop_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let op = get_child(ast, 0);
    let left_ast = get_child(ast, 1);
    let right_ast = get_child(ast, 2);
    let left_result = lower_expr_sb(left_ast, temp_id, block_id, sb);
    let left_temp = unpack_temp(left_result);
    let left_block = unpack_block(left_result);
    let left_id = left_temp - 1;
    let right_result = lower_expr_sb(right_ast, left_temp, left_block, sb);
    let right_temp = unpack_temp(right_result);
    let right_block = unpack_block(right_result);
    let right_id = right_temp - 1;
    let result_tmp = "%_t" + int_to_string(right_temp);
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + op + " %_t" + int_to_string(left_id) + ", %_t" + int_to_string(right_id));
    pack_ids(right_temp + 1, right_block);

fn lower_unary_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let op = get_child(ast, 0);
    let operand = get_child(ast, 1);
    let operand_result = lower_expr_sb(operand, temp_id, block_id, sb);
    let operand_temp = unpack_temp(operand_result);
    let operand_block = unpack_block(operand_result);
    let operand_id = operand_temp - 1;
    let result_tmp = "%_t" + int_to_string(operand_temp);
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(operand_id));
    pack_ids(operand_temp + 1, operand_block);

fn lower_if_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let cond = get_child(ast, 0);
    let then_branch = get_child(ast, 1);
    let else_branch = get_child(ast, 2);
    let cond_result = lower_expr_sb(cond, temp_id, block_id, sb);
    let cond_temp = unpack_temp(cond_result);
    let my_block_id = unpack_block(cond_result);
    let cond_id = cond_temp - 1;
    let then_label = "then_" + int_to_string(my_block_id);
    let else_label = "else_" + int_to_string(my_block_id);
    let merge_label = "merge_" + int_to_string(my_block_id);
    let w1 = sb_push_mir(sb, "  branch %_t" + int_to_string(cond_id) + ", " + then_label + ", " + else_label);
    let w2 = sb_push_mir(sb, then_label + ":");
    // v0.60.200: Pass my_block_id + 1 to then branch, track returned block_id
    let then_result = lower_expr_sb(then_branch, cond_temp, my_block_id + 1, sb);
    let then_temp = unpack_temp(then_result);
    let then_block = unpack_block(then_result);
    let then_id = then_temp - 1;
    // v0.60.201: Use recursive get_exit_label for correct PHI predecessors
    let then_exit = get_exit_label(then_branch, then_label, my_block_id + 1);
    let w3 = sb_push_mir(sb, "  goto " + merge_label);
    let w4 = sb_push_mir(sb, else_label + ":");
    // v0.60.200: Pass then_block (not my_block_id + 2) to else branch for proper tracking
    let else_result = lower_expr_sb(else_branch, then_temp, then_block, sb);
    let else_temp = unpack_temp(else_result);
    let else_block = unpack_block(else_result);
    let else_id = else_temp - 1;
    // v0.60.201: Use recursive get_exit_label for correct PHI predecessors
    let else_exit = get_exit_label(else_branch, else_label, then_block);
    let w5 = sb_push_mir(sb, "  goto " + merge_label);
    let w6 = sb_push_mir(sb, merge_label + ":");
    let phi_tmp = "%_t" + int_to_string(else_temp);
    let w7 = sb_push_mir(sb, "  " + phi_tmp + " = phi [%_t" + int_to_string(then_id) + ", " + then_exit + "], [%_t" + int_to_string(else_id) + ", " + else_exit + "]");
    pack_ids(else_temp + 1, else_block);

fn lower_let_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let name = extract_name(ast);
    let value_ast = get_child(ast, 1);
    let body_ast = get_child(ast, 2);
    // v0.60.200: Track block_id properly between value and body
    let val_result = lower_expr_sb(value_ast, temp_id, block_id, sb);
    let val_temp = unpack_temp(val_result);
    let val_block = unpack_block(val_result);
    let val_id = val_temp - 1;
    let w1 = sb_push_mir(sb, "  %" + name + " = copy %_t" + int_to_string(val_id));
    lower_expr_sb(body_ast, val_temp, val_block, sb);

fn lower_call_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let name = extract_name(ast);
    lower_call_args_sb(ast, name, temp_id, block_id, 1, "", sb);

fn lower_call_args_sb(ast: String, name: String, temp_id: i64, block_id: i64, idx: i64, args_acc: String, sb: i64) -> i64 =
    let arg = get_child(ast, idx);
    if arg == "" {
        let result_tmp = "%_t" + int_to_string(temp_id);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "(" + args_acc + ")");
        pack_ids(temp_id + 1, block_id)
    } else {
        // v0.60.200: Track block_id through arguments
        let arg_result = lower_expr_sb(arg, temp_id, block_id, sb);
        let arg_temp = unpack_temp(arg_result);
        let arg_block = unpack_block(arg_result);
        let arg_id = arg_temp - 1;
        let new_args = if args_acc == "" { "%_t" + int_to_string(arg_id) } else { args_acc + ", %_t" + int_to_string(arg_id) };
        lower_call_args_sb(ast, name, arg_temp, arg_block, idx + 1, new_args, sb)
    };

// v0.60.110: Lower method call to runtime function call
// Method AST: (method name receiver arg1 arg2 ...)
// String methods map to bmb_string_* functions
fn lower_method_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let method_name = get_child(ast, 0);
    let receiver = get_child(ast, 1);
    let runtime_fn = method_to_runtime_fn(method_name);
    lower_method_args_sb(ast, runtime_fn, receiver, temp_id, block_id, 2, sb);

fn method_to_runtime_fn(method: String) -> String =
    if method == "len" { "bmb_string_len" }
    else if method == "byte_at" { "bmb_string_char_at" }
    else if method == "slice" { "bmb_string_slice" }
    else if method == "concat" { "bmb_string_concat" }
    else { "bmb_" + method };

fn lower_method_args_sb(ast: String, fn_name: String, receiver: String, temp_id: i64, block_id: i64, idx: i64, sb: i64) -> i64 =
    // First lower the receiver, track block_id
    let recv_result = lower_expr_sb(receiver, temp_id, block_id, sb);
    let recv_temp = unpack_temp(recv_result);
    let recv_block = unpack_block(recv_result);
    let recv_id = recv_temp - 1;
    let args_acc = "%_t" + int_to_string(recv_id);
    lower_method_extra_args_sb(ast, fn_name, recv_temp, recv_block, idx, args_acc, sb);

fn lower_method_extra_args_sb(ast: String, fn_name: String, temp_id: i64, block_id: i64, idx: i64, args_acc: String, sb: i64) -> i64 =
    let arg = get_child(ast, idx);
    if arg == "" {
        let result_tmp = "%_t" + int_to_string(temp_id);
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + fn_name + "(" + args_acc + ")");
        pack_ids(temp_id + 1, block_id)
    } else {
        // v0.60.200: Track block_id through arguments
        let arg_result = lower_expr_sb(arg, temp_id, block_id, sb);
        let arg_temp = unpack_temp(arg_result);
        let arg_block = unpack_block(arg_result);
        let arg_id = arg_temp - 1;
        let new_args = args_acc + ", %_t" + int_to_string(arg_id);
        lower_method_extra_args_sb(ast, fn_name, arg_temp, arg_block, idx + 1, new_args, sb)
    };

// v0.60.126: Block expression lowering
// Block format: (block inner_expr)
fn lower_block_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let inner = block_inner(ast);
    lower_expr_sb(inner, temp_id, block_id, sb);

// Extract inner expression from (block inner)
fn block_inner(ast: String) -> String =
    let len = ast.len();
    if len < 9 { "" } else { ast.slice(7, len - 1) };

// v0.60.126: Unit expression lowering
fn lower_unit_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const 0");
    pack_ids(temp_id + 1, block_id);

// v0.60.126: Sequence expression lowering
// Seq format: (seq expr1 expr2)
fn lower_seq_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let e1 = seq_first(ast);
    let e2 = seq_second(ast);
    // Lower first for side effect
    let r1 = lower_expr_sb(e1, temp_id, block_id, sb);
    let t1 = unpack_temp(r1);
    let b1 = unpack_block(r1);
    // Lower second for value
    lower_expr_sb(e2, t1, b1, sb);

// Extract first expression from (seq e1 e2)
fn seq_first(ast: String) -> String =
    let len = ast.len();
    if len < 10 { "" } else {
        let content = ast.slice(5, len - 1);
        find_first_balanced(content, 0, 0, "")
    };

// Extract second expression from (seq e1 e2)
fn seq_second(ast: String) -> String =
    let len = ast.len();
    if len < 10 { "" } else {
        let content = ast.slice(5, len - 1);
        find_rest_balanced(content, 0, 0)
    };

// Find first balanced expression (stop at top-level space)
fn find_first_balanced(s: String, idx: i64, depth: i64, acc: String) -> String =
    if idx >= s.len() { acc } else {
        let c = s.byte_at(idx);
        if c == 40 { find_first_balanced(s, idx + 1, depth + 1, acc + chr(c)) }
        else if c == 41 { find_first_balanced(s, idx + 1, depth - 1, acc + chr(c)) }
        else if c == 32 and depth == 0 { acc }
        else { find_first_balanced(s, idx + 1, depth, acc + chr(c)) }
    };

// Find rest after first balanced expression
fn find_rest_balanced(s: String, idx: i64, depth: i64) -> String =
    if idx >= s.len() { "" } else {
        let c = s.byte_at(idx);
        if c == 40 { find_rest_balanced(s, idx + 1, depth + 1) }
        else if c == 41 { find_rest_balanced(s, idx + 1, depth - 1) }
        else if c == 32 and depth == 0 { s.slice(idx + 1, s.len()) }
        else { find_rest_balanced(s, idx + 1, depth) }
    };

// v0.60.126: Assignment expression lowering
// Assign format: (assign lhs rhs)
fn lower_assign_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let lhs = assign_lhs_expr(ast);
    let rhs = assign_rhs_expr(ast);
    // First lower rhs
    let rr = lower_expr_sb(rhs, temp_id, block_id, sb);
    let tr = unpack_temp(rr);
    let br = unpack_block(rr);
    let rhs_id = tr - 1;
    // Extract target name from lhs (var <name>)
    let name = extract_var_from_assign(lhs);
    let w1 = sb_push_mir(sb, "  %" + name + " = copy %_t" + int_to_string(rhs_id));
    // Assignment returns unit
    let tmp = "%_t" + int_to_string(tr);
    let w2 = sb_push_mir(sb, "  " + tmp + " = const 0");
    pack_ids(tr + 1, br);

// ============================================================================
// v0.60.248: While Loop Lowering
// ============================================================================
// MIR format:
//   goto loop_N
//   loop_N:
//     <cond code>
//     branch %cond, body_N, exit_N
//   body_N:
//     <body code>
//     goto loop_N
//   exit_N:
//     %result = const 0   ; while returns unit

fn lower_while_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let cond_ast = get_child(ast, 0);
    let body_ast = get_child(ast, 1);
    let loop_label = "loop_" + int_to_string(block_id);
    let body_label = "body_" + int_to_string(block_id);
    let exit_label = "exit_" + int_to_string(block_id);
    // Jump to loop header
    let w1 = sb_push_mir(sb, "  goto " + loop_label);
    let w2 = sb_push_mir(sb, loop_label + ":");
    // Lower condition
    let cond_result = lower_expr_sb(cond_ast, temp_id, block_id + 1, sb);
    let cond_temp = unpack_temp(cond_result);
    let cond_block = unpack_block(cond_result);
    let cond_id = cond_temp - 1;
    // Branch on condition
    let w3 = sb_push_mir(sb, "  branch %_t" + int_to_string(cond_id) + ", " + body_label + ", " + exit_label);
    let w4 = sb_push_mir(sb, body_label + ":");
    // Lower body
    let body_result = lower_expr_sb(body_ast, cond_temp, cond_block, sb);
    let body_temp = unpack_temp(body_result);
    let body_block = unpack_block(body_result);
    // Jump back to loop header
    let w5 = sb_push_mir(sb, "  goto " + loop_label);
    let w6 = sb_push_mir(sb, exit_label + ":");
    // While returns unit
    let result_tmp = "%_t" + int_to_string(body_temp);
    let w7 = sb_push_mir(sb, "  " + result_tmp + " = const 0");
    pack_ids(body_temp + 1, body_block);

// Extract lhs from (assign lhs rhs)
fn assign_lhs_expr(ast: String) -> String =
    let len = ast.len();
    if len < 15 { "" } else {
        let content = ast.slice(8, len - 1);
        find_first_balanced(content, 0, 0, "")
    };

// Extract rhs from (assign lhs rhs)
fn assign_rhs_expr(ast: String) -> String =
    let len = ast.len();
    if len < 15 { "" } else {
        let content = ast.slice(8, len - 1);
        find_rest_balanced(content, 0, 0)
    };

// Extract variable name from (var <name>)
fn extract_var_from_assign(ast: String) -> String =
    let len = ast.len();
    if len < 10 { "" } else {
        // (var <name>) -> skip "(var <" = 6, remove ">)" = 2
        ast.slice(6, len - 2)
    };

fn lower_function_sb(ast: String) -> String =
    let name = extract_name(ast);
    let params = collect_params(ast, 1, "");
    let ret_type = get_fn_return_type(ast);
    let body_ast = get_fn_body(ast);
    let sb = sb_new();
    // v0.60.300: Use iterative lowering to avoid stack overflow
    let final_result = lower_expr_iter(body_ast, 0, 0, sb);
    let final_temp = unpack_temp(final_result);
    let result_id = final_temp - 1;
    let w1 = sb_push_mir(sb, "  return %_t" + int_to_string(result_id));
    let body_mir = sb_build(sb);
    "fn " + name + "(" + params + ") -> " + ret_type + " {|entry:|" + body_mir + "|}";

fn lower_program_sb(ast: String) -> String =
    let sb = sb_new();
    let w1 = lower_program_inner_sb(ast, 0, sb);
    sb_build(sb);

// v0.88.6: arena_save/arena_restore per function to free lowering intermediates
fn lower_program_inner_sb(ast: String, idx: i64, sb: i64) -> i64 =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" { 0 } else if not is_fn_node(fn_ast) { 0 } else {
        let _save = bmb_arena_save();
        let fn_mir = lower_function_sb(fn_ast);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_mir);
        let _restore = bmb_arena_restore();
        lower_program_inner_sb(ast, idx + 1, sb)
    };

// ============================================================================
// SECTION 9: Expression Lowering
// ============================================================================

fn lower_expr(ast: String, temp_id: i64, block_id: i64) -> String =
    let ntype = get_node_type(ast);
    if ntype == "int" { lower_int(ast, temp_id) } else if ntype == "bool" { lower_bool(ast, temp_id) } else if ntype == "var" { lower_var(ast, temp_id) } else if ntype == "binop" { lower_binop(ast, temp_id, block_id) } else if ntype == "unary" { lower_unary(ast, temp_id, block_id) } else if ntype == "if" { lower_if(ast, temp_id, block_id) } else if ntype == "let" { lower_let(ast, temp_id, block_id) } else if ntype == "call" { lower_call(ast, temp_id, block_id) } else { pack_lower_result("ERR:unknown-" + ntype, temp_id) };

fn lower_int(ast: String, temp_id: i64) -> String =
    let val = extract_int_value(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = const " + int_to_string(val), temp_id + 1);

fn lower_bool(ast: String, temp_id: i64) -> String =
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = const " + int_to_string(val), temp_id + 1);

fn lower_var(ast: String, temp_id: i64) -> String =
    let name = extract_name(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = copy %" + name, temp_id + 1);

fn lower_binop(ast: String, temp_id: i64, block_id: i64) -> String =
    let op = get_child(ast, 0);
    let left_ast = get_child(ast, 1);
    let right_ast = get_child(ast, 2);
    let rl = lower_expr(left_ast, temp_id, block_id);
    let left_id = unpack_temp_id(rl) - 1;
    let rr = lower_expr(right_ast, unpack_temp_id(rl), block_id);
    let right_id = unpack_temp_id(rr) - 1;
    let result_tmp = "%_t" + int_to_string(unpack_temp_id(rr));
    let mir = unpack_text(rl) + "|" + unpack_text(rr) + "|" +
        "  " + result_tmp + " = " + op + " %_t" + int_to_string(left_id) + ", %_t" + int_to_string(right_id);
    pack_lower_result(mir, unpack_temp_id(rr) + 1);

fn lower_unary(ast: String, temp_id: i64, block_id: i64) -> String =
    let op = get_child(ast, 0);
    let operand = get_child(ast, 1);
    let ro = lower_expr(operand, temp_id, block_id);
    let operand_id = unpack_temp_id(ro) - 1;
    let result_tmp = "%_t" + int_to_string(unpack_temp_id(ro));
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let mir = unpack_text(ro) + "|" +
        "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(operand_id);
    pack_lower_result(mir, unpack_temp_id(ro) + 1);

fn lower_if(ast: String, temp_id: i64, block_id: i64) -> String =
    let cond = get_child(ast, 0);
    let then_branch = get_child(ast, 1);
    let else_branch = get_child(ast, 2);
    let rc = lower_expr(cond, temp_id, block_id);
    let cond_id = unpack_temp_id(rc) - 1;
    let then_label = "then_" + int_to_string(block_id);
    let else_label = "else_" + int_to_string(block_id);
    let merge_label = "merge_" + int_to_string(block_id);
    let branch = "  branch %_t" + int_to_string(cond_id) + ", " + then_label + ", " + else_label;
    let rt = lower_expr(then_branch, unpack_temp_id(rc), block_id + 1);
    let then_id = unpack_temp_id(rt) - 1;
    // v0.60.128: Determine then exit label for phi node
    let then_type = get_node_type(then_branch);
    let then_exit = if then_type == "if" { "merge_" + int_to_string(block_id + 1) } else { then_label };
    let re = lower_expr(else_branch, unpack_temp_id(rt), block_id + 2);
    let else_id = unpack_temp_id(re) - 1;
    // v0.60.128: Determine else exit label for phi node
    let else_type = get_node_type(else_branch);
    let else_exit = if else_type == "if" { "merge_" + int_to_string(block_id + 2) } else { else_label };
    let phi_tmp = "%_t" + int_to_string(unpack_temp_id(re));
    let phi = "  " + phi_tmp + " = phi [%_t" + int_to_string(then_id) + ", " + then_exit + "], [%_t" + int_to_string(else_id) + ", " + else_exit + "]";
    let mir = unpack_text(rc) + "|" + branch + "|" +
        then_label + ":|" + unpack_text(rt) + "|  goto " + merge_label + "|" +
        else_label + ":|" + unpack_text(re) + "|  goto " + merge_label + "|" +
        merge_label + ":|" + phi;
    pack_lower_result(mir, unpack_temp_id(re) + 1);

fn lower_let(ast: String, temp_id: i64, block_id: i64) -> String =
    let name = extract_name(ast);
    let value_ast = get_child(ast, 1);
    let body_ast = get_child(ast, 2);
    let rv = lower_expr(value_ast, temp_id, block_id);
    let val_id = unpack_temp_id(rv) - 1;
    let assign = "  %" + name + " = copy %_t" + int_to_string(val_id);
    let rb = lower_expr(body_ast, unpack_temp_id(rv), block_id);
    let mir = unpack_text(rv) + "|" + assign + "|" + unpack_text(rb);
    pack_lower_result(mir, unpack_temp_id(rb));

fn lower_call(ast: String, temp_id: i64, block_id: i64) -> String =
    let name = extract_name(ast);
    lower_call_args(ast, name, temp_id, block_id, 1, "", "");

fn lower_call_args(ast: String, name: String, temp_id: i64, block_id: i64, idx: i64, mir_acc: String, args_acc: String) -> String =
    let arg = get_child(ast, idx);
    if arg == "" {
        let result_tmp = "%_t" + int_to_string(temp_id);
        let call_mir = "  " + result_tmp + " = call @" + name + "(" + args_acc + ")";
        let full_mir = if mir_acc == "" { call_mir } else { mir_acc + "|" + call_mir };
        pack_lower_result(full_mir, temp_id + 1)
    } else {
        let ra = lower_expr(arg, temp_id, block_id);
        let arg_id = unpack_temp_id(ra) - 1;
        let new_args = if args_acc == "" { "%_t" + int_to_string(arg_id) } else { args_acc + ", %_t" + int_to_string(arg_id) };
        let new_mir = if mir_acc == "" { unpack_text(ra) } else { mir_acc + "|" + unpack_text(ra) };
        lower_call_args(ast, name, unpack_temp_id(ra), block_id, idx + 1, new_mir, new_args)
    };

// ============================================================================
// SECTION 10: Function Lowering
// ============================================================================

fn lower_function(ast: String) -> String =
    let name = extract_name(ast);
    let params = collect_params(ast, 1, "");
    let ret_type = get_fn_return_type(ast);
    let body_ast = get_fn_body(ast);
    let rb = lower_expr(body_ast, 0, 0);
    let body_mir = unpack_text(rb);
    let result_id = unpack_temp_id(rb) - 1;
    "fn " + name + "(" + params + ") -> " + ret_type + " {|entry:|" + body_mir + "|  return %_t" + int_to_string(result_id) + "|}";

fn collect_params(ast: String, idx: i64, acc: String) -> String =
    let child = get_child(ast, idx);
    if child == "" or get_node_type(child) != "param" { acc } else {
        let param_name = get_child(child, 0);
        let name = if param_name.len() >= 2 and param_name.byte_at(0) == 60 { param_name.slice(1, param_name.len() - 1) } else { param_name };
        let param_type = get_child(child, 1);
        let entry = name + ": " + param_type;
        let new_acc = if acc == "" { entry } else { acc + ", " + entry };
        collect_params(ast, idx + 1, new_acc)
    };

fn get_fn_return_type(ast: String) -> String =
    let content = extract_paren_content(ast);
    get_fn_return_scan(content, 0);

// v0.46: Added String return type support
fn get_fn_return_scan(content: String, pos: i64) -> String =
    let p = low_skip_ws(content, pos);
    if p >= content.len() { "i64" } else {
        let child = read_sexp_at(content, p);
        if child == "" { "i64" } else if child == "i32" or child == "i64" or child == "f64" or child == "bool" or child == "String" { child } else if child.byte_at(0) == 40 { get_fn_return_scan(content, p + child.len()) } else if child.byte_at(0) == 60 { get_fn_return_scan(content, p + child.len()) } else { get_fn_return_scan(content, p + child.len()) }
    };

fn get_fn_body(ast: String) -> String =
    let content = extract_paren_content(ast);
    get_fn_body_scan(content, 0, "");

fn get_fn_body_scan(content: String, pos: i64, last_expr: String) -> String =
    let p = low_skip_ws(content, pos);
    if p >= content.len() { last_expr } else {
        let child = read_sexp_at(content, p);
        if child == "" { last_expr } else if child.len() > 0 and child.byte_at(0) == 40 {
            let ntype = get_node_type(child);
            if ntype == "param" { get_fn_body_scan(content, p + child.len(), last_expr) } else { get_fn_body_scan(content, p + child.len(), child) }
        } else {
            get_fn_body_scan(content, p + child.len(), last_expr)
        }
    };

fn lower_program(ast: String) -> String =
    lower_program_inner(ast, 0, "");

fn lower_program_inner(ast: String, idx: i64, acc: String) -> String =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" { acc } else if not is_fn_node(fn_ast) { acc } else {
        let fn_mir = lower_function(fn_ast);
        let new_acc = if acc.len() > 0 { acc + "||" + fn_mir } else { fn_mir };
        lower_program_inner(ast, idx + 1, new_acc)
    };

// ============================================================================
// SECTION 11: LLVM IR Generation
// ============================================================================

fn find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 124 { pos } else { find_pipe(s, pos + 1) };

// v0.60.123: Find pipe character but skip over quoted strings
// This is needed because MIR lines can contain string literals with pipe characters like string "|"
fn find_pipe_skip_quotes(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 124 { pos }
    else if s.byte_at(pos) == 34 { find_pipe_skip_quotes(s, skip_quoted_string(s, pos + 1)) }
    else { find_pipe_skip_quotes(s, pos + 1) };

fn skip_quoted_string(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 34 { pos + 1 }
    else if s.byte_at(pos) == 92 { skip_quoted_string(s, pos + 2) }
    else { skip_quoted_string(s, pos + 1) };

// v0.46: Extract return type from MIR function signature
// MIR format: fn name(params) -> RetType {|...|}
fn extract_mir_return_type(mir: String) -> String =
    let arrow_pos = find_arrow(mir, 0);
    let brace_pos = find_char(mir, arrow_pos, 123);
    if arrow_pos >= mir.len() or brace_pos <= arrow_pos + 2 { "i64" }
    else { trim(mir.slice(arrow_pos + 2, brace_pos)) };

// v0.46: llvm_gen_line with return type awareness
fn llvm_gen_line_with_ret(line: String, ret_type: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" }
    // v0.60.118: Pass ret_type to assign for proper phi type
    else if line.byte_at(p) == 37 { llvm_gen_assign_typed(line, p, ret_type) }
    else if low_starts_with_at(line, p, "return") { llvm_gen_return_typed(line, p, ret_type) }
    else if low_starts_with_at(line, p, "branch") { llvm_gen_branch(line, p) }
    else if low_starts_with_at(line, p, "goto") { llvm_gen_goto(line, p) }
    else { line };

fn llvm_gen_line(line: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" } else if line.byte_at(p) == 37 { llvm_gen_assign(line, p) } else if low_starts_with_at(line, p, "return") { llvm_gen_return(line, p) } else if low_starts_with_at(line, p, "branch") { llvm_gen_branch(line, p) } else if low_starts_with_at(line, p, "goto") { llvm_gen_goto(line, p) } else { line };

fn llvm_gen_assign(line: String, pos: i64) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs(line, after_eq, dest);

// v0.60.118: Typed version for proper phi type
fn llvm_gen_assign_typed(line: String, pos: i64, ret_type: String) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs_typed(line, after_eq, dest, ret_type);

fn find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 61 { pos } else { find_eq(s, pos + 1) };

// v0.31.19: Added nsw for const/copy to match Rust compiler
fn llvm_gen_rhs(line: String, pos: i64, dest: String) -> String =
    llvm_gen_rhs_typed(line, pos, dest, "i64");

// v0.60.118: Typed version for proper phi type
fn llvm_gen_rhs_typed(line: String, pos: i64, dest: String, ret_type: String) -> String =
    if low_starts_with_at(line, pos, "const") {
        let val_start = low_skip_ws(line, pos + 5);
        let val = line.slice(val_start, line.len());
        "  " + dest + " = add nsw i64 0, " + trim_end(val)
    } else if low_starts_with_at(line, pos, "copy") {
        let src_start = low_skip_ws(line, pos + 4);
        let src = line.slice(src_start, line.len());
        "  " + dest + " = add nsw i64 0, " + trim_end(src)
    } else if low_starts_with_at(line, pos, "string") {
        // v0.60.109: String literal - emit call to bmb_string_from_cstr
        let str_start = low_skip_ws(line, pos + 6);
        let str_content = line.slice(str_start + 1, line.len() - 1);
        llvm_gen_string_literal(dest, str_content)
    } else if low_starts_with_at(line, pos, "+") { llvm_gen_binop("add", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "-") { llvm_gen_binop("sub", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "*") { llvm_gen_binop("mul", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "/") { llvm_gen_binop("sdiv", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "%") { llvm_gen_binop("srem", line, pos + 1, dest)
    // v0.32.1: Fix comparison operator order - check longer operators first
    } else if low_starts_with_at(line, pos, "<=") { llvm_gen_cmp("sle", line, pos + 2, dest) } else if low_starts_with_at(line, pos, ">=") { llvm_gen_cmp("sge", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "<") { llvm_gen_cmp("slt", line, pos + 1, dest) } else if low_starts_with_at(line, pos, ">") { llvm_gen_cmp("sgt", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "==") { llvm_gen_cmp("eq", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "!=") { llvm_gen_cmp("ne", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "and") { llvm_gen_binop("and", line, pos + 3, dest) } else if low_starts_with_at(line, pos, "or") { llvm_gen_binop("or", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "not") { llvm_gen_not(line, pos + 3, dest) } else if low_starts_with_at(line, pos, "neg") { llvm_gen_neg(line, pos + 3, dest) } else if low_starts_with_at(line, pos, "phi") { llvm_gen_phi_typed(line, pos, dest, ret_type) } else if low_starts_with_at(line, pos, "call") { llvm_gen_call(line, pos, dest) } else { "  ; unknown: " + line };

// v0.31.19: Added nsw (no signed wrap) for add/sub/mul to match Rust compiler
fn llvm_gen_binop(op: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let op_with_nsw = if op == "add" { "add nsw" } else if op == "sub" { "sub nsw" } else if op == "mul" { "mul nsw" } else { op };
    "  " + dest + " = " + op_with_nsw + " i64 " + trim_end(left) + ", " + trim_end(right);

// v0.60.118: Add zext to convert i1 comparison result to i64 for consistency
fn llvm_gen_cmp(pred: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    "  " + dest + "_cmp = icmp " + pred + " i64 " + trim_end(left) + ", " + trim_end(right) + "|  " + dest + " = zext i1 " + dest + "_cmp to i64";

fn llvm_gen_not(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = xor i64 " + trim_end(operand) + ", 1";

// v0.31.19: Added nsw for negation to match Rust compiler
fn llvm_gen_neg(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = sub nsw i64 0, " + trim_end(operand);

// v0.60.109: String literal (stub - use llvm_gen_string_ref with string table instead)
fn llvm_gen_string_literal(dest: String, str_content: String) -> String =
    "  ; ERROR: string literal without string table: " + str_content;

fn llvm_gen_phi(line: String, pos: i64, dest: String) -> String =
    llvm_gen_phi_typed(line, pos, dest, "i64");

// v0.60.231: PHI with string marker propagation
// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_phi_with_strings(line: String, pos: i64, dest: String, mapping: String) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let first_val = extract_phi_val(first_content);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    let second_val = extract_phi_val(second_content);
    let first_is_string = is_string_var_fast(first_val, mapping);
    let second_is_string = is_string_var_fast(second_val, mapping);
    if first_is_string or second_is_string {
        changed_mapping(add_string_marker(mapping, dest), llvm_gen_phi(line, pos, dest))
    } else {
        same_mapping(llvm_gen_phi(line, pos, dest))
    };

// v0.60.231: Extract value from PHI content "val, label"
fn extract_phi_val(content: String) -> String =
    let comma_pos = find_char(content, 0, 44);
    content.slice(0, comma_pos);

// v0.60.118: Typed phi instruction with correct type for String-returning functions
fn llvm_gen_phi_typed(line: String, pos: i64, dest: String, ret_type: String) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    let first_fixed = fix_phi_label(first_content);
    let second_fixed = fix_phi_label(second_content);
    let llvm_type = if ret_type == "String" { "ptr" } else if ret_type == "bool" { "i1" } else { "i64" };
    "  " + dest + " = phi " + llvm_type + " [ " + first_fixed + " ], [ " + second_fixed + " ]";

// v0.60.118: Add % prefix to phi label
fn fix_phi_label(content: String) -> String =
    let comma_pos = find_char(content, 0, 44);
    let val = content.slice(0, comma_pos);
    let label = content.slice(comma_pos + 2, content.len());
    val + ", %" + label;

// v0.46: Determine LLVM return type from function name
fn get_call_return_type(fn_name: String) -> String =
    // Void functions (no return value assignment)
    if fn_name == "@println" or fn_name == "@print_str" or fn_name == "@println_str" or fn_name == "@bmb_panic" { "void" }
    // v0.88.10: Void concurrency functions
    else if fn_name == "@bmb_mutex_unlock" or fn_name == "@bmb_mutex_free" { "void" }
    else if fn_name == "@bmb_channel_send" or fn_name == "@bmb_channel_close" { "void" }
    else if fn_name == "@bmb_arc_drop" { "void" }
    else if fn_name == "@bmb_rwlock_read_unlock" or fn_name == "@bmb_rwlock_write_unlock" or fn_name == "@bmb_rwlock_free" { "void" }
    else if fn_name == "@bmb_barrier_free" or fn_name == "@bmb_condvar_notify_one" or fn_name == "@bmb_condvar_notify_all" or fn_name == "@bmb_condvar_free" { "void" }
    else if fn_name == "@bmb_async_file_write" or fn_name == "@bmb_async_file_close" { "void" }
    else if fn_name == "@bmb_async_socket_write" or fn_name == "@bmb_async_socket_close" { "void" }
    else if fn_name == "@bmb_thread_pool_execute" or fn_name == "@bmb_thread_pool_join" or fn_name == "@bmb_thread_pool_shutdown" { "void" }
    else if fn_name == "@bmb_scope_spawn" or fn_name == "@bmb_scope_wait" { "void" }
    // Pointer-returning functions (String type)
    else if fn_name == "@get_arg" or fn_name == "@bmb_read_file" or fn_name == "@bmb_getenv" or fn_name == "@bmb_system_capture" { "ptr" }
    else if fn_name == "@bmb_string_new" or fn_name == "@bmb_string_from_cstr" or fn_name == "@bmb_string_slice" { "ptr" }
    else if fn_name == "@bmb_string_concat" or fn_name == "@bmb_chr" or fn_name == "@bmb_int_to_string" { "ptr" }
    else if fn_name == "@bmb_sb_build" or fn_name == "@bmb_read_file" or fn_name == "@bmb_getenv" or fn_name == "@get_arg" { "ptr" }
    // v0.60.226: Bool-returning functions (need call i1 + zext)
    else if is_bool_returning_fn(fn_name) { "i1" }
    // All other functions return i64
    else { "i64" };

// v0.60.226: Check if a function returns bool
fn is_bool_returning_fn(name: String) -> bool =
    name == "@is_whitespace" or name == "@is_digit" or name == "@is_alpha" or
    name == "@is_alnum_or_underscore" or name == "@is_ident_start" or name == "@is_error" or
    name == "@starts_with" or name == "@has_pattern" or name == "@is_int_literal" or
    name == "@low_is_whitespace" or name == "@low_is_ident_char" or name == "@low_is_op_char" or
    name == "@low_starts_with_at" or name == "@is_fn_node" or name == "@ends_with_colon" or
    name == "@matches_string_pattern" or name == "@is_string_var" or name == "@string_in_mapping" or
    name == "@is_string_var_fast" or name == "@has_prefix_or_contains_marker" or
    name == "@find_marker_limited" or name == "@is_string_returning_fn" or
    name == "@is_user_variable" or name == "@is_compile_error" or name == "@is_bool_returning_fn";

// v0.60.120: Map user-facing function names to runtime function names
// v0.60.235: Removed int_to_string -> bmb_int_to_string mapping
// The BMB program defines its own int_to_string, so calls should go there
fn map_runtime_fn(fn_name: String) -> String =
    if fn_name == "@main" { "@bmb_user_main" }
    else if fn_name == "@chr" { "@bmb_chr" }
    else if fn_name == "@ord" { "@bmb_ord" }
    else if fn_name == "@println" { "@println" }
    else if fn_name == "@print_str" { "@print_str" }
    else if fn_name == "@println_str" { "@println_str" }
    else if fn_name == "@read_file" { "@bmb_read_file" }
    else if fn_name == "@write_file" { "@bmb_write_file" }
    else if fn_name == "@write_file_newlines" { "@write_file_newlines" }
    else if fn_name == "@file_exists" { "@bmb_file_exists" }
    else if fn_name == "@sb_new" { "@bmb_sb_new" }
    else if fn_name == "@sb_push" { "@bmb_sb_push" }
    else if fn_name == "@sb_len" { "@bmb_sb_len" }
    else if fn_name == "@sb_build" { "@bmb_sb_build" }
    else if fn_name == "@sb_clear" { "@bmb_sb_clear" }
    else if fn_name == "@sb_contains" { "@bmb_sb_contains" }
    else if fn_name == "@arg_count" { "@arg_count" }
    else if fn_name == "@get_arg" { "@get_arg" }
    else if fn_name == "@getenv" { "@bmb_getenv" }
    else if fn_name == "@system" { "@bmb_system" }
    else if fn_name == "@system_capture" { "@bmb_system_capture" }
    else if fn_name == "@free_string" { "@bmb_string_free" }
    else if fn_name == "@sb_free" { "@bmb_sb_free" }
    else if fn_name == "@arena_mode" { "@bmb_arena_mode" }
    else if fn_name == "@arena_reset" { "@bmb_arena_reset" }
    else if fn_name == "@arena_save" { "@bmb_arena_save" }
    else if fn_name == "@arena_restore" { "@bmb_arena_restore" }
    else if fn_name == "@arena_usage" { "@bmb_arena_usage" }
    // v0.88.10: Concurrency runtime - Thread
    else if fn_name == "@thread_spawn" { "@bmb_thread_spawn" }
    else if fn_name == "@thread_join" { "@bmb_thread_join" }
    // v0.88.10: Concurrency runtime - Mutex
    else if fn_name == "@mutex_new" { "@bmb_mutex_new" }
    else if fn_name == "@mutex_lock" { "@bmb_mutex_lock" }
    else if fn_name == "@mutex_unlock" { "@bmb_mutex_unlock" }
    else if fn_name == "@mutex_try_lock" { "@bmb_mutex_try_lock" }
    else if fn_name == "@mutex_free" { "@bmb_mutex_free" }
    // v0.88.10: Concurrency runtime - Channel
    else if fn_name == "@channel_new" { "@bmb_channel_new" }
    else if fn_name == "@channel_send" { "@bmb_channel_send" }
    else if fn_name == "@channel_recv" { "@bmb_channel_recv" }
    else if fn_name == "@channel_try_send" { "@bmb_channel_try_send" }
    else if fn_name == "@channel_try_recv" { "@bmb_channel_try_recv" }
    else if fn_name == "@channel_recv_timeout" { "@bmb_channel_recv_timeout" }
    else if fn_name == "@channel_send_timeout" { "@bmb_channel_send_timeout" }
    else if fn_name == "@channel_close" { "@bmb_channel_close" }
    else if fn_name == "@channel_is_closed" { "@bmb_channel_is_closed" }
    else if fn_name == "@channel_recv_opt" { "@bmb_channel_recv_opt" }
    else if fn_name == "@sender_clone" { "@bmb_sender_clone" }
    // v0.88.10: Concurrency runtime - Arc
    else if fn_name == "@arc_new" { "@bmb_arc_new" }
    else if fn_name == "@arc_clone" { "@bmb_arc_clone" }
    else if fn_name == "@arc_get" { "@bmb_arc_get" }
    else if fn_name == "@arc_drop" { "@bmb_arc_drop" }
    else if fn_name == "@arc_strong_count" { "@bmb_arc_strong_count" }
    // v0.88.10: Concurrency runtime - RwLock
    else if fn_name == "@rwlock_new" { "@bmb_rwlock_new" }
    else if fn_name == "@rwlock_read" { "@bmb_rwlock_read" }
    else if fn_name == "@rwlock_read_unlock" { "@bmb_rwlock_read_unlock" }
    else if fn_name == "@rwlock_write" { "@bmb_rwlock_write" }
    else if fn_name == "@rwlock_write_unlock" { "@bmb_rwlock_write_unlock" }
    else if fn_name == "@rwlock_free" { "@bmb_rwlock_free" }
    // v0.88.10: Concurrency runtime - Barrier & Condvar
    else if fn_name == "@barrier_new" { "@bmb_barrier_new" }
    else if fn_name == "@barrier_wait" { "@bmb_barrier_wait" }
    else if fn_name == "@barrier_free" { "@bmb_barrier_free" }
    else if fn_name == "@condvar_new" { "@bmb_condvar_new" }
    else if fn_name == "@condvar_wait" { "@bmb_condvar_wait" }
    else if fn_name == "@condvar_notify_one" { "@bmb_condvar_notify_one" }
    else if fn_name == "@condvar_notify_all" { "@bmb_condvar_notify_all" }
    else if fn_name == "@condvar_free" { "@bmb_condvar_free" }
    // v0.88.10: Concurrency runtime - Async I/O
    else if fn_name == "@async_file_open" { "@bmb_async_file_open" }
    else if fn_name == "@async_file_read" { "@bmb_async_file_read" }
    else if fn_name == "@async_file_write" { "@bmb_async_file_write" }
    else if fn_name == "@async_file_close" { "@bmb_async_file_close" }
    else if fn_name == "@async_socket_connect" { "@bmb_async_socket_connect" }
    else if fn_name == "@async_socket_read" { "@bmb_async_socket_read" }
    else if fn_name == "@async_socket_write" { "@bmb_async_socket_write" }
    else if fn_name == "@async_socket_close" { "@bmb_async_socket_close" }
    // v0.88.10: Concurrency runtime - ThreadPool, Scope, BlockOn
    else if fn_name == "@thread_pool_new" { "@bmb_thread_pool_new" }
    else if fn_name == "@thread_pool_execute" { "@bmb_thread_pool_execute" }
    else if fn_name == "@thread_pool_join" { "@bmb_thread_pool_join" }
    else if fn_name == "@thread_pool_shutdown" { "@bmb_thread_pool_shutdown" }
    else if fn_name == "@scope_new" { "@bmb_scope_new" }
    else if fn_name == "@scope_spawn" { "@bmb_scope_spawn" }
    else if fn_name == "@scope_wait" { "@bmb_scope_wait" }
    else if fn_name == "@block_on" { "@bmb_block_on" }
    else { fn_name };

// v0.32.1: Rename @main calls to @bmb_user_main for runtime compatibility
// v0.46: Handle different return types (i64, ptr, void)
// v0.60.119: Add type conversions for ptr-returning functions and ptr arguments
fn llvm_gen_call(line: String, pos: i64, dest: String) -> String =
    let at_pos = find_char(line, pos, 64);
    let paren_pos = find_char(line, at_pos, 40);
    let close_pos = find_char(line, paren_pos, 41);
    let fn_name = line.slice(at_pos, paren_pos);
    let emitted_fn = map_runtime_fn(fn_name);
    let args = line.slice(paren_pos + 1, close_pos);
    let arg_types = get_call_arg_types(emitted_fn);
    let formatted = format_call_args_typed(args, arg_types, 0, 0, "", "");
    let conversions = call_arg_conversions(formatted);
    let formatted_args = call_arg_formatted(formatted);
    let ret_type = get_call_return_type(emitted_fn);
    if ret_type == "void" {
        conversions + "  call void " + emitted_fn + "(" + formatted_args + ")"
    } else if ret_type == "ptr" {
        // ptr-returning functions need ptrtoint conversion to i64
        conversions + "  " + dest + "_ptr = call ptr " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = ptrtoint ptr " + dest + "_ptr to i64"
    } else if ret_type == "i1" {
        // v0.60.226: i1-returning functions (bool) need zext to i64
        conversions + "  " + dest + "_bool = call i1 " + emitted_fn + "(" + formatted_args + ")|  " + dest + " = zext i1 " + dest + "_bool to i64"
    } else {
        conversions + "  " + dest + " = call " + ret_type + " " + emitted_fn + "(" + formatted_args + ")"
    };

// v0.60.119: Get argument type signature for a function (p=ptr, i=i64)
fn get_call_arg_types(fn_name: String) -> String =
    // String functions with ptr first arg
    if fn_name == "@bmb_string_slice" { "pii" }
    else if fn_name == "@bmb_string_concat" { "pp" }
    else if fn_name == "@bmb_string_new" { "pi" }
    else if fn_name == "@bmb_string_from_cstr" { "p" }
    else if fn_name == "@bmb_string_eq" { "pp" }
    else if fn_name == "@bmb_string_len" { "p" }
    else if fn_name == "@bmb_string_char_at" { "pi" }
    else if fn_name == "@bmb_read_file" { "p" }
    else if fn_name == "@bmb_write_file" { "pp" }
    else if fn_name == "@write_file_newlines" { "pp" }
    else if fn_name == "@bmb_append_file" { "pp" }
    else if fn_name == "@bmb_file_exists" { "p" }
    else if fn_name == "@bmb_file_size" { "p" }
    else if fn_name == "@bmb_getenv" { "p" }
    else if fn_name == "@bmb_system" { "p" }
    else if fn_name == "@bmb_system_capture" { "p" }
    else if fn_name == "@bmb_string_free" { "p" }
    else if fn_name == "@bmb_sb_free" { "i" }
    else if fn_name == "@bmb_arena_mode" { "i" }
    else if fn_name == "@bmb_sb_push" { "ip" }
    else if fn_name == "@print_str" { "p" }
    else if fn_name == "@println_str" { "p" }
    else if fn_name == "@bmb_panic" { "p" }
    // Default: all i64
    else { "" };

// v0.60.119: Format args with type conversions
// Returns pair: (conversions_string, formatted_args_string)
// Uses separator "###" to split conversions from args
fn format_call_args_typed(args: String, types: String, pos: i64, idx: i64, conv_acc: String, arg_acc: String) -> String =
    let p = low_skip_ws(args, pos);
    if p >= args.len() { conv_acc + "###" + arg_acc } else {
        let comma = find_comma_or_end(args, p);
        let arg = trim_end(args.slice(p, comma));
        let typ = if idx < types.len() { types.byte_at(idx) } else { 105 };
        let pair = if typ == 112 {
            // 'p' = ptr: need inttoptr conversion
            let ptr_name = arg + "_p" + int_to_string(idx);
            let conv = "  " + ptr_name + " = inttoptr i64 " + arg + " to ptr|";
            let typed_arg = "ptr " + ptr_name;
            pack_conv_arg(conv, typed_arg)
        } else {
            // 'i' or default = i64: no conversion needed
            pack_conv_arg("", "i64 " + arg)
        };
        let new_conv = conv_acc + unpack_conv(pair);
        let typed_arg = unpack_arg(pair);
        let new_arg = if arg_acc == "" { typed_arg } else { arg_acc + ", " + typed_arg };
        if comma >= args.len() { new_conv + "###" + new_arg } else { format_call_args_typed(args, types, comma + 1, idx + 1, new_conv, new_arg) }
    };

// Helper to pack conversion and arg into a pair string
fn pack_conv_arg(conv: String, arg: String) -> String = conv + "###" + arg;

// Helper to unpack conversion from pair
fn unpack_conv(pair: String) -> String =
    let sep = find_separator(pair, 0);
    pair.slice(0, sep);

// Helper to unpack arg from pair
fn unpack_arg(pair: String) -> String =
    let sep = find_separator(pair, 0);
    pair.slice(sep + 3, pair.len());

// Find "###" separator
fn find_separator(s: String, pos: i64) -> i64 =
    if pos + 2 >= s.len() { s.len() }
    else if s.byte_at(pos) == 35 and s.byte_at(pos + 1) == 35 and s.byte_at(pos + 2) == 35 { pos }
    else { find_separator(s, pos + 1) };

// v0.60.119: Extract conversions part from "conversions###args"
fn call_arg_conversions(formatted: String) -> String =
    let sep = find_separator(formatted, 0);
    formatted.slice(0, sep);

// v0.60.119: Extract args part from "conversions###args"
fn call_arg_formatted(formatted: String) -> String =
    let sep = find_separator(formatted, 0);
    formatted.slice(sep + 3, formatted.len());

fn format_call_args(args: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(args, pos);
    if p >= args.len() { acc } else {
        let comma = find_comma_or_end(args, p);
        let arg = trim_end(args.slice(p, comma));
        let typed_arg = "i64 " + arg;
        let new_acc = if acc == "" { typed_arg } else { acc + ", " + typed_arg };
        if comma >= args.len() { new_acc } else { format_call_args(args, comma + 1, new_acc) }
    };

fn find_comma(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { pos } else { find_comma(s, pos + 1) };

fn find_comma_or_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { pos } else { find_comma_or_end(s, pos + 1) };

fn find_char(s: String, pos: i64, ch: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == ch { pos } else { find_char(s, pos + 1, ch) };

fn trim_end(s: String) -> String =
    trim_end_at(s, s.len() - 1);

fn trim_end_at(s: String, pos: i64) -> String =
    if pos < 0 { "" } else if low_is_whitespace(s.byte_at(pos)) { trim_end_at(s, pos - 1) } else { s.slice(0, pos + 1) };

// v0.46: Trim both leading and trailing whitespace
fn trim(s: String) -> String =
    let start = low_skip_ws(s, 0);
    if start >= s.len() { "" } else { trim_end(s.slice(start, s.len())) };

fn llvm_gen_return(line: String, pos: i64) -> String =
    let val_start = low_skip_ws(line, pos + 6);
    let val = line.slice(val_start, line.len());
    "  ret i64 " + trim_end(val);

// v0.46: Return with proper type for String functions
// v0.60.118: Add inttoptr conversion for String returns (values are i64 internally)
// v0.60.225: Simplified - String returns i64 directly (no ptr conversion)
fn llvm_gen_return_typed(line: String, pos: i64, ret_type: String) -> String =
    let val_start = low_skip_ws(line, pos + 6);
    let val = trim_end(line.slice(val_start, line.len()));
    if ret_type == "bool" {
        "  " + val + "_ret = trunc i64 " + val + " to i1|  ret i1 " + val + "_ret"
    } else {
        "  ret i64 " + val
    };

// v0.60.118: Add trunc to convert i64 condition to i1 for branch
fn llvm_gen_branch(line: String, pos: i64) -> String =
    let after = low_skip_ws(line, pos + 6);
    let comma1 = find_comma(line, after);
    let cond = trim_end(line.slice(after, comma1));
    let after1 = low_skip_ws(line, comma1 + 1);
    let comma2 = find_comma(line, after1);
    let then_label = line.slice(after1, comma2);
    let after2 = low_skip_ws(line, comma2 + 1);
    let else_label = trim_end(line.slice(after2, line.len()));
    "  " + cond + "_i1 = trunc i64 " + cond + " to i1|  br i1 " + cond + "_i1, label %" + trim_end(then_label) + ", label %" + else_label;

fn llvm_gen_goto(line: String, pos: i64) -> String =
    let label_start = low_skip_ws(line, pos + 4);
    let label = line.slice(label_start, line.len());
    "  br label %" + trim_end(label);

// v0.46: Updated to pass return type for proper LLVM IR generation
fn gen_function(mir: String) -> String =
    let ret_type = extract_mir_return_type(mir);
    gen_function_lines_typed(mir, 0, "", ret_type);

fn gen_function_lines(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line(line);
        let new_acc = if acc == "" { llvm_line } else { acc + "|" + llvm_line };
        if pipe_pos >= mir.len() { new_acc } else { gen_function_lines(mir, pipe_pos + 1, new_acc) }
    };

// v0.46: Type-aware function line generation
fn gen_function_lines_typed(mir: String, pos: i64, acc: String, ret_type: String) -> String =
    if pos >= mir.len() { acc } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line_typed(line, ret_type);
        let new_acc = if acc == "" { llvm_line } else { acc + "|" + llvm_line };
        if pipe_pos >= mir.len() { new_acc } else { gen_function_lines_typed(mir, pipe_pos + 1, new_acc, ret_type) }
    };

// ============================================================================
// SECTION 11B: StringBuilder-aware LLVM Generation (v0.31.20)
// ============================================================================
// O(1) amortized string concatenation for LLVM IR generation

// v0.46: Updated to pass return type for proper LLVM IR generation
fn gen_function_sb(mir: String) -> String =
    let sb = sb_new();
    let ret_type = extract_mir_return_type(mir);
    let w1 = gen_function_lines_sb_typed(mir, 0, sb, ret_type);
    sb_build(sb);

fn gen_function_lines_sb(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line(line);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, llvm_line);
        if pipe_pos >= mir.len() { 0 } else { gen_function_lines_sb(mir, pipe_pos + 1, sb) }
    };

// v0.46: Type-aware StringBuilder function line generation
fn gen_function_lines_sb_typed(mir: String, pos: i64, sb: i64, ret_type: String) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line_typed(line, ret_type);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, llvm_line);
        if pipe_pos >= mir.len() { 0 } else { gen_function_lines_sb_typed(mir, pipe_pos + 1, sb, ret_type) }
    };

fn gen_program_sb(mir: String) -> String =
    let sb = sb_new();
    let w1 = gen_program_acc_sb(mir, 0, sb);
    sb_build(sb);

fn gen_program_acc_sb(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function_sb(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_llvm);
        if fn_end + 2 >= mir.len() { 0 } else { gen_program_acc_sb(mir, fn_end + 2, sb) }
    };

fn llvm_gen_fn_line(line: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" } else if low_starts_with_at(line, p, "fn ") { llvm_gen_fn_header(line, p) } else if ends_with_colon(line) { line } else if line == "}" { "}" } else { llvm_gen_line(line) };

// v0.46: Type-aware line generation for proper return types
fn llvm_gen_fn_line_typed(line: String, ret_type: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" }
    else if low_starts_with_at(line, p, "fn ") { llvm_gen_fn_header(line, p) }
    else if ends_with_colon(line) { line }
    else if line == "}" { "}" }
    else { llvm_gen_line_with_ret(line, ret_type) };

// v0.31.19: Added nounwind attribute for non-main functions
// v0.32.1: Rename main to bmb_user_main for runtime compatibility
fn llvm_gen_fn_header(line: String, pos: i64) -> String =
    let name_start = pos + 3;
    let paren_pos = find_char(line, name_start, 40);
    let fn_name = line.slice(name_start, paren_pos);
    let close_pos = find_char(line, paren_pos, 41);
    let params = line.slice(paren_pos + 1, close_pos);
    let formatted_params = format_fn_params(params, 0, "");
    let arrow_pos = find_arrow(line, close_pos);
    let brace_pos = find_char(line, arrow_pos, 123);
    // v0.46: Use trim to handle leading/trailing whitespace in return type
    let ret_type = trim(line.slice(arrow_pos + 2, brace_pos));
    // v0.60.225: Use i64 for all return types except bool (consistency with internal representation)
    let llvm_ret = if ret_type == "bool" { "i1" } else { "i64" };
    let emitted_name = if fn_name == "main" { "bmb_user_main" } else { fn_name };
    let attrs = if fn_name == "main" { "" } else { " nounwind" };
    "define " + llvm_ret + " @" + emitted_name + "(" + formatted_params + ")" + attrs + " {";

// v0.46: Added String parameter type support
fn format_fn_params(params: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { acc } else {
        let comma = find_comma_or_end(params, p);
        let param = trim_end(params.slice(p, comma));
        let colon_pos = find_char(param, 0, 58);
        let name = param.slice(0, colon_pos);
        let param_type = trim_end(param.slice(colon_pos + 1, param.len()));
        // v0.60.225: Use i64 for String params (consistency with internal representation)
        let llvm_type = if param_type == "bool" { "i1" } else { "i64" };
        let typed_param = llvm_type + " %" + name;
        let new_acc = if acc == "" { typed_param } else { acc + ", " + typed_param };
        if comma >= params.len() { new_acc } else { format_fn_params(params, comma + 1, new_acc) }
    };

fn find_arrow(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { pos } else if s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 62 { pos } else { find_arrow(s, pos + 1) };

fn ends_with_colon(s: String) -> bool =
    if s.len() == 0 { false } else {
        let last = trim_end(s);
        if last.len() == 0 { false } else { last.byte_at(last.len() - 1) == 58 }
    };

// v0.60.124: Skip quoted strings to avoid treating "||" inside strings as function separator
fn find_double_pipe(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { s.len() }
    else if s.byte_at(pos) == 124 and s.byte_at(pos + 1) == 124 { pos }
    else if s.byte_at(pos) == 34 { find_double_pipe(s, skip_quoted_string(s, pos + 1)) }
    else { find_double_pipe(s, pos + 1) };

fn gen_program(mir: String) -> String =
    gen_program_acc(mir, 0, "");

fn gen_program_acc(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function(fn_mir);
        let new_acc = if acc == "" { fn_llvm } else { acc + "||" + fn_llvm };
        if fn_end + 2 >= mir.len() { new_acc } else { gen_program_acc(mir, fn_end + 2, new_acc) }
    };

// ============================================================================
// SECTION 12: Module Generation
// ============================================================================

fn gen_module_header() -> String =
    // v0.60.224: Removed target triple - let LLVM use host default
    "; ModuleID = bmb_bootstrap";

// v0.46: Complete runtime declarations for 3-stage bootstrap
// Basic I/O
fn gen_extern_println() -> String = "declare void @println(i64)";
fn gen_extern_print_str() -> String = "declare void @print_str(ptr)";
fn gen_extern_println_str() -> String = "declare void @println_str(ptr)";

// Math functions
fn gen_extern_abs() -> String = "declare i64 @bmb_abs(i64)";
fn gen_extern_min() -> String = "declare i64 @min(i64, i64)";
fn gen_extern_max() -> String = "declare i64 @max(i64, i64)";

// String operations
fn gen_extern_string_new() -> String = "declare ptr @bmb_string_new(ptr, i64)";
fn gen_extern_string_from_cstr() -> String = "declare ptr @bmb_string_from_cstr(ptr)";
fn gen_extern_string_len() -> String = "declare i64 @bmb_string_len(ptr)";
fn gen_extern_string_char_at() -> String = "declare i64 @bmb_string_char_at(ptr, i64)";
fn gen_extern_string_slice() -> String = "declare ptr @bmb_string_slice(ptr, i64, i64)";
fn gen_extern_string_concat() -> String = "declare ptr @bmb_string_concat(ptr, ptr)";
fn gen_extern_string_eq() -> String = "declare i64 @bmb_string_eq(ptr, ptr)";
fn gen_extern_chr() -> String = "declare ptr @bmb_chr(i64)";
fn gen_extern_ord() -> String = "declare i64 @bmb_ord(ptr)";
fn gen_extern_int_to_string() -> String = "declare ptr @bmb_int_to_string(i64)";
// v0.60.244: Fast i2s that returns BmbString* (matches String type)
fn gen_extern_fast_i2s() -> String = "declare ptr @bmb_fast_i2s(i64)";

// File I/O
fn gen_extern_file_exists() -> String = "declare i64 @bmb_file_exists(ptr)";
fn gen_extern_file_size() -> String = "declare i64 @bmb_file_size(ptr)";
fn gen_extern_read_file() -> String = "declare ptr @bmb_read_file(ptr)";
fn gen_extern_write_file() -> String = "declare i64 @bmb_write_file(ptr, ptr)";
fn gen_extern_append_file() -> String = "declare i64 @bmb_append_file(ptr, ptr)";
// v0.60.134: write_file_newlines converts | to newlines during write
fn gen_extern_write_file_newlines() -> String = "declare i64 @write_file_newlines(ptr, ptr)";

// StringBuilder
fn gen_extern_sb_new() -> String = "declare i64 @bmb_sb_new()";
fn gen_extern_sb_push() -> String = "declare i64 @bmb_sb_push(i64, ptr)";
fn gen_extern_sb_push_int() -> String = "declare i64 @bmb_sb_push_int(i64, i64)";
fn gen_extern_sb_push_char() -> String = "declare i64 @bmb_sb_push_char(i64, i64)";
fn gen_extern_sb_len() -> String = "declare i64 @bmb_sb_len(i64)";
fn gen_extern_sb_build() -> String = "declare ptr @bmb_sb_build(i64)";
fn gen_extern_sb_clear() -> String = "declare i64 @bmb_sb_clear(i64)";
fn gen_extern_sb_contains() -> String = "declare i64 @bmb_sb_contains(i64, ptr)";

// Process/System
fn gen_extern_system() -> String = "declare i64 @bmb_system(ptr)";
fn gen_extern_getenv() -> String = "declare ptr @bmb_getenv(ptr)";
// v0.88.2: system_capture, free_string, arena management
fn gen_extern_system_capture() -> String = "declare ptr @bmb_system_capture(ptr)";
fn gen_extern_free_string() -> String = "declare i64 @bmb_string_free(ptr)";
fn gen_extern_sb_free() -> String = "declare i64 @bmb_sb_free(i64)";
fn gen_extern_arena_mode() -> String = "declare i64 @bmb_arena_mode(i64)";
fn gen_extern_arena_reset() -> String = "declare i64 @bmb_arena_reset()";
fn gen_extern_arena_save() -> String = "declare i64 @bmb_arena_save()";
fn gen_extern_arena_restore() -> String = "declare i64 @bmb_arena_restore()";
fn gen_extern_arena_usage() -> String = "declare i64 @bmb_arena_usage()";

// CLI arguments
fn gen_extern_arg_count() -> String = "declare i64 @arg_count()";
fn gen_extern_get_arg() -> String = "declare ptr @get_arg(i64)";

// Panic/Error handling
fn gen_extern_panic() -> String = "declare void @bmb_panic(ptr)";

// v0.60.238: Split to avoid deep concat nesting
fn gen_runtime_decls() -> String =
    let io = gen_runtime_decls_io();
    let str = gen_runtime_decls_string();
    let file = gen_runtime_decls_file();
    let rest = gen_runtime_decls_rest();
    io + str + file + rest;

fn gen_runtime_decls_io() -> String =
    gen_extern_println() + "|" + gen_extern_print_str() + "|" + gen_extern_println_str() + "|" +
    gen_extern_abs() + "|" + gen_extern_min() + "|" + gen_extern_max() + "|";

fn gen_runtime_decls_string() -> String =
    gen_extern_string_new() + "|" + gen_extern_string_from_cstr() + "|" +
    gen_extern_string_len() + "|" + gen_extern_string_char_at() + "|" +
    gen_extern_string_slice() + "|" + gen_extern_string_concat() + "|" +
    gen_extern_string_eq() + "|" + gen_extern_chr() + "|" + gen_extern_ord() + "|" +
    gen_extern_int_to_string() + "|" + gen_extern_fast_i2s() + "|";

fn gen_runtime_decls_file() -> String =
    gen_extern_file_exists() + "|" + gen_extern_file_size() + "|" +
    gen_extern_read_file() + "|" + gen_extern_write_file() + "|" + gen_extern_append_file() + "|" +
    gen_extern_write_file_newlines() + "|";

// v0.60.244: Added sb_push_int and sb_push_char for faster int-to-string conversion
fn gen_runtime_decls_rest() -> String =
    gen_extern_sb_new() + "|" + gen_extern_sb_push() + "|" +
    gen_extern_sb_push_int() + "|" + gen_extern_sb_push_char() + "|" +
    gen_extern_sb_len() + "|" +
    gen_extern_sb_build() + "|" + gen_extern_sb_clear() + "|" + gen_extern_sb_contains() + "|" +
    gen_extern_system() + "|" + gen_extern_getenv() + "|" +
    gen_extern_system_capture() + "|" + gen_extern_free_string() + "|" +
    gen_extern_sb_free() + "|" +
    gen_extern_arena_mode() + "|" + gen_extern_arena_reset() + "|" +
    gen_extern_arena_save() + "|" + gen_extern_arena_restore() + "|" +
    gen_extern_arena_usage() + "|" +
    gen_extern_arg_count() + "|" + gen_extern_get_arg() + "|" +
    gen_extern_panic();

// ============================================================================
// SECTION 12b: String Literal Handling (v0.60.109)
// ============================================================================

// Collect all string literals from MIR, returns tab-separated list
// v0.60.242: Optimized to avoid O(N²) sb_build calls during collection
// Now passes current list as parameter instead of rebuilding every iteration
fn collect_strings_from_mir(mir: String) -> String =
    collect_strings_acc_v2(mir, 0, "");

// v0.60.242: Rewritten to avoid sb_build on every iteration
// Uses String accumulator directly, trading some allocation for avoiding
// the O(N) sb_build call that was happening on every string found
fn collect_strings_acc_v2(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else {
        let next = find_string_in_mir(mir, pos);
        if next < 0 { acc } else {
            let str_start = next + 8;
            let str_end = find_quote_in_mir(mir, str_start);
            let str_content = mir.slice(str_start, str_end);
            let is_dup = string_in_list(acc, str_content);
            let new_acc = if is_dup == 0 {
                if acc == "" { str_content } else { acc + chr(9) + str_content }
            } else { acc };
            collect_strings_acc_v2(mir, str_end + 1, new_acc)
        }
    };

// Find "string " pattern in MIR (returns position or -1)
fn find_string_in_mir(mir: String, pos: i64) -> i64 =
    if pos + 8 > mir.len() { 0 - 1 }
    else if matches_string_pattern(mir, pos) { pos }
    else { find_string_in_mir(mir, pos + 1) };

fn matches_string_pattern(s: String, pos: i64) -> bool =
    s.byte_at(pos) == 115 and s.byte_at(pos + 1) == 116 and
    s.byte_at(pos + 2) == 114 and s.byte_at(pos + 3) == 105 and
    s.byte_at(pos + 4) == 110 and s.byte_at(pos + 5) == 103 and
    s.byte_at(pos + 6) == 32 and s.byte_at(pos + 7) == 34;

fn find_quote_in_mir(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 34 { pos }
    else { find_quote_in_mir(s, pos + 1) };

fn string_in_list(list: String, target: String) -> i64 =
    if list == "" { 0 } else { string_in_list_scan(list, target, 0) };

fn string_in_list_scan(list: String, target: String, pos: i64) -> i64 =
    if pos >= list.len() { 0 } else {
        let pipe = find_tab_in_list(list, pos);
        let end = if pipe >= list.len() { list.len() } else { pipe };
        let item = list.slice(pos, end);
        if item == target { 1 }
        else if pipe >= list.len() { 0 }
        else { string_in_list_scan(list, target, pipe + 1) }
    };

// v0.60.123: Renamed to find_tab_in_list, uses tab (byte 9) as separator
fn find_tab_in_list(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 9 { pos }
    else { find_tab_in_list(s, pos + 1) };

// Find index of string in list
fn find_string_index(list: String, target: String) -> i64 =
    find_string_index_scan(list, target, 0, 0);

fn find_string_index_scan(list: String, target: String, pos: i64, idx: i64) -> i64 =
    if pos >= list.len() { 0 } else {
        let pipe = find_tab_in_list(list, pos);
        let end = if pipe >= list.len() { list.len() } else { pipe };
        let item = list.slice(pos, end);
        if item == target { idx }
        else if pipe >= list.len() { 0 }
        else { find_string_index_scan(list, target, pipe + 1, idx + 1) }
    };

// v0.60.233: Collect all functions that return String from MIR
// Returns comma-separated list of function names
fn collect_string_fns_from_mir(mir: String) -> String =
    collect_string_fns_acc(mir, 0, "");

fn collect_string_fns_acc(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc }
    else {
        // Find next function definition
        let fn_start = find_fn_start(mir, pos);
        if fn_start < 0 { acc }
        else {
            let fn_name = extract_fn_name_from_mir(mir, fn_start);
            let ret_type = extract_fn_ret_type_from_mir(mir, fn_start);
            let new_acc = if ret_type == "String" {
                if acc == "" { fn_name } else { acc + "," + fn_name }
            } else { acc };
            // Find end of this function and continue
            let fn_end = find_fn_end(mir, fn_start);
            if fn_end < 0 { new_acc } else { collect_string_fns_acc(mir, fn_end, new_acc) }
        }
    };

// Find "fn " at or after pos
fn find_fn_start(mir: String, pos: i64) -> i64 =
    if pos + 3 > mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 102 and mir.byte_at(pos + 1) == 110 and mir.byte_at(pos + 2) == 32 { pos }
    else { find_fn_start(mir, pos + 1) };

// Extract function name after "fn "
fn extract_fn_name_from_mir(mir: String, fn_start: i64) -> String =
    let name_start = fn_start + 3;
    let paren = find_char(mir, name_start, 40);
    if paren < name_start { "" } else { mir.slice(name_start, paren) };

// Extract return type after "-> "
fn extract_fn_ret_type_from_mir(mir: String, fn_start: i64) -> String =
    let arrow = find_arrow_in_mir(mir, fn_start);
    if arrow < 0 { "i64" }
    else {
        let type_start = arrow + 3;
        let brace = find_char(mir, type_start, 123);
        if brace < type_start { "i64" } else { trim(mir.slice(type_start, brace)) }
    };

// Find "-> " after fn_start
fn find_arrow_in_mir(mir: String, pos: i64) -> i64 =
    if pos + 3 > mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 45 and mir.byte_at(pos + 1) == 62 and mir.byte_at(pos + 2) == 32 { pos }
    else if mir.byte_at(pos) == 123 { 0 - 1 }  // Hit '{' before finding arrow
    else { find_arrow_in_mir(mir, pos + 1) };

// Find end of function (||)
fn find_fn_end(mir: String, pos: i64) -> i64 =
    if pos + 1 >= mir.len() { 0 - 1 }
    else if mir.byte_at(pos) == 124 and mir.byte_at(pos + 1) == 124 { pos + 2 }
    else { find_fn_end(mir, pos + 1) };

// Check if function name is in dynamic string functions list
fn is_dynamic_string_fn(fn_name: String, string_fns: String) -> bool =
    if string_fns == "" { false }
    else { check_fn_in_list(fn_name, string_fns, 0) };

fn check_fn_in_list(fn_name: String, list: String, pos: i64) -> bool =
    if pos >= list.len() { false }
    else {
        let comma = find_comma_or_end(list, pos);
        let item = list.slice(pos, comma);
        if item == fn_name { true }
        else if comma >= list.len() { false }
        else { check_fn_in_list(fn_name, list, comma + 1) }
    };

// Generate global string constants
fn gen_string_globals(strings: String) -> String =
    if strings == "" { "" } else {
        let sb = sb_new();
        let w1 = gen_string_globals_acc(strings, 0, 0, sb);
        sb_build(sb)
    };

// v0.60.124: Escape pipe character in LLVM IR string constants to avoid
// confusion with the output line separator. Use \7C for | (byte 124).
fn escape_llvm_string(s: String) -> String =
    escape_llvm_string_acc(s, 0, "");

fn escape_llvm_string_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc }
    else {
        let ch = s.byte_at(pos);
        let escaped = if ch == 124 { chr(92) + "7C" }
                      else if ch == 92 { chr(92) + "5C" }
                      else if ch == 34 { chr(92) + "22" }
                      else { chr(ch) };
        escape_llvm_string_acc(s, pos + 1, acc + escaped)
    };

fn gen_string_globals_acc(strings: String, pos: i64, idx: i64, sb: i64) -> i64 =
    if pos >= strings.len() { 0 } else {
        let pipe = find_tab_in_list(strings, pos);
        let end = if pipe >= strings.len() { strings.len() } else { pipe };
        let str_content = strings.slice(pos, end);
        let escaped_content = escape_llvm_string(str_content);
        let str_len = str_content.len() + 1;
        let global = "@str_data_" + int_to_string(idx) + " = private unnamed_addr constant [" +
            int_to_string(str_len) + " x i8] c" + chr(34) + escaped_content + chr(92) + "00" + chr(34);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, global);
        if pipe >= strings.len() { 0 } else { gen_string_globals_acc(strings, pipe + 1, idx + 1, sb) }
    };

// Generate program with string table
fn gen_program_sb_with_strings(mir: String, strings: String) -> String =
    gen_program_sb_with_strings_and_fns(mir, strings, "");

// v0.60.233: Generate program with string table and dynamic string functions
fn gen_program_sb_with_strings_and_fns(mir: String, strings: String, string_fns: String) -> String =
    let sb = sb_new();
    let w1 = gen_program_acc_sb_with_strings_and_fns(mir, 0, strings, string_fns, sb);
    sb_build(sb);

fn gen_program_acc_sb_with_strings(mir: String, pos: i64, strings: String, sb: i64) -> i64 =
    gen_program_acc_sb_with_strings_and_fns(mir, pos, strings, "", sb);

// v0.88.6: arena_save/arena_restore per function to free intermediates
fn gen_program_acc_sb_with_strings_and_fns(mir: String, pos: i64, strings: String, string_fns: String, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let fn_end = find_double_pipe(mir, pos);
        let _save = bmb_arena_save();
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function_sb_with_strings_and_fns(fn_mir, strings, string_fns);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_llvm);
        let _restore = bmb_arena_restore();
        if fn_end + 2 >= mir.len() { 0 } else { gen_program_acc_sb_with_strings_and_fns(mir, fn_end + 2, strings, string_fns, sb) }
    };

// v0.60.121: Copy elimination to fix SSA conflicts with user variables
// Mapping format: "name1:src1,name2:src2,..." where name is user var and src is the temp it copies from
// v0.60.202: Also includes "S:varname" for string type tracking
fn gen_function_sb_with_strings(mir: String, strings: String) -> String =
    gen_function_sb_with_strings_and_fns(mir, strings, "");

// v0.60.233: Generate function with string table and dynamic string functions
// v0.88.6: Separated string markers into SB for O(1) append, zero-arena lookup
fn gen_function_sb_with_strings_and_fns(mir: String, strings: String, string_fns: String) -> String =
    let sb = sb_new();
    let str_sb = sb_new();
    let ret_type = extract_mir_return_type(mir);
    // Extract string parameters to initialize the string marker SB
    let w0 = init_string_params_sb(mir, str_sb);
    let w1 = gen_function_lines_sb_with_strings_map_and_fns(mir, 0, sb, ret_type, strings, string_fns, "", str_sb);
    let result = sb_build(sb);
    let _f1 = sb_free(sb);
    let _f2 = sb_free(str_sb);
    result;

// v0.88.6: Push string parameter markers to SB
fn init_string_params_sb(mir: String, str_sb: i64) -> i64 =
    let fn_start = find_pattern_at(mir, "fn ", 0);
    if fn_start < 0 { 0 } else {
        let paren_start = find_char(mir, fn_start, 40);
        let paren_end = find_char(mir, paren_start, 41);
        if paren_start < 0 or paren_end < 0 { 0 }
        else {
            let params = mir.slice(paren_start + 1, paren_end);
            collect_string_params_sb(params, 0, str_sb)
        }
    };

// Collect string parameters and push "S:%name," markers to SB
fn collect_string_params_sb(params: String, pos: i64, str_sb: i64) -> i64 =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { 0 }
    else {
        let comma_pos = find_comma_or_end(params, p);
        let param = params.slice(p, comma_pos);
        let colon_pos = find_char(param, 0, 58);
        if colon_pos < param.len() {
            let param_name = trim(param.slice(0, colon_pos));
            let param_type = trim(param.slice(colon_pos + 1, param.len()));
            let w = if param_type == "String" {
                let w1 = sb_push(str_sb, "S:%");
                let w2 = sb_push(str_sb, param_name);
                sb_push(str_sb, ",")
            } else { 0 };
            if comma_pos >= params.len() { 0 }
            else { collect_string_params_sb(params, comma_pos + 1, str_sb) }
        } else {
            if comma_pos >= params.len() { 0 }
            else { collect_string_params_sb(params, comma_pos + 1, str_sb) }
        }
    };

// v0.60.202: Iterative pattern finding to avoid stack overflow on large strings
fn find_pattern_at(s: String, pat: String, pos: i64) -> i64 =
    // Check from start - MIR functions always start with "fn "
    if pos == 0 and pat.len() <= s.len() and s.slice(0, pat.len()) == pat { 0 }
    // If not at start, do linear search (shouldn't happen often for "fn ")
    else { find_pattern_at_slow(s, pat, pos) };

fn find_pattern_at_slow(s: String, pat: String, pos: i64) -> i64 =
    if pos + pat.len() > s.len() { 0 - 1 }
    else if s.slice(pos, pos + pat.len()) == pat { pos }
    else { find_pattern_at_slow(s, pat, pos + 1) };

fn gen_function_lines_sb_with_strings_map(mir: String, pos: i64, sb: i64, ret_type: String, strings: String, mapping: String) -> i64 =
    let str_sb = sb_new();
    gen_function_lines_sb_with_strings_map_and_fns(mir, pos, sb, ret_type, strings, "", mapping, str_sb);

// v0.88.6: Added str_sb parameter for string marker tracking
fn gen_function_lines_sb_with_strings_map_and_fns(mir: String, pos: i64, sb: i64, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else {
        let pipe_pos = find_pipe_skip_quotes(mir, pos);
        let line = mir.slice(pos, pipe_pos);
        let result = llvm_gen_fn_line_with_strings_map_and_fns(line, ret_type, strings, string_fns, mapping, str_sb);
        let is_changed = result.len() > 0 and result.byte_at(0) == 33;
        let new_mapping = if is_changed { extract_new_mapping(result) } else { mapping };
        let llvm_line = if is_changed { extract_new_llvm_line(result) } else { result };
        let len = sb_len(sb);
        let w1 = if len > 0 and llvm_line != "" { sb_push(sb, "|") } else { 0 };
        let w2 = if llvm_line != "" { sb_push(sb, llvm_line) } else { 0 };
        if pipe_pos >= mir.len() { 0 } else { gen_function_lines_sb_with_strings_map_and_fns(mir, pipe_pos + 1, sb, ret_type, strings, string_fns, new_mapping, str_sb) }
    };

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_fn_line_with_strings_map(line: String, ret_type: String, strings: String, mapping: String) -> String =
    let str_sb = sb_new();
    llvm_gen_fn_line_with_strings_map_and_fns(line, ret_type, strings, "", mapping, str_sb);

// v0.88.6: Added str_sb parameter
fn llvm_gen_fn_line_with_strings_map_and_fns(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if low_starts_with_at(line, p, "fn ") { same_mapping(llvm_gen_fn_header(line, p)) }
    else if ends_with_colon(line) { same_mapping(line) }
    else if line == "}" { same_mapping("}") }
    else { llvm_gen_line_with_strings_map_and_fns(line, ret_type, strings, string_fns, mapping, str_sb) };

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_line_with_strings_map(line: String, ret_type: String, strings: String, mapping: String) -> String =
    let str_sb = sb_new();
    llvm_gen_line_with_strings_map_and_fns(line, ret_type, strings, "", mapping, str_sb);

// v0.88.6: Added str_sb parameter
fn llvm_gen_line_with_strings_map_and_fns(line: String, ret_type: String, strings: String, string_fns: String, mapping: String, str_sb: i64) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { same_mapping_empty() }
    else if line.byte_at(p) == 37 { llvm_gen_assign_with_strings_map_and_fns(line, p, strings, string_fns, mapping, str_sb) }
    else if low_starts_with_at(line, p, "return") { same_mapping(llvm_gen_return_typed(line, p, ret_type)) }
    else if low_starts_with_at(line, p, "branch") { same_mapping(llvm_gen_branch(line, p)) }
    else if low_starts_with_at(line, p, "goto") { same_mapping(llvm_gen_goto(line, p)) }
    // v0.88.10: Non-assignment concurrency instructions
    else if low_starts_with_at(line, p, "mutex-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "arc-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "atomic-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "channel-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "rwlock-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "condvar-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "async-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-pool-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "thread-join") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    else if low_starts_with_at(line, p, "scope-") { same_mapping(llvm_gen_conc_stmt(line, p)) }
    // v0.88.10: channel-new dual-dest format: (%sender, %receiver) = channel-new %cap
    else if line.byte_at(p) == 40 { same_mapping(llvm_gen_channel_new(line, p)) }
    else { same_mapping(line) };

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
fn llvm_gen_assign_with_strings_map(line: String, pos: i64, strings: String, mapping: String) -> String =
    let str_sb = sb_new();
    llvm_gen_assign_with_strings_map_and_fns(line, pos, strings, "", mapping, str_sb);

// v0.88.6: Added str_sb parameter
fn llvm_gen_assign_with_strings_map_and_fns(line: String, pos: i64, strings: String, string_fns: String, mapping: String, str_sb: i64) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs_with_strings_map_and_fns(line, after_eq, dest, strings, string_fns, mapping, str_sb);

// Returns tagged result: llvm_line directly (mapping unchanged) or "!len:mapping+llvm_line" (mapping changed)
// v0.60.202: Track string temporaries for proper string comparison generation
// Mapping now includes "S:varname" entries to mark string variables
fn llvm_gen_rhs_with_strings_map(line: String, pos: i64, dest: String, strings: String, mapping: String) -> String =
    let str_sb = sb_new();
    llvm_gen_rhs_with_strings_map_and_fns(line, pos, dest, strings, "", mapping, str_sb);

// v0.88.6: String markers tracked via str_sb (SB), mapping only for name:value copy-elimination
fn llvm_gen_rhs_with_strings_map_and_fns(line: String, pos: i64, dest: String, strings: String, string_fns: String, mapping: String, str_sb: i64) -> String =
    if low_starts_with_at(line, pos, "const") {
        let val_start = low_skip_ws(line, pos + 5);
        let val = line.slice(val_start, line.len());
        same_mapping("  " + dest + " = add nsw i64 0, " + trim_end(val))
    } else if low_starts_with_at(line, pos, "copy") {
        let src_start = low_skip_ws(line, pos + 4);
        let src = trim_end(line.slice(src_start, line.len()));
        // Check if this is a copy TO a user variable (not %_t)
        if is_user_variable(dest) {
            // Don't emit code, just update mapping
            let resolved_src = resolve_variable(src, mapping);
            let src_is_string = is_string_var_sb(src, str_sb);
            let w = if src_is_string { push_string_marker(str_sb, dest) } else { 0 };
            let name_mapping = add_mapping(mapping, dest, resolved_src);
            changed_mapping_empty(name_mapping)
        } else {
            // Propagate string marker if source is string
            let resolved_src = resolve_variable(src, mapping);
            let src_is_string = is_string_var_sb(src, str_sb);
            let w = if src_is_string { push_string_marker(str_sb, dest) } else { 0 };
            same_mapping("  " + dest + " = add nsw i64 0, " + resolved_src)
        }
    } else if low_starts_with_at(line, pos, "string") {
        let str_start = low_skip_ws(line, pos + 6);
        let str_content = line.slice(str_start + 1, line.len() - 1);
        let w = push_string_marker(str_sb, dest);
        same_mapping(llvm_gen_string_ref(dest, str_content, strings))
    } else if low_starts_with_at(line, pos, "+") { llvm_gen_add_with_strings_sb(line, pos + 1, dest, mapping, str_sb) }
    else if low_starts_with_at(line, pos, "-") { same_mapping(llvm_gen_binop("sub", line, pos + 1, dest)) }
    else if low_starts_with_at(line, pos, "*") { same_mapping(llvm_gen_binop("mul", line, pos + 1, dest)) }
    else if low_starts_with_at(line, pos, "/") { same_mapping(llvm_gen_binop("sdiv", line, pos + 1, dest)) }
    else if low_starts_with_at(line, pos, "%") { same_mapping(llvm_gen_binop("srem", line, pos + 1, dest)) }
    else if low_starts_with_at(line, pos, "<=") { same_mapping(llvm_gen_cmp("sle", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, ">=") { same_mapping(llvm_gen_cmp("sge", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "<") { same_mapping(llvm_gen_cmp("slt", line, pos + 1, dest)) }
    else if low_starts_with_at(line, pos, ">") { same_mapping(llvm_gen_cmp("sgt", line, pos + 1, dest)) }
    // v0.60.225: Re-enabled string comparison with ptr conversion fix
    else if low_starts_with_at(line, pos, "==") { llvm_gen_cmp_with_strings_sb("eq", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "!=") { llvm_gen_cmp_with_strings_sb("ne", line, pos + 2, dest, str_sb) }
    else if low_starts_with_at(line, pos, "and") { same_mapping(llvm_gen_binop("and", line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "or") { same_mapping(llvm_gen_binop("or", line, pos + 2, dest)) }
    else if low_starts_with_at(line, pos, "not") { same_mapping(llvm_gen_not(line, pos + 3, dest)) }
    else if low_starts_with_at(line, pos, "neg") { same_mapping(llvm_gen_neg(line, pos + 3, dest)) }
    // v0.60.231: PHI with string marker propagation
    else if low_starts_with_at(line, pos, "phi") { llvm_gen_phi_with_strings_sb(line, pos, dest, str_sb) }
    // v0.60.233: Call with dynamic string function tracking
    else if low_starts_with_at(line, pos, "call") { llvm_gen_call_with_string_tracking_sb(line, pos, dest, str_sb, string_fns) }
    // v0.88.10: Concurrency MIR instructions (assignment form)
    else if low_starts_with_at(line, pos, "mutex-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "thread-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "arc-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "atomic-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "channel-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "sender-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "rwlock-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "barrier-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "condvar-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "block-on") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "async-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "thread-pool-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else if low_starts_with_at(line, pos, "scope-") { same_mapping(llvm_gen_conc_rhs(line, pos, dest)) }
    else { same_mapping("  ; unknown: " + line) };

// Add a string marker to the mapping: "S:varname" (prepend for O(1) recent lookup)
fn add_string_marker(mapping: String, varname: String) -> String =
    if mapping == "" { "S:" + varname }
    else { "S:" + varname + "," + mapping };

// v0.88.6: Push string marker to SB (zero mapping copy)
fn push_string_marker(str_sb: i64, varname: String) -> i64 =
    let w1 = sb_push(str_sb, "S:");
    let w2 = sb_push(str_sb, varname);
    sb_push(str_sb, ",");

// v0.88.6: Check if variable is marked as string in SB (zero arena allocation)
fn is_string_var_sb(varname: String, str_sb: i64) -> bool =
    let marker = "S:" + varname;
    bmb_sb_contains(str_sb, marker) > 0;

// v0.88.6: SB-based comparison (== / !=)
fn llvm_gen_cmp_with_strings_sb(pred: String, line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_cmp_with_strings_sb_2(pred, line, pos, dest, str_sb, left, comma);

fn llvm_gen_cmp_with_strings_sb_2(pred: String, line: String, pos: i64, dest: String, str_sb: i64, left: String, comma: i64) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_cmp_with_strings_sb_3(pred, line, pos, dest, str_sb, left_trimmed, right_trimmed);

fn llvm_gen_cmp_with_strings_sb_3(pred: String, line: String, pos: i64, dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_sb(left_trimmed, str_sb);
    let right_is_string = is_string_var_sb(right_trimmed, str_sb);
    if left_is_string or right_is_string {
        // Reuse existing string cmp (mapping param unused for string cmp result - it returns same_mapping)
        llvm_gen_string_cmp(pred, left_trimmed, right_trimmed, dest, "")
    } else {
        same_mapping(llvm_gen_cmp(pred, line, pos, dest))
    };

// v0.88.6: SB-based add (string concat detection)
fn llvm_gen_add_with_strings_sb(line: String, pos: i64, dest: String, mapping: String, str_sb: i64) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_add_with_strings_sb_2(line, pos, dest, mapping, str_sb, p1, comma, left);

fn llvm_gen_add_with_strings_sb_2(line: String, pos: i64, dest: String, mapping: String, str_sb: i64, p1: i64, comma: i64, left: String) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_add_with_strings_sb_3(dest, mapping, str_sb, left_trimmed, right_trimmed);

fn llvm_gen_add_with_strings_sb_3(dest: String, mapping: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_sb(left_trimmed, str_sb);
    let right_is_string = is_string_var_sb(right_trimmed, str_sb);
    if left_is_string or right_is_string {
        llvm_gen_add_string_concat_sb(dest, str_sb, left_trimmed, right_trimmed)
    } else {
        same_mapping("  " + dest + " = add nsw i64 " + left_trimmed + ", " + right_trimmed)
    };

fn llvm_gen_add_string_concat_sb(dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String) -> String =
    let lptr = dest + "_l";
    let rptr = dest + "_r";
    let cptr = dest + "_c";
    llvm_gen_add_string_concat_sb_2(dest, str_sb, left_trimmed, right_trimmed, lptr, rptr, cptr);

fn llvm_gen_add_string_concat_sb_2(dest: String, str_sb: i64, left_trimmed: String, right_trimmed: String, lptr: String, rptr: String, cptr: String) -> String =
    let line1 = "  " + lptr + " = inttoptr i64 " + left_trimmed + " to ptr";
    let line2 = "  " + rptr + " = inttoptr i64 " + right_trimmed + " to ptr";
    let line3 = "  " + cptr + " = call ptr @bmb_string_concat(ptr " + lptr + ", ptr " + rptr + ")";
    let line4 = "  " + dest + " = ptrtoint ptr " + cptr + " to i64";
    let w = push_string_marker(str_sb, dest);
    same_mapping(line1 + "|" + line2 + "|" + line3 + "|" + line4);

// v0.88.6: SB-based PHI with string marker
fn llvm_gen_phi_with_strings_sb(line: String, pos: i64, dest: String, str_sb: i64) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let first_val = extract_phi_val(first_content);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    let second_val = extract_phi_val(second_content);
    let first_is_string = is_string_var_sb(first_val, str_sb);
    let second_is_string = is_string_var_sb(second_val, str_sb);
    let w = if first_is_string or second_is_string { push_string_marker(str_sb, dest) } else { 0 };
    same_mapping(llvm_gen_phi(line, pos, dest));

// v0.88.6: SB-based call tracking
fn llvm_gen_call_with_string_tracking_sb(line: String, pos: i64, dest: String, str_sb: i64, string_fns: String) -> String =
    let llvm_code = llvm_gen_call(line, pos, dest);
    let fn_name = extract_call_fn_name(line, pos);
    let is_hardcoded_string_fn = is_string_returning_fn(fn_name);
    let is_dynamic_string_fn_result = is_dynamic_string_fn(fn_name, string_fns);
    let is_string_fn = is_hardcoded_string_fn or is_dynamic_string_fn_result;
    let w = if is_string_fn { push_string_marker(str_sb, dest) } else { 0 };
    same_mapping(llvm_code);

// Check if a variable is marked as a string in the mapping
fn is_string_var(varname: String, mapping: String) -> bool =
    let marker = "S:" + varname;
    string_in_mapping(mapping, marker);

// Check if a marker string exists in the mapping
fn string_in_mapping(mapping: String, marker: String) -> bool =
    if mapping == "" { false }
    else { find_string_in_list(mapping, marker, 0) >= 0 };

// Find a string in a comma-separated list (iterative to avoid stack overflow)
fn find_string_in_list(list: String, target: String, pos: i64) -> i64 =
    find_string_in_list_iter(list, target, pos);

fn find_string_in_list_iter(list: String, target: String, pos: i64) -> i64 =
    if pos >= list.len() { 0 - 1 }
    else {
        let comma = find_comma_or_end(list, pos);
        // v0.88.6: Length check before slice to avoid allocation on mismatch
        if comma - pos == target.len() and list.slice(pos, comma) == target { pos }
        else if comma >= list.len() { 0 - 1 }
        // Use tail position to help with TCO
        else { find_string_in_list_iter(list, target, comma + 1) }
    };

// v0.60.238: Split to reduce let-chain depth
fn llvm_gen_cmp_with_strings(pred: String, line: String, pos: i64, dest: String, mapping: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_cmp_with_strings_2(pred, line, pos, dest, mapping, left, comma);

fn llvm_gen_cmp_with_strings_2(pred: String, line: String, pos: i64, dest: String, mapping: String, left: String, comma: i64) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_cmp_with_strings_3(pred, line, pos, dest, mapping, left_trimmed, right_trimmed);

fn llvm_gen_cmp_with_strings_3(pred: String, line: String, pos: i64, dest: String, mapping: String, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_fast(left_trimmed, mapping);
    let right_is_string = is_string_var_fast(right_trimmed, mapping);
    if left_is_string or right_is_string {
        llvm_gen_string_cmp(pred, left_trimmed, right_trimmed, dest, mapping)
    } else {
        same_mapping(llvm_gen_cmp(pred, line, pos, dest))
    };

// Fast string variable check - only looks at first few entries to avoid deep recursion
fn is_string_var_fast(varname: String, mapping: String) -> bool =
    let marker = "S:" + varname;
    if mapping == "" { false }
    else { has_prefix_or_contains_marker(mapping, marker) };

// v0.88.6: Search from START since new entries are prepended
fn has_prefix_or_contains_marker(mapping: String, marker: String) -> bool =
    if mapping.len() < marker.len() { false }
    // Check if first entry matches (most common case for recent markers)
    else if starts_with_marker(mapping, marker) { true }
    // Search forward from start for first 100 entries
    else { find_marker_from_start(mapping, marker, 0, 0) };

// v0.88.6: Check if mapping starts with marker, or marker,
fn starts_with_marker(mapping: String, marker: String) -> bool =
    let mlen = mapping.len();
    let klen = marker.len();
    if mlen == klen { mapping == marker }
    else if mlen > klen {
        // Check if starts with marker,
        mapping.byte_at(klen) == 44 and mapping.slice(0, klen) == marker
    }
    else { false };

// v0.88.6: Search forward from start - check first 100 entries
fn find_marker_from_start(mapping: String, marker: String, pos: i64, count: i64) -> bool =
    if count > 100 or pos >= mapping.len() { false }
    else {
        let comma = find_comma_or_end(mapping, pos);
        if comma - pos == marker.len() and mapping.slice(pos, comma) == marker { true }
        else if comma >= mapping.len() { false }
        else { find_marker_from_start(mapping, marker, comma + 1, count + 1) }
    };

// v0.60.238: Simplified to avoid deep parameter nesting
fn llvm_gen_string_cmp(pred: String, left: String, right: String, dest: String, mapping: String) -> String =
    let lptr = dest + "_lp";
    let rptr = dest + "_rp";
    let eq_dest = dest + "_streq";
    let conv_l = "  " + lptr + " = inttoptr i64 " + left + " to ptr";
    llvm_gen_string_cmp_2(pred, right, dest, mapping, lptr, rptr, eq_dest, conv_l);

fn llvm_gen_string_cmp_2(pred: String, right: String, dest: String, mapping: String, lptr: String, rptr: String, eq_dest: String, conv_l: String) -> String =
    let conv_r = "  " + rptr + " = inttoptr i64 " + right + " to ptr";
    let call_ln = "  " + eq_dest + " = call i64 @bmb_string_eq(ptr " + lptr + ", ptr " + rptr + ")";
    let cmp_ln = "  " + dest + "_cmp = icmp ne i64 " + eq_dest + ", 0";
    llvm_gen_string_cmp_3(pred, dest, mapping, conv_l, conv_r, call_ln, cmp_ln);

fn llvm_gen_string_cmp_3(pred: String, dest: String, mapping: String, conv_l: String, conv_r: String, call_ln: String, cmp_ln: String) -> String =
    let res_ln = "  " + dest + " = zext i1 " + dest + "_cmp to i64";
    if pred == "ne" {
        let inv_cmp = "  " + dest + "_cmp = icmp eq i64 " + dest + "_streq, 0";
        same_mapping(conv_l + "|" + conv_r + "|" + call_ln + "|" + inv_cmp + "|" + res_ln)
    } else {
        same_mapping(conv_l + "|" + conv_r + "|" + call_ln + "|" + cmp_ln + "|" + res_ln)
    };

// Track string-returning function calls

// v0.60.238: Split to reduce let-chain depth
fn llvm_gen_add_with_strings(line: String, pos: i64, dest: String, mapping: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    llvm_gen_add_with_strings_2(line, pos, dest, mapping, p1, comma, left);

fn llvm_gen_add_with_strings_2(line: String, pos: i64, dest: String, mapping: String, p1: i64, comma: i64, left: String) -> String =
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let left_trimmed = trim_end(left);
    let right_trimmed = trim_end(right);
    llvm_gen_add_with_strings_3(dest, mapping, left_trimmed, right_trimmed);

fn llvm_gen_add_with_strings_3(dest: String, mapping: String, left_trimmed: String, right_trimmed: String) -> String =
    let left_is_string = is_string_var_fast(left_trimmed, mapping);
    let right_is_string = is_string_var_fast(right_trimmed, mapping);
    if left_is_string or right_is_string {
        llvm_gen_add_string_concat(dest, mapping, left_trimmed, right_trimmed)
    } else {
        same_mapping("  " + dest + " = add nsw i64 " + left_trimmed + ", " + right_trimmed)
    };

fn llvm_gen_add_string_concat(dest: String, mapping: String, left_trimmed: String, right_trimmed: String) -> String =
    let lptr = dest + "_l";
    let rptr = dest + "_r";
    let cptr = dest + "_c";
    llvm_gen_add_string_concat_2(dest, mapping, left_trimmed, right_trimmed, lptr, rptr, cptr);

fn llvm_gen_add_string_concat_2(dest: String, mapping: String, left_trimmed: String, right_trimmed: String, lptr: String, rptr: String, cptr: String) -> String =
    let line1 = "  " + lptr + " = inttoptr i64 " + left_trimmed + " to ptr";
    let line2 = "  " + rptr + " = inttoptr i64 " + right_trimmed + " to ptr";
    let line3 = "  " + cptr + " = call ptr @bmb_string_concat(ptr " + lptr + ", ptr " + rptr + ")";
    let line4 = "  " + dest + " = ptrtoint ptr " + cptr + " to i64";
    changed_mapping(add_string_marker(mapping, dest), line1 + "|" + line2 + "|" + line3 + "|" + line4);

fn llvm_gen_call_with_string_tracking(line: String, pos: i64, dest: String, mapping: String) -> String =
    llvm_gen_call_with_string_tracking_and_fns(line, pos, dest, mapping, "");

// v0.60.233: Call tracking with dynamic string functions
fn llvm_gen_call_with_string_tracking_and_fns(line: String, pos: i64, dest: String, mapping: String, string_fns: String) -> String =
    let llvm_code = llvm_gen_call(line, pos, dest);
    // Check if the called function returns a string
    let fn_name = extract_call_fn_name(line, pos);
    // Check both hardcoded list and dynamic functions
    let is_hardcoded_string_fn = is_string_returning_fn(fn_name);
    let is_dynamic_string_fn_result = is_dynamic_string_fn(fn_name, string_fns);
    let is_string_fn = is_hardcoded_string_fn or is_dynamic_string_fn_result;
    if is_string_fn {
        changed_mapping(add_string_marker(mapping, dest), llvm_code)
    } else {
        same_mapping(llvm_code)
    };

// Check if a function returns a string
// v0.60.230: Split into helper functions to reduce stack depth during compilation
fn is_string_returning_fn(name: String) -> bool =
    is_string_fn_group1(name) or is_string_fn_group2(name) or is_string_fn_group3(name) or
    is_string_fn_group4(name) or is_string_fn_group5(name);

fn is_string_fn_group1(name: String) -> bool =
    name == "get_node_type" or name == "get_child" or name == "extract_name" or
    name == "bmb_string_slice" or name == "bmb_string_concat" or
    name == "bmb_string_from_cstr" or name == "bmb_chr" or name == "bmb_read_file" or
    name == "bmb_getenv" or name == "get_arg" or name == "int_to_string" or
    name == "chr" or name == "slice" or name == "concat";

fn is_string_fn_group2(name: String) -> bool =
    name == "sb_build" or name == "digit_char" or name == "escape_parens" or
    name == "unescape_parens_from_ast" or name == "extract_string_content" or
    name == "get_fn_return_type" or name == "collect_params" or name == "get_fn_body" or
    name == "lower_function_sb" or name == "lower_program_sb" or
    name == "compile_function" or name == "compile_source";

fn is_string_fn_group3(name: String) -> bool =
    name == "parse_source" or name == "gen_function" or name == "gen_program" or
    name == "tokenize" or name == "read_file" or name == "make_error" or
    name == "gen_module_header" or name == "gen_runtime_decls" or
    name == "gen_string_globals" or name == "gen_program_sb_with_strings" or
    name == "collect_strings_from_mir" or name == "compile_program";

fn is_string_fn_group4(name: String) -> bool =
    name == "gen_extern_println" or name == "gen_extern_print_str" or
    name == "llvm_gen_binop" or name == "llvm_gen_cmp" or name == "llvm_gen_call" or
    name == "llvm_gen_not" or name == "llvm_gen_neg" or name == "llvm_gen_phi" or
    name == "llvm_gen_branch" or name == "llvm_gen_goto" or name == "llvm_gen_return_typed" or
    name == "llvm_gen_string_ref" or name == "llvm_gen_line_with_ret";

fn is_string_fn_group5(name: String) -> bool =
    name == "llvm_gen_assign_typed" or name == "llvm_gen_rhs_typed" or
    name == "gen_function_lines_typed" or name == "gen_function_sb_typed" or
    name == "llvm_gen_fn_line_typed" or name == "llvm_gen_fn_header" or
    name == "gen_all_externs" or name == "pack_result" or name == "unpack_ast" or
    name == "make_step" or name == "make_work" or name == "make_work3" or name == "make_work4" or
    name == "step_work" or name == "get_field" or name == "trim_end" or name == "i2s" or
    name == "sb_build" or name == "pack_lower_result" or name == "unescape_parens";

// Extract function name from call instruction
fn extract_call_fn_name(line: String, pos: i64) -> String =
    let after_call = low_skip_ws(line, pos + 4);
    let at_pos = if line.byte_at(after_call) == 64 { after_call + 1 } else { after_call };
    let paren_pos = find_char(line, at_pos, 40);
    if paren_pos > at_pos { line.slice(at_pos, paren_pos) } else { "" };

// Check if a variable name is a user variable (not %_t)
fn is_user_variable(name: String) -> bool =
    if name.len() < 3 { false }
    else {
        let after_pct = name.byte_at(1);
        // User vars don't start with _t after the %
        not (after_pct == 95 and name.len() > 2 and name.byte_at(2) == 116)
    };

// Resolve a variable using the mapping
fn resolve_variable(varname: String, mapping: String) -> String =
    if not is_user_variable(varname) { varname }
    else { lookup_mapping(mapping, varname, varname) };

// Look up a variable in the mapping, return default if not found
fn lookup_mapping(mapping: String, name: String, default_val: String) -> String =
    if mapping == "" { default_val }
    else { lookup_mapping_at(mapping, name, 0, default_val) };

// v0.88.6: First-match lookup (prepend order = newest first), index-based to reduce allocations
fn lookup_mapping_at(mapping: String, name: String, pos: i64, default_val: String) -> String =
    if pos >= mapping.len() { default_val }
    else {
        let comma = find_comma_or_end(mapping, pos);
        let colon = find_char(mapping, pos, 58);
        // Compare name directly: mapping[pos..colon] == name?
        if colon - pos == name.len() and mapping.slice(pos, colon) == name {
            // First match = most recent (prepend order), return immediately
            mapping.slice(colon + 1, comma)
        } else if comma >= mapping.len() { default_val }
        else { lookup_mapping_at(mapping, name, comma + 1, default_val) }
    };

// Add a name:value pair to the mapping (prepend for O(1) recent lookup)
fn add_mapping(mapping: String, name: String, value: String) -> String =
    let entry = name + ":" + value;
    if mapping == "" { entry } else { entry + "," + mapping };

// Extract mapping from "mapping@@@llvm_line"
fn extract_mapping(result: String) -> String =
    let sep = find_triple_at(result, 0);
    result.slice(0, sep);

// Extract llvm_line from "mapping@@@llvm_line"
fn extract_llvm_line(result: String) -> String =
    let sep = find_triple_at(result, 0);
    result.slice(sep + 3, result.len());

// Find "@@@" separator
fn find_triple_at(s: String, pos: i64) -> i64 =
    if pos + 2 >= s.len() { s.len() }
    else if s.byte_at(pos) == 64 and s.byte_at(pos + 1) == 64 and s.byte_at(pos + 2) == 64 { pos }
    else { find_triple_at(s, pos + 1) };

// v0.88.5: Two-part return protocol for memory optimization
// No prefix: mapping unchanged, reuse caller's mapping (result IS the llvm_line)
// Tag "!" (byte 33): mapping changed, length-prefixed new mapping
fn same_mapping(llvm_line: String) -> String = llvm_line;
fn same_mapping_empty() -> String = "";
fn changed_mapping(new_mapping: String, llvm_line: String) -> String =
    "!" + int_to_string(new_mapping.len()) + ":" + new_mapping + llvm_line;
fn changed_mapping_empty(new_mapping: String) -> String =
    "!" + int_to_string(new_mapping.len()) + ":" + new_mapping;

fn extract_new_mapping(result: String) -> String =
    let colon_pos = find_char(result, 1, 58);
    let map_len = parse_len_at(result, 1, colon_pos);
    result.slice(colon_pos + 1, colon_pos + 1 + map_len);

fn extract_new_llvm_line(result: String) -> String =
    let colon_pos = find_char(result, 1, 58);
    let map_len = parse_len_at(result, 1, colon_pos);
    result.slice(colon_pos + 1 + map_len, result.len());

fn parse_len_at(s: String, start: i64, end_pos: i64) -> i64 =
    parse_len_acc(s, start, end_pos, 0);

fn parse_len_acc(s: String, pos: i64, end_pos: i64, acc: i64) -> i64 =
    if pos >= end_pos { acc }
    else { parse_len_acc(s, pos + 1, end_pos, acc * 10 + s.byte_at(pos) - 48) };

// v0.88.10: Concurrency MIR instruction helpers
// Extract single operand from "opcode %operand" format
// pos points to start of operand (after opcode + whitespace)
fn conc_extract_single_op(line: String, pos: i64) -> String =
    trim_end(line.slice(pos, line.len()));

// Extract two space-separated operands: "%op1 %op2"
fn conc_extract_two_ops_first(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    line.slice(pos, sp);

fn conc_extract_two_ops_second(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp + 1);
    trim_end(line.slice(p2, line.len()));

// Extract three space-separated operands: "%op1 %op2 %op3"
fn conc_extract_three_first(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    line.slice(pos, sp);

fn conc_extract_three_second(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    line.slice(p2, sp2);

fn conc_extract_three_third(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    let p3 = low_skip_ws(line, sp2 + 1);
    trim_end(line.slice(p3, line.len()));

// Extract four space-separated operands
fn conc_extract_four_first(line: String, pos: i64) -> String =
    let sp = find_char(line, pos, 32);
    line.slice(pos, sp);

fn conc_extract_four_second(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    line.slice(p2, sp2);

fn conc_extract_four_third(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    let p3 = low_skip_ws(line, sp2 + 1);
    let sp3 = find_char(line, p3, 32);
    line.slice(p3, sp3);

fn conc_extract_four_fourth(line: String, pos: i64) -> String =
    let sp1 = find_char(line, pos, 32);
    let p2 = low_skip_ws(line, sp1 + 1);
    let sp2 = find_char(line, p2, 32);
    let p3 = low_skip_ws(line, sp2 + 1);
    let sp3 = find_char(line, p3, 32);
    let p4 = low_skip_ws(line, sp3 + 1);
    trim_end(line.slice(p4, line.len()));

// Generate simple i64 call: %dest = call i64 @fn_name(i64 %op)
fn conc_gen_call_i64_1(dest: String, fn_name: String, op: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op + ")";

// Generate i64 call with 2 args
fn conc_gen_call_i64_2(dest: String, fn_name: String, op1: String, op2: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ")";

// Generate i64 call with 3 args
fn conc_gen_call_i64_3(dest: String, fn_name: String, op1: String, op2: String, op3: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ", i64 " + op3 + ")";

// Generate void call with 1 arg
fn conc_gen_call_void_1(fn_name: String, op: String) -> String =
    "  call void @" + fn_name + "(i64 " + op + ")";

// Generate void call with 2 args
fn conc_gen_call_void_2(fn_name: String, op1: String, op2: String) -> String =
    "  call void @" + fn_name + "(i64 " + op1 + ", i64 " + op2 + ")";

// Generate i64 call with 0 args
fn conc_gen_call_i64_0(dest: String, fn_name: String) -> String =
    "  " + dest + " = call i64 @" + fn_name + "()";

// v0.88.10: Concurrency RHS handler - dispatches concurrency MIR instructions in assignment form
// Input: line is full MIR line, pos points to start of RHS (after "= "), dest is "%varname"
fn llvm_gen_conc_rhs(line: String, pos: i64, dest: String) -> String =
    // Thread operations
    if low_starts_with_at(line, pos, "thread-spawn") {
        // Phase 1: synchronous. %dest = thread-spawn func(captures...)
        // The first capture is the pre-computed result
        let after = low_skip_ws(line, pos + 12);
        let paren = find_char(line, after, 40);
        let args_start = paren + 1;
        let args_end = find_char(line, args_start, 41);
        let args = line.slice(args_start, args_end);
        let first_arg = if args.len() > 0 {
            let c = find_comma_or_end(args, 0);
            trim_end(args.slice(0, c))
        } else { "0" };
        "  ; Phase 1: ThreadSpawn - body executed synchronously|  " + dest + " = add i64 " + first_arg + ", 0"
    } else if low_starts_with_at(line, pos, "thread-join") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        "  ; Phase 1: ThreadJoin - handle is the result|  " + dest + " = add i64 " + op + ", 0"
    }
    // Mutex operations
    else if low_starts_with_at(line, pos, "mutex-new") {
        let op_start = low_skip_ws(line, pos + 9);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_new", op))
    } else if low_starts_with_at(line, pos, "mutex-try-lock") {
        let op_start = low_skip_ws(line, pos + 14);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_try_lock", op))
    } else if low_starts_with_at(line, pos, "mutex-lock") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_mutex_lock", op))
    }
    // Arc operations
    else if low_starts_with_at(line, pos, "arc-new") {
        let op_start = low_skip_ws(line, pos + 7);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_new", op))
    } else if low_starts_with_at(line, pos, "arc-clone") {
        let op_start = low_skip_ws(line, pos + 9);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_clone", op))
    } else if low_starts_with_at(line, pos, "arc-get") {
        let op_start = low_skip_ws(line, pos + 7);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_get", op))
    } else if low_starts_with_at(line, pos, "arc-strong-count") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_arc_strong_count", op))
    }
    // Atomic operations
    else if low_starts_with_at(line, pos, "atomic-new") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        // Allocate heap memory for atomic, store value, return as i64 ptr
        "  " + dest + "_ptr = call ptr @malloc(i64 8)|  store atomic i64 " + op + ", ptr " + dest + "_ptr seq_cst, align 8|  " + dest + " = ptrtoint ptr " + dest + "_ptr to i64"
    } else if low_starts_with_at(line, pos, "atomic-load") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op + " to ptr|  " + dest + " = load atomic i64, ptr " + dest + "_ptr seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-fetch-add") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw add ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-fetch-sub") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw sub ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-swap") {
        let op_start = low_skip_ws(line, pos + 11);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + " = atomicrmw xchg ptr " + dest + "_ptr, i64 " + op2 + " seq_cst, align 8"
    } else if low_starts_with_at(line, pos, "atomic-cmpxchg") {
        let op_start = low_skip_ws(line, pos + 14);
        let op1 = conc_extract_three_first(line, op_start);
        let op2 = conc_extract_three_second(line, op_start);
        let op3 = conc_extract_three_third(line, op_start);
        "  " + dest + "_ptr = inttoptr i64 " + op1 + " to ptr|  " + dest + "_result = cmpxchg ptr " + dest + "_ptr, i64 " + op2 + ", i64 " + op3 + " seq_cst seq_cst, align 8|  " + dest + " = extractvalue { i64, i1 } " + dest + "_result, 0"
    }
    // Channel operations (assignment form)
    else if low_starts_with_at(line, pos, "channel-recv-timeout") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        "  " + dest + "_alloc = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_recv_timeout(i64 " + op1 + ", i64 " + op2 + ", ptr " + dest + "_alloc)|  " + dest + "_loaded = load i64, ptr " + dest + "_alloc|  " + dest + "_is_success = icmp ne i64 " + dest + "_success, 0|  " + dest + " = select i1 " + dest + "_is_success, i64 " + dest + "_loaded, i64 -1"
    } else if low_starts_with_at(line, pos, "channel-recv-opt") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_ptr = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_recv_opt(i64 " + op + ", ptr " + dest + "_ptr)|  " + dest + "_tmp = load i64, ptr " + dest + "_ptr|  " + dest + "_cond = icmp eq i64 " + dest + "_success, 1|  " + dest + " = select i1 " + dest + "_cond, i64 " + dest + "_tmp, i64 -1"
    } else if low_starts_with_at(line, pos, "channel-recv") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_channel_recv", op))
    } else if low_starts_with_at(line, pos, "channel-try-send") {
        let op_start = low_skip_ws(line, pos + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_channel_try_send", op1, op2))
    } else if low_starts_with_at(line, pos, "channel-try-recv") {
        let op_start = low_skip_ws(line, pos + 16);
        let op = conc_extract_single_op(line, op_start);
        "  " + dest + "_alloc = alloca i64, align 8|  " + dest + "_success = call i64 @bmb_channel_try_recv(i64 " + op + ", ptr " + dest + "_alloc)|  " + dest + " = load i64, ptr " + dest + "_alloc"
    } else if low_starts_with_at(line, pos, "channel-send-timeout") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_three_first(line, op_start);
        let op2 = conc_extract_three_second(line, op_start);
        let op3 = conc_extract_three_third(line, op_start);
        same_mapping(conc_gen_call_i64_3(dest, "bmb_channel_send_timeout", op1, op2, op3))
    } else if low_starts_with_at(line, pos, "channel-is-closed") {
        let op_start = low_skip_ws(line, pos + 17);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_channel_is_closed", op))
    } else if low_starts_with_at(line, pos, "sender-clone") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_sender_clone", op))
    }
    // RwLock operations
    else if low_starts_with_at(line, pos, "rwlock-new") {
        let op_start = low_skip_ws(line, pos + 10);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_new", op))
    } else if low_starts_with_at(line, pos, "rwlock-read") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_read", op))
    } else if low_starts_with_at(line, pos, "rwlock-write") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_rwlock_write", op))
    }
    // Barrier operations
    else if low_starts_with_at(line, pos, "barrier-new") {
        let op_start = low_skip_ws(line, pos + 11);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_barrier_new", op))
    } else if low_starts_with_at(line, pos, "barrier-wait") {
        let op_start = low_skip_ws(line, pos + 12);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_barrier_wait", op))
    }
    // Condvar operations
    else if low_starts_with_at(line, pos, "condvar-new") {
        same_mapping(conc_gen_call_i64_0(dest, "bmb_condvar_new"))
    } else if low_starts_with_at(line, pos, "condvar-wait") {
        let op_start = low_skip_ws(line, pos + 12);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_condvar_wait", op1, op2))
    }
    // Block-on
    else if low_starts_with_at(line, pos, "block-on") {
        let op_start = low_skip_ws(line, pos + 8);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_block_on", op))
    }
    // Async I/O operations
    else if low_starts_with_at(line, pos, "async-file-open") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_file_open", op))
    } else if low_starts_with_at(line, pos, "async-file-read") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_file_read", op))
    } else if low_starts_with_at(line, pos, "async-socket-connect") {
        let op_start = low_skip_ws(line, pos + 20);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        same_mapping(conc_gen_call_i64_2(dest, "bmb_async_socket_connect", op1, op2))
    } else if low_starts_with_at(line, pos, "async-socket-read") {
        let op_start = low_skip_ws(line, pos + 17);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_async_socket_read", op))
    }
    // ThreadPool
    else if low_starts_with_at(line, pos, "thread-pool-new") {
        let op_start = low_skip_ws(line, pos + 15);
        let op = conc_extract_single_op(line, op_start);
        same_mapping(conc_gen_call_i64_1(dest, "bmb_thread_pool_new", op))
    }
    // Scope
    else if low_starts_with_at(line, pos, "scope-new") {
        same_mapping(conc_gen_call_i64_0(dest, "bmb_scope_new"))
    }
    // Unknown concurrency instruction
    else { same_mapping("  ; unknown-conc: " + line) };

// v0.88.10: Non-assignment concurrency instruction handler
// Handles MIR lines like "mutex-unlock %h = %v", "channel-send %s %v", etc.
fn llvm_gen_conc_stmt(line: String, p: i64) -> String =
    if low_starts_with_at(line, p, "mutex-unlock") {
        // mutex-unlock %handle = %value
        let op_start = low_skip_ws(line, p + 12);
        let eq_pos = find_eq(line, op_start);
        let handle = trim_end(line.slice(op_start, eq_pos - 1));
        let val_start = low_skip_ws(line, eq_pos + 1);
        let value = trim_end(line.slice(val_start, line.len()));
        conc_gen_call_void_2("bmb_mutex_unlock", handle, value)
    } else if low_starts_with_at(line, p, "mutex-free") {
        let op_start = low_skip_ws(line, p + 10);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_mutex_free", op)
    } else if low_starts_with_at(line, p, "arc-drop") {
        let op_start = low_skip_ws(line, p + 8);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_arc_drop", op)
    } else if low_starts_with_at(line, p, "atomic-store") {
        // atomic-store %ptr = %value
        let op_start = low_skip_ws(line, p + 12);
        let eq_pos = find_eq(line, op_start);
        let ptr_op = trim_end(line.slice(op_start, eq_pos - 1));
        let val_start = low_skip_ws(line, eq_pos + 1);
        let value = trim_end(line.slice(val_start, line.len()));
        "  %_atomic_store_ptr = inttoptr i64 " + ptr_op + " to ptr|  store atomic i64 " + value + ", ptr %_atomic_store_ptr seq_cst, align 8"
    } else if low_starts_with_at(line, p, "channel-send") {
        let op_start = low_skip_ws(line, p + 12);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_channel_send", op1, op2)
    } else if low_starts_with_at(line, p, "channel-close") {
        let op_start = low_skip_ws(line, p + 13);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_channel_close", op)
    } else if low_starts_with_at(line, p, "rwlock-read-unlock") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_rwlock_read_unlock", op)
    } else if low_starts_with_at(line, p, "rwlock-write-unlock") {
        let op_start = low_skip_ws(line, p + 19);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_rwlock_write_unlock", op1, op2)
    } else if low_starts_with_at(line, p, "condvar-notify-one") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_condvar_notify_one", op)
    } else if low_starts_with_at(line, p, "condvar-notify-all") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_condvar_notify_all", op)
    } else if low_starts_with_at(line, p, "async-file-write") {
        let op_start = low_skip_ws(line, p + 16);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_async_file_write", op1, op2)
    } else if low_starts_with_at(line, p, "async-file-close") {
        let op_start = low_skip_ws(line, p + 16);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_async_file_close", op)
    } else if low_starts_with_at(line, p, "async-socket-write") {
        let op_start = low_skip_ws(line, p + 18);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_async_socket_write", op1, op2)
    } else if low_starts_with_at(line, p, "async-socket-close") {
        let op_start = low_skip_ws(line, p + 18);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_async_socket_close", op)
    } else if low_starts_with_at(line, p, "thread-pool-execute") {
        let op_start = low_skip_ws(line, p + 19);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_thread_pool_execute", op1, op2)
    } else if low_starts_with_at(line, p, "thread-pool-join") {
        let op_start = low_skip_ws(line, p + 16);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_thread_pool_join", op)
    } else if low_starts_with_at(line, p, "thread-pool-shutdown") {
        let op_start = low_skip_ws(line, p + 20);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_thread_pool_shutdown", op)
    } else if low_starts_with_at(line, p, "scope-spawn") {
        let op_start = low_skip_ws(line, p + 11);
        let op1 = conc_extract_two_ops_first(line, op_start);
        let op2 = conc_extract_two_ops_second(line, op_start);
        conc_gen_call_void_2("bmb_scope_spawn", op1, op2)
    } else if low_starts_with_at(line, p, "scope-wait") {
        let op_start = low_skip_ws(line, p + 10);
        let op = conc_extract_single_op(line, op_start);
        conc_gen_call_void_1("bmb_scope_wait", op)
    } else if low_starts_with_at(line, p, "thread-join") {
        // thread-join without dest (discard result)
        let op_start = low_skip_ws(line, p + 11);
        let op = conc_extract_single_op(line, op_start);
        "  call i64 @bmb_thread_join(i64 " + op + ")"
    } else { "  ; unknown-conc-stmt: " + line };

// v0.88.10: channel-new handler for dual-dest format: (%sender, %receiver) = channel-new %capacity
fn llvm_gen_channel_new(line: String, p: i64) -> String =
    // Parse: (%sender, %receiver) = channel-new %capacity
    let p1 = p + 1;
    let comma = find_comma(line, p1);
    let sender_dest = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let rparen = find_char(line, p2, 41);
    let receiver_dest = line.slice(p2, rparen);
    let eq_pos = find_eq(line, rparen + 1);
    let rhs_start = low_skip_ws(line, eq_pos + 1);
    // Skip "channel-new"
    let cap_start = low_skip_ws(line, rhs_start + 11);
    let cap = trim_end(line.slice(cap_start, line.len()));
    // Generate alloca + call + load
    "  " + sender_dest + "_alloc = alloca i64, align 8|  " + receiver_dest + "_alloc = alloca i64, align 8|  call void @bmb_channel_new(i64 " + cap + ", ptr " + sender_dest + "_alloc, ptr " + receiver_dest + "_alloc)|  " + sender_dest + " = load i64, ptr " + sender_dest + "_alloc|  " + receiver_dest + " = load i64, ptr " + receiver_dest + "_alloc";

// Legacy versions for compatibility
fn gen_function_lines_sb_with_strings(mir: String, pos: i64, sb: i64, ret_type: String, strings: String) -> i64 =
    gen_function_lines_sb_with_strings_map(mir, pos, sb, ret_type, strings, "");

fn llvm_gen_fn_line_with_strings(line: String, ret_type: String, strings: String) -> String =
    let r = llvm_gen_fn_line_with_strings_map(line, ret_type, strings, "");
    if r.len() > 0 and r.byte_at(0) == 33 { extract_new_llvm_line(r) } else { r };

fn llvm_gen_line_with_strings(line: String, ret_type: String, strings: String) -> String =
    let r = llvm_gen_line_with_strings_map(line, ret_type, strings, "");
    if r.len() > 0 and r.byte_at(0) == 33 { extract_new_llvm_line(r) } else { r };

fn llvm_gen_assign_with_strings(line: String, pos: i64, strings: String) -> String =
    let r = llvm_gen_assign_with_strings_map(line, pos, strings, "");
    if r.len() > 0 and r.byte_at(0) == 33 { extract_new_llvm_line(r) } else { r };

fn llvm_gen_rhs_with_strings(line: String, pos: i64, dest: String, strings: String) -> String =
    let r = llvm_gen_rhs_with_strings_map(line, pos, dest, strings, "");
    if r.len() > 0 and r.byte_at(0) == 33 { extract_new_llvm_line(r) } else { r };

// Generate reference to string global
fn llvm_gen_string_ref(dest: String, str_content: String, strings: String) -> String =
    let idx = find_string_index(strings, str_content);
    let str_len = str_content.len() + 1;
    let global_name = "@str_data_" + int_to_string(idx);
    let gep_dest = dest + "_gep";
    let call_dest = dest + "_call";
    "  " + gep_dest + " = getelementptr [" + int_to_string(str_len) + " x i8], ptr " + global_name + ", i64 0, i64 0|" +
    "  " + call_dest + " = call ptr @bmb_string_from_cstr(ptr " + gep_dest + ")|" +
    "  " + dest + " = ptrtoint ptr " + call_dest + " to i64";

// ============================================================================
// SECTION 13: Unified Compiler Entry Point (v0.10.9)
// ============================================================================

// Compile BMB source code to LLVM IR module
// Returns complete LLVM IR module text with:
// - Module header
// - Runtime declarations
// - Function definitions
fn compile_program(source: String) -> String =
    let ast = parse_source(source);
    if is_error(ast) { "ERR:PARSE:" + ast } else {
        let mir = lower_program_sb(ast);
        if mir == "" { "ERR:LOWERING:empty" } else {
            let header = gen_module_header();
            let decls = gen_runtime_decls();
            // v0.60.109: Collect string literals and generate globals
            let strings = collect_strings_from_mir(mir);
            let string_globals = gen_string_globals(strings);
            // v0.60.233: Collect dynamic String-returning functions
            let string_fns = collect_string_fns_from_mir(mir);
            // v0.31.20: Use StringBuilder-aware LLVM generation for O(1) IR generation
            let code = gen_program_sb_with_strings_and_fns(mir, strings, string_fns);
            // v0.60.127: Use step-by-step concatenation to avoid LLVM codegen bug
            // with chained string concat on large strings
            let base = header + "|";
            let base2 = base + decls;
            // Build with_globals without nesting
            let base3 = base2 + "|";
            let base4 = base3 + string_globals;
            let with_globals = if string_globals == "" { base2 } else { base4 };
            let final1 = with_globals + "||";
            final1 + code
        }
    };

// Compile single function source to LLVM IR
fn compile_function(source: String) -> String =
    let full_source = source;
    let ast = parse_source(full_source);
    if is_error(ast) { "ERR:PARSE:" + ast } else {
        let mir = lower_program_sb(ast);
        // v0.31.20: Use StringBuilder-aware LLVM generation for O(1) IR generation
        if mir == "" { "ERR:LOWERING:empty" } else { gen_function_sb(mir) }
    };

// Check if compilation result is an error
fn is_compile_error(result: String) -> bool =
    result.len() >= 4 and result.slice(0, 4) == "ERR:";

// Extract error type from compilation result
fn get_error_type(result: String) -> String =
    if not is_compile_error(result) { "" } else {
        let after_err = result.slice(4, result.len());
        let colon_pos = find_colon(after_err, 0);
        if colon_pos >= after_err.len() { after_err } else { after_err.slice(0, colon_pos) }
    };

// ============================================================================
// SECTION 14: Test Utilities
// ============================================================================


// v0.88: Emit LLVM IR to file
// Note: Full native build requires external tools (opt, clang)
// Use golden-bootstrap.sh for complete native compilation
fn emit_ir(input: String, output: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        { print_str("Error: Cannot read file: "); println_str(input); 1 }
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            // v0.88.8: Show full error detail with parse/lowering context
            let end = if llvm.len() > 500 { 500 } else { llvm.len() };
            let err_detail = llvm.slice(4, end);
            { print_str("error["); print_str(input); print_str("]: "); println_str(err_detail); 1 }
        } else {
            let w1 = write_file_newlines(output, llvm);
            { print_str("Wrote: "); println_str(output); 0 }
        }
    };

// Bootstrap version - extended CLI
fn main() -> i64 =
    let argc = arg_count();
    if argc < 2 {
        show_help()
    } else {
        let cmd = get_arg(1);
        if cmd == "emit-ir" and argc >= 4 {
            emit_ir(get_arg(2), get_arg(3))
        } else if cmd == "emit-ir" and argc >= 3 {
            // Default output name: replace .bmb with .ll
            let input = get_arg(2);
            let output = if input.len() > 4 and input.slice(input.len() - 4, input.len()) == ".bmb" {
                input.slice(0, input.len() - 4) + ".ll"
            } else { input + ".ll" };
            emit_ir(input, output)
        } else if argc >= 3 {
            // Legacy mode: compiler input.bmb output.ll
            compile_file_to(get_arg(1), get_arg(2))
        } else {
            show_help()
        }
    };

fn show_help() -> i64 =
    let x1 = println_str("BMB Bootstrap Compiler v0.88");
    let x2 = println_str("");
    let x3 = println_str("Usage:");
    let x4 = println_str("  bmb emit-ir <input.bmb> [output.ll]  Emit LLVM IR");
    let x5 = println_str("  bmb <input.bmb> <output.ll>          Emit LLVM IR (legacy)");
    let x6 = println_str("");
    let x7 = println_str("For full native builds, use golden-bootstrap.sh:");
    let x8 = println_str("  bash scripts/golden-bootstrap.sh");
    0;


// v0.46: Compile with output file
fn compile_file_to(input: String, output: String) -> i64 =
    let source = read_file(input);
    if source.len() == 0 {
        { print_str("Error: Cannot read file: "); println_str(input); 1 }
    } else {
        let llvm = compile_program(source);
        if is_compile_error(llvm) {
            { print_str("Compile error: "); println_str(get_error_type(llvm)); 1 }
        } else {
            // v0.60.134: Use write_file_newlines to convert | to newlines
            let w2 = write_file_newlines(output, llvm);
            0
        }
    };
