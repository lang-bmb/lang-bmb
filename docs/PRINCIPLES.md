# BMB Development Principles

> **Performance > Everything**

이 문서는 BMB 언어 개발의 핵심 원칙과 벤치마크 주도 개발 프로세스를 정의합니다.

---

## 1. 핵심 목표: 성능

BMB의 유일한 목표는 **성능**입니다. 다른 모든 가치(안정성, 편의성, 복잡도)는 성능 달성을 위해 희생될 수 있습니다.

```
Performance 추구
    → 런타임 체크 제거 필요
    → 컴파일타임 증명 필요
    → 증명된 코드는 자동으로 안전
```

### 왜 성능인가?

- **안정성**은 독립적 목표가 아닙니다. 성능을 위해 런타임 체크를 제거하면, 컴파일타임 증명이 필요하고, 증명된 코드는 자동으로 안전합니다.
- **편의성**은 AI가 감당합니다. 인간에게 장황한 코드/Contract 작성이 불가능해도, AI는 이를 수행할 수 있습니다.
- **복잡도**는 기피 사유가 아닙니다. 근본 해결을 위해 필요한 복잡도는 수용합니다.

---

## 2. 벤치마크 주도 개발 (Benchmark-Driven Development)

### 2.1. 프로세스 사이클

```
┌───────────────────────────────────────────────────────────────────────┐
│                                                                       │
│   ┌──────────────┐      ┌──────────────┐                             │
│   │ 1. 벤치마크  │ ───▶ │ 2. 성능 측정 │                             │
│   │    실행      │      │   분석       │                             │
│   └──────────────┘      └──────────────┘                             │
│          ▲                     │                                      │
│          │                     ▼                                      │
│   ┌──────────────┐      ┌──────────────┐                             │
│   │ 5. 검증 및   │      │ 3. 근본 원인 │  Decision Framework:        │
│   │    반복      │      │   파악       │  L1: 언어 스펙              │
│   └──────────────┘      └──────────────┘  L2: 컴파일러 구조          │
│          ▲                     │          L3: 최적화 패스            │
│          │                     ▼          L4: 코드 생성              │
│          │              ┌──────────────┐  L5: 런타임                 │
│          │              │ 4. 언어/컴파 │                             │
│          │              │    일러 수정 │                             │
│          │              └──────────────┘                             │
│          │                     │                                      │
│          │   ┌─────────────────┼─────────────────┐                   │
│          │   ▼                 ▼                 ▼                   │
│          │ ┌────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐              │
│          │ │Spec│ │ IR/AST  │ │Optimize │ │ CodeGen │              │
│          │ │변경│ │  확장   │ │패스 추가│ │  수정   │              │
│          │ └──┬─┘ └────┬────┘ └────┬────┘ └────┬────┘              │
│          │    │        │           │           │                    │
│          │    └────────┴───────────┴───────────┘                    │
│          │                     │                                      │
│          └─────────────────────┘                                      │
│                                                                       │
└───────────────────────────────────────────────────────────────────────┘
```

**Step 4 세부 흐름**:
```
근본 원인 수준에 따라 적절한 작업 선택:

Level 1 (언어 스펙)     →  Spec 변경 → Parser → AST → Types → MIR → CodeGen
Level 2 (컴파일러 구조) →  IR 확장 → 변환기 수정 → 최적화 수정
Level 3 (최적화 패스)   →  패스 설계 → 구현 → 파이프라인 등록
Level 4 (코드 생성)     →  IR 분석 → 패턴 개선 → 코드젠 수정
Level 5 (런타임)        →  런타임 설계 → 구현 → 링킹 (⚠️ 최후 수단)
```

### 2.2. 각 단계 상세

#### Step 1: 벤치마크 실행

```bash
# 전체 벤치마크 실행
./ecosystem/benchmark-bmb/run.sh

# 특정 벤치마크 실행
./ecosystem/benchmark-bmb/run.sh fibonacci

# C/Rust 비교 실행
./ecosystem/benchmark-bmb/run.sh --compare
```

#### Step 2: 성능 측정 및 분석

| 비율 | 상태 | 조치 |
|------|------|------|
| ≤ 1.00x | ✅ BMB > C | 다음 벤치마크로 이동 |
| 1.00x ~ 1.10x | ✅ 동등 | 허용 가능, 최적화 선택적 |
| 1.10x ~ 1.50x | ⚠️ 느림 | 조사 필수 |
| > 1.50x | ❌ 심각 | 즉시 수정 필요 |

#### Step 3: 근본 원인 파악

**Decision Framework** (반드시 위에서부터 검토):

| 순위 | 수준 | 검토 질문 |
|------|------|----------|
| 1 | **언어 스펙** | 이 기능이 언어에 있어야 하는가? |
| 2 | **컴파일러 구조** | MIR/AST가 이를 표현할 수 있는가? |
| 3 | **최적화 패스** | 최적화 패스가 이를 처리하는가? |
| 4 | **코드 생성** | 생성되는 IR이 최적인가? |
| 5 | **런타임** | 런타임이 지원해야 하는가? |

**경고**: 낮은 수준에서 해결하려는 유혹을 경계하라. 1번에서 해결할 문제를 4번에서 해결하면 그것은 **workaround**다.

#### Step 4: 언어/컴파일러 수정

Step 3에서 파악한 **근본 원인 수준**에 따라 다른 작업을 수행합니다.

**핵심 원칙**:
- 스펙 변경이 필요하면 **스펙을 변경**한다
- 컴파일러 구조 변경이 필요하면 **구조를 변경**한다
- 작업량이 크다는 것은 하지 않을 이유가 **아니다**

##### 4.1. 언어 스펙 변경 (Level 1)

**트리거**: "이 기능이 언어에 있어야 하는가?"에 대한 답이 "예"인 경우

| 작업 | 상세 | 산출물 |
|------|------|--------|
| 문법 설계 | 새 구문의 형태 결정 | grammar.lalrpop 수정안 |
| 의미론 정의 | 타입 규칙, 실행 의미 정의 | SPECIFICATION.md 업데이트 |
| 파서 구현 | lalrpop 문법 수정 | `parser/grammar.lalrpop` |
| AST 확장 | 새 노드 타입 추가 | `ast/expr.rs`, `ast/types.rs` |
| 타입체커 확장 | 타입 규칙 구현 | `types/infer.rs` |
| 인터프리터 확장 | 평가 규칙 구현 | `interp/eval.rs` |

**예시**: `while` 루프 추가
```
문법: while <cond> { <body> }
의미론: cond가 참인 동안 body 반복
영향 범위: parser → ast → types → mir → codegen → bootstrap
```

##### 4.2. 컴파일러 구조 변경 (Level 2)

**트리거**: "MIR/AST가 이를 표현할 수 있는가?"에 대한 답이 "아니오"인 경우

| 작업 | 상세 | 산출물 |
|------|------|--------|
| IR 설계 | 새 IR 노드/필드 설계 | 설계 문서 |
| MIR 확장 | MirInstr, MirType 확장 | `mir/mod.rs` |
| CIR/PIR 확장 | 필요시 증명 IR 확장 | `cir/`, `pir/` |
| 변환기 수정 | AST→MIR, CIR→PIR 등 | `mir/lower.rs` 등 |

**예시**: tail call 표현
```
MIR 확장: is_tail: bool 필드 추가
영향 범위: mir → optimize → codegen
```

##### 4.3. 최적화 패스 추가/수정 (Level 3)

**트리거**: "최적화 패스가 이를 처리하는가?"에 대한 답이 "아니오"인 경우

| 작업 | 상세 | 산출물 |
|------|------|--------|
| 패스 설계 | 최적화 규칙 정의 | 설계 문서 |
| 패스 구현 | OptimizationPass trait 구현 | `mir/optimize/*.rs` |
| 통합 | 최적화 파이프라인에 등록 | `mir/optimize/mod.rs` |
| 검증 | 벤치마크로 효과 측정 | 벤치마크 결과 |

**예시**: Loop Invariant Code Motion (LICM)
```
패스: 루프 불변 코드를 루프 밖으로 이동
규칙: side-effect 없고 루프 변수 미의존 표현식 → 호이스팅
```

##### 4.4. 코드 생성 수정 (Level 4)

**트리거**: "생성되는 IR이 최적인가?"에 대한 답이 "아니오"인 경우

| 작업 | 상세 | 산출물 |
|------|------|--------|
| IR 분석 | 생성된 LLVM IR 검토 | 분석 보고서 |
| 패턴 식별 | 비최적 패턴 식별 | 개선 대상 목록 |
| 코드젠 수정 | 더 나은 IR 생성 | `codegen/llvm.rs` |
| 검증 | 어셈블리 비교 | diff 결과 |

**예시**: `musttail` 방출
```
문제: tail call이 일반 call로 생성
해결: LLVM IR에 musttail 키워드 방출
```

##### 4.5. 런타임 변경 (Level 5)

**트리거**: "런타임이 지원해야 하는가?"에 대한 답이 "예"인 경우

| 작업 | 상세 | 산출물 |
|------|------|--------|
| 런타임 설계 | 필요한 런타임 지원 정의 | 설계 문서 |
| 런타임 구현 | C/Rust로 런타임 함수 구현 | `runtime/` |
| 링킹 | 컴파일된 코드와 연결 | 빌드 시스템 수정 |

**경고**: 런타임에서 해결하려는 유혹을 경계하라. 대부분의 경우 더 높은 수준(1-4)에서 해결하는 것이 올바르다.

##### 4.6. 작업 완료 체크리스트

모든 변경에 대해:

- [ ] 영향받는 모든 컴포넌트 식별 완료
- [ ] 단위 테스트 추가/업데이트
- [ ] 통합 테스트 통과
- [ ] 문서 업데이트 (SPECIFICATION.md, ARCHITECTURE.md 등)
- [ ] 부트스트랩 컴파일러 업데이트 (언어 스펙 변경 시)

#### Step 5: 검증 및 반복

##### 5.1. 변경 검증

```bash
# 수정 후 벤치마크 재실행
./ecosystem/benchmark-bmb/run.sh

# 어셈블리 비교 (동일 IR 확인)
diff <(./target/release/bmb build test.bmb --emit-ir) expected.ll

# 전체 테스트 통과 확인
cargo test --release
```

##### 5.2. 검증 체크리스트

| 검증 항목 | 명령어 | 통과 기준 |
|----------|--------|----------|
| 단위 테스트 | `cargo test` | 모든 테스트 통과 |
| 벤치마크 | `./run_compare_all3.ps1` | 목표 성능 달성 |
| IR 비교 | `--emit-ir` + diff | 최적 IR 생성 |
| 부트스트랩 | bootstrap 재빌드 | 셀프 컴파일 성공 |

##### 5.3. 반복 판단

| 결과 | 조치 |
|------|------|
| ✅ 목표 달성 | 다음 벤치마크로 이동 |
| ⚠️ 부분 개선 | 동일 문제에 대해 더 높은 수준 검토 |
| ❌ 개선 없음 | Step 3으로 돌아가 근본 원인 재분석 |
| ❌ 회귀 발생 | 변경 롤백 후 대안 검토 |

##### 5.4. 캐스케이드 효과 처리

한 수준의 변경이 다른 수준에 영향을 줄 수 있습니다:

```
언어 스펙 변경 (L1)
    ↓ 필연적으로
컴파일러 구조 변경 (L2)
    ↓ 대부분
최적화 패스 추가/수정 (L3)
    ↓ 가능성 있음
코드 생성 조정 (L4)
```

**캐스케이드 발생 시**:
1. 전체 영향 범위를 먼저 파악
2. 위(L1)에서 아래(L5) 순서로 작업
3. 각 단계에서 테스트 통과 확인 후 다음 단계 진행

**목표 달성까지 반복**한다.

---

## 3. 성능 동등/추월의 유일한 조건

> **BMB >= C/Rust** 달성의 유일한 조건은 **동일한 IR 생성**입니다.

```
BMB Source → MIR → LLVM IR → Native Code
C Source   → Clang AST → LLVM IR → Native Code
                   ↓
            동일한 LLVM IR = 동일한 성능
```

### 동일 IR 검증 방법

```bash
# BMB IR 생성
./target/release/bmb build test.bmb --emit-ir -o bmb.ll

# C IR 생성
clang -O3 -S -emit-llvm test.c -o c.ll

# 비교 (핵심 로직)
diff bmb.ll c.ll
```

**C/Rust가 이미 최적화된 경우**, BMB가 동일한 IR을 생성하면 성능은 **동등**합니다.

---

## 4. 부정행위 금지

### 4.1. 금지된 행위

| 행위 | 설명 | 올바른 대응 |
|------|------|------------|
| **벤치마크 조작** | BMB에 유리하게 벤치마크 수정 | 공정한 비교 유지 |
| **불공정 비교** | 최적화 수준 불일치 | 동일 `-O3` 수준 |
| **작업량 불일치** | BMB가 더 적은 작업 수행 | 동일 작업량 보장 |
| **워크어라운드** | 근본 해결 대신 우회 | 언어/컴파일러 수정 |

### 4.2. 비판적 점검 체크리스트

모든 성능 개선에 대해:

- [ ] 벤치마크가 C/Rust와 동일한 작업을 수행하는가?
- [ ] 최적화 수준이 동일한가? (`-O3` vs `-O3`)
- [ ] 알고리즘이 동일한가? (O(n) vs O(n))
- [ ] 데이터 크기가 동일한가?
- [ ] 측정 방법이 공정한가? (warm-up, 반복 횟수)
- [ ] 이것은 workaround인가, proper fix인가?

---

## 5. 연구 및 조사 활용

### 5.1. 적극 활용 대상

| 영역 | 활용 사례 |
|------|----------|
| **최신 연구** | LLVM 최적화, 컴파일러 기법 |
| **수학** | 타입 이론, SMT 솔버 |
| **컴퓨터 공학** | CPU 아키텍처, 캐시 최적화 |
| **벤치마크 분석** | 성능 프로파일링, 어셈블리 분석 |

### 5.2. 조사 트리거

다음 상황에서 web-search/research 수행:

- 성능 차이 원인 불명확
- 최적화 기법 탐색 필요
- LLVM IR 패턴 조사
- 다른 언어의 해결책 참고

---

## 6. 원칙 요약

| 번호 | 원칙 | 설명 |
|------|------|------|
| **P1** | 성능 저하는 버그다 | 성능 문제 = 기능 버그 동일 심각도 |
| **P2** | Workaround 금지 | 근본 해결만 허용 |
| **P3** | 복잡도는 기피 사유 아님 | 어려운 해결책이 proper fix |
| **P4** | 언어 한계는 답이 아님 | 한계가 있으면 언어를 바꾼다 |
| **P5** | 측정 없는 주장 금지 | 모든 성능 주장은 벤치마크로 증명 |
| **P6** | 부정행위 금지 | 공정한 비교만 허용 |

---

## 관련 문서

- [DEVELOPMENT.md](DEVELOPMENT.md) - 개발 가이드라인
- [ROADMAP.md](ROADMAP.md) - 개발 로드맵
- [SPECIFICATION.md](SPECIFICATION.md) - 언어 스펙
- [ARCHITECTURE.md](ARCHITECTURE.md) - 컴파일러 아키텍처
- [COMPILER.md](COMPILER.md) - 컴파일러
