# BMB 갭 분석: 현재 구현 vs 이론적 최적

> 작성일: 2026-01-19
> 기반 문서: research-01.md, review-01.md, review-02.md

---

## Executive Summary

```
┌─────────────────────────────────────────────────────────────┐
│                    BMB 성능 갭 분석                          │
├─────────────────────────────────────────────────────────────┤
│  현재 추정 성능:  이론적 최적의 85~92%                       │
│  목표 성능:       이론적 최적의 97~99%                       │
│  개선 잠재력:     +5~14%p                                   │
├─────────────────────────────────────────────────────────────┤
│  제거 가능 비용:  ~10~15% → ~1~2%                           │
│  제거 불가 비용:  ~3~5% (NP-Hard, 물리적 한계)               │
└─────────────────────────────────────────────────────────────┘
```

---

## 1. 영역별 갭 분석

### 1.1 Bounds Checking

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| 내부 연산 | 0% | 런타임 검사 | **큼** |
| 외부 입력 | 1회 검사 | 1회 검사 | 없음 |
| 루프 인덱스 | 자동 증명 | 수동 | **큼** |

**현재 문제**:
```bmb
fn sum(arr: [i64]) -> i64 = {
    let mut total = 0;
    for i in 0..arr.len() {
        total = total + arr[i];  // 매번 런타임 bounds check
    }
    total
};
```

**성능 영향**: 0.5~3% (핫 루프에서 최대 10%)

**필요 기능**:
- `Fin[N]` 의존 타입 (유한 인덱스)
- 루프 인덱스 자동 Fin 추론
- 증명 전파 시스템

---

### 1.2 Integer Overflow

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| 범위 추론 | 자동 | 부분 | **중간** |
| 타입 승격 | 자동 | 없음 | **중간** |
| 증명 연동 | SMT 자동 | 수동 post | **중간** |

**현재 문제**:
```bmb
type Percentage = i64 where 0 <= self && self <= 100;

fn add(a: Percentage, b: Percentage) -> i64 = a + b;
// 결과 범위 0..200 자동 추론 안됨
// 오버플로우 검사가 필요할 수 있음
```

**성능 영향**: ~1% (Debug 모드에서 10~100x)

**필요 기능**:
- 산술 연산 범위 자동 추론
- 정제 타입 간 연산 규칙
- 자동 타입 승격 (i32 → i64)

---

### 1.3 Null Safety

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| Null 불가 참조 | 기본 | Option<T> | 없음 |
| 메모리 오버헤드 | 0 | 0 | 없음 |
| 패턴 매칭 강제 | 있음 | 있음 | 없음 |

**상태**: ✅ 이미 달성

---

### 1.4 Aliasing Analysis

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| noalias 활용 | 100% | ~0% | **큼** |
| 유일 참조 보장 | 타입 수준 | 없음 | **큼** |
| 벡터화 성공률 | 95%+ | LLVM 의존 (~70%) | **큼** |

**현재 문제**:
```bmb
fn compute(a: &mut [i64], b: &[i64], c: &[i64]) = {
    for i in 0..a.len() {
        a[i] = b[i] + c[i];  // a, b, c 겹침 가능성
    }                         // LLVM noalias 힌트 없음
};                            // 벡터화 실패 가능
```

**성능 영향**: 1~5% (벡터화 실패 시 2~8x)

**필요 기능**:
- `disjoint(a, b)` predicate
- `Unique[T]` 유일 참조 타입
- 효과 시스템 (`reads`, `writes`)
- MIR → LLVM noalias 변환

---

### 1.5 Virtual Dispatch

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| 정적 디스패치 | 기본 | 제네릭만 | **중간** |
| Devirtualization | WPA | 없음 | **중간** |
| Sealed 계층 | 지원 | 없음 | **중간** |

**성능 영향**: ~0.5%

**필요 기능**:
- `sealed` 키워드
- trait 시스템
- 전체 프로그램 분석

---

### 1.6 Exception Handling

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| 정상 경로 비용 | 0% | 0% (Result) | 없음 |
| 스택 되감기 | 없음 | 없음 | 없음 |

**상태**: ✅ 이미 달성 (Result<T, E> 패턴)

---

### 1.7 Floating Point Precision

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| 타입 수준 제어 | 지원 | 없음 | **작음** |
| fast-math 옵션 | 선택적 | 전역만 | **작음** |

**성능 영향**: 가변 (fast-math로 10~40% 향상 가능)

**필요 기능**:
- `IEEE754[f64]`, `Relaxed[f64]` 타입
- 함수/블록 수준 정밀도 제어

---

### 1.8 Auto-Vectorization

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| 성공률 | 95%+ | ~70% (LLVM) | **중간** |
| 진단 | IDE 통합 | 없음 | **중간** |
| 증명 기반 | 지원 | 없음 | **중간** |

**성능 영향**: 2~5%

**필요 기능**:
- `@vectorize` 어트리뷰트
- 벡터화 실패 진단
- Contract 기반 안전성 증명

---

### 1.9 LTO/PGO

| 항목 | 이론적 목표 | BMB 현재 | 갭 크기 |
|------|-----------|---------|--------|
| LTO | 기본 활성 | 미지원 | **큼** |
| PGO | 자동 통합 | 미지원 | **큼** |
| 증분 빌드 | 지원 | 없음 | **중간** |

**성능 영향**: 10~20%

**필요 기능**:
- LLVM LTO 플래그 연결
- PGO 워크플로우
- 프로젝트 설정 파일

---

## 2. 본질적 한계 (제거 불가)

| 영역 | 이유 | 예상 손실 |
|------|------|----------|
| 분기 예측 | 런타임 데이터 의존 (물리적 한계) | 1~2% |
| 레지스터 할당 | NP-Complete | 2~3% |
| 명령어 스케줄링 | NP-Hard | 1~2% |
| 캐시 미스 | 하드웨어 한계 | 1~2% |

**총 제거 불가 비용**: ~3~7%

---

## 3. 종합 갭 매트릭스

```
영역               현재    목표    갭     우선순위
─────────────────────────────────────────────────
Bounds Check       ███░░   █████   큼     P0
Overflow Check     ██░░░   █████   중간   P0
Null Safety        █████   █████   없음   완료
Aliasing           █░░░░   █████   큼     P1
Virtual Dispatch   ██░░░   █████   중간   P2
Exception          █████   █████   없음   완료
FP Precision       ██░░░   █████   작음   P2
Vectorization      ███░░   █████   중간   P1
LTO/PGO            ░░░░░   █████   큼     P1
```

---

## 4. BMB 강점 (이미 갖춤)

1. **Contract 시스템**: `pre`, `post`, `@trust`, `@check`
2. **Refinement Types**: `type T = i64 where P(self)`
3. **SMT Verification**: Z3 연동
4. **Option/Result ADT**: Null safety + Exception 대체
5. **LLVM 백엔드**: 네이티브 코드 생성

---

## 5. 개선 시 예상 성능

```
┌─────────────────────────────────────────────────────────────┐
│                    개선 후 예상 성능                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Phase 1 완료 후 (안전성 검사 제거):                         │
│    현재 ~87% → ~92% (+5%p)                                  │
│                                                             │
│  Phase 2 완료 후 (Aliasing 최적화):                         │
│    ~92% → ~95% (+3%p)                                       │
│                                                             │
│  Phase 3 완료 후 (LTO/PGO):                                 │
│    ~95% → ~98% (+3%p)                                       │
│                                                             │
│  최종 목표:                                                  │
│    이론적 최적의 97~99%                                      │
│    (본질적 한계 3~5% 제외)                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 6. 결론

BMB는 contract + refinement type + SMT라는 강력한 기반을 이미 갖추고 있습니다.
이를 **의존 타입 확장**, **범위 산술 추론**, **aliasing 증명**으로 연결하면
"증명된 zero-cost safety"라는 고유 포지션을 확보할 수 있습니다.

**핵심 메시지**:
> Rust는 컴파일 타임 안전성 + 런타임 비용 0.5~3%
> BMB는 컴파일 타임 안전성 + 런타임 비용 0% (SMT 증명)
