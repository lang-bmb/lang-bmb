//! AST to SMT-LIB2 translator
//!
//! Translates BMB expressions into SMT-LIB2 format strings.

use std::collections::HashMap;
use std::fmt::Write;

use crate::ast::{BinOp, Expr, FnDef, Spanned, Type, UnOp};

/// SMT-LIB2 code generator
#[derive(Debug, Default, Clone)]
pub struct SmtLibGenerator {
    /// Generated declarations
    declarations: Vec<String>,
    /// Generated assertions
    assertions: Vec<String>,
    /// Variable types for tracking
    var_types: HashMap<String, SmtSort>,
}

/// SMT sorts (types)
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SmtSort {
    Int,
    Bool,
}

impl SmtLibGenerator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Declare a variable with the given sort
    pub fn declare_var(&mut self, name: &str, sort: SmtSort) {
        let sort_str = match sort {
            SmtSort::Int => "Int",
            SmtSort::Bool => "Bool",
        };
        self.declarations.push(format!("(declare-const {} {})", name, sort_str));
        self.var_types.insert(name.to_string(), sort);
    }

    /// Add an assertion
    pub fn assert(&mut self, expr: &str) {
        self.assertions.push(format!("(assert {})", expr));
    }

    /// Generate complete SMT-LIB2 script
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Header
        writeln!(output, "; Generated by BMB compiler").unwrap();
        writeln!(output, "(set-logic QF_LIA)").unwrap();
        writeln!(output).unwrap();

        // Declarations
        for decl in &self.declarations {
            writeln!(output, "{}", decl).unwrap();
        }
        writeln!(output).unwrap();

        // Assertions
        for assertion in &self.assertions {
            writeln!(output, "{}", assertion).unwrap();
        }
        writeln!(output).unwrap();

        // Check and get model
        writeln!(output, "(check-sat)").unwrap();
        writeln!(output, "(get-model)").unwrap();

        output
    }

    /// Clear all declarations and assertions
    pub fn clear(&mut self) {
        self.declarations.clear();
        self.assertions.clear();
        self.var_types.clear();
    }
}

/// Translator from BMB AST to SMT-LIB2 expressions
pub struct SmtTranslator {
    /// Variable types
    var_types: HashMap<String, SmtSort>,
}

impl SmtTranslator {
    pub fn new() -> Self {
        Self {
            var_types: HashMap::new(),
        }
    }

    /// Set up the translator for a function definition
    pub fn setup_function(&mut self, func: &FnDef, generator: &mut SmtLibGenerator) {
        self.var_types.clear();

        // Declare parameters
        for param in &func.params {
            let sort = Self::type_to_sort(&param.ty.node);
            let name = &param.name.node;
            generator.declare_var(name, sort);
            self.var_types.insert(name.clone(), sort);
        }

        // Declare __ret__ for return value
        let ret_sort = Self::type_to_sort(&func.ret_ty.node);
        generator.declare_var("__ret__", ret_sort);
        self.var_types.insert("__ret__".to_string(), ret_sort);

        // v0.2: Also declare named return binding if present (e.g., -> r: i64)
        if let Some(ret_name) = &func.ret_name {
            generator.declare_var(&ret_name.node, ret_sort);
            self.var_types.insert(ret_name.node.clone(), ret_sort);
        }
    }

    /// Convert BMB Type to SMT Sort
    pub fn type_to_sort(ty: &Type) -> SmtSort {
        match ty {
            // v0.38: Include unsigned types, v0.64: Include char
            Type::I32 | Type::I64 | Type::U32 | Type::U64 | Type::F64 | Type::Char => SmtSort::Int,
            Type::Bool => SmtSort::Bool,
            Type::Unit => SmtSort::Bool, // Unit maps to true
            Type::String => SmtSort::Int, // String as Int (simplified) v0.5
            Type::Range(_) => SmtSort::Int, // Range as Int (simplified) v0.5 Phase 3
            Type::Named(_) => SmtSort::Int, // Named types default to Int for now
            // v0.13.1: Type variables treated as Int (unresolved)
            Type::TypeVar(_) => SmtSort::Int,
            // v0.13.1: Generic types treated as Int (simplified)
            Type::Generic { .. } => SmtSort::Int,
            Type::Struct { .. } => SmtSort::Int, // Struct types as Int (simplified)
            Type::Enum { .. } => SmtSort::Int, // Enum types as Int (simplified)
            // v0.5 Phase 5: References as Int (simplified)
            Type::Ref(_) | Type::RefMut(_) => SmtSort::Int,
            // v0.5 Phase 6: Arrays as Int (simplified)
            Type::Array(_, _) => SmtSort::Int,
            // v0.2: Refined types use base type sort
            Type::Refined { base, .. } => Self::type_to_sort(base),
            // v0.20.0: Fn types as Int (function pointers)
            Type::Fn { .. } => SmtSort::Int,
            // v0.31: Never type - represents unreachable code
            Type::Never => SmtSort::Bool,
            // v0.37: Nullable type - use same sort as inner (simplified for SMT)
            Type::Nullable(inner) => Self::type_to_sort(inner),
            // v0.42: Tuple type - use Int for now (simplified)
            Type::Tuple(_) => SmtSort::Int,
            // v0.51.37: Pointer type - use Int (addresses)
            Type::Ptr(_) => SmtSort::Int,
            // v0.70: Thread type - use Int for handle
            Type::Thread(_) => SmtSort::Int,
            // v0.71: Mutex type - use Int for handle
            Type::Mutex(_) => SmtSort::Int,
            // v0.72: Arc and Atomic types - use Int for handle
            Type::Arc(_) => SmtSort::Int,
            Type::Atomic(_) => SmtSort::Int,
            // v0.73: Sender and Receiver types - use Int for handle
            Type::Sender(_) => SmtSort::Int,
            Type::Receiver(_) => SmtSort::Int,
            // v0.74: RwLock, Barrier, Condvar - use Int for handle
            Type::RwLock(_) => SmtSort::Int,
            Type::Barrier => SmtSort::Int,
            Type::Condvar => SmtSort::Int,
            // v0.75: Future - use Int for handle
            Type::Future(_) => SmtSort::Int,
            // v0.83: AsyncFile - use Int for handle
            Type::AsyncFile => SmtSort::Int,
            // v0.83.1: AsyncSocket - use Int for handle
            Type::AsyncSocket => SmtSort::Int,
            // v0.84: ThreadPool - use Int for handle
            Type::ThreadPool => SmtSort::Int,
            // v0.85: Scope - use Int for handle
            Type::Scope => SmtSort::Int,
        }
    }

    /// Translate a BMB expression to SMT-LIB2 string
    pub fn translate(&self, expr: &Spanned<Expr>) -> Result<String, TranslateError> {
        self.translate_expr(&expr.node)
    }

    fn translate_expr(&self, expr: &Expr) -> Result<String, TranslateError> {
        match expr {
            Expr::IntLit(n) => {
                if *n >= 0 {
                    Ok(n.to_string())
                } else {
                    Ok(format!("(- {})", -n))
                }
            }

            Expr::FloatLit(f) => {
                // Approximate as integer
                let n = *f as i64;
                if n >= 0 {
                    Ok(n.to_string())
                } else {
                    Ok(format!("(- {})", -n))
                }
            }

            Expr::BoolLit(b) => Ok(b.to_string()),

            Expr::StringLit(_) => {
                // Strings not fully supported in SMT - approximate as 0
                Ok("0".to_string())
            }

            // v0.64: Character literal - represented as integer (char code)
            Expr::CharLit(c) => {
                let n = *c as i64;
                Ok(n.to_string())
            }

            Expr::Unit => Ok("true".to_string()),

            // v0.51.40: Null pointer literal - represented as 0
            Expr::Null => Ok("0".to_string()),

            // v0.51.41: Sizeof - approximate as constant (SMT doesn't track memory layout)
            Expr::Sizeof { .. } => Ok("8".to_string()),

            // v0.70: Spawn - threads are not relevant for SMT verification
            // Just return a placeholder integer (thread handle)
            Expr::Spawn { .. } => Ok("0".to_string()),

            // v0.72: Atomic creation - not relevant for SMT verification
            // Just return a placeholder integer (atomic handle)
            Expr::AtomicNew { .. } => Ok("0".to_string()),

            // v0.71: Mutex creation - not relevant for SMT verification
            // Just return a placeholder integer (mutex handle)
            Expr::MutexNew { .. } => Ok("0".to_string()),

            // v0.73: Channel creation - not relevant for SMT verification
            // Just return a placeholder tuple (sender, receiver handles)
            Expr::ChannelNew { .. } => Ok("(tuple 0 0)".to_string()),

            // v0.74: RwLock, Barrier, Condvar - not relevant for SMT verification
            Expr::RwLockNew { .. } => Ok("0".to_string()),
            Expr::BarrierNew { .. } => Ok("0".to_string()),
            Expr::CondvarNew => Ok("0".to_string()),
            // v0.75: Await - not relevant for SMT verification
            Expr::Await { future } => self.translate(future),
            // v0.82: Select - not relevant for SMT verification (runtime construct)
            Expr::Select { .. } => Ok("0".to_string()),

            Expr::Var(name) => {
                if self.var_types.contains_key(name) {
                    Ok(name.clone())
                } else {
                    Err(TranslateError::UndefinedVariable(name.clone()))
                }
            }

            Expr::Ret => {
                if self.var_types.contains_key("__ret__") {
                    Ok("__ret__".to_string())
                } else {
                    Err(TranslateError::RetNotDefined)
                }
            }

            Expr::Binary { left, op, right } => {
                let l = self.translate(left)?;
                let r = self.translate(right)?;
                self.translate_binary(&l, *op, &r)
            }

            Expr::Unary { op, expr } => {
                let e = self.translate(expr)?;
                self.translate_unary(*op, &e)
            }

            Expr::If { cond, then_branch, else_branch } => {
                let c = self.translate(cond)?;
                let t = self.translate(then_branch)?;
                let e = self.translate(else_branch)?;
                Ok(format!("(ite {} {} {})", c, t, e))
            }

            Expr::Let { name, mutable: _, ty: _, value, body } => {
                // For SMT-LIB, we use let binding
                let v = self.translate(value)?;
                let b = self.translate(body)?;
                Ok(format!("(let (({} {})) {})", name, v, b))
            }

            // v0.60.21: Uninitialized let binding - for SMT verification, treat as uninterpreted
            Expr::LetUninit { name, mutable: _, ty: _, body } => {
                // For SMT-LIB, declare variable without value (uninitialized)
                let b = self.translate(body)?;
                // Use a fresh constant for uninitialized value
                Ok(format!("(let (({} undefined_array)) {})", name, b))
            }

            Expr::Assign { name, .. } => {
                // Assignment not fully supported in pure SMT
                Err(TranslateError::UnsupportedFeature(format!("assignment: {}", name)))
            }

            Expr::While { .. } => {
                // While loops not supported in SMT
                Err(TranslateError::UnsupportedFeature("while loop".to_string()))
            }

            Expr::Call { func, args: _ } => {
                Err(TranslateError::UnsupportedFeature(format!("function call: {}", func)))
            }

            Expr::Block(exprs) => {
                if let Some(last) = exprs.last() {
                    self.translate(last)
                } else {
                    Ok("true".to_string())
                }
            }

            // v0.5: Struct and Enum expressions - not fully supported in SMT
            Expr::StructInit { name, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("struct init: {}", name)))
            }

            Expr::FieldAccess { field, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("field access: {}", field.node)))
            }

            // v0.51.23: Field assignment
            Expr::FieldAssign { field, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("field assignment: {}", field.node)))
            }

            // v0.60.21: Dereference assignment
            Expr::DerefAssign { .. } => {
                Err(TranslateError::UnsupportedFeature("dereference assignment".to_string()))
            }

            // v0.43: Tuple field access
            Expr::TupleField { index, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("tuple field access: .{}", index)))
            }

            Expr::EnumVariant { enum_name, variant, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("enum variant: {}::{}", enum_name, variant)))
            }

            Expr::Match { .. } => {
                Err(TranslateError::UnsupportedFeature("match expression".to_string()))
            }

            // v0.5 Phase 3: Range and For expressions - not supported in SMT
            Expr::Range { .. } => {
                Err(TranslateError::UnsupportedFeature("range expression".to_string()))
            }

            Expr::For { .. } => {
                Err(TranslateError::UnsupportedFeature("for loop".to_string()))
            }

            // v0.5 Phase 5: References - not supported in SMT
            Expr::Ref(_) | Expr::RefMut(_) => {
                Err(TranslateError::UnsupportedFeature("reference".to_string()))
            }

            Expr::Deref(_) => {
                Err(TranslateError::UnsupportedFeature("dereference".to_string()))
            }

            // v0.5 Phase 6: Arrays - not supported in SMT
            Expr::ArrayLit(_) => {
                Err(TranslateError::UnsupportedFeature("array literal".to_string()))
            }

            // v0.60.22: Array repeat - not supported in SMT
            Expr::ArrayRepeat { .. } => {
                Err(TranslateError::UnsupportedFeature("array repeat".to_string()))
            }

            // v0.42: Tuple expressions - not supported in SMT
            Expr::Tuple(_) => {
                Err(TranslateError::UnsupportedFeature("tuple expression".to_string()))
            }

            Expr::Index { .. } => {
                Err(TranslateError::UnsupportedFeature("array index".to_string()))
            }

            // v0.51: Index assignment - not supported in SMT
            Expr::IndexAssign { .. } => {
                Err(TranslateError::UnsupportedFeature("array index assignment".to_string()))
            }

            // v0.5 Phase 8: Method calls - not supported in SMT
            Expr::MethodCall { .. } => {
                Err(TranslateError::UnsupportedFeature("method call".to_string()))
            }

            // v0.2: State references for contracts
            Expr::StateRef { expr, state } => {
                let base = self.translate_expr(&expr.node)?;
                // Append state suffix to create unique SMT variable
                // e.g., x.pre -> x_pre, x.post -> x_post
                let suffix = match state {
                    crate::ast::StateKind::Pre => "_pre",
                    crate::ast::StateKind::Post => "_post",
                };
                Ok(format!("{}{}", base, suffix))
            }

            // v0.2: Refinement self-reference
            Expr::It => Ok("__it__".to_string()),

            // v0.20.0: Closure expressions
            // Closures are currently not supported in SMT verification
            // They would require higher-order logic which is not in SMT-LIB2 core
            Expr::Closure { .. } => Err(TranslateError::UnsupportedFeature(
                "closures are not supported in contract verification".to_string(),
            )),

            // v0.31: Todo expression
            // In SMT context, todo represents unreachable code (absurd/false)
            // Any constraints involving todo are vacuously satisfied
            Expr::Todo { .. } => Ok("false".to_string()),

            // v0.36: Additional control flow
            // These are not verifiable in SMT context, return false (unreachable)
            Expr::Loop { .. } => Err(TranslateError::UnsupportedFeature(
                "loops are not supported in contract verification".to_string(),
            )),
            Expr::Break { .. } => Ok("false".to_string()),
            Expr::Continue => Ok("false".to_string()),
            Expr::Return { .. } => Ok("false".to_string()),

            // v0.37: Quantifiers - translate directly to SMT-LIB2 forall/exists
            Expr::Forall { var, ty, body } => {
                let smt_type = self.type_to_smt(&ty.node)?;
                let body_smt = self.translate(body)?;
                Ok(format!("(forall (({} {})) {})", var.node, smt_type, body_smt))
            }

            Expr::Exists { var, ty, body } => {
                let smt_type = self.type_to_smt(&ty.node)?;
                let body_smt = self.translate(body)?;
                Ok(format!("(exists (({} {})) {})", var.node, smt_type, body_smt))
            }

            // v0.39: Type cast - in SMT we just use the inner expression
            // Type safety is already verified by the type checker
            Expr::Cast { expr, ty: _ } => {
                self.translate(expr)
            }
        }
    }

    fn translate_binary(&self, left: &str, op: BinOp, right: &str) -> Result<String, TranslateError> {
        let smt_op = match op {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "div",
            BinOp::Mod => "mod",
            // v0.37: Wrapping arithmetic - for SMT, treat as regular arithmetic
            // (overflow semantics not captured in SMT-LIB integer theory)
            BinOp::AddWrap => "+",
            BinOp::SubWrap => "-",
            BinOp::MulWrap => "*",
            // v0.38: Checked arithmetic - for SMT, treat as regular arithmetic
            // (Option wrapping not captured in SMT-LIB)
            BinOp::AddChecked => "+",
            BinOp::SubChecked => "-",
            BinOp::MulChecked => "*",
            // v0.38: Saturating arithmetic - for SMT, treat as regular arithmetic
            // (saturation semantics not captured in SMT-LIB)
            BinOp::AddSat => "+",
            BinOp::SubSat => "-",
            BinOp::MulSat => "*",
            BinOp::Eq => "=",
            BinOp::Ne => return Ok(format!("(not (= {} {}))", left, right)),
            BinOp::Lt => "<",
            BinOp::Gt => ">",
            BinOp::Le => "<=",
            BinOp::Ge => ">=",
            BinOp::And => "and",
            BinOp::Or => "or",
            // v0.32: Shift operators - not directly supported in SMT-LIB integer arithmetic
            // Return error for now; shift operations are rarely used in contracts
            BinOp::Shl => return Err(TranslateError::UnsupportedFeature("shift left operator (<<) in contracts".to_string())),
            BinOp::Shr => return Err(TranslateError::UnsupportedFeature("shift right operator (>>) in contracts".to_string())),
            // v0.36: Bitwise operators - not directly supported in SMT-LIB integer arithmetic
            // Return error for now; bitwise operations are rarely used in contracts
            BinOp::Band => return Err(TranslateError::UnsupportedFeature("bitwise AND operator (band) in contracts".to_string())),
            BinOp::Bor => return Err(TranslateError::UnsupportedFeature("bitwise OR operator (bor) in contracts".to_string())),
            BinOp::Bxor => return Err(TranslateError::UnsupportedFeature("bitwise XOR operator (bxor) in contracts".to_string())),
            // v0.36: Logical implication - SMT-LIB uses => for implication
            BinOp::Implies => "=>",
        };
        Ok(format!("({} {} {})", smt_op, left, right))
    }

    fn translate_unary(&self, op: UnOp, expr: &str) -> Result<String, TranslateError> {
        match op {
            UnOp::Neg => Ok(format!("(- {})", expr)),
            UnOp::Not => Ok(format!("(not {})", expr)),
            // v0.36: Bitwise not - not directly supported in SMT-LIB integer arithmetic
            UnOp::Bnot => Err(TranslateError::UnsupportedFeature("bitwise NOT operator (bnot) in contracts".to_string())),
        }
    }

    /// v0.37: Convert BMB type to SMT-LIB sort
    fn type_to_smt(&self, ty: &crate::ast::Type) -> Result<String, TranslateError> {
        use crate::ast::Type;
        match ty {
            // v0.38: Include unsigned types
            Type::I32 | Type::I64 | Type::U32 | Type::U64 => Ok("Int".to_string()),
            Type::F64 => Ok("Real".to_string()),
            Type::Bool => Ok("Bool".to_string()),
            Type::String => Err(TranslateError::UnsupportedFeature(
                "String type in quantifier".to_string()
            )),
            Type::Unit => Err(TranslateError::UnsupportedFeature(
                "Unit type in quantifier".to_string()
            )),
            Type::Named(name) => Err(TranslateError::UnsupportedFeature(
                format!("Named type '{}' in quantifier", name)
            )),
            _ => Err(TranslateError::UnsupportedFeature(
                format!("type {:?} in quantifier", ty)
            )),
        }
    }

    /// Get variable types
    pub fn var_types(&self) -> &HashMap<String, SmtSort> {
        &self.var_types
    }
}

impl Default for SmtTranslator {
    fn default() -> Self {
        Self::new()
    }
}

/// Errors during translation
#[derive(Debug, Clone)]
pub enum TranslateError {
    UndefinedVariable(String),
    TypeMismatch(String),
    UnsupportedFeature(String),
    RetNotDefined,
}

impl std::fmt::Display for TranslateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TranslateError::UndefinedVariable(name) => write!(f, "undefined variable: {}", name),
            TranslateError::TypeMismatch(msg) => write!(f, "type mismatch: {}", msg),
            TranslateError::UnsupportedFeature(msg) => write!(f, "unsupported: {}", msg),
            TranslateError::RetNotDefined => write!(f, "'ret' not defined"),
        }
    }
}

impl std::error::Error for TranslateError {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::Span;

    fn span() -> Span { Span::new(0, 0) }
    fn spanned(e: Expr) -> Spanned<Expr> { Spanned::new(e, span()) }

    // ================================================================
    // Literal Translation Tests
    // ================================================================

    #[test]
    fn test_int_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::IntLit(42));
        assert_eq!(trans.translate(&expr).unwrap(), "42");
    }

    #[test]
    fn test_negative_int() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::IntLit(-5));
        assert_eq!(trans.translate(&expr).unwrap(), "(- 5)");
    }

    #[test]
    fn test_int_zero() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::IntLit(0));
        assert_eq!(trans.translate(&expr).unwrap(), "0");
    }

    #[test]
    fn test_bool_lit_true() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::BoolLit(true));
        assert_eq!(trans.translate(&expr).unwrap(), "true");
    }

    #[test]
    fn test_bool_lit_false() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::BoolLit(false));
        assert_eq!(trans.translate(&expr).unwrap(), "false");
    }

    #[test]
    fn test_unit_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Unit);
        assert_eq!(trans.translate(&expr).unwrap(), "true");
    }

    #[test]
    fn test_string_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::StringLit("hello".to_string()));
        assert_eq!(trans.translate(&expr).unwrap(), "0");
    }

    #[test]
    fn test_char_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::CharLit('A'));
        assert_eq!(trans.translate(&expr).unwrap(), "65");
    }

    #[test]
    fn test_null_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Null);
        assert_eq!(trans.translate(&expr).unwrap(), "0");
    }

    // ================================================================
    // Variable Translation Tests
    // ================================================================

    #[test]
    fn test_var_known() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Var("x".to_string()));
        assert_eq!(trans.translate(&expr).unwrap(), "x");
    }

    #[test]
    fn test_var_unknown() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Var("x".to_string()));
        assert!(trans.translate(&expr).is_err());
    }

    #[test]
    fn test_ret_with_ret_declared() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("__ret__".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Ret);
        assert_eq!(trans.translate(&expr).unwrap(), "__ret__");
    }

    #[test]
    fn test_ret_without_ret_declared() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Ret);
        assert!(trans.translate(&expr).is_err());
    }

    // ================================================================
    // Binary Operation Translation Tests
    // ================================================================

    #[test]
    fn test_binary_add() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("a".to_string(), SmtSort::Int);
        trans.var_types.insert("b".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("a".to_string()))),
            op: BinOp::Add,
            right: Box::new(spanned(Expr::Var("b".to_string()))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(+ a b)");
    }

    #[test]
    fn test_binary_sub() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(10))),
            op: BinOp::Sub,
            right: Box::new(spanned(Expr::IntLit(3))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(- 10 3)");
    }

    #[test]
    fn test_binary_mul() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(4))),
            op: BinOp::Mul,
            right: Box::new(spanned(Expr::IntLit(5))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(* 4 5)");
    }

    #[test]
    fn test_binary_div() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(10))),
            op: BinOp::Div,
            right: Box::new(spanned(Expr::IntLit(2))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(div 10 2)");
    }

    #[test]
    fn test_binary_mod() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(7))),
            op: BinOp::Mod,
            right: Box::new(spanned(Expr::IntLit(3))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(mod 7 3)");
    }

    #[test]
    fn test_binary_eq() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("x".to_string()))),
            op: BinOp::Eq,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(= x 0)");
    }

    #[test]
    fn test_binary_ne() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("x".to_string()))),
            op: BinOp::Ne,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(not (= x 0))");
    }

    #[test]
    fn test_binary_comparisons() {
        let trans = SmtTranslator::new();

        for (op, expected) in [
            (BinOp::Lt, "(< 1 2)"),
            (BinOp::Gt, "(> 1 2)"),
            (BinOp::Le, "(<= 1 2)"),
            (BinOp::Ge, "(>= 1 2)"),
        ] {
            let expr = spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(1))),
                op,
                right: Box::new(spanned(Expr::IntLit(2))),
            });
            assert_eq!(trans.translate(&expr).unwrap(), expected, "Failed for op {:?}", op);
        }
    }

    #[test]
    fn test_binary_logical() {
        let trans = SmtTranslator::new();

        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::BoolLit(true))),
            op: BinOp::And,
            right: Box::new(spanned(Expr::BoolLit(false))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(and true false)");

        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::BoolLit(true))),
            op: BinOp::Or,
            right: Box::new(spanned(Expr::BoolLit(false))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(or true false)");
    }

    #[test]
    fn test_binary_implies() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::BoolLit(true))),
            op: BinOp::Implies,
            right: Box::new(spanned(Expr::BoolLit(false))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(=> true false)");
    }

    #[test]
    fn test_binary_shift_unsupported() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(1))),
            op: BinOp::Shl,
            right: Box::new(spanned(Expr::IntLit(2))),
        });
        assert!(trans.translate(&expr).is_err());
    }

    // ================================================================
    // Unary Operation Translation Tests
    // ================================================================

    #[test]
    fn test_unary_neg() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Unary {
            op: UnOp::Neg,
            expr: Box::new(spanned(Expr::IntLit(5))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(- 5)");
    }

    #[test]
    fn test_unary_not() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Unary {
            op: UnOp::Not,
            expr: Box::new(spanned(Expr::BoolLit(true))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(not true)");
    }

    #[test]
    fn test_unary_bnot_unsupported() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Unary {
            op: UnOp::Bnot,
            expr: Box::new(spanned(Expr::IntLit(5))),
        });
        assert!(trans.translate(&expr).is_err());
    }

    // ================================================================
    // Compound Expression Tests
    // ================================================================

    #[test]
    fn test_if_then_else() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::If {
            cond: Box::new(spanned(Expr::BoolLit(true))),
            then_branch: Box::new(spanned(Expr::IntLit(1))),
            else_branch: Box::new(spanned(Expr::IntLit(0))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(ite true 1 0)");
    }

    #[test]
    fn test_nested_binary() {
        // (1 + 2) * 3
        let trans = SmtTranslator::new();
        let inner = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(1))),
            op: BinOp::Add,
            right: Box::new(spanned(Expr::IntLit(2))),
        });
        let expr = spanned(Expr::Binary {
            left: Box::new(inner),
            op: BinOp::Mul,
            right: Box::new(spanned(Expr::IntLit(3))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(* (+ 1 2) 3)");
    }

    // ================================================================
    // SmtLibGenerator Tests
    // ================================================================

    #[test]
    fn test_generator_declare_and_assert() {
        let mut generator = SmtLibGenerator::new();
        generator.declare_var("x", SmtSort::Int);
        generator.assert("(> x 0)");
        let output = generator.generate();
        assert!(output.contains("(declare-const x Int)"));
        assert!(output.contains("(assert (> x 0))"));
        assert!(output.contains("(check-sat)"));
    }

    #[test]
    fn test_generator_clear() {
        let mut generator = SmtLibGenerator::new();
        generator.declare_var("x", SmtSort::Int);
        generator.clear();
        let output = generator.generate();
        assert!(!output.contains("declare-const x"));
    }

    // ================================================================
    // Type Sort Conversion Tests
    // ================================================================

    #[test]
    fn test_type_to_sort_basic() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::I64), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::I32), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Bool), SmtSort::Bool);
        assert_eq!(SmtTranslator::type_to_sort(&Type::F64), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Unit), SmtSort::Bool);
    }

    #[test]
    fn test_type_to_sort_concurrency() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Barrier), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Condvar), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::ThreadPool), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Scope), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::AsyncFile), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::AsyncSocket), SmtSort::Int);
    }

    // ---- Cycle 74: Additional SMT translator tests ----

    #[test]
    fn test_type_to_sort_ptr_ref() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Ptr(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Ref(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::RefMut(Box::new(Type::I64))), SmtSort::Int);
    }

    #[test]
    fn test_type_to_sort_array_tuple() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Array(Box::new(Type::I64), 10)), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Tuple(vec![Box::new(Type::I64)])), SmtSort::Int);
    }

    #[test]
    fn test_type_to_sort_nullable() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Nullable(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Nullable(Box::new(Type::Bool))), SmtSort::Bool);
    }

    #[test]
    fn test_type_to_sort_refined() {
        let refined = Type::Refined {
            base: Box::new(Type::I64),
            constraints: vec![Spanned::new(Expr::BoolLit(true), span())],
        };
        assert_eq!(SmtTranslator::type_to_sort(&refined), SmtSort::Int);
    }

    #[test]
    fn test_type_to_sort_never() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Never), SmtSort::Bool);
    }

    #[test]
    fn test_type_to_sort_string_named() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::String), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Named("Foo".to_string())), SmtSort::Int);
    }

    #[test]
    fn test_float_lit_positive() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::FloatLit(3.7));
        assert_eq!(trans.translate(&expr).unwrap(), "3");
    }

    #[test]
    fn test_float_lit_negative() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::FloatLit(-2.5));
        assert_eq!(trans.translate(&expr).unwrap(), "(- 2)");
    }

    #[test]
    fn test_todo_expr() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Todo { message: None });
        assert_eq!(trans.translate(&expr).unwrap(), "false");
    }

    #[test]
    fn test_break_continue_return() {
        let trans = SmtTranslator::new();
        assert_eq!(trans.translate(&spanned(Expr::Break { value: None })).unwrap(), "false");
        assert_eq!(trans.translate(&spanned(Expr::Continue)).unwrap(), "false");
        assert_eq!(trans.translate(&spanned(Expr::Return { value: None })).unwrap(), "false");
    }

    #[test]
    fn test_it_expr() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::It);
        assert_eq!(trans.translate(&expr).unwrap(), "__it__");
    }

    #[test]
    fn test_sizeof_expr() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Sizeof { ty: Spanned::new(Type::I64, span()) });
        assert_eq!(trans.translate(&expr).unwrap(), "8");
    }

    #[test]
    fn test_block_expr_empty() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Block(vec![]));
        assert_eq!(trans.translate(&expr).unwrap(), "true");
    }

    #[test]
    fn test_block_expr_last() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Block(vec![
            spanned(Expr::IntLit(1)),
            spanned(Expr::IntLit(2)),
            spanned(Expr::IntLit(42)),
        ]));
        assert_eq!(trans.translate(&expr).unwrap(), "42");
    }

    #[test]
    fn test_let_expr() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Let {
            name: "x".to_string(),
            mutable: false,
            ty: Some(Spanned::new(Type::I64, span())),
            value: Box::new(spanned(Expr::IntLit(5))),
            body: Box::new(spanned(Expr::IntLit(10))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(let ((x 5)) 10)");
    }

    #[test]
    fn test_wrapping_arithmetic() {
        let trans = SmtTranslator::new();
        for (op, expected_smt) in [
            (BinOp::AddWrap, "+"),
            (BinOp::SubWrap, "-"),
            (BinOp::MulWrap, "*"),
        ] {
            let expr = spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(1))),
                op,
                right: Box::new(spanned(Expr::IntLit(2))),
            });
            let result = trans.translate(&expr).unwrap();
            assert!(result.contains(expected_smt), "Op {:?} should use {}", op, expected_smt);
        }
    }

    #[test]
    fn test_translate_error_display() {
        let e1 = TranslateError::UndefinedVariable("x".to_string());
        assert_eq!(format!("{}", e1), "undefined variable: x");

        let e2 = TranslateError::TypeMismatch("int vs bool".to_string());
        assert_eq!(format!("{}", e2), "type mismatch: int vs bool");

        let e3 = TranslateError::UnsupportedFeature("loops".to_string());
        assert_eq!(format!("{}", e3), "unsupported: loops");

        let e4 = TranslateError::RetNotDefined;
        assert_eq!(format!("{}", e4), "'ret' not defined");
    }

    #[test]
    fn test_unsupported_features() {
        let trans = SmtTranslator::new();

        assert!(trans.translate(&spanned(Expr::While {
            cond: Box::new(spanned(Expr::BoolLit(true))),
            invariant: None,
            body: Box::new(spanned(Expr::Unit)),
        })).is_err());

        assert!(trans.translate(&spanned(Expr::ArrayLit(vec![]))).is_err());
        assert!(trans.translate(&spanned(Expr::Tuple(vec![]))).is_err());

        assert!(trans.translate(&spanned(Expr::Match {
            expr: Box::new(spanned(Expr::IntLit(0))),
            arms: vec![],
        })).is_err());
    }

    #[test]
    fn test_generator_header_and_footer() {
        let generator = SmtLibGenerator::new();
        let output = generator.generate();
        assert!(output.contains("; Generated by BMB compiler"));
        assert!(output.contains("(set-logic QF_LIA)"));
        assert!(output.contains("(check-sat)"));
        assert!(output.contains("(get-model)"));
    }

    #[test]
    fn test_generator_bool_sort() {
        let mut generator = SmtLibGenerator::new();
        generator.declare_var("flag", SmtSort::Bool);
        let output = generator.generate();
        assert!(output.contains("(declare-const flag Bool)"));
    }

    #[test]
    fn test_translator_default() {
        let trans = SmtTranslator::default();
        assert!(trans.var_types().is_empty());
    }

    #[test]
    fn test_smt_sort_eq() {
        assert_eq!(SmtSort::Int, SmtSort::Int);
        assert_eq!(SmtSort::Bool, SmtSort::Bool);
        assert_ne!(SmtSort::Int, SmtSort::Bool);
    }

    #[test]
    fn test_bitwise_ops_unsupported() {
        let trans = SmtTranslator::new();
        for op in [BinOp::Band, BinOp::Bor, BinOp::Bxor, BinOp::Shr] {
            let expr = spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(1))),
                op,
                right: Box::new(spanned(Expr::IntLit(2))),
            });
            assert!(trans.translate(&expr).is_err(), "Op {:?} should be unsupported", op);
        }
    }

    // ================================================================
    // Cycles 119-120: Additional SMT Translator Tests
    // ================================================================

    #[test]
    fn test_checked_arithmetic_translates_as_regular() {
        let trans = SmtTranslator::new();
        for (op, expected_smt) in [
            (BinOp::AddChecked, "+"),
            (BinOp::SubChecked, "-"),
            (BinOp::MulChecked, "*"),
        ] {
            let expr = spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(3))),
                op,
                right: Box::new(spanned(Expr::IntLit(4))),
            });
            let result = trans.translate(&expr).unwrap();
            assert!(result.contains(expected_smt), "Checked op {:?} should use {}", op, expected_smt);
        }
    }

    #[test]
    fn test_saturating_arithmetic_translates_as_regular() {
        let trans = SmtTranslator::new();
        for (op, expected_smt) in [
            (BinOp::AddSat, "+"),
            (BinOp::SubSat, "-"),
            (BinOp::MulSat, "*"),
        ] {
            let expr = spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(10))),
                op,
                right: Box::new(spanned(Expr::IntLit(20))),
            });
            let result = trans.translate(&expr).unwrap();
            assert!(result.contains(expected_smt), "Saturating op {:?} should use {}", op, expected_smt);
        }
    }

    #[test]
    fn test_cast_translates_inner_expression() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Cast {
            expr: Box::new(spanned(Expr::IntLit(42))),
            ty: Spanned::new(Type::F64, span()),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "42");
    }

    #[test]
    fn test_spawn_translates_to_zero() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Spawn {
            body: Box::new(spanned(Expr::IntLit(1))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "0");
    }

    #[test]
    fn test_concurrency_creation_exprs_translate_to_zero() {
        let trans = SmtTranslator::new();

        let mutex = spanned(Expr::MutexNew { value: Box::new(spanned(Expr::IntLit(0))) });
        assert_eq!(trans.translate(&mutex).unwrap(), "0");

        let atomic = spanned(Expr::AtomicNew { value: Box::new(spanned(Expr::IntLit(0))) });
        assert_eq!(trans.translate(&atomic).unwrap(), "0");

        let rwlock = spanned(Expr::RwLockNew { value: Box::new(spanned(Expr::IntLit(0))) });
        assert_eq!(trans.translate(&rwlock).unwrap(), "0");

        let barrier = spanned(Expr::BarrierNew { count: Box::new(spanned(Expr::IntLit(4))) });
        assert_eq!(trans.translate(&barrier).unwrap(), "0");

        let condvar = spanned(Expr::CondvarNew);
        assert_eq!(trans.translate(&condvar).unwrap(), "0");
    }

    #[test]
    fn test_type_to_sort_generic_fn_typevar() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::TypeVar("T".to_string())), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Generic {
            name: "Vec".to_string(),
            type_args: vec![Box::new(Type::I64)],
        }), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Fn {
            params: vec![],
            ret: Box::new(Type::I64),
        }), SmtSort::Int);
    }

    #[test]
    fn test_type_to_sort_channel_thread_types() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Sender(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Receiver(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Thread(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Future(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Mutex(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Arc(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Atomic(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::RwLock(Box::new(Type::I64))), SmtSort::Int);
    }

    #[test]
    fn test_type_to_smt_for_quantifiers() {
        let trans = SmtTranslator::new();
        assert_eq!(trans.type_to_smt(&Type::I64).unwrap(), "Int");
        assert_eq!(trans.type_to_smt(&Type::I32).unwrap(), "Int");
        assert_eq!(trans.type_to_smt(&Type::U32).unwrap(), "Int");
        assert_eq!(trans.type_to_smt(&Type::U64).unwrap(), "Int");
        assert_eq!(trans.type_to_smt(&Type::F64).unwrap(), "Real");
        assert_eq!(trans.type_to_smt(&Type::Bool).unwrap(), "Bool");
        // String and Unit should be unsupported in quantifiers
        assert!(trans.type_to_smt(&Type::String).is_err());
        assert!(trans.type_to_smt(&Type::Unit).is_err());
    }

    #[test]
    fn test_nested_if_then_else_legacy() {
        let trans = SmtTranslator::new();
        let inner_if = spanned(Expr::If {
            cond: Box::new(spanned(Expr::BoolLit(false))),
            then_branch: Box::new(spanned(Expr::IntLit(2))),
            else_branch: Box::new(spanned(Expr::IntLit(3))),
        });
        let outer = spanned(Expr::If {
            cond: Box::new(spanned(Expr::BoolLit(true))),
            then_branch: Box::new(spanned(Expr::IntLit(1))),
            else_branch: Box::new(inner_if),
        });
        assert_eq!(trans.translate(&outer).unwrap(), "(ite true 1 (ite false 2 3))");
    }

    #[test]
    fn test_generator_multiple_assertions() {
        let mut generator = SmtLibGenerator::new();
        generator.declare_var("x", SmtSort::Int);
        generator.declare_var("y", SmtSort::Int);
        generator.assert("(> x 0)");
        generator.assert("(> y 0)");
        generator.assert("(< (+ x y) 100)");
        let output = generator.generate();
        assert!(output.contains("(declare-const x Int)"));
        assert!(output.contains("(declare-const y Int)"));
        assert!(output.contains("(assert (> x 0))"));
        assert!(output.contains("(assert (> y 0))"));
        assert!(output.contains("(assert (< (+ x y) 100))"));
    }

    // ================================================================
    // Cycle 206: Edge Case Tests for SMT Translator
    // ================================================================

    // ---- Complex contract expressions (3 tests) ----

    /// Nested pre/post conditions: (x > 0 && y > 0) => (x + y > 0)
    /// Exercises deeply nested binary ops with implication.
    #[test]
    fn test_complex_nested_precondition_with_implication() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);
        trans.var_types.insert("y".to_string(), SmtSort::Int);

        // Build: (x > 0 && y > 0) => (x + y > 0)
        let x_gt_0 = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("x".to_string()))),
            op: BinOp::Gt,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        let y_gt_0 = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("y".to_string()))),
            op: BinOp::Gt,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        let lhs = spanned(Expr::Binary {
            left: Box::new(x_gt_0),
            op: BinOp::And,
            right: Box::new(y_gt_0),
        });
        let sum = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("x".to_string()))),
            op: BinOp::Add,
            right: Box::new(spanned(Expr::Var("y".to_string()))),
        });
        let rhs = spanned(Expr::Binary {
            left: Box::new(sum),
            op: BinOp::Gt,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        let implies = spanned(Expr::Binary {
            left: Box::new(lhs),
            op: BinOp::Implies,
            right: Box::new(rhs),
        });

        assert_eq!(
            trans.translate(&implies).unwrap(),
            "(=> (and (> x 0) (> y 0)) (> (+ x y) 0))"
        );
    }

    /// Multiple clauses in a post-condition: ret >= 0 && ret <= x && ret == x mod y
    /// Tests chaining of three clauses with logical AND.
    #[test]
    fn test_complex_multi_clause_postcondition() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("__ret__".to_string(), SmtSort::Int);
        trans.var_types.insert("x".to_string(), SmtSort::Int);
        trans.var_types.insert("y".to_string(), SmtSort::Int);

        // ret >= 0
        let clause1 = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Ret)),
            op: BinOp::Ge,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        // ret <= x
        let clause2 = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Ret)),
            op: BinOp::Le,
            right: Box::new(spanned(Expr::Var("x".to_string()))),
        });
        // ret == x mod y
        let x_mod_y = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("x".to_string()))),
            op: BinOp::Mod,
            right: Box::new(spanned(Expr::Var("y".to_string()))),
        });
        let clause3 = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Ret)),
            op: BinOp::Eq,
            right: Box::new(x_mod_y),
        });
        // clause1 && clause2 && clause3
        let c1_and_c2 = spanned(Expr::Binary {
            left: Box::new(clause1),
            op: BinOp::And,
            right: Box::new(clause2),
        });
        let all = spanned(Expr::Binary {
            left: Box::new(c1_and_c2),
            op: BinOp::And,
            right: Box::new(clause3),
        });

        assert_eq!(
            trans.translate(&all).unwrap(),
            "(and (and (>= __ret__ 0) (<= __ret__ x)) (= __ret__ (mod x y)))"
        );
    }

    /// Nested let + if contract: let tmp = x + 1 in (ite (> 99 0) 99 0)
    /// Tests let-binding inside an if-expression for complex contract shapes.
    #[test]
    fn test_complex_let_inside_if_contract() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);

        let x_plus_1 = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("x".to_string()))),
            op: BinOp::Add,
            right: Box::new(spanned(Expr::IntLit(1))),
        });
        let inner_if = spanned(Expr::If {
            cond: Box::new(spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(99))),
                op: BinOp::Gt,
                right: Box::new(spanned(Expr::IntLit(0))),
            })),
            then_branch: Box::new(spanned(Expr::IntLit(99))),
            else_branch: Box::new(spanned(Expr::IntLit(0))),
        });
        let let_expr = spanned(Expr::Let {
            name: "tmp".to_string(),
            mutable: false,
            ty: Some(Spanned::new(Type::I64, span())),
            value: Box::new(x_plus_1),
            body: Box::new(inner_if),
        });

        assert_eq!(
            trans.translate(&let_expr).unwrap(),
            "(let ((tmp (+ x 1))) (ite (> 99 0) 99 0))"
        );
    }

    // ---- Array contract expressions (2 tests) ----

    /// Array literal returns UnsupportedFeature, confirming array-related
    /// contract expressions are correctly rejected with descriptive message.
    #[test]
    fn test_array_literal_in_contract_rejected() {
        let trans = SmtTranslator::new();
        let arr = spanned(Expr::ArrayLit(vec![
            spanned(Expr::IntLit(1)),
            spanned(Expr::IntLit(2)),
            spanned(Expr::IntLit(3)),
        ]));
        let err = trans.translate(&arr).unwrap_err();
        match err {
            TranslateError::UnsupportedFeature(msg) => {
                assert!(msg.contains("array"), "Expected 'array' in error: {}", msg);
            }
            other => panic!("Expected UnsupportedFeature, got: {:?}", other),
        }
    }

    /// Index expression and index assignment are both rejected, testing both
    /// array access patterns that could appear in contracts.
    #[test]
    fn test_array_index_and_index_assign_rejected() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("arr".to_string(), SmtSort::Int);

        // arr[0]
        let index_expr = spanned(Expr::Index {
            expr: Box::new(spanned(Expr::Var("arr".to_string()))),
            index: Box::new(spanned(Expr::IntLit(0))),
        });
        let err1 = trans.translate(&index_expr).unwrap_err();
        match &err1 {
            TranslateError::UnsupportedFeature(msg) => {
                assert!(msg.contains("array index"), "Expected 'array index' in error: {}", msg);
            }
            other => panic!("Expected UnsupportedFeature, got: {:?}", other),
        }

        // arr[0] = 42
        let index_assign = spanned(Expr::IndexAssign {
            array: Box::new(spanned(Expr::Var("arr".to_string()))),
            index: Box::new(spanned(Expr::IntLit(0))),
            value: Box::new(spanned(Expr::IntLit(42))),
        });
        let err2 = trans.translate(&index_assign).unwrap_err();
        match &err2 {
            TranslateError::UnsupportedFeature(msg) => {
                assert!(msg.contains("array index"), "Expected 'array index' in error: {}", msg);
            }
            other => panic!("Expected UnsupportedFeature, got: {:?}", other),
        }
    }

    // ---- Nullable contract expressions (2 tests) ----

    /// Nullable type T? maps to the same sort as T.
    /// Test nested nullable (T??) and confirm sort resolution.
    #[test]
    fn test_nullable_type_sort_nested() {
        // i64? -> Int
        assert_eq!(SmtTranslator::type_to_sort(&Type::Nullable(Box::new(Type::I64))), SmtSort::Int);
        // Bool? -> Bool
        assert_eq!(SmtTranslator::type_to_sort(&Type::Nullable(Box::new(Type::Bool))), SmtSort::Bool);
        // i64?? (double-nullable) -> Int (unwraps recursively)
        let double_nullable = Type::Nullable(Box::new(Type::Nullable(Box::new(Type::I64))));
        assert_eq!(SmtTranslator::type_to_sort(&double_nullable), SmtSort::Int);
    }

    /// Null literal (Expr::Null) translates to "0", and comparing a variable
    /// with null produces proper SMT not-equal / equal expressions.
    #[test]
    fn test_nullable_null_check_contract() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("ptr".to_string(), SmtSort::Int);

        // ptr != null  =>  (not (= ptr 0))
        let ne_null = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("ptr".to_string()))),
            op: BinOp::Ne,
            right: Box::new(spanned(Expr::Null)),
        });
        assert_eq!(trans.translate(&ne_null).unwrap(), "(not (= ptr 0))");

        // ptr == null  =>  (= ptr 0)
        let eq_null = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("ptr".to_string()))),
            op: BinOp::Eq,
            right: Box::new(spanned(Expr::Null)),
        });
        assert_eq!(trans.translate(&eq_null).unwrap(), "(= ptr 0)");
    }

    // ---- Error handling (3 tests) ----

    /// Undefined variable in a nested expression should propagate the error
    /// through the entire expression tree.
    #[test]
    fn test_error_propagation_in_nested_expr() {
        let trans = SmtTranslator::new();

        // (1 + unknown_var) * 2 -- `unknown_var` is not declared
        let inner = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(1))),
            op: BinOp::Add,
            right: Box::new(spanned(Expr::Var("unknown_var".to_string()))),
        });
        let outer = spanned(Expr::Binary {
            left: Box::new(inner),
            op: BinOp::Mul,
            right: Box::new(spanned(Expr::IntLit(2))),
        });
        let err = trans.translate(&outer).unwrap_err();
        match err {
            TranslateError::UndefinedVariable(name) => {
                assert_eq!(name, "unknown_var");
            }
            other => panic!("Expected UndefinedVariable, got: {:?}", other),
        }
    }

    /// Closure expressions are explicitly unsupported in contracts.
    /// Verify the error message is descriptive.
    #[test]
    fn test_error_closure_in_contract() {
        let trans = SmtTranslator::new();
        let closure = spanned(Expr::Closure {
            params: vec![],
            ret_ty: None,
            body: Box::new(spanned(Expr::IntLit(0))),
        });
        let err = trans.translate(&closure).unwrap_err();
        match err {
            TranslateError::UnsupportedFeature(msg) => {
                assert!(msg.contains("closure"), "Expected 'closure' in msg: {}", msg);
            }
            other => panic!("Expected UnsupportedFeature, got: {:?}", other),
        }
    }

    /// Multiple different unsupported expression types each produce
    /// distinct error messages (struct init, field access, method call).
    #[test]
    fn test_error_distinct_unsupported_messages() {
        let trans = SmtTranslator::new();

        // StructInit
        let si = spanned(Expr::StructInit {
            name: "Point".to_string(),
            fields: vec![],
        });
        match trans.translate(&si).unwrap_err() {
            TranslateError::UnsupportedFeature(msg) => {
                assert!(msg.contains("struct init"), "Got: {}", msg);
                assert!(msg.contains("Point"), "Expected struct name in msg: {}", msg);
            }
            other => panic!("Expected UnsupportedFeature, got: {:?}", other),
        }

        // FieldAccess
        let fa = spanned(Expr::FieldAccess {
            expr: Box::new(spanned(Expr::IntLit(0))),
            field: Spanned::new("x".to_string(), span()),
        });
        match trans.translate(&fa).unwrap_err() {
            TranslateError::UnsupportedFeature(msg) => {
                assert!(msg.contains("field access"), "Got: {}", msg);
                assert!(msg.contains("x"), "Expected field name in msg: {}", msg);
            }
            other => panic!("Expected UnsupportedFeature, got: {:?}", other),
        }

        // MethodCall
        let mc = spanned(Expr::MethodCall {
            receiver: Box::new(spanned(Expr::IntLit(0))),
            method: "len".to_string(),
            args: vec![],
        });
        match trans.translate(&mc).unwrap_err() {
            TranslateError::UnsupportedFeature(msg) => {
                assert!(msg.contains("method call"), "Got: {}", msg);
            }
            other => panic!("Expected UnsupportedFeature, got: {:?}", other),
        }
    }

    // ---- SMT output format (2 tests) ----

    /// Verify correct SMT-LIB2 output structure: header, declarations,
    /// assertions, check-sat, get-model in proper order.
    #[test]
    fn test_smt_output_format_ordering() {
        let mut generator = SmtLibGenerator::new();
        generator.declare_var("a", SmtSort::Int);
        generator.declare_var("b", SmtSort::Bool);
        generator.assert("(> a 0)");
        generator.assert("(= b true)");
        let output = generator.generate();

        // Verify ordering: header before declarations before assertions before check-sat
        let header_pos = output.find("; Generated by BMB compiler").unwrap();
        let logic_pos = output.find("(set-logic QF_LIA)").unwrap();
        let decl_a_pos = output.find("(declare-const a Int)").unwrap();
        let decl_b_pos = output.find("(declare-const b Bool)").unwrap();
        let assert1_pos = output.find("(assert (> a 0))").unwrap();
        let assert2_pos = output.find("(assert (= b true))").unwrap();
        let check_pos = output.find("(check-sat)").unwrap();
        let model_pos = output.find("(get-model)").unwrap();

        assert!(header_pos < logic_pos, "Header should precede logic declaration");
        assert!(logic_pos < decl_a_pos, "Logic should precede declarations");
        assert!(decl_a_pos < decl_b_pos, "Declarations in insertion order");
        assert!(decl_b_pos < assert1_pos, "Declarations precede assertions");
        assert!(assert1_pos < assert2_pos, "Assertions in insertion order");
        assert!(assert2_pos < check_pos, "Assertions precede check-sat");
        assert!(check_pos < model_pos, "check-sat precedes get-model");
    }

    /// Verify setup_function correctly declares function parameters and
    /// return value including named return bindings.
    #[test]
    fn test_smt_setup_function_with_named_return() {
        use crate::ast::{FnDef, Param, Visibility};

        let mut trans = SmtTranslator::new();
        let mut generator = SmtLibGenerator::new();

        // fn clamp(x: i64, lo: i64, hi: i64) -> result: i64
        let func = FnDef {
            attributes: vec![],
            visibility: Visibility::Private,
            is_async: false,
            name: Spanned::new("clamp".to_string(), span()),
            type_params: vec![],
            params: vec![
                Param {
                    name: Spanned::new("x".to_string(), span()),
                    ty: Spanned::new(Type::I64, span()),
                },
                Param {
                    name: Spanned::new("lo".to_string(), span()),
                    ty: Spanned::new(Type::I64, span()),
                },
                Param {
                    name: Spanned::new("hi".to_string(), span()),
                    ty: Spanned::new(Type::I64, span()),
                },
            ],
            ret_name: Some(Spanned::new("result".to_string(), span())),
            ret_ty: Spanned::new(Type::I64, span()),
            pre: None,
            post: None,
            contracts: vec![],
            body: Spanned::new(Expr::IntLit(0), span()),
            span: span(),
        };

        trans.setup_function(&func, &mut generator);

        // Verify all parameters and return value are declared
        let output = generator.generate();
        assert!(output.contains("(declare-const x Int)"), "param x declared");
        assert!(output.contains("(declare-const lo Int)"), "param lo declared");
        assert!(output.contains("(declare-const hi Int)"), "param hi declared");
        assert!(output.contains("(declare-const __ret__ Int)"), "__ret__ declared");
        assert!(output.contains("(declare-const result Int)"), "named return 'result' declared");

        // Verify translator's var_types are populated
        assert_eq!(trans.var_types().get("x"), Some(&SmtSort::Int));
        assert_eq!(trans.var_types().get("lo"), Some(&SmtSort::Int));
        assert_eq!(trans.var_types().get("hi"), Some(&SmtSort::Int));
        assert_eq!(trans.var_types().get("__ret__"), Some(&SmtSort::Int));
        assert_eq!(trans.var_types().get("result"), Some(&SmtSort::Int));
    }

    /// Forall quantifier with nested implication body.
    #[test]
    fn test_forall_nested_implication_body() {
        let trans = SmtTranslator::new();

        let premise = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(0))),
            op: BinOp::Ge,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        let conclusion = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(1))),
            op: BinOp::Ge,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        let body = spanned(Expr::Binary {
            left: Box::new(premise),
            op: BinOp::Implies,
            right: Box::new(conclusion),
        });

        let forall = spanned(Expr::Forall {
            var: Spanned::new("i".to_string(), span()),
            ty: Spanned::new(Type::I64, span()),
            body: Box::new(body),
        });

        assert_eq!(
            trans.translate(&forall).unwrap(),
            "(forall ((i Int)) (=> (>= 0 0) (>= 1 0)))"
        );
    }

    /// StateRef (pre/post) translation generates correct variable suffixes.
    #[test]
    fn test_state_ref_pre_post_suffixes() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);

        let pre_ref = spanned(Expr::StateRef {
            expr: Box::new(spanned(Expr::Var("x".to_string()))),
            state: crate::ast::StateKind::Pre,
        });
        assert_eq!(trans.translate(&pre_ref).unwrap(), "x_pre");

        let post_ref = spanned(Expr::StateRef {
            expr: Box::new(spanned(Expr::Var("x".to_string()))),
            state: crate::ast::StateKind::Post,
        });
        assert_eq!(trans.translate(&post_ref).unwrap(), "x_post");
    }
}
