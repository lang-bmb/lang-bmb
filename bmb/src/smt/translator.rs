//! AST to SMT-LIB2 translator
//!
//! Translates BMB expressions into SMT-LIB2 format strings.

use std::collections::HashMap;
use std::fmt::Write;

use crate::ast::{BinOp, Expr, FnDef, Spanned, Type, UnOp};

/// SMT-LIB2 code generator
#[derive(Debug, Default, Clone)]
pub struct SmtLibGenerator {
    /// Generated declarations
    declarations: Vec<String>,
    /// Generated assertions
    assertions: Vec<String>,
    /// Variable types for tracking
    var_types: HashMap<String, SmtSort>,
}

/// SMT sorts (types)
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SmtSort {
    Int,
    Bool,
}

impl SmtLibGenerator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Declare a variable with the given sort
    pub fn declare_var(&mut self, name: &str, sort: SmtSort) {
        let sort_str = match sort {
            SmtSort::Int => "Int",
            SmtSort::Bool => "Bool",
        };
        self.declarations.push(format!("(declare-const {} {})", name, sort_str));
        self.var_types.insert(name.to_string(), sort);
    }

    /// Add an assertion
    pub fn assert(&mut self, expr: &str) {
        self.assertions.push(format!("(assert {})", expr));
    }

    /// Generate complete SMT-LIB2 script
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Header
        writeln!(output, "; Generated by BMB compiler").unwrap();
        writeln!(output, "(set-logic QF_LIA)").unwrap();
        writeln!(output).unwrap();

        // Declarations
        for decl in &self.declarations {
            writeln!(output, "{}", decl).unwrap();
        }
        writeln!(output).unwrap();

        // Assertions
        for assertion in &self.assertions {
            writeln!(output, "{}", assertion).unwrap();
        }
        writeln!(output).unwrap();

        // Check and get model
        writeln!(output, "(check-sat)").unwrap();
        writeln!(output, "(get-model)").unwrap();

        output
    }

    /// Clear all declarations and assertions
    pub fn clear(&mut self) {
        self.declarations.clear();
        self.assertions.clear();
        self.var_types.clear();
    }
}

/// Translator from BMB AST to SMT-LIB2 expressions
pub struct SmtTranslator {
    /// Variable types
    var_types: HashMap<String, SmtSort>,
}

impl SmtTranslator {
    pub fn new() -> Self {
        Self {
            var_types: HashMap::new(),
        }
    }

    /// Set up the translator for a function definition
    pub fn setup_function(&mut self, func: &FnDef, generator: &mut SmtLibGenerator) {
        self.var_types.clear();

        // Declare parameters
        for param in &func.params {
            let sort = Self::type_to_sort(&param.ty.node);
            let name = &param.name.node;
            generator.declare_var(name, sort);
            self.var_types.insert(name.clone(), sort);
        }

        // Declare __ret__ for return value
        let ret_sort = Self::type_to_sort(&func.ret_ty.node);
        generator.declare_var("__ret__", ret_sort);
        self.var_types.insert("__ret__".to_string(), ret_sort);

        // v0.2: Also declare named return binding if present (e.g., -> r: i64)
        if let Some(ret_name) = &func.ret_name {
            generator.declare_var(&ret_name.node, ret_sort);
            self.var_types.insert(ret_name.node.clone(), ret_sort);
        }
    }

    /// Convert BMB Type to SMT Sort
    pub fn type_to_sort(ty: &Type) -> SmtSort {
        match ty {
            // v0.38: Include unsigned types, v0.64: Include char
            Type::I32 | Type::I64 | Type::U32 | Type::U64 | Type::F64 | Type::Char => SmtSort::Int,
            Type::Bool => SmtSort::Bool,
            Type::Unit => SmtSort::Bool, // Unit maps to true
            Type::String => SmtSort::Int, // String as Int (simplified) v0.5
            Type::Range(_) => SmtSort::Int, // Range as Int (simplified) v0.5 Phase 3
            Type::Named(_) => SmtSort::Int, // Named types default to Int for now
            // v0.13.1: Type variables treated as Int (unresolved)
            Type::TypeVar(_) => SmtSort::Int,
            // v0.13.1: Generic types treated as Int (simplified)
            Type::Generic { .. } => SmtSort::Int,
            Type::Struct { .. } => SmtSort::Int, // Struct types as Int (simplified)
            Type::Enum { .. } => SmtSort::Int, // Enum types as Int (simplified)
            // v0.5 Phase 5: References as Int (simplified)
            Type::Ref(_) | Type::RefMut(_) => SmtSort::Int,
            // v0.5 Phase 6: Arrays as Int (simplified)
            Type::Array(_, _) => SmtSort::Int,
            // v0.2: Refined types use base type sort
            Type::Refined { base, .. } => Self::type_to_sort(base),
            // v0.20.0: Fn types as Int (function pointers)
            Type::Fn { .. } => SmtSort::Int,
            // v0.31: Never type - represents unreachable code
            Type::Never => SmtSort::Bool,
            // v0.37: Nullable type - use same sort as inner (simplified for SMT)
            Type::Nullable(inner) => Self::type_to_sort(inner),
            // v0.42: Tuple type - use Int for now (simplified)
            Type::Tuple(_) => SmtSort::Int,
            // v0.51.37: Pointer type - use Int (addresses)
            Type::Ptr(_) => SmtSort::Int,
            // v0.70: Thread type - use Int for handle
            Type::Thread(_) => SmtSort::Int,
            // v0.71: Mutex type - use Int for handle
            Type::Mutex(_) => SmtSort::Int,
            // v0.72: Arc and Atomic types - use Int for handle
            Type::Arc(_) => SmtSort::Int,
            Type::Atomic(_) => SmtSort::Int,
            // v0.73: Sender and Receiver types - use Int for handle
            Type::Sender(_) => SmtSort::Int,
            Type::Receiver(_) => SmtSort::Int,
            // v0.74: RwLock, Barrier, Condvar - use Int for handle
            Type::RwLock(_) => SmtSort::Int,
            Type::Barrier => SmtSort::Int,
            Type::Condvar => SmtSort::Int,
            // v0.75: Future - use Int for handle
            Type::Future(_) => SmtSort::Int,
            // v0.83: AsyncFile - use Int for handle
            Type::AsyncFile => SmtSort::Int,
            // v0.83.1: AsyncSocket - use Int for handle
            Type::AsyncSocket => SmtSort::Int,
            // v0.84: ThreadPool - use Int for handle
            Type::ThreadPool => SmtSort::Int,
            // v0.85: Scope - use Int for handle
            Type::Scope => SmtSort::Int,
        }
    }

    /// Translate a BMB expression to SMT-LIB2 string
    pub fn translate(&self, expr: &Spanned<Expr>) -> Result<String, TranslateError> {
        self.translate_expr(&expr.node)
    }

    fn translate_expr(&self, expr: &Expr) -> Result<String, TranslateError> {
        match expr {
            Expr::IntLit(n) => {
                if *n >= 0 {
                    Ok(n.to_string())
                } else {
                    Ok(format!("(- {})", -n))
                }
            }

            Expr::FloatLit(f) => {
                // Approximate as integer
                let n = *f as i64;
                if n >= 0 {
                    Ok(n.to_string())
                } else {
                    Ok(format!("(- {})", -n))
                }
            }

            Expr::BoolLit(b) => Ok(b.to_string()),

            Expr::StringLit(_) => {
                // Strings not fully supported in SMT - approximate as 0
                Ok("0".to_string())
            }

            // v0.64: Character literal - represented as integer (char code)
            Expr::CharLit(c) => {
                let n = *c as i64;
                Ok(n.to_string())
            }

            Expr::Unit => Ok("true".to_string()),

            // v0.51.40: Null pointer literal - represented as 0
            Expr::Null => Ok("0".to_string()),

            // v0.51.41: Sizeof - approximate as constant (SMT doesn't track memory layout)
            Expr::Sizeof { .. } => Ok("8".to_string()),

            // v0.70: Spawn - threads are not relevant for SMT verification
            // Just return a placeholder integer (thread handle)
            Expr::Spawn { .. } => Ok("0".to_string()),

            // v0.72: Atomic creation - not relevant for SMT verification
            // Just return a placeholder integer (atomic handle)
            Expr::AtomicNew { .. } => Ok("0".to_string()),

            // v0.71: Mutex creation - not relevant for SMT verification
            // Just return a placeholder integer (mutex handle)
            Expr::MutexNew { .. } => Ok("0".to_string()),

            // v0.73: Channel creation - not relevant for SMT verification
            // Just return a placeholder tuple (sender, receiver handles)
            Expr::ChannelNew { .. } => Ok("(tuple 0 0)".to_string()),

            // v0.74: RwLock, Barrier, Condvar - not relevant for SMT verification
            Expr::RwLockNew { .. } => Ok("0".to_string()),
            Expr::BarrierNew { .. } => Ok("0".to_string()),
            Expr::CondvarNew => Ok("0".to_string()),
            // v0.75: Await - not relevant for SMT verification
            Expr::Await { future } => self.translate(future),
            // v0.82: Select - not relevant for SMT verification (runtime construct)
            Expr::Select { .. } => Ok("0".to_string()),

            Expr::Var(name) => {
                if self.var_types.contains_key(name) {
                    Ok(name.clone())
                } else {
                    Err(TranslateError::UndefinedVariable(name.clone()))
                }
            }

            Expr::Ret => {
                if self.var_types.contains_key("__ret__") {
                    Ok("__ret__".to_string())
                } else {
                    Err(TranslateError::RetNotDefined)
                }
            }

            Expr::Binary { left, op, right } => {
                let l = self.translate(left)?;
                let r = self.translate(right)?;
                self.translate_binary(&l, *op, &r)
            }

            Expr::Unary { op, expr } => {
                let e = self.translate(expr)?;
                self.translate_unary(*op, &e)
            }

            Expr::If { cond, then_branch, else_branch } => {
                let c = self.translate(cond)?;
                let t = self.translate(then_branch)?;
                let e = self.translate(else_branch)?;
                Ok(format!("(ite {} {} {})", c, t, e))
            }

            Expr::Let { name, mutable: _, ty: _, value, body } => {
                // For SMT-LIB, we use let binding
                let v = self.translate(value)?;
                let b = self.translate(body)?;
                Ok(format!("(let (({} {})) {})", name, v, b))
            }

            // v0.60.21: Uninitialized let binding - for SMT verification, treat as uninterpreted
            Expr::LetUninit { name, mutable: _, ty: _, body } => {
                // For SMT-LIB, declare variable without value (uninitialized)
                let b = self.translate(body)?;
                // Use a fresh constant for uninitialized value
                Ok(format!("(let (({} undefined_array)) {})", name, b))
            }

            Expr::Assign { name, .. } => {
                // Assignment not fully supported in pure SMT
                Err(TranslateError::UnsupportedFeature(format!("assignment: {}", name)))
            }

            Expr::While { .. } => {
                // While loops not supported in SMT
                Err(TranslateError::UnsupportedFeature("while loop".to_string()))
            }

            Expr::Call { func, args: _ } => {
                Err(TranslateError::UnsupportedFeature(format!("function call: {}", func)))
            }

            Expr::Block(exprs) => {
                if let Some(last) = exprs.last() {
                    self.translate(last)
                } else {
                    Ok("true".to_string())
                }
            }

            // v0.5: Struct and Enum expressions - not fully supported in SMT
            Expr::StructInit { name, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("struct init: {}", name)))
            }

            Expr::FieldAccess { field, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("field access: {}", field.node)))
            }

            // v0.51.23: Field assignment
            Expr::FieldAssign { field, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("field assignment: {}", field.node)))
            }

            // v0.60.21: Dereference assignment
            Expr::DerefAssign { .. } => {
                Err(TranslateError::UnsupportedFeature("dereference assignment".to_string()))
            }

            // v0.43: Tuple field access
            Expr::TupleField { index, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("tuple field access: .{}", index)))
            }

            Expr::EnumVariant { enum_name, variant, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("enum variant: {}::{}", enum_name, variant)))
            }

            Expr::Match { .. } => {
                Err(TranslateError::UnsupportedFeature("match expression".to_string()))
            }

            // v0.5 Phase 3: Range and For expressions - not supported in SMT
            Expr::Range { .. } => {
                Err(TranslateError::UnsupportedFeature("range expression".to_string()))
            }

            Expr::For { .. } => {
                Err(TranslateError::UnsupportedFeature("for loop".to_string()))
            }

            // v0.5 Phase 5: References - not supported in SMT
            Expr::Ref(_) | Expr::RefMut(_) => {
                Err(TranslateError::UnsupportedFeature("reference".to_string()))
            }

            Expr::Deref(_) => {
                Err(TranslateError::UnsupportedFeature("dereference".to_string()))
            }

            // v0.5 Phase 6: Arrays - not supported in SMT
            Expr::ArrayLit(_) => {
                Err(TranslateError::UnsupportedFeature("array literal".to_string()))
            }

            // v0.60.22: Array repeat - not supported in SMT
            Expr::ArrayRepeat { .. } => {
                Err(TranslateError::UnsupportedFeature("array repeat".to_string()))
            }

            // v0.42: Tuple expressions - not supported in SMT
            Expr::Tuple(_) => {
                Err(TranslateError::UnsupportedFeature("tuple expression".to_string()))
            }

            Expr::Index { .. } => {
                Err(TranslateError::UnsupportedFeature("array index".to_string()))
            }

            // v0.51: Index assignment - not supported in SMT
            Expr::IndexAssign { .. } => {
                Err(TranslateError::UnsupportedFeature("array index assignment".to_string()))
            }

            // v0.5 Phase 8: Method calls - not supported in SMT
            Expr::MethodCall { .. } => {
                Err(TranslateError::UnsupportedFeature("method call".to_string()))
            }

            // v0.2: State references for contracts
            Expr::StateRef { expr, state } => {
                let base = self.translate_expr(&expr.node)?;
                // Append state suffix to create unique SMT variable
                // e.g., x.pre -> x_pre, x.post -> x_post
                let suffix = match state {
                    crate::ast::StateKind::Pre => "_pre",
                    crate::ast::StateKind::Post => "_post",
                };
                Ok(format!("{}{}", base, suffix))
            }

            // v0.2: Refinement self-reference
            Expr::It => Ok("__it__".to_string()),

            // v0.20.0: Closure expressions
            // Closures are currently not supported in SMT verification
            // They would require higher-order logic which is not in SMT-LIB2 core
            Expr::Closure { .. } => Err(TranslateError::UnsupportedFeature(
                "closures are not supported in contract verification".to_string(),
            )),

            // v0.31: Todo expression
            // In SMT context, todo represents unreachable code (absurd/false)
            // Any constraints involving todo are vacuously satisfied
            Expr::Todo { .. } => Ok("false".to_string()),

            // v0.36: Additional control flow
            // These are not verifiable in SMT context, return false (unreachable)
            Expr::Loop { .. } => Err(TranslateError::UnsupportedFeature(
                "loops are not supported in contract verification".to_string(),
            )),
            Expr::Break { .. } => Ok("false".to_string()),
            Expr::Continue => Ok("false".to_string()),
            Expr::Return { .. } => Ok("false".to_string()),

            // v0.37: Quantifiers - translate directly to SMT-LIB2 forall/exists
            Expr::Forall { var, ty, body } => {
                let smt_type = self.type_to_smt(&ty.node)?;
                let body_smt = self.translate(body)?;
                Ok(format!("(forall (({} {})) {})", var.node, smt_type, body_smt))
            }

            Expr::Exists { var, ty, body } => {
                let smt_type = self.type_to_smt(&ty.node)?;
                let body_smt = self.translate(body)?;
                Ok(format!("(exists (({} {})) {})", var.node, smt_type, body_smt))
            }

            // v0.39: Type cast - in SMT we just use the inner expression
            // Type safety is already verified by the type checker
            Expr::Cast { expr, ty: _ } => {
                self.translate(expr)
            }
        }
    }

    fn translate_binary(&self, left: &str, op: BinOp, right: &str) -> Result<String, TranslateError> {
        let smt_op = match op {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "div",
            BinOp::Mod => "mod",
            // v0.37: Wrapping arithmetic - for SMT, treat as regular arithmetic
            // (overflow semantics not captured in SMT-LIB integer theory)
            BinOp::AddWrap => "+",
            BinOp::SubWrap => "-",
            BinOp::MulWrap => "*",
            // v0.38: Checked arithmetic - for SMT, treat as regular arithmetic
            // (Option wrapping not captured in SMT-LIB)
            BinOp::AddChecked => "+",
            BinOp::SubChecked => "-",
            BinOp::MulChecked => "*",
            // v0.38: Saturating arithmetic - for SMT, treat as regular arithmetic
            // (saturation semantics not captured in SMT-LIB)
            BinOp::AddSat => "+",
            BinOp::SubSat => "-",
            BinOp::MulSat => "*",
            BinOp::Eq => "=",
            BinOp::Ne => return Ok(format!("(not (= {} {}))", left, right)),
            BinOp::Lt => "<",
            BinOp::Gt => ">",
            BinOp::Le => "<=",
            BinOp::Ge => ">=",
            BinOp::And => "and",
            BinOp::Or => "or",
            // v0.32: Shift operators - not directly supported in SMT-LIB integer arithmetic
            // Return error for now; shift operations are rarely used in contracts
            BinOp::Shl => return Err(TranslateError::UnsupportedFeature("shift left operator (<<) in contracts".to_string())),
            BinOp::Shr => return Err(TranslateError::UnsupportedFeature("shift right operator (>>) in contracts".to_string())),
            // v0.36: Bitwise operators - not directly supported in SMT-LIB integer arithmetic
            // Return error for now; bitwise operations are rarely used in contracts
            BinOp::Band => return Err(TranslateError::UnsupportedFeature("bitwise AND operator (band) in contracts".to_string())),
            BinOp::Bor => return Err(TranslateError::UnsupportedFeature("bitwise OR operator (bor) in contracts".to_string())),
            BinOp::Bxor => return Err(TranslateError::UnsupportedFeature("bitwise XOR operator (bxor) in contracts".to_string())),
            // v0.36: Logical implication - SMT-LIB uses => for implication
            BinOp::Implies => "=>",
        };
        Ok(format!("({} {} {})", smt_op, left, right))
    }

    fn translate_unary(&self, op: UnOp, expr: &str) -> Result<String, TranslateError> {
        match op {
            UnOp::Neg => Ok(format!("(- {})", expr)),
            UnOp::Not => Ok(format!("(not {})", expr)),
            // v0.36: Bitwise not - not directly supported in SMT-LIB integer arithmetic
            UnOp::Bnot => Err(TranslateError::UnsupportedFeature("bitwise NOT operator (bnot) in contracts".to_string())),
        }
    }

    /// v0.37: Convert BMB type to SMT-LIB sort
    fn type_to_smt(&self, ty: &crate::ast::Type) -> Result<String, TranslateError> {
        use crate::ast::Type;
        match ty {
            // v0.38: Include unsigned types
            Type::I32 | Type::I64 | Type::U32 | Type::U64 => Ok("Int".to_string()),
            Type::F64 => Ok("Real".to_string()),
            Type::Bool => Ok("Bool".to_string()),
            Type::String => Err(TranslateError::UnsupportedFeature(
                "String type in quantifier".to_string()
            )),
            Type::Unit => Err(TranslateError::UnsupportedFeature(
                "Unit type in quantifier".to_string()
            )),
            Type::Named(name) => Err(TranslateError::UnsupportedFeature(
                format!("Named type '{}' in quantifier", name)
            )),
            _ => Err(TranslateError::UnsupportedFeature(
                format!("type {:?} in quantifier", ty)
            )),
        }
    }

    /// Get variable types
    pub fn var_types(&self) -> &HashMap<String, SmtSort> {
        &self.var_types
    }
}

impl Default for SmtTranslator {
    fn default() -> Self {
        Self::new()
    }
}

/// Errors during translation
#[derive(Debug, Clone)]
pub enum TranslateError {
    UndefinedVariable(String),
    TypeMismatch(String),
    UnsupportedFeature(String),
    RetNotDefined,
}

impl std::fmt::Display for TranslateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TranslateError::UndefinedVariable(name) => write!(f, "undefined variable: {}", name),
            TranslateError::TypeMismatch(msg) => write!(f, "type mismatch: {}", msg),
            TranslateError::UnsupportedFeature(msg) => write!(f, "unsupported: {}", msg),
            TranslateError::RetNotDefined => write!(f, "'ret' not defined"),
        }
    }
}

impl std::error::Error for TranslateError {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::Span;

    fn span() -> Span { Span::new(0, 0) }
    fn spanned(e: Expr) -> Spanned<Expr> { Spanned::new(e, span()) }

    // ================================================================
    // Literal Translation Tests
    // ================================================================

    #[test]
    fn test_int_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::IntLit(42));
        assert_eq!(trans.translate(&expr).unwrap(), "42");
    }

    #[test]
    fn test_negative_int() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::IntLit(-5));
        assert_eq!(trans.translate(&expr).unwrap(), "(- 5)");
    }

    #[test]
    fn test_int_zero() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::IntLit(0));
        assert_eq!(trans.translate(&expr).unwrap(), "0");
    }

    #[test]
    fn test_bool_lit_true() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::BoolLit(true));
        assert_eq!(trans.translate(&expr).unwrap(), "true");
    }

    #[test]
    fn test_bool_lit_false() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::BoolLit(false));
        assert_eq!(trans.translate(&expr).unwrap(), "false");
    }

    #[test]
    fn test_unit_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Unit);
        assert_eq!(trans.translate(&expr).unwrap(), "true");
    }

    #[test]
    fn test_string_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::StringLit("hello".to_string()));
        assert_eq!(trans.translate(&expr).unwrap(), "0");
    }

    #[test]
    fn test_char_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::CharLit('A'));
        assert_eq!(trans.translate(&expr).unwrap(), "65");
    }

    #[test]
    fn test_null_lit() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Null);
        assert_eq!(trans.translate(&expr).unwrap(), "0");
    }

    // ================================================================
    // Variable Translation Tests
    // ================================================================

    #[test]
    fn test_var_known() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Var("x".to_string()));
        assert_eq!(trans.translate(&expr).unwrap(), "x");
    }

    #[test]
    fn test_var_unknown() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Var("x".to_string()));
        assert!(trans.translate(&expr).is_err());
    }

    #[test]
    fn test_ret_with_ret_declared() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("__ret__".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Ret);
        assert_eq!(trans.translate(&expr).unwrap(), "__ret__");
    }

    #[test]
    fn test_ret_without_ret_declared() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Ret);
        assert!(trans.translate(&expr).is_err());
    }

    // ================================================================
    // Binary Operation Translation Tests
    // ================================================================

    #[test]
    fn test_binary_add() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("a".to_string(), SmtSort::Int);
        trans.var_types.insert("b".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("a".to_string()))),
            op: BinOp::Add,
            right: Box::new(spanned(Expr::Var("b".to_string()))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(+ a b)");
    }

    #[test]
    fn test_binary_sub() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(10))),
            op: BinOp::Sub,
            right: Box::new(spanned(Expr::IntLit(3))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(- 10 3)");
    }

    #[test]
    fn test_binary_mul() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(4))),
            op: BinOp::Mul,
            right: Box::new(spanned(Expr::IntLit(5))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(* 4 5)");
    }

    #[test]
    fn test_binary_div() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(10))),
            op: BinOp::Div,
            right: Box::new(spanned(Expr::IntLit(2))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(div 10 2)");
    }

    #[test]
    fn test_binary_mod() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(7))),
            op: BinOp::Mod,
            right: Box::new(spanned(Expr::IntLit(3))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(mod 7 3)");
    }

    #[test]
    fn test_binary_eq() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("x".to_string()))),
            op: BinOp::Eq,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(= x 0)");
    }

    #[test]
    fn test_binary_ne() {
        let mut trans = SmtTranslator::new();
        trans.var_types.insert("x".to_string(), SmtSort::Int);
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::Var("x".to_string()))),
            op: BinOp::Ne,
            right: Box::new(spanned(Expr::IntLit(0))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(not (= x 0))");
    }

    #[test]
    fn test_binary_comparisons() {
        let trans = SmtTranslator::new();

        for (op, expected) in [
            (BinOp::Lt, "(< 1 2)"),
            (BinOp::Gt, "(> 1 2)"),
            (BinOp::Le, "(<= 1 2)"),
            (BinOp::Ge, "(>= 1 2)"),
        ] {
            let expr = spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(1))),
                op,
                right: Box::new(spanned(Expr::IntLit(2))),
            });
            assert_eq!(trans.translate(&expr).unwrap(), expected, "Failed for op {:?}", op);
        }
    }

    #[test]
    fn test_binary_logical() {
        let trans = SmtTranslator::new();

        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::BoolLit(true))),
            op: BinOp::And,
            right: Box::new(spanned(Expr::BoolLit(false))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(and true false)");

        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::BoolLit(true))),
            op: BinOp::Or,
            right: Box::new(spanned(Expr::BoolLit(false))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(or true false)");
    }

    #[test]
    fn test_binary_implies() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::BoolLit(true))),
            op: BinOp::Implies,
            right: Box::new(spanned(Expr::BoolLit(false))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(=> true false)");
    }

    #[test]
    fn test_binary_shift_unsupported() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(1))),
            op: BinOp::Shl,
            right: Box::new(spanned(Expr::IntLit(2))),
        });
        assert!(trans.translate(&expr).is_err());
    }

    // ================================================================
    // Unary Operation Translation Tests
    // ================================================================

    #[test]
    fn test_unary_neg() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Unary {
            op: UnOp::Neg,
            expr: Box::new(spanned(Expr::IntLit(5))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(- 5)");
    }

    #[test]
    fn test_unary_not() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Unary {
            op: UnOp::Not,
            expr: Box::new(spanned(Expr::BoolLit(true))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(not true)");
    }

    #[test]
    fn test_unary_bnot_unsupported() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Unary {
            op: UnOp::Bnot,
            expr: Box::new(spanned(Expr::IntLit(5))),
        });
        assert!(trans.translate(&expr).is_err());
    }

    // ================================================================
    // Compound Expression Tests
    // ================================================================

    #[test]
    fn test_if_then_else() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::If {
            cond: Box::new(spanned(Expr::BoolLit(true))),
            then_branch: Box::new(spanned(Expr::IntLit(1))),
            else_branch: Box::new(spanned(Expr::IntLit(0))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(ite true 1 0)");
    }

    #[test]
    fn test_nested_binary() {
        // (1 + 2) * 3
        let trans = SmtTranslator::new();
        let inner = spanned(Expr::Binary {
            left: Box::new(spanned(Expr::IntLit(1))),
            op: BinOp::Add,
            right: Box::new(spanned(Expr::IntLit(2))),
        });
        let expr = spanned(Expr::Binary {
            left: Box::new(inner),
            op: BinOp::Mul,
            right: Box::new(spanned(Expr::IntLit(3))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(* (+ 1 2) 3)");
    }

    // ================================================================
    // SmtLibGenerator Tests
    // ================================================================

    #[test]
    fn test_generator_declare_and_assert() {
        let mut generator = SmtLibGenerator::new();
        generator.declare_var("x", SmtSort::Int);
        generator.assert("(> x 0)");
        let output = generator.generate();
        assert!(output.contains("(declare-const x Int)"));
        assert!(output.contains("(assert (> x 0))"));
        assert!(output.contains("(check-sat)"));
    }

    #[test]
    fn test_generator_clear() {
        let mut generator = SmtLibGenerator::new();
        generator.declare_var("x", SmtSort::Int);
        generator.clear();
        let output = generator.generate();
        assert!(!output.contains("declare-const x"));
    }

    // ================================================================
    // Type Sort Conversion Tests
    // ================================================================

    #[test]
    fn test_type_to_sort_basic() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::I64), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::I32), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Bool), SmtSort::Bool);
        assert_eq!(SmtTranslator::type_to_sort(&Type::F64), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Unit), SmtSort::Bool);
    }

    #[test]
    fn test_type_to_sort_concurrency() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Barrier), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Condvar), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::ThreadPool), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Scope), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::AsyncFile), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::AsyncSocket), SmtSort::Int);
    }

    // ---- Cycle 74: Additional SMT translator tests ----

    #[test]
    fn test_type_to_sort_ptr_ref() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Ptr(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Ref(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::RefMut(Box::new(Type::I64))), SmtSort::Int);
    }

    #[test]
    fn test_type_to_sort_array_tuple() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Array(Box::new(Type::I64), 10)), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Tuple(vec![Box::new(Type::I64)])), SmtSort::Int);
    }

    #[test]
    fn test_type_to_sort_nullable() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Nullable(Box::new(Type::I64))), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Nullable(Box::new(Type::Bool))), SmtSort::Bool);
    }

    #[test]
    fn test_type_to_sort_refined() {
        let refined = Type::Refined {
            base: Box::new(Type::I64),
            constraints: vec![Spanned::new(Expr::BoolLit(true), span())],
        };
        assert_eq!(SmtTranslator::type_to_sort(&refined), SmtSort::Int);
    }

    #[test]
    fn test_type_to_sort_never() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::Never), SmtSort::Bool);
    }

    #[test]
    fn test_type_to_sort_string_named() {
        assert_eq!(SmtTranslator::type_to_sort(&Type::String), SmtSort::Int);
        assert_eq!(SmtTranslator::type_to_sort(&Type::Named("Foo".to_string())), SmtSort::Int);
    }

    #[test]
    fn test_float_lit_positive() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::FloatLit(3.7));
        assert_eq!(trans.translate(&expr).unwrap(), "3");
    }

    #[test]
    fn test_float_lit_negative() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::FloatLit(-2.5));
        assert_eq!(trans.translate(&expr).unwrap(), "(- 2)");
    }

    #[test]
    fn test_todo_expr() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Todo { message: None });
        assert_eq!(trans.translate(&expr).unwrap(), "false");
    }

    #[test]
    fn test_break_continue_return() {
        let trans = SmtTranslator::new();
        assert_eq!(trans.translate(&spanned(Expr::Break { value: None })).unwrap(), "false");
        assert_eq!(trans.translate(&spanned(Expr::Continue)).unwrap(), "false");
        assert_eq!(trans.translate(&spanned(Expr::Return { value: None })).unwrap(), "false");
    }

    #[test]
    fn test_it_expr() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::It);
        assert_eq!(trans.translate(&expr).unwrap(), "__it__");
    }

    #[test]
    fn test_sizeof_expr() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Sizeof { ty: Spanned::new(Type::I64, span()) });
        assert_eq!(trans.translate(&expr).unwrap(), "8");
    }

    #[test]
    fn test_block_expr_empty() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Block(vec![]));
        assert_eq!(trans.translate(&expr).unwrap(), "true");
    }

    #[test]
    fn test_block_expr_last() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Block(vec![
            spanned(Expr::IntLit(1)),
            spanned(Expr::IntLit(2)),
            spanned(Expr::IntLit(42)),
        ]));
        assert_eq!(trans.translate(&expr).unwrap(), "42");
    }

    #[test]
    fn test_let_expr() {
        let trans = SmtTranslator::new();
        let expr = spanned(Expr::Let {
            name: "x".to_string(),
            mutable: false,
            ty: Some(Spanned::new(Type::I64, span())),
            value: Box::new(spanned(Expr::IntLit(5))),
            body: Box::new(spanned(Expr::IntLit(10))),
        });
        assert_eq!(trans.translate(&expr).unwrap(), "(let ((x 5)) 10)");
    }

    #[test]
    fn test_wrapping_arithmetic() {
        let trans = SmtTranslator::new();
        for (op, expected_smt) in [
            (BinOp::AddWrap, "+"),
            (BinOp::SubWrap, "-"),
            (BinOp::MulWrap, "*"),
        ] {
            let expr = spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(1))),
                op,
                right: Box::new(spanned(Expr::IntLit(2))),
            });
            let result = trans.translate(&expr).unwrap();
            assert!(result.contains(expected_smt), "Op {:?} should use {}", op, expected_smt);
        }
    }

    #[test]
    fn test_translate_error_display() {
        let e1 = TranslateError::UndefinedVariable("x".to_string());
        assert_eq!(format!("{}", e1), "undefined variable: x");

        let e2 = TranslateError::TypeMismatch("int vs bool".to_string());
        assert_eq!(format!("{}", e2), "type mismatch: int vs bool");

        let e3 = TranslateError::UnsupportedFeature("loops".to_string());
        assert_eq!(format!("{}", e3), "unsupported: loops");

        let e4 = TranslateError::RetNotDefined;
        assert_eq!(format!("{}", e4), "'ret' not defined");
    }

    #[test]
    fn test_unsupported_features() {
        let trans = SmtTranslator::new();

        assert!(trans.translate(&spanned(Expr::While {
            cond: Box::new(spanned(Expr::BoolLit(true))),
            invariant: None,
            body: Box::new(spanned(Expr::Unit)),
        })).is_err());

        assert!(trans.translate(&spanned(Expr::ArrayLit(vec![]))).is_err());
        assert!(trans.translate(&spanned(Expr::Tuple(vec![]))).is_err());

        assert!(trans.translate(&spanned(Expr::Match {
            expr: Box::new(spanned(Expr::IntLit(0))),
            arms: vec![],
        })).is_err());
    }

    #[test]
    fn test_generator_header_and_footer() {
        let generator = SmtLibGenerator::new();
        let output = generator.generate();
        assert!(output.contains("; Generated by BMB compiler"));
        assert!(output.contains("(set-logic QF_LIA)"));
        assert!(output.contains("(check-sat)"));
        assert!(output.contains("(get-model)"));
    }

    #[test]
    fn test_generator_bool_sort() {
        let mut generator = SmtLibGenerator::new();
        generator.declare_var("flag", SmtSort::Bool);
        let output = generator.generate();
        assert!(output.contains("(declare-const flag Bool)"));
    }

    #[test]
    fn test_translator_default() {
        let trans = SmtTranslator::default();
        assert!(trans.var_types().is_empty());
    }

    #[test]
    fn test_smt_sort_eq() {
        assert_eq!(SmtSort::Int, SmtSort::Int);
        assert_eq!(SmtSort::Bool, SmtSort::Bool);
        assert_ne!(SmtSort::Int, SmtSort::Bool);
    }

    #[test]
    fn test_bitwise_ops_unsupported() {
        let trans = SmtTranslator::new();
        for op in [BinOp::Band, BinOp::Bor, BinOp::Bxor, BinOp::Shr] {
            let expr = spanned(Expr::Binary {
                left: Box::new(spanned(Expr::IntLit(1))),
                op,
                right: Box::new(spanned(Expr::IntLit(2))),
            });
            assert!(trans.translate(&expr).is_err(), "Op {:?} should be unsupported", op);
        }
    }
}
