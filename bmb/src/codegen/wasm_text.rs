//! Text-based WASM Code Generation
//!
//! This module generates WebAssembly Text Format (.wat) that can be compiled
//! with wat2wasm or embedded in browsers. It provides a portable target
//! complementing the native LLVM backend.
//!
//! Architecture:
//! ```text
//! MIR (CFG-based)
//!     ↓
//! WASM Text Generator
//!     ↓
//! .wat file → wat2wasm → .wasm
//! ```

use std::fmt::Write;
use thiserror::Error;

use crate::mir::{
    BasicBlock, Constant, MirBinOp, MirExternFn, MirFunction, MirInst, MirProgram, MirType,
    MirUnaryOp, Operand, Terminator,
};

/// WASM text code generation error
#[derive(Debug, Error)]
pub enum WasmCodeGenError {
    #[error("Unknown function: {0}")]
    UnknownFunction(String),

    #[error("Unknown variable: {0}")]
    UnknownVariable(String),

    #[error("Formatting error: {0}")]
    FormatError(#[from] std::fmt::Error),

    #[error("Unsupported feature: {0}")]
    UnsupportedFeature(String),

    #[error("Stack validation error: {0}")]
    StackError(String),
}

/// Result type for WASM code generation
pub type WasmCodeGenResult<T> = Result<T, WasmCodeGenError>;

/// WASM target environment
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub enum WasmTarget {
    /// WASI runtime (command-line, file system access)
    #[default]
    Wasi,
    /// Browser/JS environment
    Browser,
    /// Standalone (no imports, pure computation)
    Standalone,
}

/// Text-based WASM Code Generator
pub struct WasmCodeGen {
    /// Target environment
    target: WasmTarget,
    /// Memory pages (64KB each)
    memory_pages: u32,
    /// v0.90.42: String constant table: string -> (offset, length)
    string_data: std::cell::RefCell<Vec<(String, u32)>>,
    /// v0.90.42: Next available data offset (starts after globals/IO buffer area)
    next_data_offset: std::cell::RefCell<u32>,
}

impl WasmCodeGen {
    /// Create a new WASM code generator with default settings
    pub fn new() -> Self {
        Self {
            target: WasmTarget::default(),
            memory_pages: 1,
            string_data: std::cell::RefCell::new(Vec::new()),
            next_data_offset: std::cell::RefCell::new(2048), // Start after reserved area
        }
    }

    /// Create with specific target environment
    pub fn with_target(target: WasmTarget) -> Self {
        Self {
            target,
            memory_pages: 1,
            string_data: std::cell::RefCell::new(Vec::new()),
            next_data_offset: std::cell::RefCell::new(2048),
        }
    }

    /// Set initial memory pages
    pub fn with_memory(mut self, pages: u32) -> Self {
        self.memory_pages = pages;
        self
    }

    /// v0.90.42: Intern a string constant and return its (offset, length)
    fn intern_string(&self, s: &str) -> (u32, u32) {
        // Check if already interned
        let data = self.string_data.borrow();
        for (existing, offset) in data.iter() {
            if existing == s {
                return (*offset, s.len() as u32);
            }
        }
        drop(data);
        // Add new string
        let offset = *self.next_data_offset.borrow();
        let len = s.len() as u32;
        self.string_data.borrow_mut().push((s.to_string(), offset));
        *self.next_data_offset.borrow_mut() = offset + len;
        (offset, len)
    }

    /// v0.90.42: Emit data section with collected string constants
    fn emit_data_section(&self, out: &mut String) -> WasmCodeGenResult<()> {
        let data = self.string_data.borrow();
        if data.is_empty() {
            return Ok(());
        }
        writeln!(out, "  ;; Data section: string constants")?;
        for (s, offset) in data.iter() {
            // Escape string for WAT data segment
            let escaped = s.bytes()
                .map(|b| format!("\\{:02x}", b))
                .collect::<String>();
            writeln!(out, "  (data (i32.const {}) \"{}\")", offset, escaped)?;
        }
        writeln!(out)?;
        Ok(())
    }

    /// Generate complete WASM module as text (.wat format)
    pub fn generate(&self, program: &MirProgram) -> WasmCodeGenResult<String> {
        let mut output = String::new();

        // Module header
        writeln!(output, "(module")?;
        writeln!(output, "  ;; Generated by BMB compiler (v0.12.1)")?;
        writeln!(output)?;

        // Memory declaration
        self.emit_memory(&mut output)?;

        // Global variables for runtime
        self.emit_globals(&mut output)?;

        // Runtime imports based on target (v0.13.0: includes extern fns)
        self.emit_imports(&mut output, program)?;

        // Generate function type signatures
        self.emit_types(&mut output, program)?;

        // Runtime helper functions (println, print, etc.)
        self.emit_runtime_functions(&mut output)?;

        // Generate functions
        for func in &program.functions {
            self.emit_function(&mut output, func)?;
        }

        // Export main function if exists
        self.emit_exports(&mut output, program)?;

        // v0.90.42: Emit string constant data section
        self.emit_data_section(&mut output)?;

        writeln!(output, ")")?;

        Ok(output)
    }

    /// Emit memory declaration
    fn emit_memory(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Memory: {} pages ({}KB)",
            self.memory_pages,
            self.memory_pages * 64)?;
        writeln!(out, "  (memory (export \"memory\") {})", self.memory_pages)?;
        writeln!(out)?;
        Ok(())
    }

    /// Emit global variables for runtime
    fn emit_globals(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Globals for runtime")?;
        // Heap pointer for simple memory allocation (starts after reserved area)
        writeln!(out, "  (global $heap_ptr (mut i32) (i32.const 1024))")?;
        // Buffer pointer for I/O operations
        writeln!(out, "  (global $io_buf i32 (i32.const 0))")?;
        writeln!(out)?;
        Ok(())
    }

    /// Emit runtime imports based on target
    fn emit_imports(&self, out: &mut String, program: &MirProgram) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Runtime imports")?;

        match self.target {
            WasmTarget::Wasi => {
                // WASI standard imports
                writeln!(out, "  (import \"wasi_snapshot_preview1\" \"fd_write\"")?;
                writeln!(out, "    (func $fd_write (param i32 i32 i32 i32) (result i32)))")?;
                writeln!(out, "  (import \"wasi_snapshot_preview1\" \"proc_exit\"")?;
                writeln!(out, "    (func $proc_exit (param i32)))")?;
            }
            WasmTarget::Browser => {
                // JavaScript interface
                writeln!(out, "  (import \"env\" \"console_log\"")?;
                writeln!(out, "    (func $console_log (param i64)))")?;
                writeln!(out, "  (import \"env\" \"console_log_f64\"")?;
                writeln!(out, "    (func $console_log_f64 (param f64)))")?;
            }
            WasmTarget::Standalone => {
                // No imports
                writeln!(out, "  ;; Standalone mode - no imports")?;
            }
        }

        // User-defined extern function imports (v0.13.0)
        if !program.extern_fns.is_empty() {
            writeln!(out)?;
            writeln!(out, "  ;; User-defined extern imports")?;
            for ext_fn in &program.extern_fns {
                self.emit_extern_import(out, ext_fn)?;
            }
        }

        writeln!(out)?;
        Ok(())
    }

    /// Emit a single extern function import (v0.13.0)
    fn emit_extern_import(&self, out: &mut String, ext_fn: &MirExternFn) -> WasmCodeGenResult<()> {
        let params: Vec<&str> = ext_fn
            .params
            .iter()
            .map(|ty| self.mir_type_to_wasm(ty))
            .collect();

        let ret = self.mir_type_to_wasm_result(&ext_fn.ret_ty);

        write!(out, "  (import \"{}\" \"{}\"", ext_fn.module, ext_fn.name)?;
        write!(out, "\n    (func ${}", ext_fn.name)?;

        if !params.is_empty() {
            write!(out, " (param")?;
            for p in &params {
                write!(out, " {}", p)?;
            }
            write!(out, ")")?;
        }

        if !ret.is_empty() {
            write!(out, " (result {})", ret)?;
        }

        writeln!(out, "))")?;
        Ok(())
    }

    /// Emit function type signatures
    fn emit_types(&self, out: &mut String, program: &MirProgram) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Function types")?;

        // Runtime function types
        writeln!(out, "  (type $t_println_i64 (func (param i64)))")?;
        writeln!(out, "  (type $t_print_i64 (func (param i64)))")?;
        writeln!(out, "  (type $t_exit (func (param i32)))")?;
        writeln!(out, "  (type $t_assert (func (param i32)))")?;

        for (i, func) in program.functions.iter().enumerate() {
            let params: Vec<&str> = func
                .params
                .iter()
                .map(|(_, ty)| self.mir_type_to_wasm(ty))
                .collect();
            let ret = self.mir_type_to_wasm_result(&func.ret_ty);

            write!(out, "  (type $type_{} (func", i)?;
            if !params.is_empty() {
                write!(out, " (param")?;
                for p in &params {
                    write!(out, " {}", p)?;
                }
                write!(out, ")")?;
            }
            if !ret.is_empty() {
                write!(out, " (result {})", ret)?;
            }
            writeln!(out, "))")?;
        }

        writeln!(out)?;
        Ok(())
    }

    /// Emit runtime helper functions (println, print, exit, assert)
    fn emit_runtime_functions(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Runtime helper functions")?;

        match self.target {
            WasmTarget::Wasi => {
                self.emit_wasi_runtime(out)?;
            }
            WasmTarget::Browser => {
                self.emit_browser_runtime(out)?;
            }
            WasmTarget::Standalone => {
                writeln!(out, "  ;; Standalone mode - no I/O functions")?;
            }
        }

        // v0.90.44: Bump allocator (all targets)
        self.emit_bump_allocator(out)?;

        writeln!(out)?;
        Ok(())
    }

    /// v0.90.44: Emit bump allocator function
    /// $bump_alloc(size: i32) -> i32 (pointer)
    /// Uses $heap_ptr global, advances by size, returns old pointer.
    fn emit_bump_allocator(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out)?;
        writeln!(out, "  ;; $bump_alloc: Bump allocator — allocate 'size' bytes from linear memory")?;
        writeln!(out, "  ;; Returns: pointer to allocated region (old heap_ptr)")?;
        writeln!(out, "  (func $bump_alloc (param $size i32) (result i32)")?;
        writeln!(out, "    (local $ptr i32)")?;
        writeln!(out, "    ;; Save current heap pointer")?;
        writeln!(out, "    (local.set $ptr (global.get $heap_ptr))")?;
        writeln!(out, "    ;; Advance heap pointer by size (8-byte aligned)")?;
        writeln!(out, "    (global.set $heap_ptr")?;
        writeln!(out, "      (i32.add")?;
        writeln!(out, "        (global.get $heap_ptr)")?;
        writeln!(out, "        (i32.and")?;
        writeln!(out, "          (i32.add (local.get $size) (i32.const 7))")?;
        writeln!(out, "          (i32.const -8)")?;
        writeln!(out, "        )")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out, "    ;; Return old pointer")?;
        writeln!(out, "    (local.get $ptr)")?;
        writeln!(out, "  )")?;
        Ok(())
    }

    /// Emit WASI runtime functions
    fn emit_wasi_runtime(&self, out: &mut String) -> WasmCodeGenResult<()> {
        // Helper: Convert i64 to decimal string and store at $io_buf
        // Returns length of string
        writeln!(out, "  ;; $i64_to_str: Convert i64 to decimal string at $io_buf")?;
        writeln!(out, "  ;; Returns: length of string")?;
        writeln!(out, "  (func $i64_to_str (param $val i64) (result i32)")?;
        writeln!(out, "    (local $len i32)")?;
        writeln!(out, "    (local $digit i64)")?;
        writeln!(out, "    (local $ptr i32)")?;
        writeln!(out, "    (local $neg i32)")?;
        writeln!(out, "    (local $start i32)")?;
        writeln!(out)?;
        writeln!(out, "    ;; Handle negative numbers")?;
        writeln!(out, "    (if (i64.lt_s (local.get $val) (i64.const 0))")?;
        writeln!(out, "      (then")?;
        writeln!(out, "        (local.set $neg (i32.const 1))")?;
        writeln!(out, "        (local.set $val (i64.sub (i64.const 0) (local.get $val)))")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    ;; Start at end of buffer (offset 100) and work backwards")?;
        writeln!(out, "    (local.set $ptr (i32.const 100))")?;
        writeln!(out)?;
        writeln!(out, "    ;; Handle zero specially")?;
        writeln!(out, "    (if (i64.eq (local.get $val) (i64.const 0))")?;
        writeln!(out, "      (then")?;
        writeln!(out, "        (i32.store8 (global.get $io_buf) (i32.const 48))  ;; '0'")?;
        writeln!(out, "        (return (i32.const 1))")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    ;; Extract digits (reversed)")?;
        writeln!(out, "    (block $done")?;
        writeln!(out, "      (loop $extract")?;
        writeln!(out, "        (br_if $done (i64.eq (local.get $val) (i64.const 0)))")?;
        writeln!(out, "        (local.set $digit (i64.rem_u (local.get $val) (i64.const 10)))")?;
        writeln!(out, "        (local.set $val (i64.div_u (local.get $val) (i64.const 10)))")?;
        writeln!(out, "        (local.set $ptr (i32.sub (local.get $ptr) (i32.const 1)))")?;
        writeln!(out, "        (i32.store8 (local.get $ptr) (i32.add (i32.const 48) (i32.wrap_i64 (local.get $digit))))")?;
        writeln!(out, "        (local.set $len (i32.add (local.get $len) (i32.const 1)))")?;
        writeln!(out, "        (br $extract)")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    ;; Add minus sign if negative")?;
        writeln!(out, "    (if (local.get $neg)")?;
        writeln!(out, "      (then")?;
        writeln!(out, "        (local.set $ptr (i32.sub (local.get $ptr) (i32.const 1)))")?;
        writeln!(out, "        (i32.store8 (local.get $ptr) (i32.const 45))  ;; '-'")?;
        writeln!(out, "        (local.set $len (i32.add (local.get $len) (i32.const 1)))")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    ;; Copy to beginning of buffer")?;
        writeln!(out, "    (local.set $start (i32.const 0))")?;
        writeln!(out, "    (block $copy_done")?;
        writeln!(out, "      (loop $copy")?;
        writeln!(out, "        (br_if $copy_done (i32.eq (local.get $start) (local.get $len)))")?;
        writeln!(out, "        (i32.store8 (i32.add (global.get $io_buf) (local.get $start))")?;
        writeln!(out, "          (i32.load8_u (local.get $ptr)))")?;
        writeln!(out, "        (local.set $start (i32.add (local.get $start) (i32.const 1)))")?;
        writeln!(out, "        (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))")?;
        writeln!(out, "        (br $copy)")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    (local.get $len)")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // println: print i64 with newline
        writeln!(out, "  ;; $println: Print i64 value with newline to stdout")?;
        writeln!(out, "  (func $println (param $val i64)")?;
        writeln!(out, "    (local $len i32)")?;
        writeln!(out, "    (local $written i32)")?;
        writeln!(out)?;
        writeln!(out, "    ;; Convert number to string")?;
        writeln!(out, "    (local.set $len (call $i64_to_str (local.get $val)))")?;
        writeln!(out)?;
        writeln!(out, "    ;; Add newline")?;
        writeln!(out, "    (i32.store8 (i32.add (global.get $io_buf) (local.get $len)) (i32.const 10))")?;
        writeln!(out, "    (local.set $len (i32.add (local.get $len) (i32.const 1)))")?;
        writeln!(out)?;
        writeln!(out, "    ;; Set up iovec at offset 200: [pointer, length]")?;
        writeln!(out, "    (i32.store (i32.const 200) (global.get $io_buf))  ;; iov_base")?;
        writeln!(out, "    (i32.store (i32.const 204) (local.get $len))       ;; iov_len")?;
        writeln!(out)?;
        writeln!(out, "    ;; fd_write(fd=1, iovs=200, iovs_len=1, nwritten=208)")?;
        writeln!(out, "    (drop (call $fd_write")?;
        writeln!(out, "      (i32.const 1)    ;; fd: stdout")?;
        writeln!(out, "      (i32.const 200)  ;; iovs")?;
        writeln!(out, "      (i32.const 1)    ;; iovs_len")?;
        writeln!(out, "      (i32.const 208)  ;; nwritten")?;
        writeln!(out, "    ))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // print: print i64 without newline
        writeln!(out, "  ;; $print: Print i64 value without newline to stdout")?;
        writeln!(out, "  (func $print (param $val i64)")?;
        writeln!(out, "    (local $len i32)")?;
        writeln!(out)?;
        writeln!(out, "    ;; Convert number to string")?;
        writeln!(out, "    (local.set $len (call $i64_to_str (local.get $val)))")?;
        writeln!(out)?;
        writeln!(out, "    ;; Set up iovec at offset 200")?;
        writeln!(out, "    (i32.store (i32.const 200) (global.get $io_buf))")?;
        writeln!(out, "    (i32.store (i32.const 204) (local.get $len))")?;
        writeln!(out)?;
        writeln!(out, "    ;; fd_write(fd=1, iovs=200, iovs_len=1, nwritten=208)")?;
        writeln!(out, "    (drop (call $fd_write")?;
        writeln!(out, "      (i32.const 1)")?;
        writeln!(out, "      (i32.const 200)")?;
        writeln!(out, "      (i32.const 1)")?;
        writeln!(out, "      (i32.const 208)")?;
        writeln!(out, "    ))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // exit: terminate with exit code
        writeln!(out, "  ;; $exit: Terminate process with exit code")?;
        writeln!(out, "  (func $exit (param $code i32)")?;
        writeln!(out, "    (call $proc_exit (local.get $code))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // assert: assertion that exits on failure
        writeln!(out, "  ;; $assert: Exit with code 1 if condition is false")?;
        writeln!(out, "  (func $assert (param $cond i32)")?;
        writeln!(out, "    (if (i32.eqz (local.get $cond))")?;
        writeln!(out, "      (then (call $proc_exit (i32.const 1)))")?;
        writeln!(out, "    )")?;
        writeln!(out, "  )")?;

        Ok(())
    }

    /// Emit Browser runtime functions
    fn emit_browser_runtime(&self, out: &mut String) -> WasmCodeGenResult<()> {
        // println: calls imported console_log
        writeln!(out, "  ;; $println: Print i64 value to console")?;
        writeln!(out, "  (func $println (param $val i64)")?;
        writeln!(out, "    (call $console_log (local.get $val))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // print: same as println in browser (console always adds newline)
        writeln!(out, "  ;; $print: Print i64 value to console")?;
        writeln!(out, "  (func $print (param $val i64)")?;
        writeln!(out, "    (call $console_log (local.get $val))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // exit: throw error (no process exit in browser)
        writeln!(out, "  ;; $exit: Simulate exit (unreachable in browser)")?;
        writeln!(out, "  (func $exit (param $code i32)")?;
        writeln!(out, "    unreachable")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // assert: throw if false
        writeln!(out, "  ;; $assert: Trap if condition is false")?;
        writeln!(out, "  (func $assert (param $cond i32)")?;
        writeln!(out, "    (if (i32.eqz (local.get $cond))")?;
        writeln!(out, "      (then unreachable)")?;
        writeln!(out, "    )")?;
        writeln!(out, "  )")?;

        Ok(())
    }

    /// Emit a function definition
    fn emit_function(&self, out: &mut String, func: &MirFunction) -> WasmCodeGenResult<()> {
        // Function signature
        let params: Vec<String> = func
            .params
            .iter()
            .map(|(name, ty)| format!("(param ${} {})", name, self.mir_type_to_wasm(ty)))
            .collect();

        let ret = self.mir_type_to_wasm_result(&func.ret_ty);
        let result_str = if ret.is_empty() {
            String::new()
        } else {
            format!(" (result {})", ret)
        };

        writeln!(out, "  (func ${} {}{}", func.name, params.join(" "), result_str)?;

        // Collect all locals: declared locals + temporaries from instructions
        let mut all_locals: std::collections::HashMap<String, MirType> = func.locals.iter().cloned().collect();

        // Collect destination places from all instructions (temporaries)
        for block in &func.blocks {
            for inst in &block.instructions {
                if let Some((name, ty)) = self.get_dest_place_info(inst, func) {
                    // Skip if already a parameter
                    if !func.params.iter().any(|(p, _)| p == &name) {
                        all_locals.entry(name).or_insert(ty);
                    }
                }
            }
        }

        // Emit local declarations
        for (name, ty) in &all_locals {
            writeln!(out, "    (local ${} {})", name, self.mir_type_to_wasm(ty))?;
        }

        // Emit basic blocks
        // For simple functions with one block, emit directly
        // For control flow, use WASM block/loop/br structure
        if func.blocks.len() == 1 {
            self.emit_simple_block(out, &func.blocks[0], func)?;
        } else {
            self.emit_control_flow(out, func)?;
        }

        writeln!(out, "  )")?;
        writeln!(out)?;

        Ok(())
    }

    /// Emit a simple single-block function body
    fn emit_simple_block(
        &self,
        out: &mut String,
        block: &BasicBlock,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        // Emit instructions
        for inst in &block.instructions {
            self.emit_instruction(out, inst, func)?;
        }

        // Emit terminator
        self.emit_terminator(out, &block.terminator, func)?;

        Ok(())
    }

    /// Emit control flow with blocks and branches
    fn emit_control_flow(&self, out: &mut String, func: &MirFunction) -> WasmCodeGenResult<()> {
        // WASM uses structured control flow with block/loop/br
        // Convert CFG to structured control flow

        // Simple approach: create a block for each label, use br_table
        writeln!(out, "    ;; Control flow (CFG to structured)")?;

        // Create outer block structure
        for block in func.blocks.iter().rev() {
            writeln!(out, "    (block ${}", block.label)?;
        }

        // Entry point
        writeln!(out, "      ;; Jump table dispatch")?;

        // For each block, emit its contents
        for block in &func.blocks {
            writeln!(out, "      ;; Block: {}", block.label)?;

            for inst in &block.instructions {
                self.emit_instruction(out, inst, func)?;
            }

            self.emit_terminator(out, &block.terminator, func)?;
        }

        // Close blocks
        for _ in &func.blocks {
            writeln!(out, "    )")?;
        }

        Ok(())
    }

    /// Emit an instruction (stack-based)
    fn emit_instruction(
        &self,
        out: &mut String,
        inst: &MirInst,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        match inst {
            MirInst::Const { dest, value } => {
                // Push constant to stack, then store to local
                self.emit_constant(out, value)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::Copy { dest, src } => {
                writeln!(out, "    local.get ${}", src.name)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::BinOp { dest, op, lhs, rhs } => {
                // v0.36: Special handling for Implies (P implies Q = !P || Q)
                if *op == MirBinOp::Implies {
                    // Push left operand and negate (xor with 1)
                    self.emit_operand(out, lhs)?;
                    writeln!(out, "    i32.const 1")?;
                    writeln!(out, "    i32.xor")?;
                    // Push right operand
                    self.emit_operand(out, rhs)?;
                    // Or them together
                    writeln!(out, "    i32.or")?;
                    // Store result
                    writeln!(out, "    local.set ${}", dest.name)?;
                } else {
                    // Push operands
                    self.emit_operand(out, lhs)?;
                    self.emit_operand(out, rhs)?;

                    // Apply operation
                    let wasm_op = self.binop_to_wasm(*op, lhs, func)?;
                    writeln!(out, "    {}", wasm_op)?;

                    // Store result
                    writeln!(out, "    local.set ${}", dest.name)?;
                }
            }

            MirInst::UnaryOp { dest, op, src } => {
                match op {
                    MirUnaryOp::Neg => {
                        // 0 - src
                        writeln!(out, "    i64.const 0")?;
                        self.emit_operand(out, src)?;
                        writeln!(out, "    i64.sub")?;
                    }
                    MirUnaryOp::FNeg => {
                        writeln!(out, "    f64.const 0.0")?;
                        self.emit_operand(out, src)?;
                        writeln!(out, "    f64.sub")?;
                    }
                    MirUnaryOp::Not => {
                        // XOR with 1
                        self.emit_operand(out, src)?;
                        writeln!(out, "    i32.const 1")?;
                        writeln!(out, "    i32.xor")?;
                    }
                    // v0.36: Bitwise not (XOR with -1)
                    MirUnaryOp::Bnot => {
                        self.emit_operand(out, src)?;
                        writeln!(out, "    i64.const -1")?;
                        writeln!(out, "    i64.xor")?;
                    }
                }
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::Call { dest, func: fn_name, args, is_tail: _ } => {
                // Push arguments (tail call not used in WASM text backend)
                for arg in args {
                    self.emit_operand(out, arg)?;
                }

                // Call function
                writeln!(out, "    call ${}", fn_name)?;

                // Store result if any
                if let Some(d) = dest {
                    writeln!(out, "    local.set ${}", d.name)?;
                }
            }

            MirInst::Phi { dest, values: _ } => {
                // PHI nodes are converted to explicit assignments in CFG-to-structured conversion
                // For now, just emit a placeholder
                writeln!(out, "    ;; PHI node for {} (requires CFG conversion)", dest.name)?;
            }

            // v0.19.0: Struct operations
            MirInst::StructInit { dest, struct_name, fields } => {
                // In WASM, structs are stored in linear memory
                // For now, allocate space on the stack and store field values
                writeln!(out, "    ;; struct {} init with {} fields", struct_name, fields.len())?;
                // v0.90.44: Bump-allocate struct (8 bytes per field)
                writeln!(out, "    i32.const {}", fields.len() * 8)?;
                writeln!(out, "    call $bump_alloc")?;
                writeln!(out, "    local.set ${}", dest.name)?;
                for (i, (field_name, value)) in fields.iter().enumerate() {
                    writeln!(out, "    ;; field {} at offset {}", field_name, i * 8)?;
                    // Get base pointer
                    writeln!(out, "    local.get ${}", dest.name)?;
                    // Add offset
                    writeln!(out, "    i32.const {}", i * 8)?;
                    writeln!(out, "    i32.add")?;
                    // Get value
                    self.emit_operand(out, value)?;
                    // Store (simplified: assume i64)
                    writeln!(out, "    i64.store")?;
                }
            }

            MirInst::FieldAccess { dest, base, field, field_index, struct_name: _ } => {
                // v0.51.23: Load field from struct in linear memory using field_index
                // v0.51.31: struct_name available for future type-aware codegen
                writeln!(out, "    ;; field access .{}[{}] from ${}", field, field_index, base.name)?;
                // Get base pointer and add field offset
                writeln!(out, "    local.get ${}", base.name)?;
                if *field_index > 0 {
                    writeln!(out, "    i32.const {}", field_index * 8)?;
                    writeln!(out, "    i32.add")?;
                }
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::FieldStore { base, field, field_index, struct_name: _, value } => {
                // v0.51.23: Store value to field in struct using field_index
                writeln!(out, "    ;; field store .{}[{}]", field, field_index)?;
                writeln!(out, "    local.get ${}", base.name)?;
                if *field_index > 0 {
                    writeln!(out, "    i32.const {}", field_index * 8)?;
                    writeln!(out, "    i32.add")?;
                }
                self.emit_operand(out, value)?;
                writeln!(out, "    i64.store")?;
            }

            // v0.19.1: Enum variant
            MirInst::EnumVariant { dest, enum_name, variant, args } => {
                // Enums are represented as tagged unions in linear memory
                writeln!(out, "    ;; enum {}::{} with {} args", enum_name, variant, args.len())?;
                // Calculate discriminant (simplified: hash of variant name)
                let discriminant: i64 = variant.bytes().fold(0i64, |acc, b| acc.wrapping_mul(31).wrapping_add(b as i64));
                // v0.90.44: Bump-allocate enum (discriminant + args, 8 bytes each)
                writeln!(out, "    i32.const {}", (args.len() + 1) * 8)?;
                writeln!(out, "    call $bump_alloc")?;
                writeln!(out, "    local.set ${}", dest.name)?;
                // Store discriminant at offset 0
                writeln!(out, "    local.get ${}", dest.name)?;
                writeln!(out, "    i64.const {}", discriminant)?;
                writeln!(out, "    i64.store")?;
                // Store variant arguments at subsequent offsets
                for (i, arg) in args.iter().enumerate() {
                    writeln!(out, "    local.get ${}", dest.name)?;
                    writeln!(out, "    i32.const {}", (i + 1) * 8)?;
                    writeln!(out, "    i32.add")?;
                    self.emit_operand(out, arg)?;
                    writeln!(out, "    i64.store")?;
                }
            }

            // v0.19.3: Array operations
            MirInst::ArrayInit { dest, element_type: _, elements } => {
                writeln!(out, "    ;; array init with {} elements", elements.len())?;
                // v0.90.44: Bump-allocate array (8 bytes per element)
                let size = elements.len() * 8;
                writeln!(out, "    i32.const {}", size)?;
                writeln!(out, "    call $bump_alloc")?;
                writeln!(out, "    local.set ${}", dest.name)?;
                // Store each element
                for (i, elem) in elements.iter().enumerate() {
                    writeln!(out, "    local.get ${}", dest.name)?;
                    writeln!(out, "    i32.const {}", i * 8)?;
                    writeln!(out, "    i32.add")?;
                    self.emit_operand(out, elem)?;
                    writeln!(out, "    i64.store")?;
                }
            }

            // v0.51.35: Added element_type field (unused in WASM, uses i64 for all)
            MirInst::IndexLoad { dest, array, index, element_type: _ } => {
                writeln!(out, "    ;; index load")?;
                // Calculate address: array_base + index * 8
                writeln!(out, "    local.get ${}", array.name)?;
                self.emit_operand(out, index)?;
                writeln!(out, "    i32.wrap_i64")?;  // Convert i64 index to i32
                writeln!(out, "    i32.const 8")?;
                writeln!(out, "    i32.mul")?;
                writeln!(out, "    i32.add")?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.51.35: Added element_type field (unused in WASM, uses i64 for all)
            MirInst::IndexStore { array, index, value, element_type: _ } => {
                writeln!(out, "    ;; index store")?;
                // Calculate address: array_base + index * 8
                writeln!(out, "    local.get ${}", array.name)?;
                self.emit_operand(out, index)?;
                writeln!(out, "    i32.wrap_i64")?;  // Convert i64 index to i32
                writeln!(out, "    i32.const 8")?;
                writeln!(out, "    i32.mul")?;
                writeln!(out, "    i32.add")?;
                self.emit_operand(out, value)?;
                writeln!(out, "    i64.store")?;
            }

            // v0.50.80: Type cast instruction
            MirInst::Cast { dest, src, from_ty, to_ty } => {
                writeln!(out, "    ;; cast {} -> {}", self.mir_type_str(from_ty), self.mir_type_str(to_ty))?;
                self.emit_operand(out, src)?;
                self.emit_wasm_cast(out, from_ty, to_ty)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.55: Tuple initialization - store elements in linear memory
            MirInst::TupleInit { dest, elements } => {
                writeln!(out, "    ;; tuple init with {} elements", elements.len())?;
                // v0.90.48: Use bump allocator (8 bytes per element)
                let size = elements.len() * 8;
                writeln!(out, "    i32.const {}", size)?;
                writeln!(out, "    call $bump_alloc")?;
                writeln!(out, "    local.set ${}", dest.name)?;
                // Store each element
                for (i, (_, op)) in elements.iter().enumerate() {
                    writeln!(out, "    local.get ${}", dest.name)?;
                    writeln!(out, "    i32.const {}", i * 8)?;
                    writeln!(out, "    i32.add")?;
                    self.emit_operand(out, op)?;
                    writeln!(out, "    i64.store")?;
                }
            }

            // v0.55: Tuple field extraction - load element from memory
            MirInst::TupleExtract { dest, tuple, index, element_type: _ } => {
                writeln!(out, "    ;; tuple extract index {}", index)?;
                writeln!(out, "    local.get ${}", tuple.name)?;
                writeln!(out, "    i32.const {}", index * 8)?;
                writeln!(out, "    i32.add")?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.60.19: Pointer offset - compute ptr + offset * element_size
            MirInst::PtrOffset { dest, ptr, offset, element_type } => {
                // Calculate element size (8 for i64/f64/ptr, 4 for i32, etc.)
                let elem_size = match element_type {
                    MirType::I32 | MirType::U32 => 4,
                    MirType::I64 | MirType::U64 | MirType::F64 | MirType::Ptr(_) | MirType::StructPtr(_) => 8,
                    MirType::Bool | MirType::Char => 1,
                    MirType::Struct { fields, .. } => fields.len() * 8, // Rough estimate
                    _ => 8, // Default to 8 bytes
                };
                writeln!(out, "    ;; ptr offset")?;
                self.emit_operand(out, ptr)?;
                self.emit_operand(out, offset)?;
                writeln!(out, "    i64.const {}", elem_size)?;
                writeln!(out, "    i64.mul")?;
                writeln!(out, "    i64.add")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.60.21: Stack array allocation - for WASM we need to use linear memory
            // This is a simplified implementation that allocates from the stack pointer
            MirInst::ArrayAlloc { dest, element_type, size } => {
                // Calculate element size (8 for i64/f64/ptr, 4 for i32, etc.)
                let elem_size = match element_type {
                    MirType::I32 | MirType::U32 => 4,
                    MirType::I64 | MirType::U64 | MirType::F64 | MirType::Ptr(_) | MirType::StructPtr(_) => 8,
                    MirType::Bool | MirType::Char => 1,
                    _ => 8, // Default to 8 bytes
                };
                let total_size = elem_size * size;
                writeln!(out, "    ;; array alloc [{} x {} bytes]", size, elem_size)?;
                // v0.90.48: Use bump allocator
                writeln!(out, "    i32.const {}", total_size)?;
                writeln!(out, "    call $bump_alloc")?;
                writeln!(out, "    i64.extend_i32_u")?; // Convert to i64 for pointer
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.60.20: Pointer load - load from memory through pointer
            MirInst::PtrLoad { dest, ptr, element_type } => {
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i32.wrap_i64")?; // Convert i64 ptr to i32 address
                let load_op = match element_type {
                    MirType::I32 | MirType::U32 => "i32.load",
                    MirType::I64 | MirType::U64 | MirType::Ptr(_) | MirType::StructPtr(_) => "i64.load",
                    MirType::F64 => "f64.load",
                    MirType::Bool | MirType::Char => "i32.load8_u",
                    _ => "i64.load", // Default
                };
                writeln!(out, "    {}", load_op)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.60.20: Pointer store - store to memory through pointer
            MirInst::PtrStore { ptr, value, element_type } => {
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i32.wrap_i64")?; // Convert i64 ptr to i32 address
                self.emit_operand(out, value)?;
                let store_op = match element_type {
                    MirType::I32 | MirType::U32 => "i32.store",
                    MirType::I64 | MirType::U64 | MirType::Ptr(_) | MirType::StructPtr(_) => "i64.store",
                    MirType::F64 => "f64.store",
                    MirType::Bool | MirType::Char => "i32.store8",
                    _ => "i64.store", // Default
                };
                writeln!(out, "    {}", store_op)?;
            }

            // v0.70: Threading is not supported in WASM
            MirInst::ThreadSpawn { dest, .. } => {
                writeln!(out, "    ;; WARNING: ThreadSpawn not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::ThreadJoin { dest, handle } => {
                writeln!(out, "    ;; WARNING: ThreadJoin not supported in WASM")?;
                self.emit_operand(out, handle)?;
                writeln!(out, "    drop")?;
                if let Some(d) = dest {
                    writeln!(out, "    i64.const 0")?;
                    writeln!(out, "    local.set ${}", d.name)?;
                }
            }

            // v0.71: Mutex operations not supported in WASM
            MirInst::MutexNew { dest, initial_value } => {
                writeln!(out, "    ;; WARNING: MutexNew not supported in WASM")?;
                self.emit_operand(out, initial_value)?;
                writeln!(out, "    drop")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::MutexLock { dest, mutex } => {
                writeln!(out, "    ;; WARNING: MutexLock not supported in WASM")?;
                self.emit_operand(out, mutex)?;
                writeln!(out, "    drop")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::MutexUnlock { mutex, new_value } => {
                writeln!(out, "    ;; WARNING: MutexUnlock not supported in WASM")?;
                self.emit_operand(out, mutex)?;
                writeln!(out, "    drop")?;
                self.emit_operand(out, new_value)?;
                writeln!(out, "    drop")?;
            }

            MirInst::MutexTryLock { dest, mutex } => {
                writeln!(out, "    ;; WARNING: MutexTryLock not supported in WASM")?;
                self.emit_operand(out, mutex)?;
                writeln!(out, "    drop")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::MutexFree { mutex } => {
                writeln!(out, "    ;; WARNING: MutexFree not supported in WASM")?;
                self.emit_operand(out, mutex)?;
                writeln!(out, "    drop")?;
            }

            // v0.72: Arc operations not supported in WASM
            MirInst::ArcNew { dest, value } => {
                writeln!(out, "    ;; WARNING: ArcNew not supported in WASM")?;
                self.emit_operand(out, value)?;
                writeln!(out, "    drop")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::ArcClone { dest, arc } => {
                writeln!(out, "    ;; WARNING: ArcClone not supported in WASM")?;
                self.emit_operand(out, arc)?;
                writeln!(out, "    drop")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::ArcGet { dest, arc } => {
                writeln!(out, "    ;; WARNING: ArcGet not supported in WASM")?;
                self.emit_operand(out, arc)?;
                writeln!(out, "    drop")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::ArcDrop { arc } => {
                writeln!(out, "    ;; WARNING: ArcDrop not supported in WASM")?;
                self.emit_operand(out, arc)?;
                writeln!(out, "    drop")?;
            }

            MirInst::ArcStrongCount { dest, arc } => {
                writeln!(out, "    ;; WARNING: ArcStrongCount not supported in WASM")?;
                self.emit_operand(out, arc)?;
                writeln!(out, "    drop")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.72: Atomic operations - WASM has atomic support but we use stubs for now
            MirInst::AtomicNew { dest, value } => {
                writeln!(out, "    ;; WARNING: AtomicNew - using non-atomic fallback in WASM")?;
                self.emit_operand(out, value)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::AtomicLoad { dest, ptr } => {
                writeln!(out, "    ;; WARNING: AtomicLoad - using non-atomic fallback in WASM")?;
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::AtomicStore { ptr, value } => {
                writeln!(out, "    ;; WARNING: AtomicStore - using non-atomic fallback in WASM")?;
                self.emit_operand(out, ptr)?;
                self.emit_operand(out, value)?;
                writeln!(out, "    i64.store")?;
            }

            MirInst::AtomicFetchAdd { dest, ptr, delta } => {
                writeln!(out, "    ;; WARNING: AtomicFetchAdd - using non-atomic fallback in WASM")?;
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.tee ${}", dest.name)?;
                self.emit_operand(out, delta)?;
                writeln!(out, "    i64.add")?;
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i64.store")?;
            }

            MirInst::AtomicFetchSub { dest, ptr, delta } => {
                writeln!(out, "    ;; WARNING: AtomicFetchSub - using non-atomic fallback in WASM")?;
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.tee ${}", dest.name)?;
                self.emit_operand(out, delta)?;
                writeln!(out, "    i64.sub")?;
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i64.store")?;
            }

            MirInst::AtomicSwap { dest, ptr, new_value } => {
                writeln!(out, "    ;; WARNING: AtomicSwap - using non-atomic fallback in WASM")?;
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.set ${}", dest.name)?;
                self.emit_operand(out, ptr)?;
                self.emit_operand(out, new_value)?;
                writeln!(out, "    i64.store")?;
            }

            MirInst::AtomicCompareExchange { dest, ptr, expected, new_value } => {
                writeln!(out, "    ;; WARNING: AtomicCompareExchange - using non-atomic fallback in WASM")?;
                // Load current value
                self.emit_operand(out, ptr)?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.tee ${}", dest.name)?;
                // Compare with expected
                self.emit_operand(out, expected)?;
                writeln!(out, "    i64.eq")?;
                writeln!(out, "    if")?;
                // If equal, store new value
                self.emit_operand(out, ptr)?;
                self.emit_operand(out, new_value)?;
                writeln!(out, "    i64.store")?;
                writeln!(out, "    end")?;
            }

            // ================================================================
            // v0.73: Channel operations (not supported in WASM - stubs)
            // ================================================================

            MirInst::ChannelNew { sender_dest, receiver_dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", sender_dest.name)?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", receiver_dest.name)?;
            }

            MirInst::ChannelSend { .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
            }

            MirInst::ChannelRecv { dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::ChannelTrySend { dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::ChannelTryRecv { dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.77: Receive with timeout (not supported in WASM)
            MirInst::ChannelRecvTimeout { dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.78: Block on future (in sync mode, just return the value)
            MirInst::BlockOn { dest, future } => {
                writeln!(out, "    ;; block_on: in sync mode, future IS the result")?;
                self.emit_operand(out, future)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.79: Send with timeout (not supported in WASM)
            MirInst::ChannelSendTimeout { dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.80: Channel close operations (not supported in WASM)
            MirInst::ChannelClose { .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
            }

            MirInst::ChannelIsClosed { dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::ChannelRecvOpt { dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const -1")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::SenderClone { dest, .. } => {
                writeln!(out, "    ;; ERROR: Channels not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.74: RwLock instructions (not supported in WASM)
            MirInst::RwLockNew { dest, .. } => {
                writeln!(out, "    ;; ERROR: RwLock not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::RwLockRead { dest, .. } => {
                writeln!(out, "    ;; ERROR: RwLock not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::RwLockReadUnlock { .. } => {
                writeln!(out, "    ;; ERROR: RwLock not supported in WASM")?;
            }

            MirInst::RwLockWrite { dest, .. } => {
                writeln!(out, "    ;; ERROR: RwLock not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::RwLockWriteUnlock { .. } => {
                writeln!(out, "    ;; ERROR: RwLock not supported in WASM")?;
            }

            // v0.74: Barrier instructions (not supported in WASM)
            MirInst::BarrierNew { dest, .. } => {
                writeln!(out, "    ;; ERROR: Barrier not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::BarrierWait { dest, .. } => {
                writeln!(out, "    ;; ERROR: Barrier not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            // v0.74: Condvar instructions (not supported in WASM)
            MirInst::CondvarNew { dest } => {
                writeln!(out, "    ;; ERROR: Condvar not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::CondvarWait { dest, .. } => {
                writeln!(out, "    ;; ERROR: Condvar not supported in WASM")?;
                writeln!(out, "    i64.const 0")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::CondvarNotifyOne { .. } => {
                writeln!(out, "    ;; ERROR: Condvar not supported in WASM")?;
            }

            MirInst::CondvarNotifyAll { .. } => {
                writeln!(out, "    ;; ERROR: Condvar not supported in WASM")?;
            }

            // v0.83: AsyncFile instructions (not supported in WASM yet)
            MirInst::AsyncFileOpen { .. } => {
                writeln!(out, "    ;; ERROR: AsyncFile not supported in WASM")?;
            }
            MirInst::AsyncFileRead { .. } => {
                writeln!(out, "    ;; ERROR: AsyncFile not supported in WASM")?;
            }
            MirInst::AsyncFileWrite { .. } => {
                writeln!(out, "    ;; ERROR: AsyncFile not supported in WASM")?;
            }
            MirInst::AsyncFileClose { .. } => {
                writeln!(out, "    ;; ERROR: AsyncFile not supported in WASM")?;
            }

            // v0.83.1: AsyncSocket instructions (not supported in WASM yet)
            MirInst::AsyncSocketConnect { .. } => {
                writeln!(out, "    ;; ERROR: AsyncSocket not supported in WASM")?;
            }
            MirInst::AsyncSocketRead { .. } => {
                writeln!(out, "    ;; ERROR: AsyncSocket not supported in WASM")?;
            }
            MirInst::AsyncSocketWrite { .. } => {
                writeln!(out, "    ;; ERROR: AsyncSocket not supported in WASM")?;
            }
            MirInst::AsyncSocketClose { .. } => {
                writeln!(out, "    ;; ERROR: AsyncSocket not supported in WASM")?;
            }

            // v0.84: ThreadPool instructions (not supported in WASM yet)
            MirInst::ThreadPoolNew { .. } => {
                writeln!(out, "    ;; ERROR: ThreadPool not supported in WASM")?;
            }
            MirInst::ThreadPoolExecute { .. } => {
                writeln!(out, "    ;; ERROR: ThreadPool not supported in WASM")?;
            }
            MirInst::ThreadPoolJoin { .. } => {
                writeln!(out, "    ;; ERROR: ThreadPool not supported in WASM")?;
            }
            MirInst::ThreadPoolShutdown { .. } => {
                writeln!(out, "    ;; ERROR: ThreadPool not supported in WASM")?;
            }

            // v0.85: Scope instructions (not supported in WASM yet)
            MirInst::ScopeNew { .. } => {
                writeln!(out, "    ;; ERROR: Scope not supported in WASM")?;
            }
            MirInst::ScopeSpawn { .. } => {
                writeln!(out, "    ;; ERROR: Scope not supported in WASM")?;
            }
            MirInst::ScopeWait { .. } => {
                writeln!(out, "    ;; ERROR: Scope not supported in WASM")?;
            }

            // v0.76: Select instruction
            MirInst::Select { dest, cond_op, cond_lhs, cond_rhs, true_val, false_val } => {
                // WASM select instruction: select(true_val, false_val, cond)
                // Push true value
                self.emit_operand(out, true_val)?;
                // Push false value
                self.emit_operand(out, false_val)?;
                // Push condition operands and compare
                self.emit_operand(out, cond_lhs)?;
                self.emit_operand(out, cond_rhs)?;
                // Emit comparison
                let cmp_op = match cond_op {
                    MirBinOp::Eq => "i64.eq",
                    MirBinOp::Ne => "i64.ne",
                    MirBinOp::Lt => "i64.lt_s",
                    MirBinOp::Le => "i64.le_s",
                    MirBinOp::Gt => "i64.gt_s",
                    MirBinOp::Ge => "i64.ge_s",
                    _ => "i64.eq",  // Fallback
                };
                writeln!(out, "    {}", cmp_op)?;
                // Select based on condition
                writeln!(out, "    select")?;
                // Store result
                writeln!(out, "    local.set ${}", dest.name)?;
            }
        }

        Ok(())
    }

    /// Emit a constant value
    fn emit_constant(&self, out: &mut String, c: &Constant) -> WasmCodeGenResult<()> {
        match c {
            Constant::Int(n) => writeln!(out, "    i64.const {}", n)?,
            Constant::Float(f) => writeln!(out, "    f64.const {}", f)?,
            Constant::Bool(b) => writeln!(out, "    i32.const {}", if *b { 1 } else { 0 })?,
            Constant::Unit => writeln!(out, "    ;; unit (no value)")?,
            Constant::String(s) => {
                // v0.90.42: String constants stored in data section
                let (offset, _len) = self.intern_string(s);
                writeln!(out, "    i32.const {}  ;; string \"{}\"", offset,
                    if s.len() > 20 { &s[..20] } else { s })?;
            }
            // v0.64: Character constant (Unicode codepoint as i32)
            Constant::Char(c) => writeln!(out, "    i32.const {}", *c as u32)?,
        }
        Ok(())
    }

    /// Emit an operand (push to stack)
    fn emit_operand(&self, out: &mut String, op: &Operand) -> WasmCodeGenResult<()> {
        match op {
            Operand::Place(p) => writeln!(out, "    local.get ${}", p.name)?,
            Operand::Constant(c) => self.emit_constant(out, c)?,
        }
        Ok(())
    }

    /// v0.50.80: Get MIR type as string for comments
    fn mir_type_str(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::I32 => "i32",
            MirType::I64 => "i64",
            MirType::U32 => "u32",
            MirType::U64 => "u64",
            MirType::F64 => "f64",
            MirType::Bool => "bool",
            MirType::String => "string",
            MirType::Unit => "unit",
            MirType::Char => "char",
            MirType::Struct { .. } | MirType::StructPtr(_) => "struct",
            MirType::Enum { .. } => "enum",
            MirType::Array { .. } => "array",
            // v0.51.37: Pointer type
            MirType::Ptr(_) => "ptr",
            // v0.55: Tuple type
            MirType::Tuple(_) => "tuple",
        }
    }

    /// v0.50.80: Emit WASM type cast instructions
    fn emit_wasm_cast(&self, out: &mut String, from_ty: &MirType, to_ty: &MirType) -> WasmCodeGenResult<()> {
        use MirType::*;
        match (from_ty, to_ty) {
            // Same type - no conversion
            (a, b) if a == b => {}

            // i32 -> i64 (sign extend)
            (I32, I64) | (I32, U64) | (Char, I64) | (Char, U64) => {
                writeln!(out, "    i64.extend_i32_s")?;
            }
            (U32, I64) | (U32, U64) => {
                writeln!(out, "    i64.extend_i32_u")?;
            }
            (Bool, I64) | (Bool, U64) => {
                writeln!(out, "    i64.extend_i32_u")?;
            }
            (Bool, I32) | (Bool, U32) => {
                // Bool is already i32 in WASM, no conversion needed
            }

            // i64 -> i32 (truncate)
            (I64, I32) | (U64, I32) | (I64, U32) | (U64, U32) => {
                writeln!(out, "    i32.wrap_i64")?;
            }
            (I64, Char) | (U64, Char) => {
                writeln!(out, "    i32.wrap_i64")?;
            }

            // Integer to float
            (I32, F64) | (I64, F64) | (Char, F64) => {
                if matches!(from_ty, I32 | Char) {
                    writeln!(out, "    f64.convert_i32_s")?;
                } else {
                    writeln!(out, "    f64.convert_i64_s")?;
                }
            }
            (U32, F64) => {
                writeln!(out, "    f64.convert_i32_u")?;
            }
            (U64, F64) => {
                writeln!(out, "    f64.convert_i64_u")?;
            }

            // Float to integer
            (F64, I32) | (F64, Char) => {
                writeln!(out, "    i32.trunc_f64_s")?;
            }
            (F64, U32) => {
                writeln!(out, "    i32.trunc_f64_u")?;
            }
            (F64, I64) => {
                writeln!(out, "    i64.trunc_f64_s")?;
            }
            (F64, U64) => {
                writeln!(out, "    i64.trunc_f64_u")?;
            }

            // Fallback - no conversion
            _ => {
                writeln!(out, "    ;; unsupported cast {:?} -> {:?}", from_ty, to_ty)?;
            }
        }
        Ok(())
    }

    /// Emit a terminator
    fn emit_terminator(
        &self,
        out: &mut String,
        term: &Terminator,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        match term {
            Terminator::Return(None) => {
                if func.ret_ty != MirType::Unit {
                    // Return default value
                    let default = self.default_value(&func.ret_ty);
                    writeln!(out, "    {}", default)?;
                }
                writeln!(out, "    return")?;
            }

            Terminator::Return(Some(val)) => {
                self.emit_operand(out, val)?;
                writeln!(out, "    return")?;
            }

            Terminator::Goto(label) => {
                writeln!(out, "    br ${}", label)?;
            }

            Terminator::Branch { cond, then_label, else_label } => {
                self.emit_operand(out, cond)?;
                writeln!(out, "    (if")?;
                writeln!(out, "      (then br ${})", then_label)?;
                writeln!(out, "      (else br ${}))", else_label)?;
            }

            Terminator::Unreachable => {
                writeln!(out, "    unreachable")?;
            }

            // v0.19.2: Switch for pattern matching using br_table
            Terminator::Switch { discriminant, cases, default } => {
                self.emit_operand(out, discriminant)?;
                writeln!(out, "    (block ${}", default)?;
                // Generate cascading if-else for now (br_table needs contiguous indices)
                for (val, label) in cases {
                    writeln!(out, "      (i64.const {})", val)?;
                    writeln!(out, "      i64.eq")?;
                    writeln!(out, "      (br_if ${})", label)?;
                    self.emit_operand(out, discriminant)?;
                }
                writeln!(out, "      (br ${}))", default)?;
            }
        }

        Ok(())
    }

    /// Emit exports
    fn emit_exports(&self, out: &mut String, program: &MirProgram) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Exports")?;

        for func in &program.functions {
            if func.name == "main" {
                // Export main as _start for WASI compatibility
                writeln!(out, "  (export \"_start\" (func $main))")?;
            }
            // Export all functions
            writeln!(out, "  (export \"{}\" (func ${}))", func.name, func.name)?;
        }

        writeln!(out)?;
        Ok(())
    }

    /// Convert MIR type to WASM type
    fn mir_type_to_wasm(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::I32 => "i32",
            MirType::I64 => "i64",
            // v0.38: Unsigned types map to same WASM types
            MirType::U32 => "i32",
            MirType::U64 => "i64",
            MirType::F64 => "f64",
            MirType::Bool => "i32",  // WASM has no boolean, use i32
            MirType::String => "i32", // Pointer (memory offset)
            MirType::Unit => "i32",   // No void in WASM params/returns
            // v0.19.0: Struct types are represented as pointers (i32 in WASM)
            MirType::Struct { .. } => "i32",
            MirType::StructPtr(_) => "i32",
            // v0.19.1: Enum types are represented as pointers (i32 in WASM)
            MirType::Enum { .. } => "i32",
            // v0.19.3: Array types are represented as pointers (i32 in WASM)
            MirType::Array { .. } => "i32",
            // v0.64: Character type (Unicode codepoint as i32)
            MirType::Char => "i32",
            // v0.51.37: Pointer types are i32 in WASM (memory offsets)
            MirType::Ptr(_) => "i32",
            // v0.55: Tuple types are pointers (i32 in WASM)
            MirType::Tuple(_) => "i32",
        }
    }

    /// Convert MIR type to WASM result type (empty string for Unit)
    fn mir_type_to_wasm_result(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::Unit => "",
            _ => self.mir_type_to_wasm(ty),
        }
    }

    /// Get default value for a type
    fn default_value(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::I32 => "i32.const 0",
            MirType::I64 => "i64.const 0",
            // v0.38: Unsigned types default to 0
            MirType::U32 => "i32.const 0",
            MirType::U64 => "i64.const 0",
            MirType::F64 => "f64.const 0.0",
            MirType::Bool => "i32.const 0",
            MirType::String => "i32.const 0",
            // v0.64: Character default to null char
            MirType::Char => "i32.const 0",
            MirType::Unit => "",
            // v0.19.0: Struct pointers default to null (0)
            MirType::Struct { .. } => "i32.const 0",
            MirType::StructPtr(_) => "i32.const 0",
            // v0.19.1: Enum pointers default to null (0)
            MirType::Enum { .. } => "i32.const 0",
            // v0.19.3: Array pointers default to null (0)
            MirType::Array { .. } => "i32.const 0",
            // v0.51.37: Pointer types default to null (0)
            MirType::Ptr(_) => "i32.const 0",
            // v0.55: Tuple pointers default to null (0)
            MirType::Tuple(_) => "i32.const 0",
        }
    }

    /// Convert binary operator to WASM instruction
    fn binop_to_wasm(&self, op: MirBinOp, lhs: &Operand, func: &MirFunction) -> WasmCodeGenResult<String> {
        let ty = self.infer_operand_wasm_type(lhs, func);

        let instr = match op {
            // Integer arithmetic
            MirBinOp::Add => format!("{}.add", ty),
            MirBinOp::Sub => format!("{}.sub", ty),
            MirBinOp::Mul => format!("{}.mul", ty),
            MirBinOp::Div => format!("{}.div_s", ty),  // Signed division
            MirBinOp::Mod => format!("{}.rem_s", ty),  // Signed remainder

            // v0.37: Wrapping arithmetic (WASM naturally wraps, same as normal ops)
            MirBinOp::AddWrap => format!("{}.add", ty),
            MirBinOp::SubWrap => format!("{}.sub", ty),
            MirBinOp::MulWrap => format!("{}.mul", ty),

            // v0.38: Checked arithmetic (for now, same as normal ops; full Option handling later)
            MirBinOp::AddChecked => format!("{}.add", ty),
            MirBinOp::SubChecked => format!("{}.sub", ty),
            MirBinOp::MulChecked => format!("{}.mul", ty),

            // v0.38: Saturating arithmetic (for now, same as normal ops; full saturation logic later)
            MirBinOp::AddSat => format!("{}.add", ty),
            MirBinOp::SubSat => format!("{}.sub", ty),
            MirBinOp::MulSat => format!("{}.mul", ty),

            // Floating-point arithmetic
            MirBinOp::FAdd => "f64.add".to_string(),
            MirBinOp::FSub => "f64.sub".to_string(),
            MirBinOp::FMul => "f64.mul".to_string(),
            MirBinOp::FDiv => "f64.div".to_string(),

            // Integer comparison
            MirBinOp::Eq => format!("{}.eq", ty),
            MirBinOp::Ne => format!("{}.ne", ty),
            MirBinOp::Lt => format!("{}.lt_s", ty),
            MirBinOp::Gt => format!("{}.gt_s", ty),
            MirBinOp::Le => format!("{}.le_s", ty),
            MirBinOp::Ge => format!("{}.ge_s", ty),

            // Floating-point comparison
            MirBinOp::FEq => "f64.eq".to_string(),
            MirBinOp::FNe => "f64.ne".to_string(),
            MirBinOp::FLt => "f64.lt".to_string(),
            MirBinOp::FGt => "f64.gt".to_string(),
            MirBinOp::FLe => "f64.le".to_string(),
            MirBinOp::FGe => "f64.ge".to_string(),

            // Logical
            MirBinOp::And => "i32.and".to_string(),
            MirBinOp::Or => "i32.or".to_string(),

            // v0.32: Shift operators
            MirBinOp::Shl => format!("{}.shl", ty),
            MirBinOp::Shr => format!("{}.shr_s", ty),  // arithmetic shift right (signed)

            // v0.36: Bitwise operators
            MirBinOp::Band => format!("{}.and", ty),
            MirBinOp::Bor => format!("{}.or", ty),
            MirBinOp::Bxor => format!("{}.xor", ty),

            // v0.36: Implies is handled specially in emit_instruction
            // This arm exists for exhaustiveness
            MirBinOp::Implies => "i32.or".to_string(),
        };

        Ok(instr)
    }

    /// Get destination place info from an instruction (name, type)
    fn get_dest_place_info(&self, inst: &MirInst, func: &MirFunction) -> Option<(String, MirType)> {
        match inst {
            MirInst::Const { dest, value } => {
                let ty = match value {
                    Constant::Int(_) => MirType::I64,
                    Constant::Float(_) => MirType::F64,
                    Constant::Bool(_) => MirType::Bool,
                    Constant::String(_) => MirType::String,
                    // v0.64: Character type
                    Constant::Char(_) => MirType::Char,
                    Constant::Unit => MirType::Unit,
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::Copy { dest, src } => {
                // Infer type from source
                let ty = self.infer_place_mir_type(&src.name, func);
                Some((dest.name.clone(), ty))
            }
            MirInst::BinOp { dest, op, lhs, .. } => {
                // Result type depends on operation
                let ty = match op {
                    MirBinOp::Eq | MirBinOp::Ne | MirBinOp::Lt | MirBinOp::Gt |
                    MirBinOp::Le | MirBinOp::Ge | MirBinOp::FEq | MirBinOp::FNe |
                    MirBinOp::FLt | MirBinOp::FGt | MirBinOp::FLe | MirBinOp::FGe |
                    MirBinOp::And | MirBinOp::Or | MirBinOp::Implies => MirType::Bool,
                    MirBinOp::FAdd | MirBinOp::FSub | MirBinOp::FMul | MirBinOp::FDiv => MirType::F64,
                    _ => self.infer_operand_mir_type(lhs, func),
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::UnaryOp { dest, op, src } => {
                let ty = match op {
                    MirUnaryOp::Not => MirType::Bool,
                    MirUnaryOp::Neg => self.infer_operand_mir_type(src, func),
                    MirUnaryOp::FNeg => MirType::F64,
                    // v0.36: Bitwise not returns same type as operand
                    MirUnaryOp::Bnot => self.infer_operand_mir_type(src, func),
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::Call { dest, .. } => {
                dest.as_ref().map(|d| (d.name.clone(), MirType::I64)) // Default to i64
            }
            MirInst::Phi { dest, values } => {
                let ty = if !values.is_empty() {
                    self.infer_operand_mir_type(&values[0].0, func)
                } else {
                    MirType::I64
                };
                Some((dest.name.clone(), ty))
            }
            // v0.19.0: Struct operations
            MirInst::StructInit { dest, struct_name, fields } => {
                Some((dest.name.clone(), MirType::Struct {
                    name: struct_name.clone(),
                    fields: fields.iter().map(|(n, _)| (n.clone(), Box::new(MirType::I64))).collect(),
                }))
            }
            MirInst::FieldAccess { dest, .. } => {
                // Field access result type defaults to i64
                Some((dest.name.clone(), MirType::I64))
            }
            MirInst::FieldStore { .. } => {
                // Field store has no destination
                None
            }
            // v0.19.1: Enum variant
            MirInst::EnumVariant { dest, enum_name, .. } => {
                Some((dest.name.clone(), MirType::Enum {
                    name: enum_name.clone(),
                    variants: vec![],  // Simplified: don't track variants here
                }))
            }
            // v0.19.3: Array operations
            MirInst::ArrayInit { dest, element_type, elements } => {
                Some((dest.name.clone(), MirType::Array {
                    element_type: Box::new(element_type.clone()),
                    size: Some(elements.len()),
                }))
            }
            MirInst::IndexLoad { dest, .. } => {
                // Index load result type defaults to i64
                Some((dest.name.clone(), MirType::I64))
            }
            MirInst::IndexStore { .. } => {
                // Index store has no destination
                None
            }
            // v0.50.80: Type cast
            MirInst::Cast { dest, to_ty, .. } => {
                Some((dest.name.clone(), to_ty.clone()))
            }
            // v0.55: Tuple operations
            MirInst::TupleInit { dest, elements } => {
                Some((dest.name.clone(), MirType::Tuple(
                    elements.iter().map(|(ty, _)| Box::new(ty.clone())).collect()
                )))
            }
            MirInst::TupleExtract { dest, element_type, .. } => {
                Some((dest.name.clone(), element_type.clone()))
            }
            // v0.60.19: Pointer offset produces pointer type
            MirInst::PtrOffset { dest, element_type, .. } => {
                Some((dest.name.clone(), MirType::Ptr(Box::new(element_type.clone()))))
            }
            // v0.60.21: Array allocation produces pointer type
            MirInst::ArrayAlloc { dest, element_type, .. } => {
                Some((dest.name.clone(), MirType::Ptr(Box::new(element_type.clone()))))
            }
            // v0.60.20: Pointer load produces the element type
            MirInst::PtrLoad { dest, element_type, .. } => {
                Some((dest.name.clone(), element_type.clone()))
            }
            // v0.60.20: Pointer store has no destination
            MirInst::PtrStore { .. } => None,
            // v0.70: Thread spawn produces i64 handle
            MirInst::ThreadSpawn { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.70: Thread join produces i64 (result value)
            MirInst::ThreadJoin { dest, .. } => dest.as_ref().map(|d| (d.name.clone(), MirType::I64)),
            // v0.71: Mutex operations produce i64 handles
            MirInst::MutexNew { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::MutexLock { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::MutexUnlock { .. } => None,
            MirInst::MutexTryLock { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::MutexFree { .. } => None,
            // v0.72: Arc operations produce i64 handles
            MirInst::ArcNew { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::ArcClone { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::ArcGet { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::ArcDrop { .. } => None,
            MirInst::ArcStrongCount { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.72: Atomic operations produce i64 values
            MirInst::AtomicNew { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AtomicLoad { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AtomicStore { .. } => None,
            MirInst::AtomicFetchAdd { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AtomicFetchSub { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AtomicSwap { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AtomicCompareExchange { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.73: Channel operations - ChannelNew produces two i64 handles
            // Note: This function only returns one dest, so ChannelNew is special-cased
            MirInst::ChannelNew { sender_dest, .. } => Some((sender_dest.name.clone(), MirType::I64)),
            MirInst::ChannelSend { .. } => None,
            MirInst::ChannelRecv { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::ChannelTrySend { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::ChannelTryRecv { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.77
            MirInst::ChannelRecvTimeout { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.78
            MirInst::BlockOn { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.79
            MirInst::ChannelSendTimeout { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.80: Channel close operations
            MirInst::ChannelClose { .. } => None,
            MirInst::ChannelIsClosed { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::ChannelRecvOpt { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::SenderClone { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.74: RwLock operations
            MirInst::RwLockNew { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::RwLockRead { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::RwLockReadUnlock { .. } => None,
            MirInst::RwLockWrite { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::RwLockWriteUnlock { .. } => None,
            // v0.74: Barrier operations
            MirInst::BarrierNew { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::BarrierWait { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            // v0.74: Condvar operations
            MirInst::CondvarNew { dest } => Some((dest.name.clone(), MirType::I64)),
            MirInst::CondvarWait { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::CondvarNotifyOne { .. } => None,
            MirInst::CondvarNotifyAll { .. } => None,
            // v0.83: AsyncFile operations
            MirInst::AsyncFileOpen { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AsyncFileRead { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AsyncFileWrite { .. } => None,
            MirInst::AsyncFileClose { .. } => None,
            // v0.83.1: AsyncSocket operations
            MirInst::AsyncSocketConnect { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AsyncSocketRead { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::AsyncSocketWrite { .. } => None,
            MirInst::AsyncSocketClose { .. } => None,
            // v0.84: ThreadPool operations
            MirInst::ThreadPoolNew { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::ThreadPoolExecute { .. } => None,
            MirInst::ThreadPoolJoin { .. } => None,
            MirInst::ThreadPoolShutdown { .. } => None,
            // v0.85: Scope operations
            MirInst::ScopeNew { dest, .. } => Some((dest.name.clone(), MirType::I64)),
            MirInst::ScopeSpawn { .. } => None,
            MirInst::ScopeWait { .. } => None,
            // v0.76: Select instruction
            MirInst::Select { dest, .. } => Some((dest.name.clone(), MirType::I64)),
        }
    }

    /// Infer MirType from a place name
    fn infer_place_mir_type(&self, name: &str, func: &MirFunction) -> MirType {
        // Check parameters
        for (pname, ty) in &func.params {
            if pname == name {
                return ty.clone();
            }
        }
        // Check locals
        for (lname, ty) in &func.locals {
            if lname == name {
                return ty.clone();
            }
        }
        // Default
        MirType::I64
    }

    /// Infer MirType from an operand
    fn infer_operand_mir_type(&self, op: &Operand, func: &MirFunction) -> MirType {
        match op {
            Operand::Constant(c) => match c {
                Constant::Int(_) => MirType::I64,
                Constant::Float(_) => MirType::F64,
                Constant::Bool(_) => MirType::Bool,
                Constant::String(_) => MirType::String,
                // v0.64: Character type
                Constant::Char(_) => MirType::Char,
                Constant::Unit => MirType::Unit,
            },
            Operand::Place(p) => self.infer_place_mir_type(&p.name, func),
        }
    }

    /// Infer WASM type prefix for an operand
    fn infer_operand_wasm_type(&self, op: &Operand, func: &MirFunction) -> &'static str {
        match op {
            Operand::Constant(c) => match c {
                Constant::Int(_) => "i64",
                Constant::Float(_) => "f64",
                Constant::Bool(_) => "i32",
                Constant::String(_) => "i32",
                // v0.64: Character type
                Constant::Char(_) => "i32",
                Constant::Unit => "i32",
            },
            Operand::Place(p) => {
                // Check parameters
                for (name, ty) in &func.params {
                    if name == &p.name {
                        return self.mir_type_to_wasm(ty);
                    }
                }
                // Check locals
                for (name, ty) in &func.locals {
                    if name == &p.name {
                        return self.mir_type_to_wasm(ty);
                    }
                }
                // Default to i64
                "i64"
            }
        }
    }
}

impl Default for WasmCodeGen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::mir::Place;

    #[test]
    fn test_simple_add_function() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "add".to_string(),
                params: vec![
                    ("a".to_string(), MirType::I64),
                    ("b".to_string(), MirType::I64),
                ],
                ret_ty: MirType::I64,
                locals: vec![("_t0".to_string(), MirType::I64)],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_t0"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("a")),
                        rhs: Operand::Place(Place::new("b")),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::new();
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("(module"));
        assert!(wat.contains("(func $add"));
        assert!(wat.contains("(param $a i64)"));
        assert!(wat.contains("(param $b i64)"));
        assert!(wat.contains("(result i64)"));
        assert!(wat.contains("i64.add"));
        assert!(wat.contains("(export \"add\" (func $add))"));
    }

    #[test]
    fn test_main_export() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "main".to_string(),
                params: vec![],
                ret_ty: MirType::Unit,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(None),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Wasi);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("(export \"_start\" (func $main))"));
        assert!(wat.contains("wasi_snapshot_preview1"));
    }

    #[test]
    fn test_browser_target() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Browser);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("console_log"));
        assert!(!wat.contains("wasi"));
    }

    #[test]
    fn test_wasi_runtime_functions() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Wasi);
        let wat = codegen.generate(&program).unwrap();

        // Check runtime function signatures exist
        assert!(wat.contains("(func $i64_to_str"), "i64_to_str helper function");
        assert!(wat.contains("(func $println (param $val i64)"), "println function");
        assert!(wat.contains("(func $print (param $val i64)"), "print function");
        assert!(wat.contains("(func $exit (param $code i32)"), "exit function");
        assert!(wat.contains("(func $assert (param $cond i32)"), "assert function");

        // Check WASI imports
        assert!(wat.contains("$fd_write"), "fd_write import");
        assert!(wat.contains("$proc_exit"), "proc_exit import");
    }

    #[test]
    fn test_browser_runtime_functions() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Browser);
        let wat = codegen.generate(&program).unwrap();

        // Check runtime functions
        assert!(wat.contains("(func $println (param $val i64)"), "println function");
        assert!(wat.contains("(func $print (param $val i64)"), "print function");
        assert!(wat.contains("(func $exit (param $code i32)"), "exit function");
        assert!(wat.contains("(func $assert (param $cond i32)"), "assert function");

        // Check browser imports
        assert!(wat.contains("$console_log"), "console_log import");

        // Should NOT have WASI imports
        assert!(!wat.contains("fd_write"), "no fd_write in browser");
        assert!(!wat.contains("proc_exit"), "no proc_exit in browser");
    }

    #[test]
    fn test_standalone_no_runtime() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Standalone);
        let wat = codegen.generate(&program).unwrap();

        // Standalone mode should not have runtime imports
        assert!(!wat.contains("wasi_snapshot_preview1"), "no WASI in standalone");
        assert!(!wat.contains("console_log"), "no console_log in standalone");
        assert!(wat.contains("Standalone mode - no I/O functions"), "standalone comment");
    }

    #[test]
    fn test_arithmetic_operations() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "math".to_string(),
                params: vec![("x".to_string(), MirType::I64)],
                ret_ty: MirType::I64,
                locals: vec![
                    ("_t0".to_string(), MirType::I64),
                    ("_t1".to_string(), MirType::I64),
                ],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![
                        MirInst::BinOp {
                            dest: Place::new("_t0"),
                            op: MirBinOp::Mul,
                            lhs: Operand::Place(Place::new("x")),
                            rhs: Operand::Constant(Constant::Int(2)),
                        },
                        MirInst::BinOp {
                            dest: Place::new("_t1"),
                            op: MirBinOp::Add,
                            lhs: Operand::Place(Place::new("_t0")),
                            rhs: Operand::Constant(Constant::Int(1)),
                        },
                    ],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t1")))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::new();
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("i64.mul"));
        assert!(wat.contains("i64.add"));
    }

    #[test]
    fn test_extern_fn_import() {
        use crate::mir::MirExternFn;

        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![MirExternFn {
                module: "wasi_snapshot_preview1".to_string(),
                name: "fd_read".to_string(),
                params: vec![MirType::I32, MirType::I32, MirType::I32, MirType::I32],
                ret_ty: MirType::I32,
            }],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Wasi);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("User-defined extern imports"));
        assert!(wat.contains("(import \"wasi_snapshot_preview1\" \"fd_read\""));
        assert!(wat.contains("(func $fd_read"));
        assert!(wat.contains("(param i32 i32 i32 i32)"));
        assert!(wat.contains("(result i32)"));
    }

    /// Helper: generate a single-function MIR program with one binop instruction
    fn binop_program(op: MirBinOp, ty: MirType) -> MirProgram {
        MirProgram {
            functions: vec![MirFunction {
                name: "f".to_string(),
                params: vec![("a".to_string(), ty.clone()), ("b".to_string(), ty.clone())],
                ret_ty: ty.clone(),
                locals: vec![("_t0".to_string(), ty)],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_t0"),
                        op,
                        lhs: Operand::Place(Place::new("a")),
                        rhs: Operand::Place(Place::new("b")),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        }
    }

    // --- Division and Modulo ---

    #[test]
    fn test_division_operation() {
        let program = binop_program(MirBinOp::Div, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.div_s"));
    }

    #[test]
    fn test_modulo_operation() {
        let program = binop_program(MirBinOp::Mod, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.rem_s"));
    }

    #[test]
    fn test_subtraction_operation() {
        let program = binop_program(MirBinOp::Sub, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.sub"));
    }

    // --- Comparison Operators ---

    #[test]
    fn test_comparison_eq() {
        let program = binop_program(MirBinOp::Eq, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.eq"));
    }

    #[test]
    fn test_comparison_ne() {
        let program = binop_program(MirBinOp::Ne, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.ne"));
    }

    #[test]
    fn test_comparison_lt() {
        let program = binop_program(MirBinOp::Lt, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.lt_s"));
    }

    #[test]
    fn test_comparison_gt() {
        let program = binop_program(MirBinOp::Gt, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.gt_s"));
    }

    #[test]
    fn test_comparison_le() {
        let program = binop_program(MirBinOp::Le, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.le_s"));
    }

    #[test]
    fn test_comparison_ge() {
        let program = binop_program(MirBinOp::Ge, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.ge_s"));
    }

    // --- Bitwise Operators ---

    #[test]
    fn test_bitwise_and() {
        let program = binop_program(MirBinOp::Band, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.and"));
    }

    #[test]
    fn test_bitwise_or() {
        let program = binop_program(MirBinOp::Bor, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.or"));
    }

    #[test]
    fn test_shift_left() {
        let program = binop_program(MirBinOp::Shl, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.shl"));
    }

    #[test]
    fn test_shift_right() {
        let program = binop_program(MirBinOp::Shr, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.shr_s"));
    }

    // --- F64 Operations ---

    #[test]
    fn test_f64_add() {
        let program = binop_program(MirBinOp::Add, MirType::F64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.add"));
        assert!(wat.contains("(param $a f64)"));
        assert!(wat.contains("(result f64)"));
    }

    #[test]
    fn test_f64_mul() {
        let program = binop_program(MirBinOp::Mul, MirType::F64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.mul"));
    }

    #[test]
    fn test_f64_div() {
        let program = binop_program(MirBinOp::Div, MirType::F64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.div"));
    }

    // --- I32 Type Support ---

    #[test]
    fn test_i32_operations() {
        let program = binop_program(MirBinOp::Add, MirType::I32);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i32.add"));
        assert!(wat.contains("(param $a i32)"));
        assert!(wat.contains("(result i32)"));
    }

    // --- Unary Operations ---

    #[test]
    fn test_unary_neg() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "neg".to_string(),
                params: vec![("x".to_string(), MirType::I64)],
                ret_ty: MirType::I64,
                locals: vec![("_t0".to_string(), MirType::I64)],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::UnaryOp {
                        dest: Place::new("_t0"),
                        op: MirUnaryOp::Neg,
                        src: Operand::Place(Place::new("x")),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.sub"), "neg uses 0 - x pattern");
    }

    #[test]
    fn test_unary_not() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "lnot".to_string(),
                params: vec![("x".to_string(), MirType::Bool)],
                ret_ty: MirType::Bool,
                locals: vec![("_t0".to_string(), MirType::Bool)],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::UnaryOp {
                        dest: Place::new("_t0"),
                        op: MirUnaryOp::Not,
                        src: Operand::Place(Place::new("x")),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i32.eqz") || wat.contains("i64.eqz") || wat.contains("i32.xor"), "not uses eqz or xor pattern");
    }

    // --- Memory Configuration ---

    #[test]
    fn test_memory_configuration() {
        let codegen = WasmCodeGen::new().with_memory(4);
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let wat = codegen.generate(&program).unwrap();
        assert!(wat.contains("(memory 4)") || wat.contains("memory"), "memory declaration present");
    }

    // --- Default Trait ---

    #[test]
    fn test_default_target_is_wasi() {
        let codegen = WasmCodeGen::new();
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let wat = codegen.generate(&program).unwrap();
        // Default should be WASI
        assert!(wat.contains("wasi"));
    }

    // --- Error Display ---

    #[test]
    fn test_error_display() {
        let err = WasmCodeGenError::UnknownFunction("foo".to_string());
        assert!(format!("{}", err).contains("foo"));

        let err2 = WasmCodeGenError::UnsupportedFeature("closures".to_string());
        assert!(format!("{}", err2).contains("closures"));
    }

    // --- Constant Values ---

    #[test]
    fn test_constant_int() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "const_fn".to_string(),
                params: vec![],
                ret_ty: MirType::I64,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(42)))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.const 42"));
    }

    #[test]
    fn test_constant_bool_true() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "truthy".to_string(),
                params: vec![],
                ret_ty: MirType::Bool,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Bool(true)))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i32.const 1"));
    }

    #[test]
    fn test_constant_float() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "pi_ish".to_string(),
                params: vec![],
                ret_ty: MirType::F64,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Float(1.5)))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.const 1.5"));
    }

    // --- Additional coverage tests ---

    #[test]
    fn test_multiple_functions() {
        let program = MirProgram {
            functions: vec![
                MirFunction {
                    name: "first".to_string(),
                    params: vec![],
                    ret_ty: MirType::I64,
                    locals: vec![],
                    blocks: vec![BasicBlock {
                        label: "entry".to_string(),
                        instructions: vec![],
                        terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(1)))),
                    }],
                    preconditions: vec![],
                    postconditions: vec![],
                    is_pure: false,
                    is_const: false,
                    always_inline: false,
                    inline_hint: false,
                    is_memory_free: false,
                },
                MirFunction {
                    name: "second".to_string(),
                    params: vec![],
                    ret_ty: MirType::I64,
                    locals: vec![],
                    blocks: vec![BasicBlock {
                        label: "entry".to_string(),
                        instructions: vec![],
                        terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(2)))),
                    }],
                    preconditions: vec![],
                    postconditions: vec![],
                    is_pure: false,
                    is_const: false,
                    always_inline: false,
                    inline_hint: false,
                    is_memory_free: false,
                },
            ],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(func $first"));
        assert!(wat.contains("(func $second"));
        assert!(wat.contains("(export \"first\""));
        assert!(wat.contains("(export \"second\""));
    }

    #[test]
    fn test_function_with_locals() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "with_locals".to_string(),
                params: vec![("x".to_string(), MirType::I64)],
                ret_ty: MirType::I64,
                locals: vec![
                    ("_t0".to_string(), MirType::I64),
                    ("_t1".to_string(), MirType::Bool),
                ],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("x")))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(local $_t0 i64)"));
        assert!(wat.contains("(local $_t1 i32)"));
    }

    #[test]
    fn test_void_return() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "noop".to_string(),
                params: vec![],
                ret_ty: MirType::Unit,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(None),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(func $noop"));
        // No result for Unit
        assert!(!wat.contains("(func $noop (result"));
    }

    #[test]
    fn test_bool_return_type() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "is_true".to_string(),
                params: vec![],
                ret_ty: MirType::Bool,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Bool(true)))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(result i32)"));
        assert!(wat.contains("i32.const 1"));
    }

    #[test]
    fn test_assign_instruction() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "assign_test".to_string(),
                params: vec![("x".to_string(), MirType::I64)],
                ret_ty: MirType::I64,
                locals: vec![("y".to_string(), MirType::I64)],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::Copy {
                        dest: Place::new("y"),
                        src: Place::new("x"),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("y")))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("local.get $x"));
        assert!(wat.contains("local.set $y"));
    }

    #[test]
    fn test_constant_string() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "str_fn".to_string(),
                params: vec![],
                ret_ty: MirType::I64,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.const 0"));
    }

    #[test]
    fn test_f64_sub() {
        let program = binop_program(MirBinOp::Sub, MirType::F64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.sub"));
    }

    #[test]
    fn test_xor_operation() {
        let program = binop_program(MirBinOp::Bxor, MirType::I64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.xor"));
    }

    #[test]
    fn test_memory_custom_pages() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().with_memory(16).generate(&program).unwrap();
        assert!(wat.contains("(memory"));
    }

    #[test]
    fn test_wasm_codegen_error_display() {
        let err = WasmCodeGenError::UnsupportedFeature("closures".to_string());
        let display = format!("{}", err);
        assert!(display.contains("closures"));
    }

    #[test]
    fn test_empty_program() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(module"));
    }

    #[test]
    fn test_i32_return() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "get_i32".to_string(),
                params: vec![],
                ret_ty: MirType::I32,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(99)))),
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(result i32)"));
    }

    // =====================================================================
    // New tests: struct, enum, array, control flow, casts, calls, etc.
    // =====================================================================

    /// Helper: create a simple single-function program with given instructions and terminator
    fn single_fn_program(
        name: &str,
        params: Vec<(&str, MirType)>,
        ret_ty: MirType,
        locals: Vec<(&str, MirType)>,
        instructions: Vec<MirInst>,
        terminator: Terminator,
    ) -> MirProgram {
        MirProgram {
            functions: vec![MirFunction {
                name: name.to_string(),
                params: params.into_iter().map(|(n, t)| (n.to_string(), t)).collect(),
                ret_ty,
                locals: locals.into_iter().map(|(n, t)| (n.to_string(), t)).collect(),
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions,
                    terminator,
                }],
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        }
    }

    /// Helper: create a multi-block function program
    fn multi_block_program(
        name: &str,
        params: Vec<(&str, MirType)>,
        ret_ty: MirType,
        locals: Vec<(&str, MirType)>,
        blocks: Vec<BasicBlock>,
    ) -> MirProgram {
        MirProgram {
            functions: vec![MirFunction {
                name: name.to_string(),
                params: params.into_iter().map(|(n, t)| (n.to_string(), t)).collect(),
                ret_ty,
                locals: locals.into_iter().map(|(n, t)| (n.to_string(), t)).collect(),
                blocks,
                preconditions: vec![],
                postconditions: vec![],
                is_pure: false,
                is_const: false,
                always_inline: false,
                inline_hint: false,
                is_memory_free: false,
            }],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        }
    }

    // --- Struct operations ---

    #[test]
    fn test_struct_init() {
        let program = single_fn_program(
            "make_point",
            vec![],
            MirType::Struct {
                name: "Point".to_string(),
                fields: vec![
                    ("x".to_string(), Box::new(MirType::I64)),
                    ("y".to_string(), Box::new(MirType::I64)),
                ],
            },
            vec![("_t0", MirType::Struct {
                name: "Point".to_string(),
                fields: vec![
                    ("x".to_string(), Box::new(MirType::I64)),
                    ("y".to_string(), Box::new(MirType::I64)),
                ],
            })],
            vec![MirInst::StructInit {
                dest: Place::new("_t0"),
                struct_name: "Point".to_string(),
                fields: vec![
                    ("x".to_string(), Operand::Constant(Constant::Int(10))),
                    ("y".to_string(), Operand::Constant(Constant::Int(20))),
                ],
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("struct Point init with 2 fields"), "struct init comment");
        assert!(wat.contains("field x at offset 0"), "field x comment");
        assert!(wat.contains("field y at offset 8"), "field y comment");
        assert!(wat.contains("i64.store"), "stores field values");
    }

    #[test]
    fn test_field_access() {
        let program = single_fn_program(
            "get_x",
            vec![("p", MirType::Struct {
                name: "Point".to_string(),
                fields: vec![
                    ("x".to_string(), Box::new(MirType::I64)),
                    ("y".to_string(), Box::new(MirType::I64)),
                ],
            })],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::FieldAccess {
                dest: Place::new("_t0"),
                base: Place::new("p"),
                field: "x".to_string(),
                field_index: 0,
                struct_name: "Point".to_string(),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("field access .x[0]"), "field access comment");
        assert!(wat.contains("local.get $p"), "loads base pointer");
        assert!(wat.contains("i64.load"), "loads field value");
    }

    #[test]
    fn test_field_store() {
        let program = single_fn_program(
            "set_y",
            vec![("p", MirType::Struct {
                name: "Point".to_string(),
                fields: vec![
                    ("x".to_string(), Box::new(MirType::I64)),
                    ("y".to_string(), Box::new(MirType::I64)),
                ],
            })],
            MirType::Unit,
            vec![],
            vec![MirInst::FieldStore {
                base: Place::new("p"),
                field: "y".to_string(),
                field_index: 1,
                struct_name: "Point".to_string(),
                value: Operand::Constant(Constant::Int(42)),
            }],
            Terminator::Return(None),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("field store .y[1]"), "field store comment");
        assert!(wat.contains("i32.const 8"), "offset for field index 1");
        assert!(wat.contains("i64.store"), "stores value");
    }

    // --- Enum operations ---

    #[test]
    fn test_enum_variant() {
        let program = single_fn_program(
            "make_some",
            vec![],
            MirType::Enum {
                name: "Option".to_string(),
                variants: vec![("Some".to_string(), vec![Box::new(MirType::I64)])],
            },
            vec![("_t0", MirType::Enum {
                name: "Option".to_string(),
                variants: vec![],
            })],
            vec![MirInst::EnumVariant {
                dest: Place::new("_t0"),
                enum_name: "Option".to_string(),
                variant: "Some".to_string(),
                args: vec![Operand::Constant(Constant::Int(99))],
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("enum Option::Some with 1 args"), "enum variant comment");
        assert!(wat.contains("i64.store"), "stores discriminant and args");
    }

    // --- Array operations ---

    #[test]
    fn test_array_init() {
        let program = single_fn_program(
            "make_arr",
            vec![],
            MirType::Array { element_type: Box::new(MirType::I64), size: Some(3) },
            vec![("_t0", MirType::Array { element_type: Box::new(MirType::I64), size: Some(3) })],
            vec![MirInst::ArrayInit {
                dest: Place::new("_t0"),
                element_type: MirType::I64,
                elements: vec![
                    Operand::Constant(Constant::Int(1)),
                    Operand::Constant(Constant::Int(2)),
                    Operand::Constant(Constant::Int(3)),
                ],
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("array init with 3 elements"), "array init comment");
        assert!(wat.contains("i64.const 1"), "first element");
        assert!(wat.contains("i64.const 2"), "second element");
        assert!(wat.contains("i64.const 3"), "third element");
    }

    #[test]
    fn test_index_load() {
        let program = single_fn_program(
            "get_elem",
            vec![("arr", MirType::Array { element_type: Box::new(MirType::I64), size: Some(3) })],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::IndexLoad {
                dest: Place::new("_t0"),
                array: Place::new("arr"),
                index: Operand::Constant(Constant::Int(1)),
                element_type: MirType::I64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("index load"), "index load comment");
        assert!(wat.contains("i32.wrap_i64"), "converts i64 index to i32");
        assert!(wat.contains("i32.const 8"), "element size multiplier");
        assert!(wat.contains("i64.load"), "loads the value");
    }

    #[test]
    fn test_index_store() {
        let program = single_fn_program(
            "set_elem",
            vec![("arr", MirType::Array { element_type: Box::new(MirType::I64), size: Some(3) })],
            MirType::Unit,
            vec![],
            vec![MirInst::IndexStore {
                array: Place::new("arr"),
                index: Operand::Constant(Constant::Int(0)),
                value: Operand::Constant(Constant::Int(42)),
                element_type: MirType::I64,
            }],
            Terminator::Return(None),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("index store"), "index store comment");
        assert!(wat.contains("i64.const 42"), "value to store");
        assert!(wat.contains("i64.store"), "stores the value");
    }

    // --- Cast operations ---

    #[test]
    fn test_cast_i32_to_i64() {
        let program = single_fn_program(
            "widen",
            vec![("x", MirType::I32)],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::I32,
                to_ty: MirType::I64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("cast i32 -> i64"), "cast comment");
        assert!(wat.contains("i64.extend_i32_s"), "sign-extend i32 to i64");
    }

    #[test]
    fn test_cast_i64_to_f64() {
        let program = single_fn_program(
            "to_float",
            vec![("x", MirType::I64)],
            MirType::F64,
            vec![("_t0", MirType::F64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::I64,
                to_ty: MirType::F64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("cast i64 -> f64"), "cast comment");
        assert!(wat.contains("f64.convert_i64_s"), "convert i64 to f64");
    }

    #[test]
    fn test_cast_f64_to_i64() {
        let program = single_fn_program(
            "to_int",
            vec![("x", MirType::F64)],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::F64,
                to_ty: MirType::I64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.trunc_f64_s"), "truncate f64 to i64");
    }

    // --- Tuple operations ---

    #[test]
    fn test_tuple_init() {
        let program = single_fn_program(
            "make_tuple",
            vec![],
            MirType::Tuple(vec![Box::new(MirType::I64), Box::new(MirType::I64)]),
            vec![("_t0", MirType::Tuple(vec![Box::new(MirType::I64), Box::new(MirType::I64)]))],
            vec![MirInst::TupleInit {
                dest: Place::new("_t0"),
                elements: vec![
                    (MirType::I64, Operand::Constant(Constant::Int(10))),
                    (MirType::I64, Operand::Constant(Constant::Int(20))),
                ],
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("tuple init with 2 elements"), "tuple init comment");
        assert!(wat.contains("call $bump_alloc"), "uses bump allocator");
    }

    #[test]
    fn test_tuple_extract() {
        let program = single_fn_program(
            "get_second",
            vec![("tup", MirType::Tuple(vec![Box::new(MirType::I64), Box::new(MirType::I64)]))],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::TupleExtract {
                dest: Place::new("_t0"),
                tuple: Place::new("tup"),
                index: 1,
                element_type: MirType::I64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("tuple extract index 1"), "tuple extract comment");
        assert!(wat.contains("i32.const 8"), "offset = index * 8");
        assert!(wat.contains("i64.load"), "loads element from memory");
    }

    // --- Control flow ---

    #[test]
    fn test_multi_block_control_flow() {
        let program = multi_block_program(
            "branch_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("_t0", MirType::Bool), ("_t1", MirType::I64)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_t0"),
                        op: MirBinOp::Gt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_t0")),
                        then_label: "then".to_string(),
                        else_label: "else_".to_string(),
                    },
                },
                BasicBlock {
                    label: "then".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(1)))),
                },
                BasicBlock {
                    label: "else_".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(block $entry"), "entry block structure");
        assert!(wat.contains("(block $then"), "then block structure");
        assert!(wat.contains("(block $else_"), "else block structure");
        assert!(wat.contains("Control flow (CFG to structured)"), "control flow comment");
    }

    #[test]
    fn test_goto_terminator() {
        let program = multi_block_program(
            "goto_fn",
            vec![],
            MirType::I64,
            vec![],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Goto("exit".to_string()),
                },
                BasicBlock {
                    label: "exit".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(42)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("br $exit"), "goto emits br instruction");
    }

    #[test]
    fn test_unreachable_terminator() {
        let program = single_fn_program(
            "unreachable_fn",
            vec![],
            MirType::Unit,
            vec![],
            vec![],
            Terminator::Unreachable,
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("unreachable"), "unreachable instruction emitted");
    }

    #[test]
    fn test_switch_terminator() {
        let program = multi_block_program(
            "switch_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Switch {
                        discriminant: Operand::Place(Place::new("x")),
                        cases: vec![
                            (0, "case_zero".to_string()),
                            (1, "case_one".to_string()),
                        ],
                        default: "default_case".to_string(),
                    },
                },
                BasicBlock {
                    label: "case_zero".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(100)))),
                },
                BasicBlock {
                    label: "case_one".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(200)))),
                },
                BasicBlock {
                    label: "default_case".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.const 0"), "case value 0");
        assert!(wat.contains("i64.const 1"), "case value 1");
        assert!(wat.contains("i64.eq"), "equality comparison for case matching");
        assert!(wat.contains("br_if $case_zero"), "branch to case_zero");
        assert!(wat.contains("br_if $case_one"), "branch to case_one");
        assert!(wat.contains("br $default_case"), "branch to default");
    }

    // --- Function call ---

    #[test]
    fn test_function_call() {
        let program = MirProgram {
            functions: vec![
                MirFunction {
                    name: "helper".to_string(),
                    params: vec![("x".to_string(), MirType::I64)],
                    ret_ty: MirType::I64,
                    locals: vec![],
                    blocks: vec![BasicBlock {
                        label: "entry".to_string(),
                        instructions: vec![],
                        terminator: Terminator::Return(Some(Operand::Place(Place::new("x")))),
                    }],
                    preconditions: vec![],
                    postconditions: vec![],
                    is_pure: false,
                    is_const: false,
                    always_inline: false,
                    inline_hint: false,
                    is_memory_free: false,
                },
                MirFunction {
                    name: "caller".to_string(),
                    params: vec![],
                    ret_ty: MirType::I64,
                    locals: vec![("_t0".to_string(), MirType::I64)],
                    blocks: vec![BasicBlock {
                        label: "entry".to_string(),
                        instructions: vec![MirInst::Call {
                            dest: Some(Place::new("_t0")),
                            func: "helper".to_string(),
                            args: vec![Operand::Constant(Constant::Int(5))],
                            is_tail: false,
                        }],
                        terminator: Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
                    }],
                    preconditions: vec![],
                    postconditions: vec![],
                    is_pure: false,
                    is_const: false,
                    always_inline: false,
                    inline_hint: false,
                    is_memory_free: false,
                },
            ],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("call $helper"), "calls the helper function");
        assert!(wat.contains("i64.const 5"), "pushes argument");
        assert!(wat.contains("local.set $_t0"), "stores call result");
    }

    // --- Implies binary operation (special path) ---

    #[test]
    fn test_implies_operation() {
        let program = single_fn_program(
            "implies_fn",
            vec![("a", MirType::Bool), ("b", MirType::Bool)],
            MirType::Bool,
            vec![("_t0", MirType::Bool)],
            vec![MirInst::BinOp {
                dest: Place::new("_t0"),
                op: MirBinOp::Implies,
                lhs: Operand::Place(Place::new("a")),
                rhs: Operand::Place(Place::new("b")),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        // Implies uses !P || Q pattern: xor with 1 (negate), then or
        assert!(wat.contains("i32.xor"), "negation via xor");
        assert!(wat.contains("i32.or"), "logical or");
    }

    // --- Unary operations: FNeg and Bnot ---

    #[test]
    fn test_unary_fneg() {
        let program = single_fn_program(
            "fneg",
            vec![("x", MirType::F64)],
            MirType::F64,
            vec![("_t0", MirType::F64)],
            vec![MirInst::UnaryOp {
                dest: Place::new("_t0"),
                op: MirUnaryOp::FNeg,
                src: Operand::Place(Place::new("x")),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.const 0"), "zero for subtraction");
        assert!(wat.contains("f64.sub"), "0.0 - x pattern for fneg");
    }

    #[test]
    fn test_unary_bnot() {
        let program = single_fn_program(
            "bnot",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::UnaryOp {
                dest: Place::new("_t0"),
                op: MirUnaryOp::Bnot,
                src: Operand::Place(Place::new("x")),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.const -1"), "all-ones mask for bitwise not");
        assert!(wat.contains("i64.xor"), "xor with -1 for bnot");
    }

    // --- Constant values: char, bool false, unit ---

    #[test]
    fn test_constant_char() {
        let program = single_fn_program(
            "get_char",
            vec![],
            MirType::Char,
            vec![("_t0", MirType::Char)],
            vec![MirInst::Const {
                dest: Place::new("_t0"),
                value: Constant::Char('A'),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i32.const 65"), "char 'A' = Unicode codepoint 65");
    }

    #[test]
    fn test_constant_bool_false() {
        let program = single_fn_program(
            "get_false",
            vec![],
            MirType::Bool,
            vec![],
            vec![],
            Terminator::Return(Some(Operand::Constant(Constant::Bool(false)))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i32.const 0"), "false = i32.const 0");
    }

    #[test]
    fn test_constant_unit() {
        let program = single_fn_program(
            "unit_fn",
            vec![],
            MirType::Unit,
            vec![("_t0", MirType::Unit)],
            vec![MirInst::Const {
                dest: Place::new("_t0"),
                value: Constant::Unit,
            }],
            Terminator::Return(None),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("unit (no value)"), "unit constant comment");
    }

    // --- F64 comparison operators ---

    #[test]
    fn test_f64_comparison_lt() {
        let program = binop_program(MirBinOp::FLt, MirType::F64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.lt"), "f64.lt for FLt comparison");
    }

    #[test]
    fn test_f64_comparison_ge() {
        let program = binop_program(MirBinOp::FGe, MirType::F64);
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.ge"), "f64.ge for FGe comparison");
    }

    // --- Logical And/Or ---

    #[test]
    fn test_logical_and() {
        let program = single_fn_program(
            "and_fn",
            vec![("a", MirType::Bool), ("b", MirType::Bool)],
            MirType::Bool,
            vec![("_t0", MirType::Bool)],
            vec![MirInst::BinOp {
                dest: Place::new("_t0"),
                op: MirBinOp::And,
                lhs: Operand::Place(Place::new("a")),
                rhs: Operand::Place(Place::new("b")),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i32.and"), "logical and uses i32.and");
    }

    #[test]
    fn test_logical_or() {
        let program = single_fn_program(
            "or_fn",
            vec![("a", MirType::Bool), ("b", MirType::Bool)],
            MirType::Bool,
            vec![("_t0", MirType::Bool)],
            vec![MirInst::BinOp {
                dest: Place::new("_t0"),
                op: MirBinOp::Or,
                lhs: Operand::Place(Place::new("a")),
                rhs: Operand::Place(Place::new("b")),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i32.or"), "logical or uses i32.or");
    }

    // --- Select instruction ---

    #[test]
    fn test_select_instruction() {
        let program = single_fn_program(
            "select_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::Select {
                dest: Place::new("_t0"),
                cond_op: MirBinOp::Gt,
                cond_lhs: Operand::Place(Place::new("x")),
                cond_rhs: Operand::Constant(Constant::Int(0)),
                true_val: Operand::Constant(Constant::Int(1)),
                false_val: Operand::Constant(Constant::Int(-1)),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.gt_s"), "condition comparison");
        assert!(wat.contains("select"), "WASM select instruction");
    }

    // --- Extern fn with void return ---

    #[test]
    fn test_extern_fn_void_return() {
        use crate::mir::MirExternFn;

        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![MirExternFn {
                module: "env".to_string(),
                name: "log_value".to_string(),
                params: vec![MirType::I64],
                ret_ty: MirType::Unit,
            }],
            struct_defs: std::collections::HashMap::new(),
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Wasi);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("(import \"env\" \"log_value\""), "extern fn import");
        assert!(wat.contains("(func $log_value"), "extern fn name");
        assert!(wat.contains("(param i64)"), "extern fn param");
        // Unit return should not have a result clause
        assert!(!wat.contains("(func $log_value (param i64) (result"), "no result for Unit return");
    }

    // --- Error variants ---

    #[test]
    fn test_error_variants_display() {
        let err1 = WasmCodeGenError::UnknownVariable("my_var".to_string());
        assert!(format!("{}", err1).contains("my_var"), "UnknownVariable displays name");

        let err2 = WasmCodeGenError::StackError("overflow".to_string());
        assert!(format!("{}", err2).contains("overflow"), "StackError displays message");
    }

    // --- Type mappings ---

    #[test]
    fn test_type_mappings_in_params() {
        // Test that various MIR types map to correct WASM types in function params
        let program = single_fn_program(
            "type_test",
            vec![
                ("a", MirType::I64),
                ("b", MirType::F64),
                ("c", MirType::Bool),
                ("d", MirType::Char),
            ],
            MirType::I64,
            vec![],
            vec![],
            Terminator::Return(Some(Operand::Place(Place::new("a")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(param $a i64)"), "i64 maps to i64");
        assert!(wat.contains("(param $b f64)"), "f64 maps to f64");
        assert!(wat.contains("(param $c i32)"), "bool maps to i32");
        assert!(wat.contains("(param $d i32)"), "char maps to i32");
    }

    // --- Wrapping/Checked/Saturating arithmetic ---

    #[test]
    fn test_wrapping_add_codegen() {
        let prog = binop_program(MirBinOp::AddWrap, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.add"), "AddWrap should emit i64.add");
    }

    #[test]
    fn test_wrapping_sub_codegen() {
        let prog = binop_program(MirBinOp::SubWrap, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.sub"), "SubWrap should emit i64.sub");
    }

    #[test]
    fn test_wrapping_mul_codegen() {
        let prog = binop_program(MirBinOp::MulWrap, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.mul"), "MulWrap should emit i64.mul");
    }

    #[test]
    fn test_checked_add_codegen() {
        let prog = binop_program(MirBinOp::AddChecked, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.add"), "AddChecked should emit i64.add");
    }

    #[test]
    fn test_checked_sub_codegen() {
        let prog = binop_program(MirBinOp::SubChecked, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.sub"), "SubChecked should emit i64.sub");
    }

    #[test]
    fn test_checked_mul_codegen() {
        let prog = binop_program(MirBinOp::MulChecked, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.mul"), "MulChecked should emit i64.mul");
    }

    #[test]
    fn test_saturating_add_codegen() {
        let prog = binop_program(MirBinOp::AddSat, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.add"), "AddSat should emit i64.add");
    }

    #[test]
    fn test_saturating_sub_codegen() {
        let prog = binop_program(MirBinOp::SubSat, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.sub"), "SubSat should emit i64.sub");
    }

    #[test]
    fn test_saturating_mul_codegen() {
        let prog = binop_program(MirBinOp::MulSat, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.mul"), "MulSat should emit i64.mul");
    }

    // --- Type cast edge cases ---

    #[test]
    fn test_cast_u32_to_i64_codegen() {
        let prog = single_fn_program(
            "cast_u32",
            vec![("x", MirType::U32)],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::U32,
                to_ty: MirType::I64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.extend_i32_u"), "U32->I64 uses unsigned extend");
    }

    #[test]
    fn test_cast_bool_to_i64_codegen() {
        let prog = single_fn_program(
            "cast_bool",
            vec![("x", MirType::Bool)],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::Bool,
                to_ty: MirType::I64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.extend_i32_u"), "Bool->I64 uses unsigned extend");
    }

    #[test]
    fn test_cast_i64_to_i32_codegen() {
        let prog = single_fn_program(
            "cast_trunc",
            vec![("x", MirType::I64)],
            MirType::I32,
            vec![("_t0", MirType::I32)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::I64,
                to_ty: MirType::I32,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.wrap_i64"), "I64->I32 uses wrap");
    }

    #[test]
    fn test_cast_i64_to_char_codegen() {
        let prog = single_fn_program(
            "cast_char",
            vec![("x", MirType::I64)],
            MirType::Char,
            vec![("_t0", MirType::Char)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::I64,
                to_ty: MirType::Char,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.wrap_i64"), "I64->Char uses wrap");
    }

    #[test]
    fn test_cast_char_to_f64_codegen() {
        let prog = single_fn_program(
            "cast_cf64",
            vec![("x", MirType::Char)],
            MirType::F64,
            vec![("_t0", MirType::F64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::Char,
                to_ty: MirType::F64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.convert_i32_s"), "Char->F64 uses signed i32 convert");
    }

    #[test]
    fn test_cast_u32_to_f64_codegen() {
        let prog = single_fn_program(
            "cast_u32f64",
            vec![("x", MirType::U32)],
            MirType::F64,
            vec![("_t0", MirType::F64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::U32,
                to_ty: MirType::F64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.convert_i32_u"), "U32->F64 uses unsigned convert");
    }

    #[test]
    fn test_cast_u64_to_f64_codegen() {
        let prog = single_fn_program(
            "cast_u64f64",
            vec![("x", MirType::U64)],
            MirType::F64,
            vec![("_t0", MirType::F64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::U64,
                to_ty: MirType::F64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.convert_i64_u"), "U64->F64 uses unsigned convert");
    }

    #[test]
    fn test_cast_f64_to_u32_codegen() {
        let prog = single_fn_program(
            "cast_f64u32",
            vec![("x", MirType::F64)],
            MirType::U32,
            vec![("_t0", MirType::U32)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::F64,
                to_ty: MirType::U32,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.trunc_f64_u"), "F64->U32 uses unsigned trunc");
    }

    #[test]
    fn test_cast_f64_to_u64_codegen() {
        let prog = single_fn_program(
            "cast_f64u64",
            vec![("x", MirType::F64)],
            MirType::U64,
            vec![("_t0", MirType::U64)],
            vec![MirInst::Cast {
                dest: Place::new("_t0"),
                src: Operand::Place(Place::new("x")),
                from_ty: MirType::F64,
                to_ty: MirType::U64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.trunc_f64_u"), "F64->U64 uses unsigned trunc");
    }

    // --- Pointer operations ---

    #[test]
    fn test_ptr_load_i64_codegen() {
        let prog = single_fn_program(
            "ptr_ld",
            vec![("p", MirType::Ptr(Box::new(MirType::I64)))],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::PtrLoad {
                dest: Place::new("_t0"),
                ptr: Operand::Place(Place::new("p")),
                element_type: MirType::I64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.wrap_i64"), "ptr converted to i32 address");
        assert!(wat.contains("i64.load"), "loads i64 value");
    }

    #[test]
    fn test_ptr_load_bool_codegen() {
        let prog = single_fn_program(
            "ptr_ld_bool",
            vec![("p", MirType::Ptr(Box::new(MirType::Bool)))],
            MirType::Bool,
            vec![("_t0", MirType::Bool)],
            vec![MirInst::PtrLoad {
                dest: Place::new("_t0"),
                ptr: Operand::Place(Place::new("p")),
                element_type: MirType::Bool,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.load8_u"), "Bool PtrLoad uses i32.load8_u");
    }

    #[test]
    fn test_ptr_load_f64_codegen() {
        let prog = single_fn_program(
            "ptr_ld_f64",
            vec![("p", MirType::Ptr(Box::new(MirType::F64)))],
            MirType::F64,
            vec![("_t0", MirType::F64)],
            vec![MirInst::PtrLoad {
                dest: Place::new("_t0"),
                ptr: Operand::Place(Place::new("p")),
                element_type: MirType::F64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.load"), "F64 PtrLoad uses f64.load");
    }

    #[test]
    fn test_ptr_store_i64_codegen() {
        let prog = single_fn_program(
            "ptr_st",
            vec![("p", MirType::Ptr(Box::new(MirType::I64))), ("v", MirType::I64)],
            MirType::Unit,
            vec![],
            vec![MirInst::PtrStore {
                ptr: Operand::Place(Place::new("p")),
                value: Operand::Place(Place::new("v")),
                element_type: MirType::I64,
            }],
            Terminator::Return(None),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.store"), "stores i64 value");
    }

    #[test]
    fn test_ptr_store_bool_codegen() {
        let prog = single_fn_program(
            "ptr_st_bool",
            vec![("p", MirType::Ptr(Box::new(MirType::Bool))), ("v", MirType::Bool)],
            MirType::Unit,
            vec![],
            vec![MirInst::PtrStore {
                ptr: Operand::Place(Place::new("p")),
                value: Operand::Place(Place::new("v")),
                element_type: MirType::Bool,
            }],
            Terminator::Return(None),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.store8"), "Bool PtrStore uses i32.store8");
    }

    #[test]
    fn test_ptr_offset_i64_codegen() {
        let prog = single_fn_program(
            "ptr_off",
            vec![("p", MirType::Ptr(Box::new(MirType::I64))), ("idx", MirType::I64)],
            MirType::Ptr(Box::new(MirType::I64)),
            vec![("_t0", MirType::Ptr(Box::new(MirType::I64)))],
            vec![MirInst::PtrOffset {
                dest: Place::new("_t0"),
                ptr: Operand::Place(Place::new("p")),
                offset: Operand::Place(Place::new("idx")),
                element_type: MirType::I64,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.const 8"), "I64 element size is 8");
        assert!(wat.contains("i64.mul"), "offset * element_size");
        assert!(wat.contains("i64.add"), "ptr + offset");
    }

    #[test]
    fn test_ptr_offset_i32_codegen() {
        let prog = single_fn_program(
            "ptr_off32",
            vec![("p", MirType::Ptr(Box::new(MirType::I32))), ("idx", MirType::I64)],
            MirType::Ptr(Box::new(MirType::I32)),
            vec![("_t0", MirType::Ptr(Box::new(MirType::I32)))],
            vec![MirInst::PtrOffset {
                dest: Place::new("_t0"),
                ptr: Operand::Place(Place::new("p")),
                offset: Operand::Place(Place::new("idx")),
                element_type: MirType::I32,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.const 4"), "I32 element size is 4");
    }

    #[test]
    fn test_array_alloc_i64_codegen() {
        let prog = single_fn_program(
            "arr_alloc",
            vec![],
            MirType::I64,
            vec![("buf", MirType::Ptr(Box::new(MirType::I64)))],
            vec![MirInst::ArrayAlloc {
                dest: Place::new("buf"),
                element_type: MirType::I64,
                size: 10,
            }],
            Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.const 80"), "10 * 8 = 80 bytes for i64 array");
        assert!(wat.contains("call $bump_alloc"), "uses bump allocator");
        assert!(wat.contains("i64.extend_i32_u"), "convert to i64 pointer");
    }

    #[test]
    fn test_array_alloc_bool_codegen() {
        let prog = single_fn_program(
            "arr_alloc_bool",
            vec![],
            MirType::I64,
            vec![("buf", MirType::Ptr(Box::new(MirType::Bool)))],
            vec![MirInst::ArrayAlloc {
                dest: Place::new("buf"),
                element_type: MirType::Bool,
                size: 16,
            }],
            Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.const 16"), "16 * 1 = 16 bytes for bool array");
    }

    // --- String interning and data section ---

    #[test]
    fn test_intern_string_dedup() {
        let cg = WasmCodeGen::new();
        let (off1, len1) = cg.intern_string("hello");
        let (off2, len2) = cg.intern_string("hello");
        assert_eq!(off1, off2, "same string should return same offset");
        assert_eq!(len1, len2, "same string should return same length");
        assert_eq!(len1, 5, "length should be 5");
    }

    #[test]
    fn test_intern_string_different_offsets() {
        let cg = WasmCodeGen::new();
        let (off1, len1) = cg.intern_string("abc");
        let (off2, _) = cg.intern_string("xyz");
        assert_eq!(off1, 2048, "first string at reserved area start");
        assert_eq!(len1, 3);
        assert_eq!(off2, 2051, "second string after first (2048 + 3)");
    }

    #[test]
    fn test_data_section_emission() {
        let cg = WasmCodeGen::new();
        cg.intern_string("hi");
        let mut out = String::new();
        cg.emit_data_section(&mut out).unwrap();
        assert!(out.contains("(data (i32.const 2048)"), "data at offset 2048");
        assert!(out.contains("\\68\\69"), "h=0x68, i=0x69 escaped bytes");
    }

    #[test]
    fn test_data_section_empty() {
        let cg = WasmCodeGen::new();
        let mut out = String::new();
        cg.emit_data_section(&mut out).unwrap();
        assert!(out.is_empty(), "empty data section produces no output");
    }

    // --- Default values for all types ---

    #[test]
    fn test_default_values() {
        let cg = WasmCodeGen::new();
        assert_eq!(cg.default_value(&MirType::I32), "i32.const 0");
        assert_eq!(cg.default_value(&MirType::I64), "i64.const 0");
        assert_eq!(cg.default_value(&MirType::U32), "i32.const 0");
        assert_eq!(cg.default_value(&MirType::U64), "i64.const 0");
        assert_eq!(cg.default_value(&MirType::F64), "f64.const 0.0");
        assert_eq!(cg.default_value(&MirType::Bool), "i32.const 0");
        assert_eq!(cg.default_value(&MirType::Char), "i32.const 0");
        assert_eq!(cg.default_value(&MirType::String), "i32.const 0");
        assert_eq!(cg.default_value(&MirType::Unit), "");
        assert_eq!(cg.default_value(&MirType::Ptr(Box::new(MirType::I64))), "i32.const 0");
        assert_eq!(cg.default_value(&MirType::Tuple(vec![Box::new(MirType::I64)])), "i32.const 0");
    }

    // --- mir_type_to_wasm for all types ---

    #[test]
    fn test_mir_type_to_wasm_all_types() {
        let cg = WasmCodeGen::new();
        assert_eq!(cg.mir_type_to_wasm(&MirType::I32), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::I64), "i64");
        assert_eq!(cg.mir_type_to_wasm(&MirType::U32), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::U64), "i64");
        assert_eq!(cg.mir_type_to_wasm(&MirType::F64), "f64");
        assert_eq!(cg.mir_type_to_wasm(&MirType::Bool), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::String), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::Char), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::Ptr(Box::new(MirType::I64))), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::StructPtr("Foo".to_string())), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::Tuple(vec![Box::new(MirType::I64), Box::new(MirType::F64)])), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::Array { element_type: Box::new(MirType::I64), size: Some(10) }), "i32");
        assert_eq!(cg.mir_type_to_wasm(&MirType::Enum { name: "Color".to_string(), variants: vec![] }), "i32");
    }

    // --- mir_type_to_wasm_result ---

    #[test]
    fn test_mir_type_to_wasm_result_unit() {
        let cg = WasmCodeGen::new();
        assert_eq!(cg.mir_type_to_wasm_result(&MirType::Unit), "", "Unit maps to empty result");
        assert_eq!(cg.mir_type_to_wasm_result(&MirType::I64), "i64", "I64 maps to i64");
        assert_eq!(cg.mir_type_to_wasm_result(&MirType::F64), "f64", "F64 maps to f64");
    }

    // --- Copy instruction ---

    #[test]
    fn test_copy_instruction_codegen() {
        let prog = single_fn_program(
            "copy_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("y", MirType::I64)],
            vec![MirInst::Copy {
                dest: Place::new("y"),
                src: Place::new("x"),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("y")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("local.get $x"), "reads source");
        assert!(wat.contains("local.set $y"), "writes dest");
    }

    // --- Standalone target ---

    #[test]
    fn test_standalone_target() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let codegen = WasmCodeGen::with_target(WasmTarget::Standalone);
        let wat = codegen.generate(&program).unwrap();
        assert!(wat.contains("(module"), "has module");
        assert!(!wat.contains("wasi"), "no wasi imports");
        assert!(!wat.contains("console_log"), "no browser imports");
    }

    // --- with_memory configuration ---

    #[test]
    fn test_with_memory_pages() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let codegen = WasmCodeGen::new().with_memory(16);
        let wat = codegen.generate(&program).unwrap();
        assert!(wat.contains("(memory"), "has memory declaration");
    }

    // --- Shift and bitwise operators ---

    #[test]
    fn test_shift_left_codegen() {
        let prog = binop_program(MirBinOp::Shl, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.shl"), "Shl emits i64.shl");
    }

    #[test]
    fn test_shift_right_codegen() {
        let prog = binop_program(MirBinOp::Shr, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.shr_s"), "Shr emits signed shift right");
    }

    #[test]
    fn test_bitwise_and_codegen() {
        let prog = binop_program(MirBinOp::Band, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.and"), "Band emits i64.and");
    }

    #[test]
    fn test_bitwise_or_codegen() {
        let prog = binop_program(MirBinOp::Bor, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.or"), "Bor emits i64.or");
    }

    #[test]
    fn test_bitwise_xor_codegen() {
        let prog = binop_program(MirBinOp::Bxor, MirType::I64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i64.xor"), "Bxor emits i64.xor");
    }

    // --- Float comparison binops ---

    #[test]
    fn test_float_eq_codegen() {
        let prog = binop_program(MirBinOp::FEq, MirType::F64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.eq"), "FEq emits f64.eq");
    }

    #[test]
    fn test_float_ne_codegen() {
        let prog = binop_program(MirBinOp::FNe, MirType::F64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.ne"), "FNe emits f64.ne");
    }

    #[test]
    fn test_float_lt_codegen() {
        let prog = binop_program(MirBinOp::FLt, MirType::F64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.lt"), "FLt emits f64.lt");
    }

    #[test]
    fn test_float_gt_codegen() {
        let prog = binop_program(MirBinOp::FGt, MirType::F64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.gt"), "FGt emits f64.gt");
    }

    #[test]
    fn test_float_le_codegen() {
        let prog = binop_program(MirBinOp::FLe, MirType::F64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.le"), "FLe emits f64.le");
    }

    #[test]
    fn test_float_ge_codegen() {
        let prog = binop_program(MirBinOp::FGe, MirType::F64);
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("f64.ge"), "FGe emits f64.ge");
    }

    // --- Runtime function verification ---

    #[test]
    fn test_wasi_runtime_i64_to_str() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let wat = WasmCodeGen::with_target(WasmTarget::Wasi).generate(&program).unwrap();
        assert!(wat.contains("(func $i64_to_str"), "i64_to_str function emitted");
        assert!(wat.contains("i64.rem_u"), "digit extraction uses unsigned remainder");
        assert!(wat.contains("i64.div_u"), "digit extraction uses unsigned division");
        assert!(wat.contains("i32.const 48"), "ASCII '0' used");
        assert!(wat.contains("i32.const 45"), "ASCII '-' used for negative");
    }

    #[test]
    fn test_wasi_runtime_println() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let wat = WasmCodeGen::with_target(WasmTarget::Wasi).generate(&program).unwrap();
        assert!(wat.contains("(func $println"), "println function emitted");
        assert!(wat.contains("call $i64_to_str"), "println calls i64_to_str");
        assert!(wat.contains("fd_write"), "println uses fd_write");
    }

    #[test]
    fn test_wasi_runtime_assert() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let wat = WasmCodeGen::with_target(WasmTarget::Wasi).generate(&program).unwrap();
        assert!(wat.contains("(func $assert"), "assert function emitted");
        assert!(wat.contains("call $proc_exit"), "assert uses proc_exit on failure");
    }

    #[test]
    fn test_browser_runtime_all_functions() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let wat = WasmCodeGen::with_target(WasmTarget::Browser).generate(&program).unwrap();
        assert!(wat.contains("(func $println"), "browser has println");
        assert!(wat.contains("call $console_log"), "browser println calls console_log");
        assert!(wat.contains("(func $exit"), "browser has exit");
        assert!(wat.contains("unreachable"), "browser exit uses unreachable");
        assert!(wat.contains("(func $assert"), "browser has assert");
    }

    #[test]
    fn test_bump_allocator_emission() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };
        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(func $bump_alloc"), "bump_alloc emitted");
        assert!(wat.contains("(param $size i32)"), "takes size param");
        assert!(wat.contains("(result i32)"), "returns pointer");
        assert!(wat.contains("global.get $heap_ptr"), "reads heap pointer");
        assert!(wat.contains("i32.const -8"), "8-byte alignment mask");
    }

    // --- Multi-field struct access ---

    #[test]
    fn test_field_access_with_offset() {
        let prog = single_fn_program(
            "get_field2",
            vec![("s", MirType::StructPtr("Point".to_string()))],
            MirType::I64,
            vec![("_t0", MirType::I64)],
            vec![MirInst::FieldAccess {
                dest: Place::new("_t0"),
                base: Place::new("s"),
                field: "z".to_string(),
                field_index: 2,
                struct_name: "Point".to_string(),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.const 16"), "field_index 2 * 8 = offset 16");
        assert!(wat.contains("i32.add"), "adds offset to base");
        assert!(wat.contains("i64.load"), "loads field value");
    }

    #[test]
    fn test_field_store_with_offset() {
        let prog = single_fn_program(
            "set_field1",
            vec![("s", MirType::StructPtr("Point".to_string())), ("v", MirType::I64)],
            MirType::Unit,
            vec![],
            vec![MirInst::FieldStore {
                base: Place::new("s"),
                field: "y".to_string(),
                field_index: 1,
                struct_name: "Point".to_string(),
                value: Operand::Place(Place::new("v")),
            }],
            Terminator::Return(None),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.const 8"), "field_index 1 * 8 = offset 8");
        assert!(wat.contains("i64.store"), "stores field value");
    }

    // --- Phi node placeholder ---

    #[test]
    fn test_phi_node_placeholder() {
        let prog = single_fn_program(
            "phi_fn",
            vec![],
            MirType::I64,
            vec![("x", MirType::I64)],
            vec![MirInst::Phi {
                dest: Place::new("x"),
                values: vec![
                    (Operand::Constant(Constant::Int(1)), "block1".to_string()),
                    (Operand::Constant(Constant::Int(2)), "block2".to_string()),
                ],
            }],
            Terminator::Return(Some(Operand::Place(Place::new("x")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("PHI node for x"), "Phi emits placeholder comment");
    }

    // --- Constant emission ---

    #[test]
    fn test_constant_char_emission() {
        let prog = single_fn_program(
            "char_const",
            vec![],
            MirType::Char,
            vec![("c", MirType::Char)],
            vec![MirInst::Const {
                dest: Place::new("c"),
                value: Constant::Char('A'),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("c")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.const 65"), "'A' = 65 as Unicode codepoint");
    }

    #[test]
    fn test_constant_unit_emission() {
        let prog = single_fn_program(
            "unit_fn",
            vec![],
            MirType::Unit,
            vec![("u", MirType::Unit)],
            vec![MirInst::Const {
                dest: Place::new("u"),
                value: Constant::Unit,
            }],
            Terminator::Return(None),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("unit (no value)"), "Unit constant emits comment");
    }

    #[test]
    fn test_constant_string_in_data() {
        let prog = single_fn_program(
            "str_fn",
            vec![],
            MirType::String,
            vec![("s", MirType::String)],
            vec![MirInst::Const {
                dest: Place::new("s"),
                value: Constant::String("hello".to_string()),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("s")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("i32.const 2048"), "string at data offset 2048");
        assert!(wat.contains("\\68\\65\\6c\\6c\\6f"), "'hello' as hex-escaped bytes");
    }

    // --- Concurrency stubs ---

    #[test]
    fn test_thread_spawn_stub() {
        let prog = single_fn_program(
            "spawn_fn",
            vec![],
            MirType::I64,
            vec![("handle", MirType::I64)],
            vec![MirInst::ThreadSpawn {
                dest: Place::new("handle"),
                func: "worker".to_string(),
                captures: vec![],
            }],
            Terminator::Return(Some(Operand::Place(Place::new("handle")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("WARNING: ThreadSpawn not supported"), "emits warning");
        assert!(wat.contains("i64.const 0"), "returns zero handle");
    }

    #[test]
    fn test_mutex_new_stub() {
        let prog = single_fn_program(
            "mutex_fn",
            vec![],
            MirType::I64,
            vec![("m", MirType::I64)],
            vec![MirInst::MutexNew {
                dest: Place::new("m"),
                initial_value: Operand::Constant(Constant::Int(42)),
            }],
            Terminator::Return(Some(Operand::Place(Place::new("m")))),
        );
        let wat = WasmCodeGen::new().generate(&prog).unwrap();
        assert!(wat.contains("WARNING: MutexNew not supported"), "emits warning");
        assert!(wat.contains("drop"), "drops initial_value");
    }

    // --- infer_place_mir_type ---

    #[test]
    fn test_infer_place_type_from_param() {
        let cg = WasmCodeGen::new();
        let func = MirFunction {
            name: "test".to_string(),
            params: vec![("x".to_string(), MirType::F64)],
            ret_ty: MirType::F64,
            locals: vec![],
            blocks: vec![],
            preconditions: vec![],
            postconditions: vec![],
            is_pure: false,
            is_const: false,
            always_inline: false,
            inline_hint: false,
            is_memory_free: false,
        };
        assert_eq!(cg.infer_place_mir_type("x", &func), MirType::F64);
    }

    #[test]
    fn test_infer_place_type_from_local() {
        let cg = WasmCodeGen::new();
        let func = MirFunction {
            name: "test".to_string(),
            params: vec![],
            ret_ty: MirType::I64,
            locals: vec![("y".to_string(), MirType::Bool)],
            blocks: vec![],
            preconditions: vec![],
            postconditions: vec![],
            is_pure: false,
            is_const: false,
            always_inline: false,
            inline_hint: false,
            is_memory_free: false,
        };
        assert_eq!(cg.infer_place_mir_type("y", &func), MirType::Bool);
    }

    #[test]
    fn test_infer_place_type_default() {
        let cg = WasmCodeGen::new();
        let func = MirFunction {
            name: "test".to_string(),
            params: vec![],
            ret_ty: MirType::I64,
            locals: vec![],
            blocks: vec![],
            preconditions: vec![],
            postconditions: vec![],
            is_pure: false,
            is_const: false,
            always_inline: false,
            inline_hint: false,
            is_memory_free: false,
        };
        assert_eq!(cg.infer_place_mir_type("unknown", &func), MirType::I64);
    }

    // --- infer_operand_wasm_type ---

    #[test]
    fn test_infer_operand_wasm_type_constants() {
        let cg = WasmCodeGen::new();
        let func = MirFunction {
            name: "test".to_string(),
            params: vec![],
            ret_ty: MirType::I64,
            locals: vec![],
            blocks: vec![],
            preconditions: vec![],
            postconditions: vec![],
            is_pure: false,
            is_const: false,
            always_inline: false,
            inline_hint: false,
            is_memory_free: false,
        };
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Constant(Constant::Int(42)), &func), "i64");
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Constant(Constant::Float(1.5)), &func), "f64");
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Constant(Constant::Bool(true)), &func), "i32");
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Constant(Constant::Char('A')), &func), "i32");
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Constant(Constant::String("hi".to_string())), &func), "i32");
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Constant(Constant::Unit), &func), "i32");
    }

    #[test]
    fn test_infer_operand_wasm_type_places() {
        let cg = WasmCodeGen::new();
        let func = MirFunction {
            name: "test".to_string(),
            params: vec![("x".to_string(), MirType::F64)],
            ret_ty: MirType::I64,
            locals: vec![("y".to_string(), MirType::Bool)],
            blocks: vec![],
            preconditions: vec![],
            postconditions: vec![],
            is_pure: false,
            is_const: false,
            always_inline: false,
            inline_hint: false,
            is_memory_free: false,
        };
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Place(Place::new("x")), &func), "f64");
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Place(Place::new("y")), &func), "i32");
        assert_eq!(cg.infer_operand_wasm_type(&Operand::Place(Place::new("unknown")), &func), "i64");
    }

    // =========================================================================
    // Cycle 1217: Loop & Control Flow Tests
    // =========================================================================

    // --- While loop pattern (goto + branch + phi) ---

    #[test]
    fn test_while_loop_pattern() {
        // while (i < n) { sum = sum + i; i = i + 1; }
        // entry: i=0, sum=0, goto loop_header
        // loop_header: branch(i < n, loop_body, loop_exit)
        // loop_body: sum = sum + i; i = i + 1; goto loop_header
        // loop_exit: return sum
        let program = multi_block_program(
            "sum_loop",
            vec![("n", MirType::I64)],
            MirType::I64,
            vec![
                ("i", MirType::I64),
                ("sum", MirType::I64),
                ("_cond", MirType::Bool),
            ],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![
                        MirInst::Const { dest: Place::new("i"), value: Constant::Int(0) },
                        MirInst::Const { dest: Place::new("sum"), value: Constant::Int(0) },
                    ],
                    terminator: Terminator::Goto("loop_header".to_string()),
                },
                BasicBlock {
                    label: "loop_header".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::Lt,
                        lhs: Operand::Place(Place::new("i")),
                        rhs: Operand::Place(Place::new("n")),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "loop_body".to_string(),
                        else_label: "loop_exit".to_string(),
                    },
                },
                BasicBlock {
                    label: "loop_body".to_string(),
                    instructions: vec![
                        MirInst::BinOp {
                            dest: Place::new("sum"),
                            op: MirBinOp::Add,
                            lhs: Operand::Place(Place::new("sum")),
                            rhs: Operand::Place(Place::new("i")),
                        },
                        MirInst::BinOp {
                            dest: Place::new("i"),
                            op: MirBinOp::Add,
                            lhs: Operand::Place(Place::new("i")),
                            rhs: Operand::Constant(Constant::Int(1)),
                        },
                    ],
                    terminator: Terminator::Goto("loop_header".to_string()),
                },
                BasicBlock {
                    label: "loop_exit".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("sum")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(block $entry"), "entry block");
        assert!(wat.contains("(block $loop_header"), "loop_header block");
        assert!(wat.contains("(block $loop_body"), "loop_body block");
        assert!(wat.contains("(block $loop_exit"), "loop_exit block");
        assert!(wat.contains("i64.lt_s"), "loop condition (i < n)");
        assert!(wat.contains("br $loop_header"), "back-edge to loop header");
        assert!(wat.contains("br $loop_exit"), "exit branch");
        assert!(wat.contains("i64.add"), "accumulation in loop body");
    }

    #[test]
    fn test_nested_branch_wasm() {
        // if (x > 0) { if (x > 10) { 2 } else { 1 } } else { 0 }
        let program = multi_block_program(
            "nested_branch",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("_c1", MirType::Bool), ("_c2", MirType::Bool)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_c1"),
                        op: MirBinOp::Gt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_c1")),
                        then_label: "outer_then".to_string(),
                        else_label: "outer_else".to_string(),
                    },
                },
                BasicBlock {
                    label: "outer_then".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_c2"),
                        op: MirBinOp::Gt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(10)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_c2")),
                        then_label: "inner_then".to_string(),
                        else_label: "inner_else".to_string(),
                    },
                },
                BasicBlock {
                    label: "inner_then".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(2)))),
                },
                BasicBlock {
                    label: "inner_else".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(1)))),
                },
                BasicBlock {
                    label: "outer_else".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(block $outer_then"), "outer then block");
        assert!(wat.contains("(block $inner_then"), "inner then block");
        assert!(wat.contains("(block $inner_else"), "inner else block");
        assert!(wat.contains("(block $outer_else"), "outer else block");
        // Both branches generate if/then/else
        assert!(wat.contains("(if"), "branch generates if instruction");
    }

    #[test]
    fn test_goto_chain_wasm() {
        // entry → block_a → block_b → block_c → return
        let program = multi_block_program(
            "chain_fn",
            vec![],
            MirType::I64,
            vec![("x", MirType::I64)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::Const {
                        dest: Place::new("x"),
                        value: Constant::Int(1),
                    }],
                    terminator: Terminator::Goto("block_a".to_string()),
                },
                BasicBlock {
                    label: "block_a".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("x"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(10)),
                    }],
                    terminator: Terminator::Goto("block_b".to_string()),
                },
                BasicBlock {
                    label: "block_b".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("x"),
                        op: MirBinOp::Mul,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(2)),
                    }],
                    terminator: Terminator::Goto("block_c".to_string()),
                },
                BasicBlock {
                    label: "block_c".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("x")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("br $block_a"), "goto block_a");
        assert!(wat.contains("br $block_b"), "goto block_b");
        assert!(wat.contains("br $block_c"), "goto block_c");
        assert!(wat.contains("i64.add"), "add in block_a");
        assert!(wat.contains("i64.mul"), "mul in block_b");
    }

    #[test]
    fn test_branch_with_computation() {
        // abs(x): if x < 0 then -x else x
        let program = multi_block_program(
            "abs_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("_cond", MirType::Bool), ("_neg", MirType::I64)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::Lt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "neg_case".to_string(),
                        else_label: "pos_case".to_string(),
                    },
                },
                BasicBlock {
                    label: "neg_case".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_neg"),
                        op: MirBinOp::Sub,
                        lhs: Operand::Constant(Constant::Int(0)),
                        rhs: Operand::Place(Place::new("x")),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_neg")))),
                },
                BasicBlock {
                    label: "pos_case".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("x")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.lt_s"), "comparison x < 0");
        assert!(wat.contains("br $neg_case"), "branch to neg_case");
        assert!(wat.contains("br $pos_case"), "branch to pos_case");
        assert!(wat.contains("i64.sub"), "negation via 0 - x");
    }

    #[test]
    fn test_switch_many_cases() {
        // switch with 5 cases
        let program = multi_block_program(
            "switch5_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Switch {
                        discriminant: Operand::Place(Place::new("x")),
                        cases: vec![
                            (0, "c0".to_string()),
                            (1, "c1".to_string()),
                            (2, "c2".to_string()),
                            (3, "c3".to_string()),
                            (4, "c4".to_string()),
                        ],
                        default: "def".to_string(),
                    },
                },
                BasicBlock {
                    label: "c0".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(100)))),
                },
                BasicBlock {
                    label: "c1".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(200)))),
                },
                BasicBlock {
                    label: "c2".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(300)))),
                },
                BasicBlock {
                    label: "c3".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(400)))),
                },
                BasicBlock {
                    label: "c4".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(500)))),
                },
                BasicBlock {
                    label: "def".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("br_if $c0"), "branch to case 0");
        assert!(wat.contains("br_if $c1"), "branch to case 1");
        assert!(wat.contains("br_if $c2"), "branch to case 2");
        assert!(wat.contains("br_if $c3"), "branch to case 3");
        assert!(wat.contains("br_if $c4"), "branch to case 4");
        assert!(wat.contains("br $def"), "default case branch");
    }

    #[test]
    fn test_switch_default_only() {
        // switch with no cases, just default
        let program = multi_block_program(
            "switch_default_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Switch {
                        discriminant: Operand::Place(Place::new("x")),
                        cases: vec![],
                        default: "def".to_string(),
                    },
                },
                BasicBlock {
                    label: "def".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(99)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("br $def"), "branch to default");
    }

    #[test]
    fn test_recursive_function_call() {
        // factorial(n): if n <= 1 return 1 else return n * factorial(n-1)
        let program = multi_block_program(
            "factorial",
            vec![("n", MirType::I64)],
            MirType::I64,
            vec![
                ("_cond", MirType::Bool),
                ("_n1", MirType::I64),
                ("_rec", MirType::I64),
                ("_result", MirType::I64),
            ],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::Le,
                        lhs: Operand::Place(Place::new("n")),
                        rhs: Operand::Constant(Constant::Int(1)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "base_case".to_string(),
                        else_label: "rec_case".to_string(),
                    },
                },
                BasicBlock {
                    label: "base_case".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(1)))),
                },
                BasicBlock {
                    label: "rec_case".to_string(),
                    instructions: vec![
                        MirInst::BinOp {
                            dest: Place::new("_n1"),
                            op: MirBinOp::Sub,
                            lhs: Operand::Place(Place::new("n")),
                            rhs: Operand::Constant(Constant::Int(1)),
                        },
                        MirInst::Call {
                            dest: Some(Place::new("_rec")),
                            func: "factorial".to_string(),
                            args: vec![Operand::Place(Place::new("_n1"))],
                            is_tail: false,
                        },
                        MirInst::BinOp {
                            dest: Place::new("_result"),
                            op: MirBinOp::Mul,
                            lhs: Operand::Place(Place::new("n")),
                            rhs: Operand::Place(Place::new("_rec")),
                        },
                    ],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_result")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(func $factorial"), "factorial function declared");
        assert!(wat.contains("call $factorial"), "recursive call emitted");
        assert!(wat.contains("i64.le_s"), "base case condition");
        assert!(wat.contains("i64.sub"), "n - 1 for recursive call");
        assert!(wat.contains("i64.mul"), "n * factorial(n-1)");
    }

    #[test]
    fn test_multi_function_call_chain() {
        // Two functions: double(x) = x * 2, apply_double(x) = double(x) + 1
        let program = MirProgram {
            functions: vec![
                MirFunction {
                    name: "double".to_string(),
                    params: vec![("x".to_string(), MirType::I64)],
                    ret_ty: MirType::I64,
                    locals: vec![("_t0".to_string(), MirType::I64)],
                    blocks: vec![BasicBlock {
                        label: "entry".to_string(),
                        instructions: vec![MirInst::BinOp {
                            dest: Place::new("_t0"),
                            op: MirBinOp::Mul,
                            lhs: Operand::Place(Place::new("x")),
                            rhs: Operand::Constant(Constant::Int(2)),
                        }],
                        terminator: Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
                    }],
                    preconditions: vec![],
                    postconditions: vec![],
                    is_pure: false,
                    is_const: false,
                    always_inline: false,
                    inline_hint: false,
                    is_memory_free: false,
                },
                MirFunction {
                    name: "apply_double".to_string(),
                    params: vec![("x".to_string(), MirType::I64)],
                    ret_ty: MirType::I64,
                    locals: vec![
                        ("_d".to_string(), MirType::I64),
                        ("_r".to_string(), MirType::I64),
                    ],
                    blocks: vec![BasicBlock {
                        label: "entry".to_string(),
                        instructions: vec![
                            MirInst::Call {
                                dest: Some(Place::new("_d")),
                                func: "double".to_string(),
                                args: vec![Operand::Place(Place::new("x"))],
                                is_tail: false,
                            },
                            MirInst::BinOp {
                                dest: Place::new("_r"),
                                op: MirBinOp::Add,
                                lhs: Operand::Place(Place::new("_d")),
                                rhs: Operand::Constant(Constant::Int(1)),
                            },
                        ],
                        terminator: Terminator::Return(Some(Operand::Place(Place::new("_r")))),
                    }],
                    preconditions: vec![],
                    postconditions: vec![],
                    is_pure: false,
                    is_const: false,
                    always_inline: false,
                    inline_hint: false,
                    is_memory_free: false,
                },
            ],
            extern_fns: vec![],
            struct_defs: std::collections::HashMap::new(),
        };

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(func $double"), "double function");
        assert!(wat.contains("(func $apply_double"), "apply_double function");
        assert!(wat.contains("call $double"), "calls double from apply_double");
    }

    #[test]
    fn test_tail_call_wasm() {
        let program = single_fn_program(
            "tail_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("_r", MirType::I64)],
            vec![MirInst::Call {
                dest: Some(Place::new("_r")),
                func: "helper".to_string(),
                args: vec![Operand::Place(Place::new("x"))],
                is_tail: true,
            }],
            Terminator::Return(Some(Operand::Place(Place::new("_r")))),
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        // WASM doesn't have native tail call yet, so it should still emit a regular call
        assert!(wat.contains("call $helper"), "tail call emits regular call in WASM");
    }

    #[test]
    fn test_branch_constant_true_condition() {
        // Branch with constant true condition — both paths should be present
        let program = multi_block_program(
            "const_true_br",
            vec![],
            MirType::I64,
            vec![],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Branch {
                        cond: Operand::Constant(Constant::Bool(true)),
                        then_label: "then_blk".to_string(),
                        else_label: "else_blk".to_string(),
                    },
                },
                BasicBlock {
                    label: "then_blk".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(1)))),
                },
                BasicBlock {
                    label: "else_blk".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i32.const 1"), "constant true condition");
        assert!(wat.contains("(if"), "branch generates if");
        assert!(wat.contains("br $then_blk"), "then branch");
        assert!(wat.contains("br $else_blk"), "else branch");
    }

    #[test]
    fn test_loop_with_float_accumulation() {
        // Float loop: sum = 0.0; while (i < n) { sum = sum + 1.5; i = i + 1; }
        let program = multi_block_program(
            "float_loop",
            vec![("n", MirType::I64)],
            MirType::F64,
            vec![
                ("i", MirType::I64),
                ("sum", MirType::F64),
                ("_cond", MirType::Bool),
            ],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![
                        MirInst::Const { dest: Place::new("i"), value: Constant::Int(0) },
                        MirInst::Const { dest: Place::new("sum"), value: Constant::Float(0.0) },
                    ],
                    terminator: Terminator::Goto("loop_hdr".to_string()),
                },
                BasicBlock {
                    label: "loop_hdr".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::Lt,
                        lhs: Operand::Place(Place::new("i")),
                        rhs: Operand::Place(Place::new("n")),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "loop_body".to_string(),
                        else_label: "loop_done".to_string(),
                    },
                },
                BasicBlock {
                    label: "loop_body".to_string(),
                    instructions: vec![
                        MirInst::BinOp {
                            dest: Place::new("sum"),
                            op: MirBinOp::FAdd,
                            lhs: Operand::Place(Place::new("sum")),
                            rhs: Operand::Constant(Constant::Float(1.5)),
                        },
                        MirInst::BinOp {
                            dest: Place::new("i"),
                            op: MirBinOp::Add,
                            lhs: Operand::Place(Place::new("i")),
                            rhs: Operand::Constant(Constant::Int(1)),
                        },
                    ],
                    terminator: Terminator::Goto("loop_hdr".to_string()),
                },
                BasicBlock {
                    label: "loop_done".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("sum")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.const 0"), "float zero init");
        assert!(wat.contains("f64.const 1.5"), "float step constant");
        assert!(wat.contains("f64.add"), "float accumulation");
        assert!(wat.contains("br $loop_hdr"), "back-edge to loop header");
    }

    #[test]
    fn test_diamond_control_flow() {
        // Diamond pattern: entry → (then | else) → merge → return
        let program = multi_block_program(
            "diamond_fn",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![
                ("_cond", MirType::Bool),
                ("result", MirType::I64),
            ],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::Gt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "then_arm".to_string(),
                        else_label: "else_arm".to_string(),
                    },
                },
                BasicBlock {
                    label: "then_arm".to_string(),
                    instructions: vec![MirInst::Const {
                        dest: Place::new("result"),
                        value: Constant::Int(42),
                    }],
                    terminator: Terminator::Goto("merge".to_string()),
                },
                BasicBlock {
                    label: "else_arm".to_string(),
                    instructions: vec![MirInst::Const {
                        dest: Place::new("result"),
                        value: Constant::Int(-1),
                    }],
                    terminator: Terminator::Goto("merge".to_string()),
                },
                BasicBlock {
                    label: "merge".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("result")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(block $then_arm"), "then arm block");
        assert!(wat.contains("(block $else_arm"), "else arm block");
        assert!(wat.contains("(block $merge"), "merge block");
        assert!(wat.contains("br $merge"), "both arms branch to merge");
    }

    #[test]
    fn test_multiple_return_paths() {
        // Function with 3 different return points
        let program = multi_block_program(
            "multi_ret",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("_c1", MirType::Bool), ("_c2", MirType::Bool)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_c1"),
                        op: MirBinOp::Lt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_c1")),
                        then_label: "neg_ret".to_string(),
                        else_label: "check2".to_string(),
                    },
                },
                BasicBlock {
                    label: "neg_ret".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(-1)))),
                },
                BasicBlock {
                    label: "check2".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_c2"),
                        op: MirBinOp::Eq,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_c2")),
                        then_label: "zero_ret".to_string(),
                        else_label: "pos_ret".to_string(),
                    },
                },
                BasicBlock {
                    label: "zero_ret".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
                },
                BasicBlock {
                    label: "pos_ret".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(1)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        // Three return instructions
        let return_count = wat.matches("return").count();
        assert!(return_count >= 3, "at least 3 return instructions, got {}", return_count);
        assert!(wat.contains("(block $neg_ret"), "neg_ret block");
        assert!(wat.contains("(block $check2"), "check2 block");
        assert!(wat.contains("(block $zero_ret"), "zero_ret block");
        assert!(wat.contains("(block $pos_ret"), "pos_ret block");
    }

    #[test]
    fn test_void_function_with_branch() {
        // void function with control flow
        let program = multi_block_program(
            "void_branch",
            vec![("x", MirType::I64)],
            MirType::Unit,
            vec![("_cond", MirType::Bool)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::Gt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "do_work".to_string(),
                        else_label: "skip".to_string(),
                    },
                },
                BasicBlock {
                    label: "do_work".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(None),
                },
                BasicBlock {
                    label: "skip".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(None),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(block $do_work"), "do_work block");
        assert!(wat.contains("(block $skip"), "skip block");
        // Void returns should not push a value
        assert!(wat.contains("return"), "return in void function");
    }

    #[test]
    fn test_loop_with_early_exit() {
        // Loop with early exit: while (true) { if (i >= n) break; i = i + 1; }
        let program = multi_block_program(
            "early_exit",
            vec![("n", MirType::I64)],
            MirType::I64,
            vec![
                ("i", MirType::I64),
                ("_cond", MirType::Bool),
            ],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::Const {
                        dest: Place::new("i"),
                        value: Constant::Int(0),
                    }],
                    terminator: Terminator::Goto("loop_top".to_string()),
                },
                BasicBlock {
                    label: "loop_top".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::Ge,
                        lhs: Operand::Place(Place::new("i")),
                        rhs: Operand::Place(Place::new("n")),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "exit".to_string(),
                        else_label: "continue".to_string(),
                    },
                },
                BasicBlock {
                    label: "continue".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("i"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("i")),
                        rhs: Operand::Constant(Constant::Int(1)),
                    }],
                    terminator: Terminator::Goto("loop_top".to_string()),
                },
                BasicBlock {
                    label: "exit".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("i")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.ge_s"), "exit condition");
        assert!(wat.contains("br $exit"), "early exit branch");
        assert!(wat.contains("br $loop_top"), "loop back-edge");
    }

    #[test]
    fn test_switch_with_computations() {
        // switch where each case has actual computation
        let program = multi_block_program(
            "switch_compute",
            vec![("x", MirType::I64), ("y", MirType::I64)],
            MirType::I64,
            vec![("_r", MirType::I64)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Switch {
                        discriminant: Operand::Place(Place::new("x")),
                        cases: vec![
                            (0, "add_case".to_string()),
                            (1, "mul_case".to_string()),
                        ],
                        default: "default".to_string(),
                    },
                },
                BasicBlock {
                    label: "add_case".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_r"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("y")),
                        rhs: Operand::Constant(Constant::Int(10)),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_r")))),
                },
                BasicBlock {
                    label: "mul_case".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_r"),
                        op: MirBinOp::Mul,
                        lhs: Operand::Place(Place::new("y")),
                        rhs: Operand::Constant(Constant::Int(2)),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_r")))),
                },
                BasicBlock {
                    label: "default".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("y")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.add"), "add in case 0");
        assert!(wat.contains("i64.mul"), "mul in case 1");
        assert!(wat.contains("br_if $add_case"), "branch to add case");
        assert!(wat.contains("br_if $mul_case"), "branch to mul case");
    }

    #[test]
    fn test_nested_loop_pattern() {
        // Outer: i = 0..n, Inner: j = 0..m (counting total iterations)
        let program = multi_block_program(
            "nested_loops",
            vec![("n", MirType::I64), ("m", MirType::I64)],
            MirType::I64,
            vec![
                ("i", MirType::I64),
                ("j", MirType::I64),
                ("count", MirType::I64),
                ("_c1", MirType::Bool),
                ("_c2", MirType::Bool),
            ],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![
                        MirInst::Const { dest: Place::new("i"), value: Constant::Int(0) },
                        MirInst::Const { dest: Place::new("count"), value: Constant::Int(0) },
                    ],
                    terminator: Terminator::Goto("outer_hdr".to_string()),
                },
                BasicBlock {
                    label: "outer_hdr".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_c1"),
                        op: MirBinOp::Lt,
                        lhs: Operand::Place(Place::new("i")),
                        rhs: Operand::Place(Place::new("n")),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_c1")),
                        then_label: "inner_init".to_string(),
                        else_label: "done".to_string(),
                    },
                },
                BasicBlock {
                    label: "inner_init".to_string(),
                    instructions: vec![MirInst::Const {
                        dest: Place::new("j"),
                        value: Constant::Int(0),
                    }],
                    terminator: Terminator::Goto("inner_hdr".to_string()),
                },
                BasicBlock {
                    label: "inner_hdr".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_c2"),
                        op: MirBinOp::Lt,
                        lhs: Operand::Place(Place::new("j")),
                        rhs: Operand::Place(Place::new("m")),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_c2")),
                        then_label: "inner_body".to_string(),
                        else_label: "outer_inc".to_string(),
                    },
                },
                BasicBlock {
                    label: "inner_body".to_string(),
                    instructions: vec![
                        MirInst::BinOp {
                            dest: Place::new("count"),
                            op: MirBinOp::Add,
                            lhs: Operand::Place(Place::new("count")),
                            rhs: Operand::Constant(Constant::Int(1)),
                        },
                        MirInst::BinOp {
                            dest: Place::new("j"),
                            op: MirBinOp::Add,
                            lhs: Operand::Place(Place::new("j")),
                            rhs: Operand::Constant(Constant::Int(1)),
                        },
                    ],
                    terminator: Terminator::Goto("inner_hdr".to_string()),
                },
                BasicBlock {
                    label: "outer_inc".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("i"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("i")),
                        rhs: Operand::Constant(Constant::Int(1)),
                    }],
                    terminator: Terminator::Goto("outer_hdr".to_string()),
                },
                BasicBlock {
                    label: "done".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("count")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("(block $outer_hdr"), "outer loop header block");
        assert!(wat.contains("(block $inner_hdr"), "inner loop header block");
        assert!(wat.contains("(block $inner_body"), "inner body block");
        assert!(wat.contains("(block $outer_inc"), "outer increment block");
        assert!(wat.contains("br $inner_hdr"), "inner loop back-edge");
        assert!(wat.contains("br $outer_hdr"), "outer loop back-edge");
    }

    #[test]
    fn test_phi_with_branch_merge() {
        // Phi node in merge block after branch
        let program = multi_block_program(
            "phi_merge",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![
                ("_cond", MirType::Bool),
                ("result", MirType::I64),
            ],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::Gt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "pos".to_string(),
                        else_label: "neg".to_string(),
                    },
                },
                BasicBlock {
                    label: "pos".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Goto("merge".to_string()),
                },
                BasicBlock {
                    label: "neg".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Goto("merge".to_string()),
                },
                BasicBlock {
                    label: "merge".to_string(),
                    instructions: vec![MirInst::Phi {
                        dest: Place::new("result"),
                        values: vec![
                            (Operand::Constant(Constant::Int(1)), "pos".to_string()),
                            (Operand::Constant(Constant::Int(-1)), "neg".to_string()),
                        ],
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("result")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("PHI node for result"), "phi node placeholder in merge");
        assert!(wat.contains("br $merge"), "branches converge at merge");
    }

    #[test]
    fn test_select_in_control_flow() {
        // Select instruction within multi-block function
        let program = multi_block_program(
            "select_cf",
            vec![("x", MirType::I64), ("y", MirType::I64)],
            MirType::I64,
            vec![
                ("_max", MirType::I64),
            ],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![
                        MirInst::Select {
                            dest: Place::new("_max"),
                            cond_op: MirBinOp::Gt,
                            cond_lhs: Operand::Place(Place::new("x")),
                            cond_rhs: Operand::Place(Place::new("y")),
                            true_val: Operand::Place(Place::new("x")),
                            false_val: Operand::Place(Place::new("y")),
                        },
                    ],
                    terminator: Terminator::Goto("done".to_string()),
                },
                BasicBlock {
                    label: "done".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_max")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("select"), "select instruction emitted");
        assert!(wat.contains("br $done"), "goto done block");
    }

    #[test]
    fn test_many_blocks_linear() {
        // Linear chain of 6 blocks with different operations
        let program = multi_block_program(
            "many_blocks",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("r", MirType::I64)],
            vec![
                BasicBlock {
                    label: "b0".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("r"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Int(1)),
                    }],
                    terminator: Terminator::Goto("b1".to_string()),
                },
                BasicBlock {
                    label: "b1".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("r"),
                        op: MirBinOp::Mul,
                        lhs: Operand::Place(Place::new("r")),
                        rhs: Operand::Constant(Constant::Int(2)),
                    }],
                    terminator: Terminator::Goto("b2".to_string()),
                },
                BasicBlock {
                    label: "b2".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("r"),
                        op: MirBinOp::Sub,
                        lhs: Operand::Place(Place::new("r")),
                        rhs: Operand::Constant(Constant::Int(3)),
                    }],
                    terminator: Terminator::Goto("b3".to_string()),
                },
                BasicBlock {
                    label: "b3".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("r"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("r")),
                        rhs: Operand::Constant(Constant::Int(100)),
                    }],
                    terminator: Terminator::Goto("b4".to_string()),
                },
                BasicBlock {
                    label: "b4".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("r"),
                        op: MirBinOp::Div,
                        lhs: Operand::Place(Place::new("r")),
                        rhs: Operand::Constant(Constant::Int(5)),
                    }],
                    terminator: Terminator::Goto("b5".to_string()),
                },
                BasicBlock {
                    label: "b5".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("r")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        for i in 0..6 {
            assert!(wat.contains(&format!("(block $b{}", i)), "block b{} present", i);
        }
        assert!(wat.contains("i64.add"), "add operation");
        assert!(wat.contains("i64.mul"), "mul operation");
        assert!(wat.contains("i64.sub"), "sub operation");
        assert!(wat.contains("i64.div_s"), "div operation");
    }

    #[test]
    fn test_copy_in_control_flow() {
        // Copy instruction used in multi-block context
        let program = multi_block_program(
            "copy_cf",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![("y", MirType::I64)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::Copy {
                        dest: Place::new("y"),
                        src: Place::new("x"),
                    }],
                    terminator: Terminator::Goto("done".to_string()),
                },
                BasicBlock {
                    label: "done".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("y")))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("local.get $x"), "copy reads source");
        assert!(wat.contains("local.set $y"), "copy writes destination");
    }

    #[test]
    fn test_branch_with_f64_comparison() {
        // Branch based on float comparison
        let program = multi_block_program(
            "float_branch",
            vec![("x", MirType::F64)],
            MirType::I64,
            vec![("_cond", MirType::Bool)],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_cond"),
                        op: MirBinOp::FLt,
                        lhs: Operand::Place(Place::new("x")),
                        rhs: Operand::Constant(Constant::Float(0.0)),
                    }],
                    terminator: Terminator::Branch {
                        cond: Operand::Place(Place::new("_cond")),
                        then_label: "negative".to_string(),
                        else_label: "non_neg".to_string(),
                    },
                },
                BasicBlock {
                    label: "negative".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(-1)))),
                },
                BasicBlock {
                    label: "non_neg".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(1)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("f64.lt"), "float less-than comparison");
        assert!(wat.contains("br $negative"), "branch to negative");
        assert!(wat.contains("br $non_neg"), "branch to non_neg");
    }

    #[test]
    fn test_goto_with_unreachable_block() {
        // Goto skips over unreachable dead block
        let program = multi_block_program(
            "dead_block_fn",
            vec![],
            MirType::I64,
            vec![],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Goto("live".to_string()),
                },
                BasicBlock {
                    label: "dead".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Unreachable,
                },
                BasicBlock {
                    label: "live".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(42)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("br $live"), "goto live block");
        assert!(wat.contains("unreachable"), "dead block has unreachable");
        assert!(wat.contains("(block $dead"), "dead block still emitted");
    }

    #[test]
    fn test_switch_with_negative_values() {
        // Switch with negative case values
        let program = multi_block_program(
            "neg_switch",
            vec![("x", MirType::I64)],
            MirType::I64,
            vec![],
            vec![
                BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Switch {
                        discriminant: Operand::Place(Place::new("x")),
                        cases: vec![
                            (-1, "neg1".to_string()),
                            (0, "zero".to_string()),
                            (1, "pos1".to_string()),
                        ],
                        default: "def".to_string(),
                    },
                },
                BasicBlock {
                    label: "neg1".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(10)))),
                },
                BasicBlock {
                    label: "zero".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(20)))),
                },
                BasicBlock {
                    label: "pos1".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(30)))),
                },
                BasicBlock {
                    label: "def".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(Some(Operand::Constant(Constant::Int(0)))),
                },
            ],
        );

        let wat = WasmCodeGen::new().generate(&program).unwrap();
        assert!(wat.contains("i64.const -1"), "negative case value");
        assert!(wat.contains("br_if $neg1"), "branch to neg1 case");
    }
}
