// BMB Grammar for LALRPOP

use crate::ast::*;
use crate::lexer::Token;

grammar;

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        "fn" => Token::Fn,
        "let" => Token::Let,
        "var" => Token::Var,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "pre" => Token::Pre,
        "post" => Token::Post,
        "true" => Token::True,
        "false" => Token::False,
        "ret" => Token::Ret,
        "and" => Token::And,
        "or" => Token::Or,
        "not" => Token::Not,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "match" => Token::Match,
        "new" => Token::New,

        "i32" => Token::TyI32,
        "i64" => Token::TyI64,
        "f64" => Token::TyF64,
        "bool" => Token::TyBool,

        "int" => Token::IntLit(<i64>),
        "float" => Token::FloatLit(<f64>),
        "ident" => Token::Ident(<String>),

        ":" => Token::Colon,
        "::" => Token::ColonColon,
        "->" => Token::Arrow,
        "=>" => Token::FatArrow,
        "_" => Token::Underscore,
        "." => Token::Dot,
        "=" => Token::Eq,
        ";" => Token::Semi,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "==" => Token::EqEq,
        "!=" => Token::NotEq,
        "<=" => Token::LtEq,
        ">=" => Token::GtEq,
        "<" => Token::Lt,
        ">" => Token::Gt,
    }
}

// Program
pub Program: Program = {
    <items:Item*> => Program { items },
};

// Items
Item: Item = {
    <f:FnDef> => Item::FnDef(f),
    <s:StructDef> => Item::StructDef(s),
    <e:EnumDef> => Item::EnumDef(e),
};

// Struct definition
StructDef: StructDef = {
    <l:@L> "struct" <name:Ident> "{" <fields:StructFields> "}" <r:@R> => StructDef {
        name,
        fields,
        span: Span::new(l, r),
    },
};

StructFields: Vec<StructField> = {
    <v:(<StructField> ",")*> <e:StructField?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

StructField: StructField = {
    <name:Ident> ":" <ty:SpannedType> => StructField { name, ty },
};

// Enum definition
EnumDef: EnumDef = {
    <l:@L> "enum" <name:Ident> "{" <variants:EnumVariants> "}" <r:@R> => EnumDef {
        name,
        variants,
        span: Span::new(l, r),
    },
};

EnumVariants: Vec<EnumVariant> = {
    <v:(<EnumVariant> ",")*> <e:EnumVariant?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

EnumVariant: EnumVariant = {
    // Unit variant: Variant
    <name:Ident> => EnumVariant { name, fields: vec![] },
    // Tuple variant: Variant(Type1, Type2)
    <name:Ident> "(" <fields:TypeList> ")" => EnumVariant { name, fields },
};

TypeList: Vec<Spanned<Type>> = {
    <v:(<SpannedType> ",")*> <e:SpannedType?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Function definition
FnDef: FnDef = {
    <l:@L> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType>
    <pre:("pre" <SpannedExpr>)?>
    <post:("post" <SpannedExpr>)?>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        name,
        params,
        ret_ty,
        pre,
        post,
        body,
        span: Span::new(l, r),
    },
};

// Parameters
Params: Vec<Param> = {
    <v:(<Param> ",")*> <e:Param?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

Param: Param = {
    <name:Ident> ":" <ty:SpannedType> => Param { name, ty },
};

// Types
SpannedType: Spanned<Type> = {
    <l:@L> <t:Type> <r:@R> => Spanned::new(t, Span::new(l, r)),
};

Type: Type = {
    "i32" => Type::I32,
    "i64" => Type::I64,
    "f64" => Type::F64,
    "bool" => Type::Bool,
    "(" ")" => Type::Unit,
    <name:RawIdent> => Type::Named(name),
};

// Expressions with span
SpannedExpr: Spanned<Expr> = {
    <l:@L> <e:Expr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Expressions (precedence from low to high)
Expr: Expr = {
    OrExpr,
    "if" <c:SpannedExpr> "then" <t:SpannedExpr> "else" <e:SpannedExpr> => Expr::If {
        cond: Box::new(c),
        then_branch: Box::new(t),
        else_branch: Box::new(e),
    },
    "let" <n:RawIdent> <ty:(":" <SpannedType>)?> "=" <v:SpannedExpr> ";" <b:SpannedExpr> => Expr::Let {
        name: n,
        ty,
        value: Box::new(v),
        body: Box::new(b),
    },
    "{" <es:(<SpannedExpr> ";")*> <last:SpannedExpr?> "}" => {
        let mut exprs = es;
        if let Some(e) = last {
            exprs.push(e);
        }
        Expr::Block(exprs)
    },
    // Match expression
    "match" <e:SpannedExpr> "{" <arms:MatchArms> "}" => Expr::Match {
        expr: Box::new(e),
        arms,
    },
};

// Match arms
MatchArms: Vec<MatchArm> = {
    <v:(<MatchArm> ",")*> <e:MatchArm?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

MatchArm: MatchArm = {
    <pattern:SpannedPattern> "=>" <body:SpannedExpr> => MatchArm { pattern, body },
};

SpannedPattern: Spanned<Pattern> = {
    <l:@L> <p:Pattern> <r:@R> => Spanned::new(p, Span::new(l, r)),
};

Pattern: Pattern = {
    // Wildcard
    "_" => Pattern::Wildcard,
    // Literal patterns
    <n:"int"> => Pattern::Literal(LiteralPattern::Int(n)),
    <n:"float"> => Pattern::Literal(LiteralPattern::Float(n)),
    "true" => Pattern::Literal(LiteralPattern::Bool(true)),
    "false" => Pattern::Literal(LiteralPattern::Bool(false)),
    // Enum variant pattern: EnumName::Variant or EnumName::Variant(bindings)
    <enum_name:RawIdent> "::" <variant:RawIdent> => Pattern::EnumVariant {
        enum_name,
        variant,
        bindings: vec![],
    },
    <enum_name:RawIdent> "::" <variant:RawIdent> "(" <bindings:PatternBindings> ")" => Pattern::EnumVariant {
        enum_name,
        variant,
        bindings,
    },
    // Variable binding (must be after enum variant to avoid ambiguity)
    <n:RawIdent> => Pattern::Var(n),
};

PatternBindings: Vec<Spanned<String>> = {
    <v:(<Ident> ",")*> <e:Ident?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Or expression
OrExpr: Expr = {
    <l:SpannedOrExpr> "or" <r:SpannedAndExpr> => Expr::Binary {
        left: Box::new(l),
        op: BinOp::Or,
        right: Box::new(r),
    },
    AndExpr,
};

SpannedOrExpr: Spanned<Expr> = {
    <l:@L> <e:OrExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// And expression
AndExpr: Expr = {
    <l:SpannedAndExpr> "and" <r:SpannedCmpExpr> => Expr::Binary {
        left: Box::new(l),
        op: BinOp::And,
        right: Box::new(r),
    },
    CmpExpr,
};

SpannedAndExpr: Spanned<Expr> = {
    <l:@L> <e:AndExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Comparison expression
CmpExpr: Expr = {
    <l:SpannedAddExpr> <op:CmpOp> <r:SpannedAddExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    AddExpr,
};

SpannedCmpExpr: Spanned<Expr> = {
    <l:@L> <e:CmpExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

CmpOp: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Ne,
    "<" => BinOp::Lt,
    ">" => BinOp::Gt,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
};

// Additive expression
AddExpr: Expr = {
    <l:SpannedAddExpr> <op:AddOp> <r:SpannedMulExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    MulExpr,
};

SpannedAddExpr: Spanned<Expr> = {
    <l:@L> <e:AddExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

// Multiplicative expression
MulExpr: Expr = {
    <l:SpannedMulExpr> <op:MulOp> <r:SpannedUnaryExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    UnaryExpr,
};

SpannedMulExpr: Spanned<Expr> = {
    <l:@L> <e:MulExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

MulOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

// Unary expression
UnaryExpr: Expr = {
    "-" <e:SpannedUnaryExpr> => Expr::Unary {
        op: UnOp::Neg,
        expr: Box::new(e),
    },
    "not" <e:SpannedUnaryExpr> => Expr::Unary {
        op: UnOp::Not,
        expr: Box::new(e),
    },
    PostfixExpr,
};

SpannedUnaryExpr: Spanned<Expr> = {
    <l:@L> <e:UnaryExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Postfix expression (field access, calls)
PostfixExpr: Expr = {
    <e:SpannedPostfixExpr> "." <field:Ident> => Expr::FieldAccess {
        expr: Box::new(e),
        field,
    },
    CallExpr,
};

SpannedPostfixExpr: Spanned<Expr> = {
    <l:@L> <e:PostfixExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Call expression / Identifier-based expressions
CallExpr: Expr = {
    // Function call: func(args)
    <f:RawIdent> "(" <args:Args> ")" => Expr::Call { func: f, args },
    // Enum variant with args: EnumName::Variant(args)
    <enum_name:RawIdent> "::" <variant:RawIdent> "(" <args:Args> ")" => Expr::EnumVariant {
        enum_name,
        variant,
        args,
    },
    // Enum variant without args: EnumName::Variant
    <enum_name:RawIdent> "::" <variant:RawIdent> => Expr::EnumVariant {
        enum_name,
        variant,
        args: vec![],
    },
    // Variable reference or other primaries
    Primary,
};

Args: Vec<Spanned<Expr>> = {
    <v:(<SpannedExpr> ",")*> <e:SpannedExpr?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Primary expressions
Primary: Expr = {
    "int" => Expr::IntLit(<>),
    "float" => Expr::FloatLit(<>),
    "true" => Expr::BoolLit(true),
    "false" => Expr::BoolLit(false),
    "ret" => Expr::Ret,
    "(" ")" => Expr::Unit,
    "(" <Expr> ")",
    <n:RawIdent> => Expr::Var(n),
    // Struct initialization: new StructName { field: value, ... }
    "new" <name:RawIdent> "{" <fields:StructInitFields> "}" => Expr::StructInit {
        name,
        fields,
    },
};

StructInitFields: Vec<(Spanned<String>, Spanned<Expr>)> = {
    <v:(<StructInitField> ",")*> <e:StructInitField?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

StructInitField: (Spanned<String>, Spanned<Expr>) = {
    <name:Ident> ":" <value:SpannedExpr> => (name, value),
};

// Identifier
Ident: Spanned<String> = {
    <l:@L> <s:RawIdent> <r:@R> => Spanned::new(s, Span::new(l, r)),
};

RawIdent: String = {
    "ident" => <>,
};
