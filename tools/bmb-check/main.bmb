// BMB Type Checker (bmb-check)
// Phase v0.64.4: Fast type checking tool
//
// Runs type checking on BMB source files without code generation.
// Provides quick feedback for IDE integration and CI pipelines.
//
// Usage:
//   bmb run tools/bmb-check/main.bmb <file.bmb>
//   bmb run tools/bmb-check/main.bmb --batch files.txt
//   bmb run tools/bmb-check/main.bmb --json <file.bmb>

fn BMB_PATH() -> String = "./target/release/bmb";

// ============================================================
// String Utilities
// ============================================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn char_is_whitespace(c: i64) -> bool = c == 32 or c == 9;
fn char_is_newline(c: i64) -> bool = c == 10 or c == 13;

// ============================================================
// Line Processing
// ============================================================

fn find_newline(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 10 { pos }
    else { find_newline(s, pos + 1) };

fn get_line_at(s: String, pos: i64) -> String =
    let end = find_newline(s, pos);
    s.slice(pos, end);

fn next_line_pos(s: String, pos: i64) -> i64 =
    let nl = find_newline(s, pos);
    if nl >= s.len() { s.len() } else { nl + 1 };

fn count_leading_spaces(s: String) -> i64 =
    count_spaces_from(s, 0);

fn count_spaces_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 32 { count_spaces_from(s, pos + 1) }
    else if s.byte_at(pos) == 9 { count_spaces_from(s, pos + 4) }
    else { pos };

fn trim_leading(s: String) -> String =
    let start = count_leading_spaces(s);
    s.slice(start, s.len());

fn trim_trailing(s: String) -> String =
    let end = find_trim_end(s, s.len());
    s.slice(0, end);

fn find_trim_end(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if char_is_whitespace(s.byte_at(pos - 1)) or char_is_newline(s.byte_at(pos - 1)) {
        find_trim_end(s, pos - 1)
    }
    else { pos };

// ============================================================
// Pattern Matching
// ============================================================

fn starts_with(s: String, prefix: String) -> bool =
    if prefix.len() > s.len() { false }
    else { matches_at(s, prefix, 0) };

fn matches_at(s: String, pattern: String, pos: i64) -> bool =
    matches_at_inner(s, pattern, pos, 0);

fn matches_at_inner(s: String, pattern: String, pos: i64, i: i64) -> bool =
    if i >= pattern.len() { true }
    else if pos + i >= s.len() { false }
    else if s.byte_at(pos + i) != pattern.byte_at(i) { false }
    else { matches_at_inner(s, pattern, pos, i + 1) };

fn contains(s: String, sub: String) -> bool =
    contains_at(s, sub, 0);

fn contains_at(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() { false }
    else if matches_at(s, sub, pos) { true }
    else { contains_at(s, sub, pos + 1) };

fn string_eq(a: String, b: String) -> bool =
    a.len() == b.len() and matches_at(a, b, 0);

// ============================================================
// Type Checking
// ============================================================

// Run type check on a single file
fn check_file(file: String) -> i64 =
    let result = exec_output(BMB_PATH(), "check " + file);
    let has_error = contains(result, "\"type\":\"error\"");
    if has_error { 1 } else { 0 };

// Count warnings in output
fn count_warnings(output: String) -> i64 =
    count_pattern(output, "\"type\":\"warning\"", 0, 0);

fn count_pattern(s: String, pattern: String, pos: i64, count: i64) -> i64 =
    if pos >= s.len() { count }
    else if matches_at(s, pattern, pos) {
        count_pattern(s, pattern, pos + pattern.len(), count + 1)
    } else {
        count_pattern(s, pattern, pos + 1, count)
    };

// Parse and display check result
fn display_result(file: String, output: String, json_mode: bool) -> i64 =
    let has_error = contains(output, "\"type\":\"error\"");
    let warnings = count_warnings(output);

    if json_mode {
        let p1 = print_str(output);
        if has_error { 1 } else { 0 }
    } else {
        if has_error {
            let p1 = println_str("FAIL: " + file);
            let p2 = println_str(output);
            1
        } else if warnings > 0 {
            let p1 = println_str("OK: " + file + " (" + int_to_string(warnings) + " warnings)");
            0
        } else {
            let p1 = println_str("OK: " + file);
            0
        }
    };

// ============================================================
// Batch Processing
// ============================================================

fn check_batch(manifest_file: String) -> i64 =
    let content = read_file(manifest_file);
    check_files_from_manifest(content, 0, 0, 0);

fn check_files_from_manifest(content: String, pos: i64, errors: i64, total: i64) -> i64 =
    if pos >= content.len() {
        // Summary
        let p1 = println_str("\n=== Summary ===");
        let p2 = println_str("Files checked: " + int_to_string(total));
        let p3 = println_str("Errors: " + int_to_string(errors));
        if errors > 0 { 1 } else { 0 }
    } else {
        let line = get_line_at(content, pos);
        let next_pos = next_line_pos(content, pos);
        let trimmed = trim_trailing(trim_leading(line));

        // Skip empty lines and comments
        if trimmed.len() == 0 or starts_with(trimmed, "#") {
            check_files_from_manifest(content, next_pos, errors, total)
        } else {
            // Check this file
            let file = trimmed;
            if file_exists(file) == 1 {
                let output = exec_output(BMB_PATH(), "check " + file);
                let new_errors = display_result(file, output, false);
                check_files_from_manifest(content, next_pos, errors + new_errors, total + 1)
            } else {
                let p1 = println_str("SKIP: " + file + " (not found)");
                check_files_from_manifest(content, next_pos, errors, total)
            }
        }
    };

// ============================================================
// Main Entry Point
// ============================================================

fn main() -> i64 = {
    let argc = arg_count();

    if argc < 2 {
        let p1 = println_str("Usage: bmb run tools/bmb-check/main.bmb <file.bmb>");
        let p2 = println_str("       bmb run tools/bmb-check/main.bmb --batch files.txt");
        let p3 = println_str("       bmb run tools/bmb-check/main.bmb --json <file.bmb>");
        1
    } else {
        let arg1 = get_arg(1);

        if string_eq(arg1, "--batch") {
            if argc < 3 {
                let p1 = println_str("Error: --batch requires a manifest file");
                1
            } else {
                let manifest = get_arg(2);
                if file_exists(manifest) != 1 {
                    let p1 = println_str("Error: Manifest not found: " + manifest);
                    1
                } else {
                    check_batch(manifest)
                }
            }
        } else if string_eq(arg1, "--json") {
            if argc < 3 {
                let p1 = println_str("Error: --json requires a file argument");
                1
            } else {
                let file = get_arg(2);
                if file_exists(file) != 1 {
                    let p1 = println_str("{\"error\":\"File not found\",\"file\":\"" + file + "\"}");
                    1
                } else {
                    let output = exec_output(BMB_PATH(), "check " + file);
                    display_result(file, output, true)
                }
            }
        } else {
            let file = arg1;
            if file_exists(file) != 1 {
                let p1 = println_str("Error: File not found: " + file);
                1
            } else {
                let output = exec_output(BMB_PATH(), "check " + file);
                display_result(file, output, false)
            }
        }
    }
};
