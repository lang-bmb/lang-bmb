// BMB Code Formatter (bmb-fmt)
// Phase v0.64.1: Code formatting tool
//
// A simple line-based formatter for BMB source code.
// Normalizes whitespace and ensures consistent style.
//
// Usage:
//   bmb run tools/bmb-fmt/main.bmb <file.bmb>
//   bmb run tools/bmb-fmt/main.bmb --check <file.bmb>

// ============================================================
// Configuration
// ============================================================

fn INDENT_SIZE() -> i64 = 4;  // Spaces per indent level

// ============================================================
// String Utilities
// ============================================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn char_is_whitespace(c: i64) -> bool = c == 32 or c == 9;
fn char_is_newline(c: i64) -> bool = c == 10 or c == 13;

// ============================================================
// Line Processing
// ============================================================

fn find_newline(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 10 { pos }
    else { find_newline(s, pos + 1) };

fn get_line_at(s: String, pos: i64) -> String =
    let end = find_newline(s, pos);
    s.slice(pos, end);

fn next_line_pos(s: String, pos: i64) -> i64 =
    let nl = find_newline(s, pos);
    if nl >= s.len() { s.len() } else { nl + 1 };

// ============================================================
// Indentation
// ============================================================

fn make_indent(level: i64) -> String =
    make_spaces(level * INDENT_SIZE());

fn make_spaces(n: i64) -> String =
    if n <= 0 { "" }
    else { " " + make_spaces(n - 1) };

fn count_leading_spaces(s: String) -> i64 =
    count_spaces_from(s, 0);

fn count_spaces_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 32 { count_spaces_from(s, pos + 1) }
    else if s.byte_at(pos) == 9 { count_spaces_from(s, pos + INDENT_SIZE()) }  // Tab = 4 spaces
    else { pos };

fn trim_leading(s: String) -> String =
    let start = count_leading_spaces(s);
    s.slice(start, s.len());

fn trim_trailing(s: String) -> String =
    let end = find_trim_end(s, s.len());
    s.slice(0, end);

fn find_trim_end(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if char_is_whitespace(s.byte_at(pos - 1)) or char_is_newline(s.byte_at(pos - 1)) {
        find_trim_end(s, pos - 1)
    }
    else { pos };

// ============================================================
// Line Classification
// ============================================================

fn starts_with(s: String, prefix: String) -> bool =
    if prefix.len() > s.len() { false }
    else { matches_at(s, prefix, 0) };

fn matches_at(s: String, pattern: String, pos: i64) -> bool =
    matches_at_inner(s, pattern, pos, 0);

fn matches_at_inner(s: String, pattern: String, pos: i64, i: i64) -> bool =
    if i >= pattern.len() { true }
    else if pos + i >= s.len() { false }
    else if s.byte_at(pos + i) != pattern.byte_at(i) { false }
    else { matches_at_inner(s, pattern, pos, i + 1) };

fn is_comment_line(line: String) -> bool =
    starts_with(trim_leading(line), "//");

fn is_fn_def(line: String) -> bool =
    starts_with(trim_leading(line), "fn ");

fn is_blank_line(line: String) -> bool =
    trim_leading(line).len() == 0;

fn is_block_open(line: String) -> bool =
    ends_with_char(trim_trailing(line), 123);  // '{'

fn is_block_close(line: String) -> bool =
    starts_with(trim_leading(line), "}");

fn ends_with_char(s: String, c: i64) -> bool =
    s.len() > 0 and s.byte_at(s.len() - 1) == c;

// ============================================================
// Formatting Rules
// ============================================================

// Calculate indent level based on previous context
fn calc_indent_level(prev_line: String, current_level: i64) -> i64 =
    if is_block_open(prev_line) { current_level + 1 }
    else { current_level };

// Adjust level for closing braces
fn adjust_for_close(line: String, level: i64) -> i64 =
    if is_block_close(line) and level > 0 { level - 1 }
    else { level };

// Format a single line
fn format_line(line: String, indent_level: i64) -> String =
    let trimmed = trim_trailing(trim_leading(line));
    if trimmed.len() == 0 { "" }
    else { make_indent(indent_level) + trimmed };

// ============================================================
// Main Formatter
// ============================================================

fn format_source(source: String) -> String =
    let sb = sb_new();
    let r = format_lines(sb, source, 0, 0, "");
    sb_build(sb);

fn format_lines(sb: i64, source: String, pos: i64, level: i64, prev: String) -> i64 =
    if pos >= source.len() { 0 }
    else {
        let line = get_line_at(source, pos);
        let next_pos = next_line_pos(source, pos);

        // Adjust indent based on context
        let new_level = calc_indent_level(prev, level);
        let adjusted = adjust_for_close(line, new_level);

        // Format and output
        let formatted = format_line(line, adjusted);
        let s1 = sb_push(sb, formatted);
        let s2 = sb_push(sb, "\n");

        // Update level for next line
        let final_level = if is_block_open(line) { adjusted + 1 } else { adjusted };
        format_lines(sb, source, next_pos, final_level, line)
    };

// ============================================================
// Check Mode (compare only)
// ============================================================

fn check_formatting(source: String, formatted: String) -> i64 =
    if string_eq(source, formatted) { 0 } else { 1 };

fn string_eq(a: String, b: String) -> bool =
    a.len() == b.len() and string_eq_from(a, b, 0);

fn string_eq_from(a: String, b: String, pos: i64) -> bool =
    if pos >= a.len() { true }
    else if a.byte_at(pos) != b.byte_at(pos) { false }
    else { string_eq_from(a, b, pos + 1) };

// ============================================================
// Main Entry Point
// ============================================================

fn main() -> i64 = {
    let argc = arg_count();

    if argc < 2 {
        let p1 = println_str("Usage: bmb run tools/bmb-fmt/main.bmb <file.bmb>");
        let p2 = println_str("       bmb run tools/bmb-fmt/main.bmb --check <file.bmb>");
        1
    } else {
        let arg1 = get_arg(1);

        if string_eq(arg1, "--check") {
            if argc < 3 {
                let p1 = println_str("Error: --check requires a file argument");
                1
            } else {
                let file = get_arg(2);
                if file_exists(file) != 1 {
                    let p1 = println_str("Error: File not found: " + file);
                    1
                } else {
                    let source = read_file(file);
                    let formatted = format_source(source);
                    if check_formatting(source, formatted) == 0 {
                        let p1 = println_str("OK: " + file + " is correctly formatted");
                        0
                    } else {
                        let p1 = println_str("FAIL: " + file + " needs formatting");
                        1
                    }
                }
            }
        } else {
            let file = arg1;
            if file_exists(file) != 1 {
                let p1 = println_str("Error: File not found: " + file);
                1
            } else {
                let source = read_file(file);
                let formatted = format_source(source);
                let p1 = print_str(formatted);
                0
            }
        }
    }
};
