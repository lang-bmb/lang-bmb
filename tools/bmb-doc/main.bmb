// BMB Documentation Generator (bmb-doc)
// Phase v0.64.3: API documentation tool
//
// Extracts doc comments and function signatures to generate
// markdown documentation.
//
// Usage:
//   bmb run tools/bmb-doc/main.bmb <file.bmb>
//   bmb run tools/bmb-doc/main.bmb --output docs.md <file.bmb>

// ============================================================
// String Utilities
// ============================================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn char_is_whitespace(c: i64) -> bool = c == 32 or c == 9;

// ============================================================
// Line Processing
// ============================================================

fn find_newline(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 10 { pos }
    else { find_newline(s, pos + 1) };

fn get_line_at(s: String, pos: i64) -> String =
    let end = find_newline(s, pos);
    s.slice(pos, end);

fn next_line_pos(s: String, pos: i64) -> i64 =
    let nl = find_newline(s, pos);
    if nl >= s.len() { s.len() } else { nl + 1 };

fn count_leading_spaces(s: String) -> i64 =
    count_spaces_from(s, 0);

fn count_spaces_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if s.byte_at(pos) == 32 { count_spaces_from(s, pos + 1) }
    else if s.byte_at(pos) == 9 { count_spaces_from(s, pos + 4) }
    else { pos };

fn trim_leading(s: String) -> String =
    let start = count_leading_spaces(s);
    s.slice(start, s.len());

fn trim_trailing(s: String) -> String =
    let end = find_trim_end(s, s.len());
    s.slice(0, end);

fn find_trim_end(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if char_is_whitespace(s.byte_at(pos - 1)) {
        find_trim_end(s, pos - 1)
    }
    else { pos };

// ============================================================
// Pattern Matching
// ============================================================

fn starts_with(s: String, prefix: String) -> bool =
    if prefix.len() > s.len() { false }
    else { matches_at(s, prefix, 0) };

fn matches_at(s: String, pattern: String, pos: i64) -> bool =
    matches_at_inner(s, pattern, pos, 0);

fn matches_at_inner(s: String, pattern: String, pos: i64, i: i64) -> bool =
    if i >= pattern.len() { true }
    else if pos + i >= s.len() { false }
    else if s.byte_at(pos + i) != pattern.byte_at(i) { false }
    else { matches_at_inner(s, pattern, pos, i + 1) };

fn string_eq(a: String, b: String) -> bool =
    a.len() == b.len() and matches_at(a, b, 0);

// ============================================================
// Doc Comment Detection
// ============================================================

// Detect /// doc comments
fn is_doc_comment(line: String) -> bool =
    let trimmed = trim_leading(line);
    starts_with(trimmed, "///");

// Detect // regular comments
fn is_regular_comment(line: String) -> bool =
    let trimmed = trim_leading(line);
    starts_with(trimmed, "//") and not starts_with(trimmed, "///");

// Detect fn definitions
fn is_fn_def(line: String) -> bool =
    let trimmed = trim_leading(line);
    starts_with(trimmed, "fn ") or starts_with(trimmed, "pub fn ");

// Detect struct definitions
fn is_struct_def(line: String) -> bool =
    let trimmed = trim_leading(line);
    starts_with(trimmed, "struct ") or starts_with(trimmed, "pub struct ");

// Detect enum definitions
fn is_enum_def(line: String) -> bool =
    let trimmed = trim_leading(line);
    starts_with(trimmed, "enum ") or starts_with(trimmed, "pub enum ");

// ============================================================
// Documentation Extraction
// ============================================================

// Extract text after "/// "
fn extract_doc_text(line: String) -> String =
    let trimmed = trim_leading(line);
    if starts_with(trimmed, "/// ") {
        trimmed.slice(4, trimmed.len())
    } else if starts_with(trimmed, "///") {
        trimmed.slice(3, trimmed.len())
    } else {
        ""
    };

// Extract function name from "fn name(...)"
fn extract_fn_name(line: String) -> String =
    let trimmed = trim_leading(line);
    let start = if starts_with(trimmed, "pub fn ") { 7 }
                else if starts_with(trimmed, "fn ") { 3 }
                else { 0 };
    if start == 0 { "" }
    else { extract_ident(trimmed, start) };

fn extract_ident(s: String, pos: i64) -> String =
    let end = find_ident_end(s, pos);
    s.slice(pos, end);

fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else {
        let c = s.byte_at(pos);
        // a-z, A-Z, 0-9, _
        if (c >= 97 and c <= 122) or (c >= 65 and c <= 90) or
           (c >= 48 and c <= 57) or c == 95 {
            find_ident_end(s, pos + 1)
        } else { pos }
    };

// Extract function signature up to = or {
fn extract_fn_signature(line: String) -> String =
    let trimmed = trim_leading(line);
    let end = find_signature_end(trimmed, 0);
    trim_trailing(trimmed.slice(0, end));

fn find_signature_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else {
        let c = s.byte_at(pos);
        if c == 61 or c == 123 { pos }  // = or {
        else { find_signature_end(s, pos + 1) }
    };

// Extract struct name
fn extract_struct_name(line: String) -> String =
    let trimmed = trim_leading(line);
    let start = if starts_with(trimmed, "pub struct ") { 11 }
                else if starts_with(trimmed, "struct ") { 7 }
                else { 0 };
    if start == 0 { "" }
    else { extract_ident(trimmed, start) };

// Extract enum name
fn extract_enum_name(line: String) -> String =
    let trimmed = trim_leading(line);
    let start = if starts_with(trimmed, "pub enum ") { 9 }
                else if starts_with(trimmed, "enum ") { 5 }
                else { 0 };
    if start == 0 { "" }
    else { extract_ident(trimmed, start) };

// ============================================================
// Markdown Generation
// ============================================================

fn generate_docs(source: String, filename: String) -> String =
    let sb = sb_new();

    // Header
    let h1 = sb_push(sb, "# ");
    let h2 = sb_push(sb, filename);
    let h3 = sb_push(sb, "\n\n");
    let h4 = sb_push(sb, "Auto-generated documentation.\n\n");

    // Generate table of contents
    let t1 = sb_push(sb, "## Table of Contents\n\n");
    let t2 = generate_toc(sb, source, 0);
    let t3 = sb_push(sb, "\n");

    // Generate function documentation
    let f1 = sb_push(sb, "## Functions\n\n");
    let f2 = generate_fn_docs(sb, source, 0, "");

    sb_build(sb);

fn generate_toc(sb: i64, source: String, pos: i64) -> i64 =
    if pos >= source.len() { 0 }
    else {
        let line = get_line_at(source, pos);
        let next_pos = next_line_pos(source, pos);
        let emit = emit_toc_entry(sb, line);
        generate_toc(sb, source, next_pos)
    };

fn emit_toc_entry(sb: i64, line: String) -> i64 =
    if is_fn_def(line) {
        let name = extract_fn_name(line);
        if name.len() > 0 {
            let t1 = sb_push(sb, "- [`");
            let t2 = sb_push(sb, name);
            let t3 = sb_push(sb, "`](#");
            let t4 = sb_push(sb, name);
            let t5 = sb_push(sb, ")\n");
            0
        } else { 0 }
    } else { 0 };

fn generate_fn_docs(sb: i64, source: String, pos: i64, doc_acc: String) -> i64 =
    if pos >= source.len() { 0 }
    else {
        let line = get_line_at(source, pos);
        let next_pos = next_line_pos(source, pos);

        if is_doc_comment(line) {
            // Accumulate doc comment
            let doc_text = extract_doc_text(line);
            let new_acc = if doc_acc.len() > 0 {
                doc_acc + "\n" + doc_text
            } else { doc_text };
            generate_fn_docs(sb, source, next_pos, new_acc)
        } else if is_fn_def(line) {
            // Output function with accumulated docs
            let name = extract_fn_name(line);
            let sig = extract_fn_signature(line);
            let output_result = output_fn_doc(sb, name, sig, doc_acc);
            generate_fn_docs(sb, source, next_pos, "")
        } else {
            // Reset doc accumulator on non-doc, non-fn lines
            let new_acc = if is_regular_comment(line) or trim_leading(line).len() == 0 {
                doc_acc  // Keep accumulating
            } else {
                ""  // Reset
            };
            generate_fn_docs(sb, source, next_pos, new_acc)
        }
    };

fn output_fn_doc(sb: i64, name: String, sig: String, doc_acc: String) -> i64 =
    if name.len() > 0 {
        let f1 = sb_push(sb, "### `");
        let f2 = sb_push(sb, name);
        let f3 = sb_push(sb, "`\n\n");
        let f4 = sb_push(sb, "```bmb\n");
        let f5 = sb_push(sb, sig);
        let f6 = sb_push(sb, "\n```\n\n");
        let d1 = if doc_acc.len() > 0 {
            let x1 = sb_push(sb, doc_acc);
            sb_push(sb, "\n\n")
        } else { 0 };
        let d3 = sb_push(sb, "---\n\n");
        0
    } else { 0 };

// ============================================================
// Main Entry Point
// ============================================================

fn main() -> i64 = {
    let argc = arg_count();

    if argc < 2 {
        let p1 = println_str("Usage: bmb run tools/bmb-doc/main.bmb <file.bmb>");
        let p2 = println_str("       bmb run tools/bmb-doc/main.bmb --output docs.md <file.bmb>");
        1
    } else {
        let arg1 = get_arg(1);

        if string_eq(arg1, "--output") {
            if argc < 4 {
                let p1 = println_str("Error: --output requires output file and input file");
                1
            } else {
                let output_file = get_arg(2);
                let input_file = get_arg(3);
                if file_exists(input_file) != 1 {
                    let p1 = println_str("Error: File not found: " + input_file);
                    1
                } else {
                    let source = read_file(input_file);
                    let docs = generate_docs(source, input_file);
                    let w = write_file(output_file, docs);
                    let p1 = println_str("Documentation written to: " + output_file);
                    0
                }
            }
        } else {
            let file = arg1;
            if file_exists(file) != 1 {
                let p1 = println_str("Error: File not found: " + file);
                1
            } else {
                let source = read_file(file);
                let docs = generate_docs(source, file);
                let p1 = print_str(docs);
                0
            }
        }
    }
};
