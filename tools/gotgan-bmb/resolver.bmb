// Gotgan-BMB Dependency Resolver
// Phase v0.65.2: Version constraint resolution
//
// Parses gotgan.toml dependencies and resolves version constraints.
// Supports semantic versioning with ^, ~, and exact constraints.

// ============================================================
// String Utilities
// ============================================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn char_is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn char_is_whitespace(c: i64) -> bool = c == 32 or c == 9;
fn char_is_newline(c: i64) -> bool = c == 10 or c == 13;

fn parse_int(s: String) -> i64 = parse_int_from(s, 0, 0);

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc }
    else {
        let c = s.byte_at(pos);
        if char_is_digit(c) { parse_int_from(s, pos + 1, acc * 10 + (c - 48)) }
        else { acc }
    };

// ============================================================
// Line Processing
// ============================================================

fn find_newline(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 10 { pos }
    else { find_newline(s, pos + 1) };

fn get_line_at(s: String, pos: i64) -> String =
    let end = find_newline(s, pos);
    s.slice(pos, end);

fn next_line_pos(s: String, pos: i64) -> i64 =
    let nl = find_newline(s, pos);
    if nl >= s.len() { s.len() } else { nl + 1 };

fn count_spaces_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if char_is_whitespace(s.byte_at(pos)) { count_spaces_from(s, pos + 1) }
    else { pos };

fn trim_leading(s: String) -> String =
    let start = count_spaces_from(s, 0);
    s.slice(start, s.len());

fn trim_trailing(s: String) -> String =
    let end = find_trim_end(s, s.len());
    s.slice(0, end);

fn find_trim_end(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if char_is_whitespace(s.byte_at(pos - 1)) or char_is_newline(s.byte_at(pos - 1)) {
        find_trim_end(s, pos - 1)
    }
    else { pos };

// ============================================================
// Pattern Matching
// ============================================================

fn starts_with(s: String, prefix: String) -> bool =
    if prefix.len() > s.len() { false }
    else { matches_at(s, prefix, 0) };

fn matches_at(s: String, pattern: String, pos: i64) -> bool =
    matches_at_inner(s, pattern, pos, 0);

fn matches_at_inner(s: String, pattern: String, pos: i64, i: i64) -> bool =
    if i >= pattern.len() { true }
    else if pos + i >= s.len() { false }
    else if s.byte_at(pos + i) != pattern.byte_at(i) { false }
    else { matches_at_inner(s, pattern, pos, i + 1) };

fn string_eq(a: String, b: String) -> bool =
    a.len() == b.len() and matches_at(a, b, 0);

fn contains(s: String, sub: String) -> bool =
    contains_at(s, sub, 0);

fn contains_at(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() { false }
    else if matches_at(s, sub, pos) { true }
    else { contains_at(s, sub, pos + 1) };

fn find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == c { pos }
    else { find_char(s, c, pos + 1) };

// ============================================================
// Semantic Version Parsing
// ============================================================

// Parse major.minor.patch version string
// Returns: major * 1000000 + minor * 1000 + patch (encoded as single i64)

fn parse_version(s: String) -> i64 =
    let trimmed = trim_leading(trim_trailing(s));
    parse_version_parts(trimmed, 0, 0, 0, 0);

fn parse_version_parts(s: String, pos: i64, part: i64, value: i64, encoded: i64) -> i64 =
    if pos >= s.len() {
        // End of string - incorporate final part
        encode_version_part(encoded, part, value)
    } else {
        let c = s.byte_at(pos);
        if char_is_digit(c) {
            parse_version_parts(s, pos + 1, part, value * 10 + (c - 48), encoded)
        } else if c == 46 {  // '.'
            let new_encoded = encode_version_part(encoded, part, value);
            parse_version_parts(s, pos + 1, part + 1, 0, new_encoded)
        } else {
            // Stop at non-version character
            encode_version_part(encoded, part, value)
        }
    };

fn encode_version_part(encoded: i64, part: i64, value: i64) -> i64 =
    if part == 0 { encoded + value * 1000000 }
    else if part == 1 { encoded + value * 1000 }
    else { encoded + value };

fn version_major(v: i64) -> i64 = v / 1000000;
fn version_minor(v: i64) -> i64 = (v / 1000) - (version_major(v) * 1000);
fn version_patch(v: i64) -> i64 = v - (version_major(v) * 1000000) - (version_minor(v) * 1000);

fn version_to_string(v: i64) -> String =
    int_to_string(version_major(v)) + "." +
    int_to_string(version_minor(v)) + "." +
    int_to_string(version_patch(v));

// ============================================================
// Version Constraint Parsing
// ============================================================

// Constraint types:
// - ^1.2.3  (caret): compatible with 1.2.3, < 2.0.0
// - ~1.2.3  (tilde): compatible with 1.2.3, < 1.3.0
// - 1.2.3   (exact): exactly 1.2.3
// - >=1.2.3 (range): >= 1.2.3
// - *       (any): any version

// Returns constraint type: 0=exact, 1=caret, 2=tilde, 3=gte, 4=any

fn parse_constraint_type(s: String) -> i64 =
    let trimmed = trim_leading(s);
    if trimmed.len() == 0 { 4 }  // any
    else if s.byte_at(0) == 94 { 1 }  // ^
    else if s.byte_at(0) == 126 { 2 }  // ~
    else if starts_with(trimmed, ">=") { 3 }
    else if starts_with(trimmed, "*") { 4 }
    else { 0 };  // exact

fn parse_constraint_version(s: String) -> i64 =
    let trimmed = trim_leading(s);
    let start = skip_constraint_prefix(trimmed, 0);
    parse_version(trimmed.slice(start, trimmed.len()));

fn skip_constraint_prefix(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else {
        let c = s.byte_at(pos);
        if c == 94 or c == 126 or c == 62 or c == 61 { skip_constraint_prefix(s, pos + 1) }
        else { pos }
    };

// ============================================================
// Version Matching
// ============================================================

// Check if a version satisfies a constraint
fn version_satisfies(ver: i64, constraint_type: i64, constraint_ver: i64) -> bool =
    if constraint_type == 4 { true }  // any
    else if constraint_type == 0 { ver == constraint_ver }  // exact
    else if constraint_type == 3 { ver >= constraint_ver }  // gte
    else if constraint_type == 1 {
        // caret: >= constraint, < next major
        let next_major = (version_major(constraint_ver) + 1) * 1000000;
        ver >= constraint_ver and ver < next_major
    } else if constraint_type == 2 {
        // tilde: >= constraint, < next minor
        let next_minor = version_major(constraint_ver) * 1000000 +
                         (version_minor(constraint_ver) + 1) * 1000;
        ver >= constraint_ver and ver < next_minor
    } else { false };

// ============================================================
// TOML Dependency Parsing
// ============================================================

// Parse [dependencies] section from gotgan.toml
// Returns dependencies as string: "name1=ver1;name2=ver2;..."

fn parse_dependencies(toml: String) -> String =
    let deps_start = find_deps_section(toml, 0);
    if deps_start >= toml.len() { "" }
    else {
        let sb = sb_new();
        let r = collect_deps(sb, toml, deps_start, false);
        sb_build(sb)
    };

fn find_deps_section(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else {
        let line = get_line_at(s, pos);
        let trimmed = trim_leading(line);
        if starts_with(trimmed, "[dependencies]") {
            next_line_pos(s, pos)
        } else {
            find_deps_section(s, next_line_pos(s, pos))
        }
    };

fn collect_deps(sb: i64, s: String, pos: i64, has_output: bool) -> i64 =
    if pos >= s.len() { 0 }
    else {
        let line = get_line_at(s, pos);
        let trimmed = trim_leading(line);

        // Stop at next section
        if trimmed.len() > 0 and s.byte_at(pos + count_spaces_from(s, pos)) == 91 { 0 }
        // Skip empty lines and comments
        else if trimmed.len() == 0 or s.byte_at(pos + count_spaces_from(s, pos)) == 35 {
            collect_deps(sb, s, next_line_pos(s, pos), has_output)
        } else {
            // Parse dependency line: name = "version"
            let eq_pos = find_char(line, 61, 0);
            if eq_pos < line.len() {
                let name = trim_trailing(line.slice(0, eq_pos));
                let rest = trim_leading(line.slice(eq_pos + 1, line.len()));
                // Extract version from quotes
                let ver = extract_quoted(rest);

                let c1 = if has_output { sb_push(sb, ";") } else { 0 };
                let c2 = sb_push(sb, name);
                let c3 = sb_push(sb, "=");
                let c4 = sb_push(sb, ver);
                collect_deps(sb, s, next_line_pos(s, pos), true)
            } else {
                collect_deps(sb, s, next_line_pos(s, pos), has_output)
            }
        }
    };

fn extract_quoted(s: String) -> String =
    let start = find_char(s, 34, 0);  // "
    if start >= s.len() { s }
    else {
        let end = find_char(s, 34, start + 1);
        s.slice(start + 1, end)
    };

// ============================================================
// Lock File Generation
// ============================================================

fn generate_lock(deps: String) -> String =
    let sb = sb_new();
    let h1 = sb_push(sb, "# gotgan.lock\n");
    let h2 = sb_push(sb, "# Auto-generated - do not edit\n\n");
    let d = generate_lock_entries(sb, deps, 0);
    sb_build(sb);

fn generate_lock_entries(sb: i64, deps: String, pos: i64) -> i64 =
    if pos >= deps.len() { 0 }
    else {
        let semi = find_char(deps, 59, pos);  // ;
        let entry = deps.slice(pos, if semi < deps.len() { semi } else { deps.len() });

        let r = write_lock_entry(sb, entry);
        generate_lock_entries(sb, deps, semi + 1)
    };

fn write_lock_entry(sb: i64, entry: String) -> i64 =
    if entry.len() == 0 { 0 }
    else {
        let eq = find_char(entry, 61, 0);
        if eq < entry.len() {
            let name = entry.slice(0, eq);
            let ver = entry.slice(eq + 1, entry.len());
            let e1 = sb_push(sb, "[[package]]\n");
            let e2 = sb_push(sb, "name = \"");
            let e3 = sb_push(sb, name);
            let e4 = sb_push(sb, "\"\n");
            let e5 = sb_push(sb, "version = \"");
            let e6 = sb_push(sb, ver);
            let e7 = sb_push(sb, "\"\n\n");
            0
        } else { 0 }
    };

// ============================================================
// Main Entry Point (for testing)
// ============================================================

fn main() -> i64 = {
    let argc = arg_count();

    if argc < 2 {
        let p1 = println_str("Usage: bmb run resolver.bmb <gotgan.toml>");
        1
    } else {
        let file = get_arg(1);
        if file_exists(file) != 1 {
            let p1 = println_str("Error: File not found: " + file);
            1
        } else {
            let toml = read_file(file);
            let deps = parse_dependencies(toml);

            let p1 = println_str("Dependencies found:");
            let p2 = println_str(deps);

            let lock = generate_lock(deps);
            let p3 = println_str("\nLock file:");
            let p4 = println_str(lock);
            0
        }
    }
};
