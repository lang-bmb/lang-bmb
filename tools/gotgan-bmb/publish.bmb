// Gotgan-BMB Package Publisher
// Phase v0.65.4: Package publishing to registry
//
// Publishes packages to local registry (~/.gotgan/registry/)

fn PROJECT_FILE() -> String = "gotgan.toml";
fn REGISTRY_DIR() -> String = "~/.gotgan/registry";

// ============================================================
// String Utilities
// ============================================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn char_is_whitespace(c: i64) -> bool = c == 32 or c == 9;
fn char_is_newline(c: i64) -> bool = c == 10 or c == 13;

fn find_newline(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 10 { pos }
    else { find_newline(s, pos + 1) };

fn get_line_at(s: String, pos: i64) -> String =
    let end = find_newline(s, pos);
    s.slice(pos, end);

fn next_line_pos(s: String, pos: i64) -> i64 =
    let nl = find_newline(s, pos);
    if nl >= s.len() { s.len() } else { nl + 1 };

fn count_spaces_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if char_is_whitespace(s.byte_at(pos)) { count_spaces_from(s, pos + 1) }
    else { pos };

fn trim_leading(s: String) -> String =
    let start = count_spaces_from(s, 0);
    s.slice(start, s.len());

fn trim_trailing(s: String) -> String =
    let end = find_trim_end(s, s.len());
    s.slice(0, end);

fn find_trim_end(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if char_is_whitespace(s.byte_at(pos - 1)) or char_is_newline(s.byte_at(pos - 1)) {
        find_trim_end(s, pos - 1)
    }
    else { pos };

fn starts_with(s: String, prefix: String) -> bool =
    if prefix.len() > s.len() { false }
    else { matches_at(s, prefix, 0) };

fn matches_at(s: String, pattern: String, pos: i64) -> bool =
    matches_at_inner(s, pattern, pos, 0);

fn matches_at_inner(s: String, pattern: String, pos: i64, i: i64) -> bool =
    if i >= pattern.len() { true }
    else if pos + i >= s.len() { false }
    else if s.byte_at(pos + i) != pattern.byte_at(i) { false }
    else { matches_at_inner(s, pattern, pos, i + 1) };

fn string_eq(a: String, b: String) -> bool =
    a.len() == b.len() and matches_at(a, b, 0);

fn find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == c { pos }
    else { find_char(s, c, pos + 1) };

// ============================================================
// TOML Parsing
// ============================================================

fn extract_toml_value(toml: String, key: String) -> String =
    extract_toml_value_from(toml, key, 0);

fn extract_toml_value_from(toml: String, key: String, pos: i64) -> String =
    if pos >= toml.len() { "" }
    else {
        let line = get_line_at(toml, pos);
        let trimmed = trim_leading(line);
        if starts_with(trimmed, key) {
            let eq_pos = find_char(line, 61, 0);
            if eq_pos < line.len() {
                let value_part = trim_leading(line.slice(eq_pos + 1, line.len()));
                extract_quoted_value(value_part)
            } else {
                extract_toml_value_from(toml, key, next_line_pos(toml, pos))
            }
        } else {
            extract_toml_value_from(toml, key, next_line_pos(toml, pos))
        }
    };

fn extract_quoted_value(s: String) -> String =
    let start = find_char(s, 34, 0);
    if start >= s.len() { trim_trailing(s) }
    else {
        let end = find_char(s, 34, start + 1);
        s.slice(start + 1, end)
    };

// ============================================================
// Package Publishing
// ============================================================

fn get_registry_path(name: String, ver: String) -> String =
    REGISTRY_DIR() + "/" + name + "/" + ver;

fn create_package_metadata(name: String, ver: String, description: String) -> String =
    let sb = sb_new();
    let s1 = sb_push(sb, "[package]\n");
    let s2 = sb_push(sb, "name = \"");
    let s3 = sb_push(sb, name);
    let s4 = sb_push(sb, "\"\n");
    let s5 = sb_push(sb, "version = \"");
    let s6 = sb_push(sb, ver);
    let s7 = sb_push(sb, "\"\n");
    let s8 = sb_push(sb, "description = \"");
    let s9 = sb_push(sb, description);
    let s10 = sb_push(sb, "\"\n");
    sb_build(sb);

fn publish_package(name: String, ver: String, dry_run: bool) -> i64 = {
    let pkg_path = get_registry_path(name, ver);

    if dry_run {
        let p1 = println_str("[dry-run] Would publish to: " + pkg_path);
        let p2 = println_str("[dry-run] Package: " + name + " v" + ver);
        0
    } else {
        let p1 = println_str("Publishing " + name + " v" + ver + " to local registry...");

        // Create registry directory structure
        let d1 = exec_output("mkdir", "-p " + REGISTRY_DIR() + "/" + name);
        let d2 = exec_output("mkdir", "-p " + pkg_path);
        let d3 = exec_output("mkdir", "-p " + pkg_path + "/src");

        // Copy source files
        let c1 = exec_output("cp", "-r src/* " + pkg_path + "/src/");
        let c2 = exec_output("cp", PROJECT_FILE() + " " + pkg_path + "/");

        // Create registry index entry
        let index_entry = name + "=" + ver + "\n";
        let index_path = REGISTRY_DIR() + "/index.txt";
        // Append to index (simple approach)
        let current = if file_exists(index_path) == 1 { read_file(index_path) } else { "" };
        let w1 = write_file(index_path, current + index_entry);

        let p2 = println_str("Published successfully to: " + pkg_path);
        0
    }
};

fn run_publish(dry_run: bool) -> i64 =
    if file_exists(PROJECT_FILE()) != 1 {
        let p1 = println_str("Error: No " + PROJECT_FILE() + " found");
        1
    } else {
        let toml = read_file(PROJECT_FILE());
        let name = extract_toml_value(toml, "name");
        let ver = extract_toml_value(toml, "version");

        if name.len() == 0 {
            let p1 = println_str("Error: Package name not found in " + PROJECT_FILE());
            1
        } else if ver.len() == 0 {
            let p1 = println_str("Error: Package version not found in " + PROJECT_FILE());
            1
        } else {
            publish_package(name, ver, dry_run)
        }
    };

// ============================================================
// Main Entry Point
// ============================================================

fn main() -> i64 = {
    let argc = arg_count();
    let dry_run = argc > 1 and string_eq(get_arg(1), "--dry-run");
    run_publish(dry_run)
};
