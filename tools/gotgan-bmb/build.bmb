// Gotgan-BMB Build System
// Phase v0.65.3: Source to binary build
//
// Handles compilation of BMB projects with dependency support.

fn BMB_PATH() -> String = "./target/release/bmb";
fn TARGET_DIR() -> String = "target";
fn SRC_DIR() -> String = "src";
fn PROJECT_FILE() -> String = "gotgan.toml";
fn LOCK_FILE() -> String = "gotgan.lock";

// ============================================================
// String Utilities
// ============================================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn char_is_whitespace(c: i64) -> bool = c == 32 or c == 9;
fn char_is_newline(c: i64) -> bool = c == 10 or c == 13;

fn find_newline(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 10 { pos }
    else { find_newline(s, pos + 1) };

fn get_line_at(s: String, pos: i64) -> String =
    let end = find_newline(s, pos);
    s.slice(pos, end);

fn next_line_pos(s: String, pos: i64) -> i64 =
    let nl = find_newline(s, pos);
    if nl >= s.len() { s.len() } else { nl + 1 };

fn count_spaces_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if char_is_whitespace(s.byte_at(pos)) { count_spaces_from(s, pos + 1) }
    else { pos };

fn trim_leading(s: String) -> String =
    let start = count_spaces_from(s, 0);
    s.slice(start, s.len());

fn trim_trailing(s: String) -> String =
    let end = find_trim_end(s, s.len());
    s.slice(0, end);

fn find_trim_end(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if char_is_whitespace(s.byte_at(pos - 1)) or char_is_newline(s.byte_at(pos - 1)) {
        find_trim_end(s, pos - 1)
    }
    else { pos };

fn starts_with(s: String, prefix: String) -> bool =
    if prefix.len() > s.len() { false }
    else { matches_at(s, prefix, 0) };

fn matches_at(s: String, pattern: String, pos: i64) -> bool =
    matches_at_inner(s, pattern, pos, 0);

fn matches_at_inner(s: String, pattern: String, pos: i64, i: i64) -> bool =
    if i >= pattern.len() { true }
    else if pos + i >= s.len() { false }
    else if s.byte_at(pos + i) != pattern.byte_at(i) { false }
    else { matches_at_inner(s, pattern, pos, i + 1) };

fn string_eq(a: String, b: String) -> bool =
    a.len() == b.len() and matches_at(a, b, 0);

fn contains(s: String, sub: String) -> bool =
    contains_at(s, sub, 0);

fn contains_at(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() { false }
    else if matches_at(s, sub, pos) { true }
    else { contains_at(s, sub, pos + 1) };

fn find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == c { pos }
    else { find_char(s, c, pos + 1) };

// ============================================================
// Project Configuration Parsing
// ============================================================

fn get_project_name(toml: String) -> String =
    extract_toml_value(toml, "name");

fn extract_toml_value(toml: String, key: String) -> String =
    extract_toml_value_from(toml, key, 0);

fn extract_toml_value_from(toml: String, key: String, pos: i64) -> String =
    if pos >= toml.len() { "" }
    else {
        let line = get_line_at(toml, pos);
        let trimmed = trim_leading(line);
        if starts_with(trimmed, key) {
            let eq_pos = find_char(line, 61, 0);
            if eq_pos < line.len() {
                let value_part = trim_leading(line.slice(eq_pos + 1, line.len()));
                extract_quoted_value(value_part)
            } else {
                extract_toml_value_from(toml, key, next_line_pos(toml, pos))
            }
        } else {
            extract_toml_value_from(toml, key, next_line_pos(toml, pos))
        }
    };

fn extract_quoted_value(s: String) -> String =
    let start = find_char(s, 34, 0);
    if start >= s.len() { trim_trailing(s) }
    else {
        let end = find_char(s, 34, start + 1);
        s.slice(start + 1, end)
    };

// ============================================================
// Build Steps
// ============================================================

fn ensure_target_dir() -> i64 =
    let result = exec_output("mkdir", TARGET_DIR());
    0;

fn find_main_source() -> String =
    if file_exists("src/main.bmb") == 1 { "src/main.bmb" }
    else if file_exists("src/lib.bmb") == 1 { "src/lib.bmb" }
    else { "" };

fn compile_source(source: String, output: String, release: bool) -> i64 =
    let build_args = if release {
        "build " + source + " -o " + output + " -O3"
    } else {
        "build " + source + " -o " + output
    };
    let result = exec_output(BMB_PATH(), build_args);
    if contains(result, "error") { 1 } else { 0 };

fn type_check_source(source: String) -> i64 =
    let result = exec_output(BMB_PATH(), "check " + source);
    if contains(result, "\"type\":\"error\"") { 1 } else { 0 };

// ============================================================
// Build Command Implementation
// ============================================================

fn run_build(release: bool) -> i64 =
    if file_exists(PROJECT_FILE()) != 1 {
        let p1 = println_str("Error: No " + PROJECT_FILE() + " found");
        1
    } else {
        do_build(release)
    };

fn do_build(release: bool) -> i64 = {
    let toml = read_file(PROJECT_FILE());
    let name = get_project_name(toml);

    let p1 = println_str("Building project: " + name);

    // Find source file
    let source = find_main_source();
    if source.len() == 0 {
        let p2 = println_str("Error: No source file found (src/main.bmb or src/lib.bmb)");
        1
    } else {
        // Create target directory
        let t = ensure_target_dir();

        // Determine output path
        let mode = if release { "release" } else { "debug" };
        let output = TARGET_DIR() + "/" + mode + "/" + name;

        // Create output directory
        let d = exec_output("mkdir", TARGET_DIR() + "/" + mode);

        // Compile
        let p2 = println_str("Compiling " + source + " -> " + output);
        let result = compile_source(source, output, release);

        if result == 0 {
            let p3 = println_str("Build successful: " + output);
            0
        } else {
            let p3 = println_str("Build failed");
            1
        }
    }
};

// ============================================================
// Check Command Implementation
// ============================================================

fn run_check() -> i64 =
    if file_exists(PROJECT_FILE()) != 1 {
        let p1 = println_str("Error: No " + PROJECT_FILE() + " found");
        1
    } else {
        let source = find_main_source();
        if source.len() == 0 {
            let p1 = println_str("Error: No source file found");
            1
        } else {
            let p1 = println_str("Type checking " + source);
            let result = type_check_source(source);
            if result == 0 {
                let p2 = println_str("Type check passed");
                0
            } else {
                let p2 = println_str("Type check failed");
                1
            }
        }
    };

// ============================================================
// Run Command Implementation
// ============================================================

fn run_run(release: bool, args: String) -> i64 = {
    let build_result = run_build(release);
    if build_result != 0 { build_result }
    else {
        let toml = read_file(PROJECT_FILE());
        let name = get_project_name(toml);
        let mode = if release { "release" } else { "debug" };
        let binary = TARGET_DIR() + "/" + mode + "/" + name;

        let p1 = println_str("\nRunning " + binary + "\n");
        let output = exec_output(binary, args);
        let p2 = print_str(output);
        0
    }
};

// ============================================================
// Clean Command Implementation
// ============================================================

fn run_clean() -> i64 = {
    let p1 = println_str("Cleaning target directory...");
    let result = exec_output("rm", "-rf " + TARGET_DIR());
    let p2 = println_str("Done");
    0
};

// ============================================================
// Main Entry Point (for testing)
// ============================================================

fn main() -> i64 = {
    let argc = arg_count();

    if argc < 2 {
        let p1 = println_str("Usage: bmb run build.bmb <build|check|run|clean> [options]");
        1
    } else {
        let cmd = get_arg(1);

        if string_eq(cmd, "build") {
            let release = argc > 2 and string_eq(get_arg(2), "--release");
            run_build(release)
        } else if string_eq(cmd, "check") {
            run_check()
        } else if string_eq(cmd, "run") {
            let release = argc > 2 and string_eq(get_arg(2), "--release");
            run_run(release, "")
        } else if string_eq(cmd, "clean") {
            run_clean()
        } else {
            let p1 = println_str("Unknown command: " + cmd);
            1
        }
    }
};
