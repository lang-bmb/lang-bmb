// Takeuchi Function Benchmark (interpreter-friendly)
// Classic recursive benchmark for function call overhead

fn tak(x: i64, y: i64, z: i64) -> i64 =
    if y < x {
        tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y))
    } else {
        z
    };

fn main() -> i64 = {
    // tak(18, 12, 6) is a reasonable size for interpreter
    let result = tak(18, 12, 6);
    println(result);
    0
};
