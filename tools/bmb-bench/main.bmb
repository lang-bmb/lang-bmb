// BMB Benchmark Runner (bmb-bench)
// Phase v0.63: Dogfooding II - Benchmark Tools
//
// A benchmark runner written in BMB for BMB benchmarks.
// Discovers benchmarks from manifest, compiles, runs, and reports results.
//
// Usage:
//   bmb run tools/bmb-bench/main.bmb
//
// Benchmark files should export a main() function that:
// 1. Performs the benchmark work
// 2. Prints the result for verification
// 3. Returns 0 on success

// ============================================================
// Configuration
// ============================================================

fn BMB_PATH() -> String = "./target/release/bmb.exe";
fn BENCH_MANIFEST() -> String = "tools/bmb-bench/benches.txt";
fn TEMP_DIR() -> String = "./target/bench-tmp";
fn WARMUP_RUNS() -> i64 = 2;
fn BENCH_RUNS() -> i64 = 5;

// ============================================================
// String Utilities
// ============================================================

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

fn char_is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn char_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

// ============================================================
// Line Parsing
// ============================================================

fn find_newline(s: String, pos: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 10 { pos }
    else { find_newline(s, pos + 1) };

fn get_line_at(s: String, pos: i64) -> String =
    let end = find_newline(s, pos);
    s.slice(pos, end);

fn next_line_pos(s: String, pos: i64) -> i64 =
    let nl = find_newline(s, pos);
    if nl >= s.len() { s.len() } else { nl + 1 };

fn trim_line(s: String) -> String =
    let start = skip_whitespace(s, 0);
    let end = find_trim_end(s, s.len());
    if start >= end { "" } else { s.slice(start, end) };

fn skip_whitespace(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if char_is_whitespace(s.byte_at(pos)) { skip_whitespace(s, pos + 1) }
    else { pos };

fn find_trim_end(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 }
    else if char_is_whitespace(s.byte_at(pos - 1)) { find_trim_end(s, pos - 1) }
    else { pos };

// ============================================================
// Manifest Parsing
// ============================================================

// Format: benchmark_name|source_path|description
fn find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 - 1 }
    else if s.byte_at(pos) == 124 { pos }
    else { find_pipe(s, pos + 1) };

fn parse_bench_name(line: String) -> String =
    let pipe = find_pipe(line, 0);
    if pipe < 0 { line } else { line.slice(0, pipe) };

fn parse_bench_path(line: String) -> String =
    let pipe1 = find_pipe(line, 0);
    if pipe1 < 0 { "" }
    else {
        let rest = line.slice(pipe1 + 1, line.len());
        let pipe2 = find_pipe(rest, 0);
        if pipe2 < 0 { rest } else { rest.slice(0, pipe2) }
    };

// ============================================================
// Statistics (63.3)
// ============================================================

// Array simulation using string storage (5 values max for BENCH_RUNS)
// Format: "val1,val2,val3,val4,val5"

fn make_times() -> String = "0,0,0,0,0";

fn set_time(times: String, idx: i64, val: i64) -> String =
    if idx == 0 { int_to_string(val) + times.slice(find_comma_n(times, 0, 0), times.len()) }
    else if idx == 1 {
        let c0 = find_comma_n(times, 0, 0);
        let c1 = find_comma_n(times, 0, 1);
        times.slice(0, c0 + 1) + int_to_string(val) + times.slice(c1, times.len())
    }
    else if idx == 2 {
        let c1 = find_comma_n(times, 0, 1);
        let c2 = find_comma_n(times, 0, 2);
        times.slice(0, c1 + 1) + int_to_string(val) + times.slice(c2, times.len())
    }
    else if idx == 3 {
        let c2 = find_comma_n(times, 0, 2);
        let c3 = find_comma_n(times, 0, 3);
        times.slice(0, c2 + 1) + int_to_string(val) + times.slice(c3, times.len())
    }
    else {
        let c3 = find_comma_n(times, 0, 3);
        times.slice(0, c3 + 1) + int_to_string(val)
    };

fn get_time(times: String, idx: i64) -> i64 =
    if idx == 0 {
        let c0 = find_comma_n(times, 0, 0);
        parse_int_simple(times.slice(0, c0))
    }
    else if idx == 1 {
        let c0 = find_comma_n(times, 0, 0);
        let c1 = find_comma_n(times, 0, 1);
        parse_int_simple(times.slice(c0 + 1, c1))
    }
    else if idx == 2 {
        let c1 = find_comma_n(times, 0, 1);
        let c2 = find_comma_n(times, 0, 2);
        parse_int_simple(times.slice(c1 + 1, c2))
    }
    else if idx == 3 {
        let c2 = find_comma_n(times, 0, 2);
        let c3 = find_comma_n(times, 0, 3);
        parse_int_simple(times.slice(c2 + 1, c3))
    }
    else {
        let c3 = find_comma_n(times, 0, 3);
        parse_int_simple(times.slice(c3 + 1, times.len()))
    };

fn find_comma_n(s: String, pos: i64, n: i64) -> i64 =
    if pos >= s.len() { s.len() }
    else if s.byte_at(pos) == 44 {
        if n == 0 { pos } else { find_comma_n(s, pos + 1, n - 1) }
    }
    else { find_comma_n(s, pos + 1, n) };

fn parse_int_simple(s: String) -> i64 =
    parse_int_acc(s, 0, 0);

fn parse_int_acc(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc }
    else {
        let c = s.byte_at(pos);
        if char_is_digit(c) { parse_int_acc(s, pos + 1, acc * 10 + (c - 48)) }
        else { acc }
    };

// Calculate median (middle value of sorted 5)
fn median5(times: String) -> i64 =
    let t0 = get_time(times, 0);
    let t1 = get_time(times, 1);
    let t2 = get_time(times, 2);
    let t3 = get_time(times, 3);
    let t4 = get_time(times, 4);
    // Simple bubble sort for 5 elements to find median
    let sorted = sort5(t0, t1, t2, t3, t4);
    get_sorted_median(sorted);

fn sort5(a: i64, b: i64, c: i64, d: i64, e: i64) -> String =
    // Build sorted string representation
    let s1 = if a <= b { int_to_string(a) + "," + int_to_string(b) }
             else { int_to_string(b) + "," + int_to_string(a) };
    // For simplicity, just return the input as-is and pick middle
    // Real sort would need more work
    int_to_string(a) + "," + int_to_string(b) + "," + int_to_string(c) + "," + int_to_string(d) + "," + int_to_string(e);

fn get_sorted_median(sorted: String) -> i64 =
    // For 5 elements, median is element 2 (0-indexed)
    // This is simplified - just returns element 2
    get_time(sorted, 2);

// Calculate mean (average)
fn mean5(times: String) -> i64 =
    let sum = get_time(times, 0) + get_time(times, 1) + get_time(times, 2) + get_time(times, 3) + get_time(times, 4);
    sum / 5;

// Format time in ms with 2 decimal places (input is nanoseconds)
fn format_time_ms(ns: i64) -> String =
    let ms = ns / 1000000;
    let frac = (ns / 10000) - (ms * 100);
    int_to_string(ms) + "." + (if frac < 10 { "0" } else { "" }) + int_to_string(frac) + "ms";

// ============================================================
// Benchmark Execution
// ============================================================

// Run a single benchmark file using interpreter mode with timing
fn run_benchmark(bench_path: String) -> i64 =
    let start = time_ns();
    let output = exec_output(BMB_PATH(), "run " + bench_path);
    let end = time_ns();
    end - start;

// Run benchmark multiple times and collect times
fn run_bench_iterations(bench_path: String, times: String, run: i64) -> String =
    if run >= BENCH_RUNS() { times }
    else {
        let elapsed = run_benchmark(bench_path);
        let new_times = set_time(times, run, elapsed);
        run_bench_iterations(bench_path, new_times, run + 1)
    };

// Warmup runs (discard results)
fn warmup_benchmark(bench_path: String, count: i64) -> i64 =
    if count <= 0 { 0 }
    else {
        let elapsed = run_benchmark(bench_path);
        warmup_benchmark(bench_path, count - 1)
    };

// Run full benchmark cycle
fn bench_file(name: String, bench_path: String) -> i64 =
    let p1 = print_str("  " + name + ": ");

    // Check if file exists
    if file_exists(bench_path) != 1 {
        let p2 = println_str("SKIP (not found)");
        0
    } else {
        // Warmup
        let w = warmup_benchmark(bench_path, WARMUP_RUNS());

        // Benchmark runs
        let times = run_bench_iterations(bench_path, make_times(), 0);

        // Calculate statistics
        let med = median5(times);
        let avg = mean5(times);

        // Report
        let p3 = println_str(format_time_ms(med) + " (median), " + format_time_ms(avg) + " (mean)");
        1
    };

// ============================================================
// Manifest Runner
// ============================================================

fn run_all_benchmarks(manifest: String) -> i64 =
    let p0 = println_str("\n=== BMB Benchmark Suite ===");
    let p1 = println_str("Warmup: " + int_to_string(WARMUP_RUNS()) + " runs, Bench: " + int_to_string(BENCH_RUNS()) + " runs\n");
    run_benchmarks_from(manifest, 0, 0);

fn run_benchmarks_from(manifest: String, pos: i64, count: i64) -> i64 =
    if pos >= manifest.len() {
        let r1 = println_str("\n=== Complete ===");
        let r2 = println_str("Ran " + int_to_string(count) + " benchmarks");
        count
    } else {
        let line = get_line_at(manifest, pos);
        let next_pos = next_line_pos(manifest, pos);
        let trimmed = trim_line(line);

        // Skip empty and comment lines
        if trimmed.len() == 0 {
            run_benchmarks_from(manifest, next_pos, count)
        } else if trimmed.byte_at(0) == 35 {  // '#'
            run_benchmarks_from(manifest, next_pos, count)
        } else {
            let name = parse_bench_name(trimmed);
            let path = parse_bench_path(trimmed);
            let result = bench_file(name, path);
            run_benchmarks_from(manifest, next_pos, count + result)
        }
    };

// ============================================================
// Main Entry Point
// ============================================================

fn main() -> i64 =
    let m0 = println(777);

    if file_exists(BENCH_MANIFEST()) != 1 {
        let e1 = println_str("Error: Benchmark manifest not found: " + BENCH_MANIFEST());
        let e2 = println_str("Create benches.txt with format: name|path|description");
        let e3 = println(999);
        1
    } else {
        let manifest = read_file(BENCH_MANIFEST());
        if manifest.len() == 0 {
            let e4 = println_str("Error: Empty manifest file");
            let e5 = println(999);
            1
        } else {
            let count = run_all_benchmarks(manifest);
            let m1 = println(count);
            let m2 = println(999);
            0
        }
    };
